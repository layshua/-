
环境光照就是在场景中任意一点往四周看去可看到的光照（距离视为无限远）, 将其记录在一张图上存储。也叫做 **IBL (image-based lighing)**。
通常我们用 Spherical Map 和 Cube Map 来存储环境光照.

# 环境光照原理

如果已知环境光照, 此时放置一个物体在场景中间, 在**不考虑阴影**时我们该如何去得到任何一物体上着色点的 shading 值呢?
- @ **首先要先来看渲染方程**
$$L_o(p,\omega_o) = \int\limits_{\Omega} f_r(p,\omega_i,\omega_o) L_i(p,\omega_i) n \cdot \omega_i d\omega_i$$
通用的解法是使用**蒙特卡洛积分**去解, 但是蒙特卡洛需要大量的样本才能让得出的结果足够接近, 如果我们对每个 shading point 都做一遍蒙特卡洛积分，那样的话太慢了。

- @ **如何避免采样?**

**brdf 分为两种情况:**
1.  brdf 为 glossy 时, lobe 覆盖在球面上的范围很小
2.  brdf 为 diffuse 时, lobe 会覆盖整个半球的区域，在积分域内变化不大
![[Pasted image 20230714130125.png]]

此时应该想到了我们之前讲的渲染方程近似公式:
[[02 PBR理论#渲染方程不等式近似]]
$$
\int_\Omega f(x)g(x)\mathrm{~d}x\approx\frac{\int_\Omega f(x)\mathrm{~d}x}{\int_\Omega\mathrm{~d}x}\cdot\int_\Omega g(x)\mathrm{~d}x
$$
![[02 PBR理论#^ptjnu8]]

由于  $f_r$  项作为 $g(x)$ 正好满足这个条件, 即 small support 或 Smooth integrand, 从而我们将渲染方程的 $L_i$ 项作为 $f(x)$ ，方程可拆分为： ^x7aaaa
$$
L_o(p,\omega_o)\approx\boxed{\frac{\int_{\Omega_{f_{r}}}L_i(p,\omega_i)\mathrm{~d}\omega_i}{\int_{\Omega_{f_r}}\mathrm{~d}\omega_i}}\cdot\int_{\Omega^+}f_r(p,\omega_i,\omega_o)\cos\theta_i\mathrm{~d}\omega_i
$$

## 拆分第一步：预滤波

**把 $L_i$ 项拆分出来, 然后将 brdf 范围内的 $L_i$ 积分起来并进行 normalize, 其实就是将 IBL 这张图给模糊了（即使用卷积核模糊图像）**

模糊就是在任何一点上取周围一片范围求出范围内的平均值并将平均值写回这个点上, 滤波核取多大取决于 BRDF 占多大, BRDF 的区域越大, 最后取得的图也就越模糊.

**环境光照的预滤波：**
- 预生成一组滤波核不同的环境光照滤波器（类似 mipmap），当我们需要使用时直接查询即可
- 其他滤波核尺寸的图可以通过 [[04 纹理#^s6etys|三线性插值]] 来近似。
![[Pasted image 20230714135052.png]]

- ? 拆分就是为了做一个 Pre-filtering, 那么做 pre-filtering 是为了干什么?
![[Pasted image 20230714135944.png]]
左图为 brdf 求 shading point 值时, 我们要以一定立体角的范围内进行多次采样再加权平均从而求出 shading point 的值.
反过来想，如右图，对环境光照做 pre-filtering，这样图上任何一点都是周围范围内的加权平均值，**只需要采样一次**就能得到和多次采样加权平均相同的结果，不需要多次采样！

## 拆分第二步：

到此我们解决了拆分后的前半部分积分采样的问题, 那么接下来我们处理 BRDF 项采样的问题：

![[4ee2a40a998a23168e390cb2d3392972_MD5.jpg]]

接下来讲的方法并不是最优方法, 现如今已经有更简单方便的方法了, 但是本课我们主要是为了学习方法背后的思想.

![[d732c617cf59e831f8be11c2172cd720_MD5.jpg]]

我们仍然可以用预计算来解决后半部分积分采样的问题, 但是预计算的话我们需要将参数的所有可能性均考虑进去, 但是比较多，包括 roughness、color 等。考虑所有参数的话我们需要打印出一张五维或者更高的表格, 这样会拥有爆炸的存储量, 因此我们需要想办法降低维度, 也就是减少参数量从而实现预计算.

![[f7a880cd20315186e67f6394fb1969d8_MD5.jpg]]

在 microfacet brdf 中中，考虑的是菲涅尔项、阴影项以及法线项，由于此时暂时不考虑阴影，此处需要关注的是 Fresnel term 和 distribution of normals。

![[f0f6a8efd002a3f75c2d1188055ba7ea_MD5.jpg]]

Frenel term 可以近似成一个基础反射率 R0 和入射角度的指数函数

法线发布函数（NDF）是一个一维的分布，其中有两个变量，一个变量定义是 diffuse 还是 gloosy，另一个是 half vector 和法线中间的夹角，可以近似成入射角度相关的数，这样就变成了 3 维的预计算。

(PS: 在这里我们认为反射角, 入射角, half vector 可以用一个角 $\theta$ 代替).

至此我们有了三个变量: 基础反射率 r0, roughness $\alpha$ 和角度 $\theta$ , 三维的预计算仍然是一个存储量爆炸的结果, 因此我们还要想办法减少参数量.

所以我们通过将 Schlick 近似带入后半部分的积分中：

![[92bac7e0c09ae9868a36833f06712d65_MD5.jpg]]

基础反射 R0 被拆出积分式，需要预计算的两个量就只有 roughness $\alpha$ 和角度 $\theta$，可以将预计算结果绘制成一张纹理，在使用时进行查询即可。

![[89ab8044817bd3598a88a9bb973411aa_MD5.jpg]]

我们可以看到, 最后产生的结果是十分满意的:

![[af284f0e4f1c61b13a675710ddbff129_MD5.jpg]]

问题:

1. renel 需要预计算吗

frenel 项被拆开了，避免了对变量的依赖性

2 这张预计算是固定的吗？

是固定的。

3 Microfacet 在 ggx 中会多参数吗

不会

4. 深度学习在实时渲染中有什么应用吗

深度学习在实时渲染中并不成功，太慢了。



# 球谐函数
主要内容：**在环境光照下利用 sh 计算出 diffuse 物体的 shading 和 shadow**

本文是闫令琪教授所教授的 Games-202: Real-Time High Quality Rendrting 学习笔记的第六讲 Real-Time Environment Mapping 02，本人属于新手上路暂无驾照，有错误欢迎各位大佬指正.

[GAMES202 - 高质量实时渲染_哔哩哔哩 (゜ - ゜) つロ 干杯~-bilibili](https://www.bilibili.com/video/BV1YK4y1T7yY?p=6&spm_id_from=pageDriver)

本课目录:

![[878750a16af4e9eb91731533aab573f1_MD5.jpg]]

我们在上节课讲述了如何不采样去计算不考虑 shadow 时的 shading 值, 那么在有了环境光照情况下如何去得到物体被环境光照射下生成的阴影呢?

严格意义上来讲, 这是不可能完成的事, 因为以目前的技术来说是很难实现的, 要从两个考虑角度来说:

1. many light 问题: 我们把环境光理解为很多个小的光源, 这种情况下去生成阴影的话, 需要在每个小光源下生成 shadow map, 因此会生成线性于光源数量的 shadow map, 这是十分高昂的代价.

2. sampling 问题: 在任何一个 Shading point 上已知来自正半球方向的光照去接 rendering equation, 最简单的方法是采样空间中各方向上的不同光照, 可以做重要性采样, 虽然做了重要性采样但仍需要大量的样本, 因为最困难的是 visibility term. 由于 Shading point 不同方向上的遮挡是不相同的, 我们可以对环境光照进行重要性采样, 但一个 SP 周围的 visibility 项是未知的, 因此我们只能盲目的去采样 (我个人对盲目采样的理解是, 为了确保准确性需要对 sp 各个方向的遮挡进行采样, 因此仍然会生成大量的样本). 我们也无法提取出 visibility 项, 因为如果是 glossy brdf, 他是一个高频的, 且 Lighting 项的积分域是整个半球, 因此并不满足 smooth 或 small support, 因此无法提取出 visibility 项.

在工业界中, 我们通常以环境光中最亮的那个作为主要光源, 也就是太阳, 只生成太阳为光源的 shadow.

下面是几篇关于生成阴影的文章:

![[19519a7774f18a374c9c17ccb8b899b0_MD5.jpg]]

1. 做的是全局光照部分产生的 shadow.

2. 解决的是离线渲染中的 many lights 的问题, 核心思想是把反射物当成小光源, 把所有的小光源做一下归类并近似出照射的结果.

3. Real Time Ray Tracing, 可能是最终解决方案.

4. PRT 可以十分准确的得到来自环境光中的阴影.

但是我们知道世上没有十全十美的事情,

**那么.... 古尔丹, 代价是什么呢?**

在讲主要内容之前让我们回顾一下 GAMES101 中讲过的一些数学知识.

## **_知识储备:_**

1. 傅里叶级数展开：任何一个函数可以写成常数和一系列基函数 (不同频率 sin 和 cos 项) 的线性组合, 基函数数量越多越接近于原函数的形状：

![[3f140e0732d7bf0f3cd2da593b2dc703_MD5.jpg]]

2. 频率：在空间上图像信号数值的变化是否剧烈, 如头发区域属于高频, 因为是一根一根的，衣服, 背景等变化不剧烈的属于低频.

任何一张图 (也就是二维函数) 的频率, 也就是频域上对应的内容可以用一张频谱表示出来。

![[f070e93469a794b79e887eea411d7098_MD5.jpg]]

频谱最中心处是低频内容, 我们可以做一个 filtering (滤波), 从而去除一系列频率上的内容, 我们对这张图用一个低通滤波器, 从而把高频的内容去除掉.

![[8259430528b70f7b19c3e56a3d356ce5_MD5.jpg]]

首先我们来说一下卷积, 卷积其实就是一个模糊操作, 在图上取任意一点, 取点的周围一定区域内的像素值进行加权平均并将结果写回这个点, 这就是卷积.

![[7c5c508d087b0e2e8ee1ad8fb00481ee_MD5.jpg]]

在 spitial 域上做卷积也就等于在函数上做一个卷积, 就等于在频域上做一个原图频谱和卷积核频谱的乘积操作, 我们可以看到卷积核的高频部分几乎是黑的, 也就是 0, 做了成绩操作后原本的高频部分就消失了, 逐点相乘后得到的结果在经过逆傅里叶变化得到模糊后的图.

在本节课其实并不用这么复杂, 本节课我们要记住的是:

![[670fefe50917fbdffd0ef1774bb28eef_MD5.jpg]]

对于任意的 product integral (两个函数先乘积在积分), 我们将其认为是做了一个卷积操作, 理解为 spatial 域上的两个信号 f (x) 和 g (x) 进行一个卷积, 等于在频域上让两个信号相乘, 如果两个信号有一个信号是低频的, 那么频域上相乘后得到的结果也是低频的, 最终相乘在积分的结果也是低频的, 可以总结为：**积分之后的频率取决于积分前最低的频率，即 the frequency of the integral is the lowest of any individual’s**。

低频意味着变换更加地 smooth 或者有着 slow 的变化。

3. Basis Functions:

![[e06fe16d8009cc056e2cd8c2bde583d7_MD5.jpg]]

把一个函数可以描绘成其他函数的线性组合, 如 f (x) 可以描绘成一系列的 Bi 函数乘以各自对应的系数最终再相加在一起, 这一系列的函数 Bi 就是基函数.

回归正题, 我们要讨论的是如何在环境光照下生成阴影, 先从最简单的开始, 如果给了你环境光和一个 diffuse 的物体, 在不考虑 Shadow 的情况下如何去计算 shading 值?

为了计算 shading 值, 我们引入数学工具 ----->Spherical Harmonics (球谐函数)

在游戏渲染中, SH 有很多应用. 比如 SH 可以用来表示低频部分的环境光照, 也可以用来提供 light probe 的烘培光照等等..

## **_Spherical Harmonics (球谐函数)_**

SH 是一系列基函数, 系列中的每个函数都是 2 维函数, 并且每个二维函数都是定义在球面上的。

1. 它是一系列的基函数，可以以傅立叶变换为参考, 与里面不同频率的 cos 和 sin 函数类似, 只是全都是二维函数

2. 因为它是定义在球面上的，球面上会有不同的值, 由于在球面上两个角度 $\theta$ 和 $\varphi$ 就可以确定一个方向了, 因此可以理解为是对方向的函数, 通过两个角度变量从而知道这一方向对应在球面上的值.

下图是对 SH 的可视化，与一维的傅里叶一样, SH 也存在不同频率的函数，但不同频率的函数个数也不同, 频率越高所含有的基函数越多。

图中的颜色表示的是值的大小, l=0 中, 越偏白的蓝色地方值越大, 越黑的地方值越小. 而黄色中则表示偏白的地方表示其绝对值大, 偏黑的地方表示绝对值小. 也就是蓝色表示正, 黄色表示负.

频率表示的就是值的变化, 因此可以很清晰的从形状看出.

![[c6e96c7e9f527f4bba2eabb395f0a096_MD5.jpg]]

其中，l 表示的是阶数，通常第 l 阶有 $2l+1$ 个基函数，前 n 阶有 $n^2$ 个基函数，m 表示的是在某一个频率下基函数的序号，分别从从 $-l$ 一直到 $l$。每个基函数都有一个比较复杂的数学表示，对应一个 legendre 多项式，我们不用去了解 legendre 多项式, 我们只需要知道基函数长这样, 可以被某些数学公式来定义不同方向的值是多少就可以了.

下面定义一些操作：

**投影**：由于一个函数 $f(w)$ 可以由一系列基函数和系数的线性组合表示，那么怎么确定基函数前面的系数，这就需要通过投影操作：

![[9b5ab4dc8a9a6e5932b54184ad5cdf2b_MD5.png]]

我们知道函数 F (X), 通过对应的基函数 B (i) 进行投影操作, 从而求出各基函数对应的系数 Ci, 与以下操作是同一个道理, 在空间中想描述一个向量，可以 xyz 三个坐标来表达，把 xyz 轴当做三个基函数，把向量投影到 xyz 轴上，得到三个系数就是三个坐标。

**重建**：知道基函数对应的系数，就能用系数和基函数恢复原来的函数。

由于基函数的阶可以是无限个的，越高的阶可恢复的细节就越好, 但一方面是因为更多的系数会带来更大的存储压力、计算压力，而一般描述变化比较平滑的环境漫反射部分，用 3 阶 SH 就足够了；另一方面则是因为 SH 的物理含义不是特别好理解，高阶 SH 容易出现各种花式 Artifact，美术同学一般都会认为这种表现属于 bug。

![[b15f86554f983e68bab406f7fbafc308_MD5.png]]

f (w) 可以是任何一个函数, 我们说过基函数可以重建任何一个球面函数, 那么我们这里的 f (w) 就是环境光照, 由于环境光是来自于四面八方且都有值, 所以环境光照就是一个球面函数,, 我们可以把它投影到任何一个 SH basis 上, 可以投影很多阶, 但是只需要取前三阶的 SH 去恢复环境光就可以恢复出最低频的细节了, 这个在下文 RAVI 教授的结论有提到.

这里补充一些球谐函数的性质：

**正交性: 能够较简单地投影 / 重建、simple rotation。**

![[59c7f34ea00747d2bff2cc9810869a27_MD5.jpg]]

旋转是一个很重要的性质：**旋转一个基函数之后，得到的函数就不再是一个基函数 (因为基函数有严格的朝向等限制)，但是旋转球谐函数等价于同阶基函数的线性组合。**

Ravi 教授等人在 01 年左右做过一些实验发现，diffuse BRDF 类似于一个低通滤波器，使用一些低频信息就可以恢复出原始内容。回忆一下，在本文之前的内容中曾说过：“**积分之后的频率取决于积分前最低的频率**”，当 diffuse BRDF 使用低频信息即可恢复内容时，也就意味着无论光照项是多么复杂，其本应该用多高频的基函数去表示，但我们希望得到的是其与 BRDF 之积的积分，所以可以使用比较低频的基函数去描述灯光。下面的实验结果意味着，遇到 diffuse 的物体时使用前 3 阶的球谐基函数就可以基本重建出正确率 99% 的结果，

![[24033880a0d3128f91fb6265fe26eeb7_MD5.jpg]]

## 到目前为止，这里只解决了如何根据环境光照进行 shading，主要说明球谐函数的作用，仍没考虑 shadow 问题，接下来我们要解决两个问题:

1. 将 shadow 考虑进去

2. 我们仍然用基函数思路去考虑任何的 brdf.

解决的思路就是 prt, 接下来我们进入 prt 学习:

## **_PRT_**

在实施渲染中, 我们把 rendering equation 写成由三部分组成的积分:

![[7ee830d85fcd905a0126e542ef05fe3f_MD5.jpg]]

光照项, visibility 项和 brdf 项, 这三项都可以描绘成球面函数, 这里用的是 cube map 描述法, 那么最简单的解这个方程的方法就是每个像素挨个去乘, 假设环境光是 $6*64*64$ 的 map，对于每个 shading point 来说，计算 shading 需要计算 $6*64*64$ 次。这个开销是十分大的.

因此我们利用基函数的基本原理把一些东西先预计算出来, 从而节省开销.

![[d642b5d298cbf75505c8a82556d29123_MD5.jpg]]

PRT 的基本思想:

我们把 rendering equation 分为两部分, lighting 和 light transport.

假设在渲染时场景中只有 lighting 项会发生变化 (旋转, 更换光照等), 由于 lighting 是一个球面函数, 因此可以用基函数来表示, 在预计算阶段计算出 lighting.

而 light transport (visibility 和 brdf) 是不变的, 因此相当于对任一 shading point 来说, light transport 项固定的, 可以认为是 shading point 自己的性质, light transport 总体来说还是一个球面函数, 因此也可以写成基函数形式, 是可以预计算出的.

我们分为两种情况, diffuse 和 glossy:

Diffuse:

![[02c9e45220740f040102b09f0c30f364_MD5.jpg]]

由于在 diffuse 情况下, brdf 几乎是一个常数, 因此我们把 brdf 提到外面.

![[e90920cad0aad1fe5dc6f14bd3769ab7_MD5.jpg]]

由于 lighting 项可以写成基函数的形式, 因此我们求和式把其代入积分中, 对于任何一个积分来说, 在 Bi 的限制下, li 此对积分来说是常数, 可以提出来.

![[72b3d9a0b6421ba178dc0dc620ddc3ad_MD5.jpg]]

对于积分中的部分来说, Bi 是基函数, v 和 cos 项在一起不就是 light transport 吗, 那不就是 light transport 乘与一个基函数，这就成了 lighting transport 投影到一个基函数的系数，接下来代入不就能进行预计算了吗，这样就只要算一个点乘就好了。

之所以说是点乘, 结果是个求和, 我们要计算 $l_{1}T_{1}$ + $l_{2}T_{2}$ +......, 不正好相当于两个向量点乘吗.

所以对于任何一个 shading point 我们去算他的 shading 和 shadow, 只需要计算一个点乘就可以了, 十分方便,

## **_但是, 没有东西是十全十美的, 那么, 古尔丹, 这次的代价又是什么呢?_**

**1. light transport 做了预计算, 因此 visibility 当了常量, 因此场景不能动, 因此只能对静止物体进行计算.**

**2. 对于预计算的光源我们把它投影到 sh 上, 如果光源发生了旋转, 那不就相当于换了个光源吗?**

**但是第二个问题由于 sh 函数的旋转不变性可以完美的解决.**

**旋转光照 = 旋转 SH 的基函数**

**但任何一个 SH 基函数旋转后都可以被同阶的 SH 基函数线性组合表示出来**

**因此, 我们根据这个性质, 还是可以立刻得出旋转后的 sh 基函数新的线性组合.**

![[986aa8a613afeb994058511f44609393_MD5.jpg]]

![[fefa799691c3c55319cb2d9de96efb06_MD5.jpg]]

用的阶数越多越接近与原始函数, 第四张图是前 26 阶函数去重建原始函数, 可以看到效果还不错. 但我们在使用时用不到那么多阶.

![[feac22b70bc7dc4a5e5de68a45eae604_MD5.jpg]]

我们将 lighting 这个球面函数, 通过 SH 的基函数用一堆系数来表示, 这些系数排成一行也就是组成了向量, 因此光照变成了一个向量.

如果要重建原函数则只需要把这些系数乘以对应的基函数再加在一起即可.

![[1b95c21b053249c9221814cb0190b315_MD5.jpg]]

我们可以把 Bi 理解为 lighting, 也就是说每个 basis 所描述的环境光去照亮这个物体从而得到照亮之后的结果, 我个人理解预计算就是把每个 basis 照亮得到的结果生成.

![[c97c488484872a02fea1e3365b32d170_MD5.jpg]]

最后我们在计算 shading 和 shadow 时只需要进行向量 li 和 ti 的点乘即可得到结果.

到此我们知道了如何再已知环境光的情况下, 通过使用 PRT 来计算出 diffuse 物体的 shading 和 Shadow 了.

下节课我们讲关于 glossy 和全局光照.