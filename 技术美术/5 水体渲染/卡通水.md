

---
title: 卡通水
aliases: []
tags: []
create_time: 2023-08-02 13:55
uid: 202308021355
banner: "![[8c71359a0845ad35f2e8feb8b31a627a_MD5.gif]]"
---

[https://roystan.net/articles/toon-water.html](https://roystan.net/articles/toon-water.html)

接下来，我会从几个方面概括实现过程：

1.  基于水深度的水着色
2.  基于 uv 的水波纹动画
3.  采样屏幕空间法线，和观察空间顶点法线点积。实现**垂直与水平**水面的物体泡沫量的单独调整
4.  自定义混合模式，实现可改变的泡沫颜色
5.  用 SmoothStep 代替阈值 cutoff，实现抗锯齿

首先调整为 AplhaBlend 模式
- 渲染队列改为 Transparent
- 混合模式改为：Blend SrcAlpha OneMinusSrcAlpha
- 关闭深度写入
# 1 基于深度着色

## 计算水深
水深 = 水下不透明物体在深度纹理中的观察空间深度（深度纹理中采样） -  水面的观察空间深度 ( i.positionCS. w = -positionVS. z）

```c h:1,13,15
//1 水下不透明物体在深度纹理中的观察空间深度
#if UNITY_REVERSED_Z
float opaqueDepth = SampleSceneDepth(ScreenUV);
#else
float opaqueDepth = lerp(UNITY_NEAR_CLIP_VALUE, 1, SampleSceneDepth(ScreenUV));
#endif
float opaqueDepthVS = LinearEyeDepth(opaqueDepth, _ZBufferParams);  //线性
//2 水面的观察空间深度
float waterSurfaceDepth = i.positionCS.w; //或= -i.positionVS.z
//3 计算水深
float WaterDepth = opaqueDepthVS - waterSurfaceDepth;
```

![[Pasted image 20230805153639.png]]

**水上水下的判定：**
![[Pasted image 20230805154127.png]]

## 深度插值着色

*   水和地面距离近时颜色表现为浅色（绿色部分）
*   水和地面距离较远时表现为深色（红色部分）

![[8a678073c4caa7d205a8aa37371d4db0_MD5.png]]

- 用 Lerp 函数对浅水区颜色和深水区颜色进行插值
- 通过调整最大深度值参考，控制近处和远处水颜色
```c
//4 除以最大水深，归一化深度
float waterDepthNormalize = saturate(waterDepth / _MaxDepth);
//5 插值深度着色
float4 waterColor = lerp(_ShallowColor, _DepthColor, waterDepthNormalize);
```

# 二、水波纹

## 1. 使用 Perlin Noise 添加波纹

*   我们使用柏林 noise 在水的表面添加波浪，并且用水深度来控制波浪的可见度（浅水处更明显，产生海岸线效果）

**a. 采样 noise**

```c
//声明个新属性用来读noise图
_SurfaceNoise("Surface Noise", 2D) = "white" {}

// 输入结构增加uv
float4 uv : TEXCOORD0;

// 输出结构增加uv
float2 noiseUV : TEXCOORD0;

// 使用前声明变量
sampler2D _SurfaceNoise;
float4 _SurfaceNoise_ST;//支持Tilling和offset

// 顶点着色器：传递uv，并支持Tilling和Offset
o.noiseUV = TRANSFORM_TEX(v.uv, _SurfaceNoise);

//片元着色器：采样noise
float surfaceNoiseSample = tex2D(_SurfaceNoise, i.noiseUV).r;
```

**b. 风格化波纹**

*   直接采样 noise 的效果是很辣眼睛的，我们需要再进行更卡通的改造
*   // 如果接触过卡渲风格的传统经验关照，一个思路就是将渐变过程截断成 “卡硬” 效果
*   所以这里我们设定一个阈值对上一步采样的 noise 结果进行 cutoff：

*   小于这个阈值的将会被直接舍弃（0）
*   大于这个阈值的将会被设为 1

```c
// Add as a new property.
_SurfaceNoiseCutoff("Surface Noise Cutoff", Range(0, 1)) = 0.777

// Matching property variable.
float _SurfaceNoiseCutoff;

// Add in the fragment shader, just after sampling the noise texture.
float surfaceNoise = surfaceNoiseSample > _SurfaceNoiseCutoff ? 1 : 0;
```

*   **// 阶段展示**  
    此时我们的已经可以通过调整阈值来控制还波纹

![[e4d5bac9d42d1688771e3b830b177ba4_MD5.gif]]

## 2. 与水相交的泡沫
泡沫产生区域：浅水区

思路：
*   基于水深度，调整 noise 的 cutoff 阈值

```c
// Control for what depth the shoreline is visible.
_FoamDistance("Foam Distance", Float) = 0.4

// Matching variable.
float _FoamDistance;

// 片元着色器
float foamDepthDifference01 = saturate(depthDifference / _FoamDistance);
	//泡沫深度
float surfaceNoiseCutoff = foamDepthDifference01 * _SurfaceNoiseCutoff;
	//将泡沫深度乘给cutoff阈值
float surfaceNoise = surfaceNoiseSample > surfaceNoiseCutoff ? 1 : 0;
```

*   **// 阶段展示**  
    可以看到，通过调节 foam DIstance 参数，我们就可以控制和水相交物体的泡沫距离

// 例子资产中地形模型就有下凹，这一步我只是将水材质的 plane 往下移动了一下，相交就是圆形边缘

注：这里有个问题：

*   水和岸的相交点很棒，但和物体的相交处缺不明显
*   后续我们会解决

![[d71558de32377863358341a23ffcec16_MD5.gif]]

## 3. 水流动、扰动动画

接下来我们为水添加动画效果

**a. 水流动（uv 流动）**

*   思路：

*   通过_Time 参数对采样 noise 的 uv 进行偏移，实现动画效果

```c
// Property to control scroll speed, in UVs per second.
_SurfaceNoiseScroll("Surface Noise Scroll Amount", Vector) = (0.03, 0.03, 0, 0)

float2 _SurfaceNoiseScroll;

// 片元着色器
float2 noiseUV = float2(i.noiseUV.x + _Time.y * _SurfaceNoiseScroll.x, i.noiseUV.y + _Time.y * _SurfaceNoiseScroll.y);
	//偏移采样noise的uv，来产生动画效果
float surfaceNoiseSample = tex2D(_SurfaceNoise, noiseUV).r;
```

*   效果如下图

可以通过更改_SurfaceNoiseScroll 参数来控制流动方向和速度

![[b93368e3870a9f010d1d8f24b7e41f39_MD5.gif]]

**b. 水扰动**
FlowMap 来处理噪声贴图, 让噪声贴图流动起来
# 三、解决和漂浮物相交泡沫不明显问题

*   岸边和水面之间的深度相当小，而水面和水下物体之间的深度（从相机的角度）相对较大。

*   **解决方法**：
    *   **方案 1：**
    *   将_FoamDistance 参数增加到 0.4 左右即
    *   这样一来岸边的部分就太大了

![[edccb30029127ac3971c067e5343ef5b_MD5.png]]

*   **方案 2：**
    *   根据**水面以下的角度**来改变**泡沫的深度（foam depth）**
    *   这样一来，垂直的物体表面（和漂浮物相交部分）可以比平坦的物体表面（岸边）得到更多的泡沫（白色）

接下来就开始施行方案 2，需要用的法线纹理


**a. 计算水面的 view space 法线**

我们需要计算**水的 view space 下的法线**，来和渲染好的法线做比较
```cs
//观察空间法线  
float3 normalVS = TransformWorldToViewNormal(N);
```

> [!NOTE] 理解观察空间法线
> 随着摄像机位移不断变化，Unity 摄像机在观察空间看向-z，所以朝向摄像机的法线都为 z 轴方向，越朝向相机值越接近（0，0，1）
> 
![[202308012045.gif]]


水面的法线纹理寸的法线，都是指向正 y 轴，值为（0，1，0）。
当相机平视水面时，观察空间法线的值也是接近（0，1，0），夹角小点积结果大。
当相机垂直观察水面时，观察空间法线越来越接近（0，0，1），夹角变大，点积结果变小。

**为什么这会让水面漂浮物的泡沫更多呢？**
深度法线纹理：
![[Pasted image 20230802141329.png|350]]

观察空间法线：
![[Pasted image 20230802141356.png|350]]

点积结果
![[Pasted image 20230802141427.png|350]]

很直观，交界处点积结果小，水面点积结果大。这样就区分出了交界的点积区别。

```cs
float3 NormalsTexture = SampleSceneNormals(ScreenUV); //法线纹理
float3 normalDot = saturate(dot(NormalsTexture, normalVS)); //法线纹理点积观察空间法线
```

我们使用 lerp，让交界处的值对应大值 `_FoamMaxDistance`，让水面对应小值 `_FoamMinDistance`。这样计算 `foamDepthDifference` 时交界处的值就小（代表深度差异小）。
```c
float foamDistance = lerp(_FoamMaxDistance, _FoamMinDistance, normalDot);
float foamDepthDifference = saturate(depthDifference / foamDistance);
```

这样计算裁剪值时，交界处的裁剪值就小。
```cs
float FoamNoiseCutoff = foamDepthDifference * _SurfaceNoiseCutoff;
```

![[100235deb9fad05e85d13a2a4dd19645_MD5.gif]]

# 四、FlowMap 处理噪声图

```cs
//扰动噪声贴图的uv  
float2 noiseUV = float2(i.noiseUV.x + _Time.y * _TimeSpeed.x,i.noiseUV.y + _Time.y * _TimeSpeed.y);  
//FlowMap来处理噪声贴图  
float3 flowDir = SAMPLE_TEXTURE2D(_FlowMap, sampler_FlowMap, i.uv)*2.0-1.0;  
flowDir*=_FlowSpeed;  
float phase0 = frac(_Time.y*_TimeSpeed.x);  
float phase1 = frac(_Time.y*_TimeSpeed.x+0.5);  
float tex0 = SAMPLE_TEXTURE2D(_SurfaceNoise, sampler_SurfaceNoise, noiseUV-flowDir.xy*phase0).rgb;  
float tex1 = SAMPLE_TEXTURE2D(_SurfaceNoise, sampler_SurfaceNoise, noiseUV-flowDir.xy*phase1).rgb;  
float NoiseFlowTex = lerp(tex0,tex1,abs((0.5-phase0)/0.5));
```

# 五、抗锯齿

*   仔细观察一下，我们能法线泡沫的边缘实际上锯齿是比较严重的。
*   锯齿严重的原因是我们 cutoff noise 的方式：**不是 0 就是 1**

![[bbd31c5b93b25fdf6cd7183ff4b1518f_MD5.png]]

**解决方法**
*   使用 SmoothStep 函数将 Alpha 从 0 到 1 平滑过渡

*   实现：
*   注释掉之前的 cutoff 方法，改用 smoothstep 计算
*   **我们定义`_FoamEdgeFade` 值必须很小，让 smoothStep 的下限和上限非常接近，0~1 的变化斜率非常大。`_FoamEdgeFade`太大会过于软，没有卡通效果**
*   它们之间的距离刚好可以给边缘增加一些平滑度。

```
//卡通硬边会有锯齿
//float FoamNoise = NoiseFlowTex > FoamNoiseCutoff ? 1 : 0;
//抗锯齿：平滑过渡
float FoamNoise = smoothstep(FoamNoiseCutoff-_FoamEdgeFade,FoamNoiseCutoff+_FoamEdgeFade,NoiseFlowTex);
```