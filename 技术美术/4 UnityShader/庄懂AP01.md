参考：[Shader学习From庄懂 - 知乎 (zhihu.com)](https://www.zhihu.com/column/c_1420948324648644608)
# 庄老师的宝藏网站
来自14&16课16：30，庄老师的收藏夹
庄老师推荐的博客：https://simonschreibt.de/
## A
![[Pasted image 20221020215455.png|300]]
![[Pasted image 20221020215202.png|300]]
![[Pasted image 20221020215057.png|300]]
![[Pasted image 20221020215430.png|300]]
## T
![[Pasted image 20221020215300.png]]
![[Pasted image 20221020215324.png]]
![[Pasted image 20221020215559.png]]
![[Pasted image 20221020215123.png|300]]
# 第2课
## 卡渲RampTex（渐变纹理）特点：![[Pasted image 20221005233058.png]]
三阶明度，过渡卡硬  （卡硬：有过度，很硬 /卡死：没过度）-》卡硬不卡死
暗部细节通过色相变化，离暗部比较进的偏暖一点，离暗部比较远的偏冷一点。少用明度变化！
# 第6课
## 其他反射模型
![[Pasted image 20221017215618.png]]
## BRDF工具
![[Pasted image 20221017215830.png]]
# 第7课
## 三色环境光
通过对World Normal的G通道进行拆解，实现上中下三色环境光。图示（上红中黄下绿）
![[Pasted image 20221017230559.png|300]]
![[Pasted image 20221017230226.png]]
```less
Shader "Unlit/code"  
{  
    Properties  
    {  
        _MainTex ("Texture", 2D) = "white" {}  
        _UpColor("UPColor",Color) = (1,1,1,1)  
        _MiddleColor("MiddleColor",Color) = (1,1,1,1)  
        _DownColor("DownColor",Color) = (1,1,1,1)  
    }  
    SubShader  
    {  
        Tags { "RenderType"="Opaque" }  
        LOD 100  
  
        Pass  
        {  
            CGPROGRAM  
            #pragma vertex vert  
            #pragma fragment frag  
  
            #include "UnityCG.cginc"  
  
            struct appdata  
            {  
                float4 vertex : POSITION;  
                float2 uv : TEXCOORD0;  
                float3 normal : NORMAL;  
            };  
  
            struct v2f  
            {  
                float2 uv : TEXCOORD0;  
                float4 vertex : SV_POSITION;  
                float3 normal : TEXCOORD1;  
            };  
  
            sampler2D _MainTex;  
            float4 _MainTex_ST;  
            float4 _UpColor;  
            float4  _MiddleColor;  
            float4 _DownColor;  
  
            v2f vert (appdata v)  
            {  
                v2f o;  
                o.vertex = UnityObjectToClipPos(v.vertex);  
                o.normal = UnityObjectToWorldNormal(v.normal);  
                o.uv = TRANSFORM_TEX(v.uv, _MainTex);  
                return o;  
            }  
  
            fixed4 frag (v2f i) : SV_Target  
            {  
                float3 world_Normal = normalize(i.normal);  
  
                //计算各部分遮罩  
                float UpMask = saturate(world_Normal.y);  
                float DownMask = saturate(-world_Normal.y);  
                float MiddleMask = saturate(1- UpMask - DownMask);  
  
                float4 UpColor = _UpColor * UpMask;  
                float4 DownColor = _DownColor * DownMask;  
                float4 MiddleColor = _MiddleColor * MiddleMask;  
  
                float4 AO = tex2D(_MainTex, i.uv);  
                float4 finalColor = (UpColor + DownColor + MiddleColor) * AO;  
                return finalColor;  
            }  
            ENDCG  
        }  
    }  
}
```
## 理解光照
### 美术向：烘焙AO图
[Blender2.8基础三：贴图烘培篇_Ainoe的博客-CSDN博客_blender 烘培](https://blog.csdn.net/u012204304/article/details/105428982)
[SP烘焙贴图 & Blender 的 AO贴图节点连接方法_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1py4y1b7wd/)
![[Pasted image 20221017232019.png]]
![[Pasted image 20221017232154.png]]
### OldSchoolPlus
![[Pasted image 20221018201209.png|300]]
```less
Shader "Unlit/code"  
{  
    Properties  
    {  
        _MainTex ("Texture", 2D) = "white" {}  
        _LightColor("LightColor",Color) = (1,1,1,1)  
        _UpColor("UPColor",Color) = (1,1,1,1)  
        _MiddleColor("MiddleColor",Color) = (1,1,1,1)  
        _DownColor("DownColor",Color) = (1,1,1,1)  
          
        _SpecularExp("PhongExp",Float) = 1    
        _SpecularScale("PhongScale",Float) = 1    
}  
    SubShader  
    {  
        Tags { "RenderType"="Opaque"  "LightMode" = "ForwardBase"}  
        Pass  
        {  
            CGPROGRAM  
            #pragma vertex vert  
            #pragma fragment frag  
            #pragma multi_compile_fwdbase_fullshadows  
            #include "UnityCG.cginc"  
            #include "Lighting.cginc"  
            #include "AutoLight.cginc"   //计算阴影时所用的宏都在这个文件中声明  
            struct appdata  
            {  
                float4 vertex : POSITION;  
                float2 uv : TEXCOORD0;  
                float3 normal : NORMAL;  
            };  
  
            struct v2f  
            {  
                float2 uv : TEXCOORD0;  
                float4 pos : SV_POSITION;   //因为下面调用了TRANSFER_VERTEX_TO_FRAGMENT(o) 这个方法，而这个方法里面有用到pos，所以这里必须用写成pos  
                LIGHTING_COORDS(1,2) //投影用坐标信息，LIGHTING_COORDS(x,y)是Unity封装好的,注意无分号  
                float3 normal : TEXCOORD3;  
                float3 worldPos : TEXCOORD4;  
            };  
  
            sampler2D _MainTex;  
            float4 _MainTex_ST;  
            float4  _LightColor;  
            float4 _UpColor;  
            float4  _MiddleColor;  
            float4 _DownColor;  
            float _SpecularExp;  
            float _SpecularScale;  
            v2f vert (appdata v)  
            {  
                v2f o;  
                o.pos = UnityObjectToClipPos(v.vertex);  
                o.normal = UnityObjectToWorldNormal(v.normal);  
                o.worldPos = mul(unity_ObjectToWorld,v.vertex);  
                o.uv = TRANSFORM_TEX(v.uv, _MainTex);  
                TRANSFER_VERTEX_TO_FRAGMENT(o);  
                return o;  
            }  
  
            fixed4 frag (v2f i) : SV_Target  
            {  
                float3 world_Normal = normalize(i.normal);  
                float3 world_LightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));  
                float3 world_ViewPos = normalize(UnityWorldSpaceViewDir(i.worldPos));  
                float3 world_HalfVector = normalize(world_LightDir + world_ViewPos);  
                  
                //Diffuse  
                float4 Lambert = dot(world_Normal,world_LightDir) * 0.5 + 0.5;  
                //Specular  
                float4 BlinnPong =pow(saturate(dot(world_Normal ,world_HalfVector)),_SpecularExp) * _SpecularScale;  
                //Shadow  
                float shadow = LIGHT_ATTENUATION(i); //取出投影  
                float3 LightingColor =  (Lambert + BlinnPong) * _LightColor * shadow ;  
                  
                //计算各部分遮罩  
                float UpMask = saturate(world_Normal.y);  
                float DownMask = saturate(-world_Normal.y);  
                float MiddleMask = saturate(1- UpMask - DownMask);  
  
                float3 UpColor = _UpColor * UpMask;  
                float3 DownColor = _DownColor * DownMask;  
                float3 MiddleColor = _MiddleColor * MiddleMask;  
  
                float AO = tex2D(_MainTex, i.uv);  
                float3 finalColor = (UpColor + DownColor + MiddleColor) * AO;  
  
                float3 finalRGB =  finalColor + LightingColor;  
                return float4(finalRGB,1);  
            }  
            ENDCG  
        }  
    }  
    FallBack "Diffuse"   //不写FallBack，又不自己写额外的Pass，会导致不显示阴影  
}
```
# 第10课 OldSchoolPro
![[Pasted image 20221019192557.png|300]]
## 贴图
1. 将AO图和高光次幂放在A通道：因为这样可以节省一次采样，优化性能；要充分利用贴图的每个通道，所以其实这里的自发光贴图的运用很浪费通道资源
2. 为什么不利用法线贴图的通道：这涉及到法线贴图的解码精度，如果法线贴图只用2个通道存储，转成法线会有“噪点”，虽然也可以利用法线的通道做其他事情，但是会有进精度损失，实际情况看自己的取舍
3. 非金属反射白光，金属反射的光颜色是自身颜色
### MainTex
**RGB:基础颜色 ， A:AO**
**头部**
![[Pasted image 20221019193423.png|300]]
![[Pasted image 20221019193434.png|300]]
**身体**
![[Pasted image 20221019193558.png|300]]
![[Pasted image 20221019193608.png|300]]

### EmissiveMap
自发光贴图
![[Pasted image 20221019193511.png|300]]
### NormalMap
头部
![[Pasted image 20221019193646.png|300]]
身体
![[Pasted image 20221019193702.png|300]]

### SpecularMap
**RGB:高光颜色 ；A:高光次幂（光滑度）——高光遮罩**
**头部**
![[Pasted image 20221019193732.png|300]]
![[Pasted image 20221019193747.png|300]]
**身体**
![[Pasted image 20221019193758.png|300]]
![[Pasted image 20221019193805.png|300]]
### CubeMap
![[Pasted image 20221019193849.png|300]]
## 代码
```less
Shader "Unlit/myOldSchoolpro"  
{    
    Properties    
{    
        [Header(Texture)]  
        _MainTex("RGB:基础颜色 A:环境遮罩", 2D) = "white" {}  //A通道放了AO  
        [Normal]_NormalMap("RGB:法线贴图", 2D) = "bump" {}  //法线其他通道也可以塞东西需要解码（暂不掌握）  
        _SpecularMap("RGB:高光颜色 A:高光次幂", 2D) = "gray" {}  //A通道要remap到1~90  
        _EmissiveMap("RGB:自发光贴图", 2d) = "black" {}  
        _CubeMap("RGB:环境贴图", Cube)  = "white" {}  
          
        [Header(Diffuse)]  
        _MainColor("基本色",Color) = (0.5, 0.5, 0.5, 1)  
        _AmbDiffuseScale ("环境漫反射强度",  Range(0, 1))    = 0.2  
        _AmbUpColor("环境顶部颜色",Color) = (1, 1, 1, 1)    
        _AmbMiddleColor("环境中部颜色",Color) = (0.5, 0.5, 0.5, 1)   
        _AmbDownColor("环境底部颜色",Color) = (0, 0, 0, 0)  
          
        [Header(Specular)]  
        _SpecularExp("高光次幂",Float) = 1      
_AmbSpecularScale("环境镜面反射强度", Range(0, 5)) = 0.2  
        _FresnelExp("菲涅尔次幂", Float) = 5  
        _FresnelScale("菲涅尔强度", Float)  = 1  
        _CubemapMip("环境球Mip", Range(0, 7)) = 1  
  
        [Header(Emission)]  
        _EmissiveScale("自发光强度", range(1, 10)) = 1  
    }  
    SubShader    
{    
        Tags { "RenderType"="Opaque"  "LightMode" = "ForwardBase"}    
        Pass    
{    
            CGPROGRAM    
#pragma vertex vert    
            #pragma fragment frag    
            #pragma multi_compile_fwdbase_fullshadows    
            #include "UnityCG.cginc"    
#include "Lighting.cginc"    
#include "AutoLight.cginc"   //计算阴影时所用的宏都在这个文件中声明    
struct appdata    
{    
                float4 vertex : POSITION;    
                float2 uv : TEXCOORD0;    
                float4 normal : NORMAL;  
                float4 tangent : TANGENT;  
            };    
    
            struct v2f    
{  
                float4 pos : SV_POSITION;    
                float2 uv : TEXCOORD0;  
                float3 world_Normal : TEXCOORD1;    
                float3 world_Pos : TEXCOORD2;  
                float3 world_Tangent : TEXCOORD3;  
                float3 world_Bitangent : TEXCOORD4;  
                LIGHTING_COORDS(5,6)  
            };    
  
            //Texture  
            sampler2D _MainTex;    
            float4 _MainTex_ST;  
            sampler2D _NormalMap;  
            sampler2D _SpecularMap;  
            sampler2D _EmissiveMap;  
            samplerCUBE _CubeMap;  
              
            //Diffuse  
            float4 _MainColor;  
            float _AmbDiffuseScale;  
            float4 _AmbUpColor;  
            float4 _AmbMiddleColor;  
            float4 _AmbDownColor;  
              
            //Specular  
            float _SpecularExp;    
            float _AmbSpecularScale;  
            float _FresnelExp;  
            float _FresnelScale;  
            float _CubemapMip;  
          
            //Emission  
            float _EmissiveScale;  
              
            v2f vert (appdata v)    
            {    
                v2f o;    
                o.pos = UnityObjectToClipPos(v.vertex);  
                o.uv = v.uv;  
                o.world_Normal = UnityObjectToWorldNormal(v.normal);    
                o.world_Pos= mul(unity_ObjectToWorld,v.vertex);    
                o.world_Tangent = normalize(UnityObjectToWorldDir(v.tangent));  
                o.world_Bitangent = normalize(cross(o.world_Normal,o.world_Tangent) * v.tangent.w);  
                  
                TRANSFER_VERTEX_TO_FRAGMENT(o);    
                return o;    
            }    
    
            fixed4 frag (v2f i) : SV_Target    
            {  
                //向量计算  
                float3 world_LightDir = normalize(UnityWorldSpaceLightDir(i.world_Pos));    
                float3 world_ViewDir = normalize(UnityWorldSpaceViewDir(i.world_Pos));    
                float3 world_HalfVector = normalize(world_LightDir + world_ViewDir);    
                float3 tangent_NormalMap = UnpackNormal(tex2D(_NormalMap, i.uv)).rgb;  
                float3x3 TBN = float3x3 (i.world_Tangent,i.world_Bitangent,i.world_Normal);  
                float3 world_NormalMap = normalize(mul(tangent_NormalMap, TBN));  
                  
                //采样纹理  
                float4 MainTex = tex2D(_MainTex, i.uv);  
                float4 SpecularMap = tex2D(_SpecularMap, i.uv);  
                float3 EmissiveMap = tex2D(_EmissiveMap, i.uv);  
                float CubeMapMip = lerp(_CubemapMip, 0, SpecularMap.a);  
                float3 Reflect = reflect(-world_ViewDir,world_NormalMap);  
                //高光次幂可以理解成光滑度，即越亮的地方越光滑 _CubemapMip值要大于0，表示不光滑的部分  
                //越光滑，反射越清晰。越粗糙，反射越模糊。使得采样的cubemap各部分清晰度不同  
                float3 CubeMap = texCUBE(_CubeMap,float4(Reflect, CubeMapMip)).rgb;  
  
                //________________直接光照部分__________________//   
                //BaseColor  
                float3 BaseColor = MainTex.rgb * _MainColor;  
                  
                //Diffuse    
float Lambert = dot(i.world_Normal, world_LightDir) * 0.5 + 0.5;  
                  
                //Specular  
                float3 SpecularColor = SpecularMap .rgb;  
                float SpecularExp = lerp(1, _SpecularExp,SpecularMap.a); //原理还是光滑度  
                float BlinnPong =pow(saturate(dot(i.world_Normal ,world_HalfVector)),SpecularExp);  
                  
                //Shadow    
float shadow = LIGHT_ATTENUATION(i); //取出投影  
  
                //光源反射混合  
                float3 DirLighting =  (BaseColor * Lambert + SpecularColor * BlinnPong) * _LightColor0 * shadow ;    
                //_LightColor0是 "Lighting.cginc"内置的变量  
                //________________环境光照部分__________________//  
                //环境AO  
                float AO = MainTex.a;  
                //3ColAmbient  
                float UpMask = saturate(i.world_Normal.y);    
                float DownMask = saturate(-i.world_Normal.y);    
                float MiddleMask = saturate(1- UpMask - DownMask);    
                  
                float3 AmbUpColor = _AmbUpColor * UpMask;    
                float3 AmbDownColor = _AmbDownColor * DownMask;    
                float3 AmbMiddleColor = _AmbMiddleColor * MiddleMask;  
                float3 AmibitionColor = (AmbUpColor + AmbDownColor + AmbMiddleColor) * AO;   
                 
                //菲涅尔  
                float Fresnel = pow(saturate(1- dot(world_ViewDir, i.world_Normal)),_FresnelExp) * _FresnelScale;  
  
                float3 AmbLighting = (BaseColor * AmibitionColor * _AmbDiffuseScale + CubeMap * Fresnel * _AmbSpecularScale * SpecularMap.a) * AO;  
  
                //________________自发光部分__________________//  
                float3 Emissive = EmissiveMap * _EmissiveScale * (sin(_Time.z) * 0.5 + 0.5);  
  
                float3 FinalColor = DirLighting + AmbLighting + Emissive;  
                  
                return float4(FinalColor,1);  
            }    
            ENDCG    
}    
    }    
    FallBack "Diffuse"   //不写FallBack，又不自己写额外的Pass，会导致不显示阴影  }
```


# 第12课 食人魔法师
[Steam 客服 :: Dota 2 创意工坊 - 物品着色器遮罩 (steampowered.com)](https://help.steampowered.com/zh-cn/faqs/view/299C-D7F9-09A5-98B6)
## 文档分析
![[Pasted image 20221019224718.png]]
## 资源分析
![[AP01_L12_12.jpg]]![[AP01_L12_13.jpg]]


## 贴图细节
### MainTex
**二合一**

**RGB：基本颜色**
![[Pasted image 20221019230525.png|300]]
**A：透贴**
![[Pasted image 20221019230952.png|300]]
### MaskTex
Mask：遮罩
**三个Mask+高光次幂 合一**

**R:高光强度**
![[Pasted image 20221019231123.png|300]]
**G：边缘光强度**
很像AO，处理的很剧烈，并且叠加了纹理信息
![[Pasted image 20221019231151.png|300]]
**B：高光染色**
越是黑色，染色越多；越是白色，染色越少。
金属部分都染色比较多，废金属部分除了皮肤，其他部分都为白色（不染色）
![[Pasted image 20221019231300.png|300]]
**A：高光次幂**
越白越光滑，越黑越粗糙。
金属、裤子、披风：粗糙
皮革部分（帽子）、牙齿：光滑
![[Pasted image 20221019231315.png|300]]

### 菲涅尔Warp图
美术向疑问：如何实现三合一
菲尼尔Warp图RGB颜色：
![[Pasted image 20221019232110.png|300]]
对Warp图lerp并取出各通道：
```less
float3 fresnel = lerp(FresnelWarp,0.0,MatelnessMask); //金属菲涅尔现象不明显  
float fresnelColor = fresnel.r;  
float fresnelEdge = fresnel.g;  
float fresnelSpec = fresnel.b;
```
lerp后可以看到，金属部分变暗
![[Pasted image 20221020143747.png|300]]
各通道颜色：
![[AP01_L12_22.jpg]]
G边缘光：过渡很实
B菲涅尔高光：除了Cubemap高光，再增加菲涅尔一个高光
### 颜色Warp图
皮肤使用：
![[Pasted image 20221020150453.png|300]]

其他部位使用：这张图用了等于没用（**原理需要查资料**），原因在于其他部位不需要使用颜色warp，又涉及超纲没有写开关功能，所以加了一个无效果的贴图。
![[Pasted image 20221020150514.png|300]]
![[Pasted image 20221020150720.png|300]]
```less
float halfLambert = NdotL * 0.5 + 0.5;  
float3 DiffuseWarp = tex2D(_DiffuseWarp, float2(halfLambert, 0.2));    //颜色Warp图
```

### 金属度遮罩
这里的金属度不是PBR中的那个！
![[Pasted image 20221019230427.png|300]]
### 自发光
武器的嘴部需要较高亮度
![[Pasted image 20221019231612.png|300]]
### 阴影
![[Pasted image 20221019231813.png|300]]
### CubeMap
![[Pasted image 20221019231929.png|300]]

## 光照分析
![[AP01_L12_14.jpg]]
补充：
TintMask是高光染色
镜面反射部分，FresnelSpecWarp也放到主光里一起算
### DiffCol&SpecCol
![[AP01_L12_21.jpg]]
**修正：这里specCol最后不需要乘specInt**
### Fresnel
![[AP01_L12_22 1.jpg]]
### 主光漫反射 DirDiffuse 
![[AP01_L12_23.jpg]]
### 主光高光反射 DirSpecular
![[AP01_L12_24.jpg]]
环境漫反射 AmiDiffuse
![[AP01_L12_25.jpg]]
**修正：不需要乘环境漫反射强度，删去**
### 环境高光反射
![[AP01_L12_26.jpg]]
### 轮廓光
![[AP01_L12_27.jpg]]
### 自发光
![[AP01_L12_28.jpg]]
### 最终混合
![[AP01_L12_29 1.jpg]]
### 透明剪切
![[AP01_L12_31.jpg]]
### FallBack
![[AP01_L12_32.jpg]]
### 双面显示
![[AP01_L12_33.jpg]]
![[AP01_L12_34.jpg]]
### 代码
![[Pasted image 20221020165057.png|300]]
```less
Shader "Unlit/dota2"  
{    
    Properties    
{    
        [Header(Texture)]  
        _MainTex                ("RGB:基础颜色 A:透贴", 2D) = "white" {}  // A通道放了透贴  
        _MaskTex                ("R:高光强度 G：边缘光强度 B：高光染色 A：高光次幂",2D) = "black"{} // 四合一  
        [Normal]_NormalMap      ("RGB:法线贴图", 2D) = "bump" {}  // 法线其他通道也可以塞东西需要解码（暂不掌握）  
        _MatelnessMask          ("金属度遮罩",2D) = "black"{}  
        _EmissiveMask           ("RGB:自发光遮罩", 2D) = "black" {}  
        _DiffuseWarp            ("颜色Warp图",2D) = "gray"{}  
        _FresnelWarp            ("菲涅尔Warp图",2D) = "gray"{}  
        _CubeMap                ("RGB:环境贴图", Cube)  = "white" {}  
          
        [Header(DirDiffuse)]  
        _LightColor("光颜色", Color) = (1.0,1.0,1.0,1.0)  
          
        [Header(DirSpecular)]  
        _SpecExp("高光次幂",Range(0.0, 128.0)) = 5  
        _SpecScale("高光强度", Range(0, 10.0)) = 5  
        [Header(AmiDiffuse)]  
        _AmiColor("环境光颜色",Color) = (1.0,1.0,1.0,1.0)  
          
        [Header(AmiSpecular)]  
        _AmiSpecScale("环境高光强度", Range(0, 10.0)) = 5  
        [Header(RimLight)]  
        [HDR]_RimColor("轮廓光颜色", Color) = (1.0,1.0,1.0,1.0)  
        _RimScale("轮廓光强度", Range(0, 3.0)) = 1  
        [Header(Emissive)]  
        _EmiScale("自发光强度",Range(0,10.0)) = 1  
        [Header(Emissive)]  
        _Cutoff("Alpha cutoff", Range(0,1)) = 0.5   //不可自定义变量名，必须这样写  
        [HideInInspector]  
        // FallBack必须要写的  
        _Color("Main Color", Color) = (1,1,1,1)  
          
    }  
    SubShader    
{    
        Tags { "RenderType"="Opaque"  "LightMode" = "ForwardBase"}    
        Pass    
{    
            Cull off    //关闭剔除，使得披风显示正常  
            CGPROGRAM    
#pragma vertex vert    
            #pragma fragment frag    
            #pragma multi_compile_fwdbase_fullshadows    
            #include "UnityCG.cginc"    
#include "Lighting.cginc"    
#include "AutoLight.cginc"   // 计算阴影时所用的宏都在这个文件中声明    
struct appdata    
{    
                float4 vertex : POSITION;    
                float2 uv : TEXCOORD0;    
                float4 normal : NORMAL;  
                float4 tangent : TANGENT;  
            };    
    
            struct v2f    
{  
                float4 pos : SV_POSITION;    
                float2 uv : TEXCOORD0;  
                float3 world_Normal : TEXCOORD1;    
                float3 world_Pos : TEXCOORD2;  
                float3 world_Tangent : TEXCOORD3;  
                float3 world_Bitangent : TEXCOORD4;  
                LIGHTING_COORDS(5,6)  
            };    
  
            // Texture  
            sampler2D _MainTex;    
            float4 _MainTex_ST;  
            sampler2D _MaskTex;  
            sampler2D _NormalMap;  
            sampler2D _MatelnessMask;  
            sampler2D _EmissiveMask;  
            sampler2D _DiffuseWarp;  
            sampler2D _FresnelWarp;  
            samplerCUBE _CubeMap;  
  
            // 主光漫反射 DirDiffusefloat3 _LightColor;  
            // 主光高光反射 DirSpecular            float _SpecExp;  
            float _SpecScale;  
            // 环境漫反射 AmiDiffuse            float4 _AmiColor;  
            float _AmiDiffScale;  
            // 环境高光反射 AmiSpecular            float _AmiSpecScale;  
            // 轮廓光 RimLight            float4 _RimColor;  
            float _RimScale;  
            // 自发光 Emissive            float _EmiScale;  
            // 透明剪切  
            float _Cutoff;  
            v2f vert (appdata v)    
            {    
                v2f o;    
                o.pos = UnityObjectToClipPos(v.vertex);  
                o.uv = v.uv;  
                o.world_Normal = UnityObjectToWorldNormal(v.normal);    
                o.world_Pos= mul(unity_ObjectToWorld,v.vertex);    
                o.world_Tangent = normalize(UnityObjectToWorldDir(v.tangent));  
                o.world_Bitangent = normalize(cross(o.world_Normal,o.world_Tangent) * v.tangent.w);  
                  
                TRANSFER_VERTEX_TO_FRAGMENT(o);    
                return o;    
            }    
    
            fixed4 frag (v2f i) : SV_Target    
            {  
                // 向量计算  
                float3 world_LightDir = normalize(UnityWorldSpaceLightDir(i.world_Pos));    
                float3 world_ViewDir = normalize(UnityWorldSpaceViewDir(i.world_Pos));    
                float3 world_HalfVector = normalize(world_LightDir + world_ViewDir);    
                float3 tangent_NormalMap = UnpackNormal(tex2D(_NormalMap, i.uv)).rgb;  
                float3x3 TBN = float3x3 (i.world_Tangent,i.world_Bitangent,i.world_Normal);  
                float3 world_NormalMap = normalize(mul(tangent_NormalMap, TBN));  
                float3 Reflect = reflect(-world_ViewDir,world_NormalMap);  
                  
                // 中间量准备  
                float NdotV = dot(i.world_Normal,world_ViewDir);  
                float NdotL = dot(i.world_Normal,world_LightDir);  
                float NdotH = dot(i.world_Normal,world_HalfVector);  
                  
                // 采样纹理  
                float4 MainTex = tex2D(_MainTex, i.uv);                 //基本颜色+A通道透贴  
                float4 MaskTex = tex2D(_MaskTex,i.uv);                  //三个Mask+高光次幂  
                float MatelnessMask = tex2D(_MatelnessMask, i.uv).r;    //金属度遮罩  
                float EmissiveMask = tex2D(_EmissiveMask, i.uv).r;      //自发光遮罩  
                float3 FresnelWarp = tex2D(_FresnelWarp, NdotV);        //菲涅尔Warp图  
                float3 CubeMap = texCUBE(_CubeMap,float4(Reflect, lerp(8.0, 0.0, MaskTex.a))).rgb;   
                  
                // 提取信息  
                float3 BaseColor = MainTex.rgb;     //基本颜色  
                float opacity = MainTex.a;          //透贴  
                float specScaleMask = MaskTex.r;    //高光强度Mask  
                float rimScaleMask = MaskTex.g;     //轮框光（边缘光）强度Mask  
                float specTintMask = MaskTex.b;     //高光染色Mask  
                float specExp = MaskTex.a;          //高光次幂  
                float shadow = LIGHT_ATTENUATION(i);//取出投影  
                // 漫反射颜色 高光反射颜色 （这里diffColor、specColor理解为漫反射贴图，高光反射贴图）   
float3 diffColor = lerp(BaseColor, float3(0,0,0), MatelnessMask); // 金属漫反射不明显，将金属压暗  
                float3 specColor = lerp(BaseColor, float3(0.3,0.3,0.3), specTintMask); // 0.3是一个经验值，根据效果取值就可以。在PBR中是一个物理值  
  
                // 菲涅尔  
                float3 fresnel = lerp(FresnelWarp,0.0,MatelnessMask); //金属菲涅尔现象不明显  
                float fresnelColor = fresnel.r; //两种diffwarp的插值mask，罕见使用，在此  
                float fresnelRim = fresnel.g;  //轮框光用Fresnel  
                float fresnelSpec = fresnel.b;  //高光反射用Fresnel  
  
                // 主光漫反射 DirDiffusefloat halfLambert = NdotL * 0.5 + 0.5;  
                float3 DiffuseWarp = tex2D(_DiffuseWarp, float2(halfLambert, 0.2));    //颜色Warp图  
                float3 dirDiffuse =  diffColor * DiffuseWarp * _LightColor;  
                  
                // 主光高光反射 DirSpecular                float blinnPhong = pow(max(0, NdotH), specExp * _SpecExp); // specExp是美术画的贴图里的高光次幂，为了灵活控制，乘上我们自己定义的_SpecExp  
                float specular = blinnPhong * max(0, NdotL); // 和Lambert相乘，在漫反射黑的地方，高光反射也弱一些  
                specular = max(specular, fresnelSpec); //根据审美取，也可以相加，这里取最大  
                specular = specular * specScaleMask * _SpecScale;     
                float3 dirSpecular = specColor * specular * _LightColor;  
  
                // 环境漫反射 AmiDiffuse                // 球谐函数更好，这里简单处理成单色环境光  
                float3 amiDiffuse = diffColor * _AmiColor;  
  
                // 环境高光反射 AmiSpecular                //休要计算一个反射度，反映出哪里需要反射。这里用max，用菲尼尔高光和金属度遮罩。  
                //非金属部分，金属度为0，取fresnelSpec  
                //金属部分取materllic  
                float reflectScale = max(fresnelSpec, MatelnessMask) * _SpecScale;  
                float3 amiSpecular = specColor * reflectScale * CubeMap * _AmiSpecScale;  
  
                // 轮廓光 RimLight                // 乘世界法线g通道是为了只显示上面的轮廓光，剔除下面的轮廓光  
                float3 rimLight = _RimColor * fresnelRim * rimScaleMask * max(0.0, world_NormalMap.g) * _RimScale;  
  
                //自发光 Emissive                float3 emissive = diffColor * EmissiveMask * _EmiScale;  
                  
                float3 finalColor = (dirDiffuse + dirSpecular) * shadow + amiDiffuse + amiSpecular + rimLight + emissive;  
  
                // 透明剪切  
                clip(opacity - _Cutoff);  
                return float4(finalColor,1);  
            }    
            ENDCG    
}    
    }    
    FallBack "Legacy Shaders/Transparent/Cutout/VertexLit"     
//为了阴影正确，要自己写一个shadowpass,或者采用这种FallBack形式，但要注意变量名要和Fallback的一致，比如这里必须要在面板声明_Color，因为FallBack使用的这个shadowpass要使用这个变量  
}
```

## Shader源码来源
![[AP01_L12_36.jpg]]
![[AP01_L12_37.jpg]]
# 第14 15 16课 uv扰动
![[flow.gif]]
## Flow流动
使用一张噪声图
![[Pasted image 20221020212222.png|300]]
```less
Shader "Unlit/Flow"  
{  
 Properties  
    {  
        _MainTex ("RGB：颜色 A：透贴", 2D) = "white" {}  
        _Opacity("透明度",Range(0,1)) = 0.5  
        _NoiseTex("噪声图",2d) = "grey"{}  
        _NoiseScale("噪声强度",range(0,5)) = 0.5  
        _FlowSpeed("流动速度",range(0,10)) = 5  
    }  
    SubShader {  
        Tags {  
            "Queue"="Transparent"                 
            "RenderType"="Transparent"            
            "ForceNoShadowCasting"="True"        
            "IgnoreProjector"="True"              
}  
        Pass {  
            Name "FORWARD"  
            Tags {  
                "LightMode"="ForwardBase"  
            }  
            Zwrite Off  
            Blend One OneMinusSrcAlpha            
              
            CGPROGRAM  
            #pragma vertex vert  
            #pragma fragment frag  
            #include "UnityCG.cginc"  
            #pragma multi_compile_fwdbase  
  
            sampler2D _MainTex;  
            float4 _MainTex_ST;  
            sampler2D _NoiseTex;  
            float4 _NoiseTex_ST;  
            float _Opacity;  
            float _NoiseScale;  
            float _FlowSpeed;  
    
            struct appdata {  unity TRANSFORM_TEX
                float4 vertex : POSITION;         
                float2 uv : TEXCOORD0;          
            };  
     
            struct v2f {  
                float4 pos : SV_POSITION;     
                float2 uv0 : TEXCOORD0;  
                float2 uv1 : TEXCOORD1; //因为要在顶点着色器中对噪声贴图进行偏移，所以这里要声明  
            };  
            v2f vert (appdata v) {  
                v2f o = (v2f)0;  
                o.pos = UnityObjectToClipPos( v.vertex);     
                o.uv0 = v.uv;  
                o.uv1 = TRANSFORM_TEX(v.uv, _NoiseTex); //UV1支持Tiling、Offset  
                //加frac的意义：（保证安全）  
                //1. time一直增长，取小数可以防止数字无限大，最后导致数值溢出，图像花掉  
                //2. 浮点精度问题导致图像花掉  
                o.uv1.y = o.uv1.y + frac(-_Time.x * _FlowSpeed);  
                return o;  
            }  
            float4 frag(v2f i) : COLOR {  
                float4 MainTex = tex2D(_MainTex,i.uv0);  
                float NoiseTex = tex2D(_NoiseTex, i.uv1).r;  
  
                float3 finalColor = MainTex.rgb;  
                //NoiseTex * 2.0将值域扩增到（0~2），然后在写个lerp进行控制。  
                float noise = lerp(1.0, NoiseTex * 2.0, _NoiseScale);  
                noise = max(0.0,noise);  
  
                float opacity = MainTex.a * _Opacity * noise;  
  
                return float4(finalColor * opacity,opacity);  
                  
                  
            }  
            ENDCG  
        }  
    }  
}

```
**加frac的意义：（保证安全**）  
       1. time一直增长，取小数可以防止数字无限大，最后导致数值溢出，图像花掉  
      2. 浮点精度问题导致图像花掉 
![[Pasted image 20221020211640.png|300]]
## Wrap扭曲
使用一张扭曲图
**R、G通道：扭曲图
B通道：噪声图**
![[Pasted image 20221020212309.png|300]]
**扭曲图制作方法**
![[AP01_L15_13.jpg]]
```less
Shader "Unlit/Warp"  
{  
 Properties  
    {  
        _MainTex ("RGB：颜色 A：透贴", 2D) = "white" {}  
        _Opacity("透明度",Range(0,1)) = 0.5  
        _WarpTex("扭曲图",2d) = "grey"{}  
        _WarpScale("扭曲强度",range(0,1)) = 0.5  
        _NoiseScale("噪声强度",range(0,5)) = 0.5  
        _FlowSpeed("流动速度",range(0,10)) = 5  
    }  
    SubShader {  
        Tags {  
            "Queue"="Transparent"                 
            "RenderType"="Transparent"            
            "ForceNoShadowCasting"="True"        
            "IgnoreProjector"="True"              
}  
        Pass {  
            Name "FORWARD"  
            Tags {  
                "LightMode"="ForwardBase"  
            }  
            Zwrite Off  
            Blend One OneMinusSrcAlpha            
              
            CGPROGRAM  
            #pragma vertex vert  
            #pragma fragment frag  
            #include "UnityCG.cginc"  
            #pragma multi_compile_fwdbase  
  
            sampler2D _MainTex;  
            float4 _MainTex_ST;  
            sampler2D _WarpTex;  
            float4 _WarpTex_ST;  
            float _Opacity;  
            float _WarpScale;  
            float _NoiseScale;  
            float _FlowSpeed;  
    
            struct appdata {  
                float4 vertex : POSITION;         
                float2 uv : TEXCOORD0;          
            };  
     
            struct v2f {  
                float4 pos : SV_POSITION;     
                float2 uv0 : TEXCOORD0;  
                float2 uv1 : TEXCOORD1;   
            };  
            v2f vert (appdata v) {  
                v2f o = (v2f)0;  
                o.pos = UnityObjectToClipPos( v.vertex);     
                o.uv0 = v.uv;  
                o.uv1 = TRANSFORM_TEX(v.uv, _WarpTex);   
                o.uv1.y = o.uv1.y + frac(-_Time.x * _FlowSpeed);  
                return o;  
            }  
            float4 frag(v2f i) : COLOR {  
                float3 WarpTex = tex2D(_WarpTex, i.uv1).rgb; //噪声图  
                float2 uvBias = (WarpTex.rg - 0.5) * _WarpScale;   //计算uv偏移值,将RG通道从（0，1）Remap到（-0.5，0.5），使扰动可以分别往正负方向偏移  
                float4 MainTex = tex2D(_MainTex,i.uv0 + uvBias); //应用uv偏移后进行采样  
                float3 finalColor = MainTex.rgb;  
                float noise = lerp(1.0, WarpTex.b * 2.0, _NoiseScale);  
                noise = max(0.0,noise);  
                float opacity = MainTex.a * _Opacity * noise;  
  
                return float4(finalColor * opacity,opacity);  
            }  
            ENDCG  
        }  
    }  
}
```
## 卡通火
![[tong.gif|300]]
### 贴图解析
#### Mask
![[Pasted image 20221020220057.png|300]]
R通道：红色为外焰
![[Pasted image 20221020220642.png|300]]
G通道：绿色为内焰
![[Pasted image 20221020220650.png|300]]
B通道：透贴，下面是黑色
![[Pasted image 20221020231613.png|300]]
A通道：控制火焰强度，白色部分强，黑色部分弱
![[Pasted image 20221020220611.png|300]]

#### 噪声图
![[Pasted image 20221020220234.png|300]]
**RG通道分别为两种不同的噪声图，对这两张noise做不同的偏移，混合占比不同，流动速度不同，可以混合出一张随机性比较强的噪声图**
R通道：
![[Pasted image 20221020220319.png|300]]
G通道：
![[Pasted image 20221020220333.png|300]]
#### 代码
```less
Shader "Unlit/Fire"  
{  
    Properties  
    {  
        _Mask ("R:外焰 G:内焰 B:透贴", 2D) = "blue" {}  
        _Noise("R:噪声1 G：噪声2", 2D) = "gray"{}  
        _Noise1Params("X:大小 Y:流速 Z:强度", vector) = (1,0.2,0.2,1)  
        _Noise2Params("X:大小 Y:流速 Z:强度", vector) = (1,0.2,0.2,1)  
        [HDR]_Color1    ("外焰颜色", color) = (1,1,1,1)  
        [HDR]_Color2    ("内焰颜色", color) = (1,1,1,1)  
    }  
    SubShader  
    {  
        Tags   
{   "Queue" = "Transparent"             
            "RenderType"="Transparent"      
"ForceNoShadowCasting" = "True"       
"IgnoreProjector" = "True"           
}  
  
        Pass  
        {  
            Name "FORWARD"  
            Tags  
            { "LightMode" = "ForwardBase" }  
            Blend One OneMinusSrcAlpha     
              
            CGPROGRAM  
            #pragma vertex vert  
            #pragma fragment frag  
            #pragma  multi_compile_fwdbase_fullshadows  
            #include "UnityCG.cginc"  
  
            struct appdata  
            {  
                float4 vertex : POSITION;  
                float2 uv : TEXCOORD0;  
            };  
  
            struct v2f  
            {  
                float4 pos : SV_POSITION;  
                float2 uv0 : TEXCOORD0;  //采样Mask  
                float2 uv1 : TEXCOORD1;  //采样Noise1  
                float2 uv2 : TEXCOORD3;  //采样Noise2  
            };  
  
            sampler2D _Mask;  
            float4 _Mask_ST;  
            sampler2D _Noise;  
            float3 _Noise1Params;  
            float3 _Noise2Params;  
            float3 _Color1;  
            float3 _Color2;  
            v2f vert (appdata v)  
            {  
                v2f o;  
                o.pos = UnityObjectToClipPos(v.vertex);  
                o.uv0 = TRANSFORM_TEX(v.uv, _Mask);  
                //只有y轴流动，所以减一个float2（0，xxx），不影响x轴  
                //加减决定y轴向上流还是向下流  
                o.uv1 = v.uv * _Noise1Params.x - float2(0 ,frac(_Time.x * _Noise1Params.y));  
                o.uv2 = v.uv * _Noise2Params.x - float2(0, frac(_Time.x * _Noise2Params.y));  
                return o;  
            }  
  
            float4 frag (v2f i) : SV_Target  
            {  
                // 扰动遮罩  
                half warpMask = tex2D(_Mask, i.uv0).b;  
                //构建噪声  
                float noise1 = tex2D(_Noise, i.uv1).r;  
                float noise2 = tex2D(_Noise, i.uv2).g;  
                float noise = noise1 * _Noise1Params.z + noise2 * _Noise2Params.z;  
                //扰动uv  
                float2 warpUV = i.uv0 - float2(0, noise) * warpMask;  
                //采样Mask  
                float4 mask = tex2D(_Mask, warpUV);  
                //计算finalColor 不透明度  
                float3 finalColor = (_Color1 * mask.r + _Color2 * mask.g) * mask  
                .a;  
                float opacity = mask.r + mask.g;    //火焰部分不透明，其他部分透明  
                return float4(finalColor,opacity);  
                  
            }  
            ENDCG  
        }  
    }  
}
```
## 卡通水
### 贴图解析
#### MainTex
![[Pasted image 20221021220922.png]]
####  扭曲图Warp
![[Pasted image 20221021211312.png]]
#### 代码
```c
Shader "Unlit/CartoomWater"  
{  
    Properties  
    {  
        _MainTex ("颜色贴图", 2D) = "blue" {}  
        _WarpTex("扰动图", 2D) = "gray"{}  
        _Speed("X：流速X Y：流速Y", vector) = (1.0, 1.0, 0.5, 1.0)  
        _Warp1Params("X:大小 Y:流速X Z:流速Y W:强度", vector) = (1.0, 1.0, 0.5, 1.0)  
        _Warp2Params("X:大小 Y:流速X Z:流速Y W:强度", vector) = (2.0, 0.5, 0.5, 1.0)  
    }  
    SubShader  
    {  
        Tags   
{  
            "RenderType"="Opaque"      
}  
  
        Pass  
        {  
            Name "FORWARD"  
            Tags  
            { "LightMode" = "ForwardBase" }  
            Blend One OneMinusSrcAlpha     
              
            CGPROGRAM  
            #pragma vertex vert  
            #pragma fragment frag  
            #pragma  multi_compile_fwdbase_fullshadows  
            #include "UnityCG.cginc"  
  
            struct appdata  
            {  
                float4 vertex : POSITION;  
                float2 uv : TEXCOORD0;  
            };  
  
            struct v2f  
            {  
                float4 pos : SV_POSITION;  
                float2 uv0 : TEXCOORD0;  //采样Mask  
                float2 uv1 : TEXCOORD1;  //采样Noise1  
                float2 uv2 : TEXCOORD3;  //采样Noise2  
            };  
  
            sampler2D _MainTex;  
            float4 _MainTex_ST;  
            sampler2D _WarpTex;  
            float2 _Speed;  
            float4 _Warp1Params;  
            float4 _Warp2Params;  
            v2f vert (appdata v)  
            {  
                v2f o;  
                o.pos = UnityObjectToClipPos(v.vertex);  
                o.uv0 = v.uv - frac(_Time.x * _Speed);  
                //与卡通火不同，这里对xy方向都进行偏移  
                o.uv1 = v.uv * _Warp1Params.x - frac(_Time.x * _Warp1Params.yz);  
                o.uv2 = v.uv * _Warp2Params.x - frac(_Time.x * _Warp2Params.yz);  
                return o;  
            }  
  
            float4 frag (v2f i) : SV_Target  
            {  
                float3 warp1 = tex2D(_WarpTex, i.uv1).rgb;  //扰动1  
                float3 warp2 = tex2D(_WarpTex, i.uv2).rgb;  //扰动2  
                //扰动混合  
                float2 warp = (warp1.xy - 0.5) * _Warp1Params.w * (warp2.xy - 0.5) * _Warp2Params.w;  
                //扰动UV  
                float2 warpUV = i.uv0 + warp;  
                //扰动UV  
                float3 MainTex = tex2D(_MainTex, warpUV);  
                  
                return float4(MainTex,1);  
            }  
            ENDCG  
        }  
    }  
}
```
# 第17课 屏幕UV
![[screen 1.gif|300]]
## 屏幕UV的使用方法
![[AP01_L17_4.jpg]]
![[AP01_L17_7.jpg]]
```less
Shader "Unlit/SceenUV"  
{  
    Properties  
    {  
        _MainTex ("RGB：颜色 A：透贴", 2D) = "white" {}  
        _Opacity ("透明度",range(0,1)) = 0.5  
        _ScreenTex ("屏幕纹理", 2d) = "black"{}  
    }  
    SubShader  
    {  
        Tags   
{   "Queue" = "Transparent"             //调整渲染顺序  
            "RenderType"="Transparent"    //对应改为Cutout  
            "ForceNoShadowCasting" = "True"     //关闭阴影投射  
            "IgnoreProjector" = "True"          //不响应投射器  
        }  
  
        Pass  
        {  
            Name "FORWARD"  
            Tags  
            { "LightMode" = "ForwardBase" }  
            Blend One OneMinusSrcAlpha  
              
            CGPROGRAM  
            #pragma vertex vert  
            #pragma fragment frag  
            #pragma  multi_compile_fwdbase_fullshadows  
            #include "UnityCG.cginc"  
  
            struct appdata  
            {  
                float4 vertex : POSITION;  
                float2 uv : TEXCOORD0;  
            };  
  
            struct v2f  
            {  
                float4 pos : SV_POSITION;  
                float2 uv : TEXCOORD0;  
                float2 screenUV : TEXCOORD1; //屏幕UV  
            };  
  
            sampler2D _MainTex;  
            float4 _MainTex_ST;  
            float _Opacity;  
            sampler2D _ScreenTex;  
            float4 _ScreenTex_ST;  
            v2f vert (appdata v)  
            {  
                v2f o;  
                o.pos = UnityObjectToClipPos(v.vertex);  
                o.uv = TRANSFORM_TEX(v.uv, _MainTex);  
  
                //观察空间以摄像机为中心，将xy轴视为uv，用这个uv去采样就能采样到屏幕上。  
                //1. 表面会有畸变，需要除以z（深度）  
                //2. 模型与采样的纹理随着视野缩放，tilling值变化不一样。需要进行锁定,锁定后变化一致  
                float3 posVS = UnityObjectToViewPos(v.vertex).xyz;  //顶点位置 OS->VS                float originDist = UnityObjectToViewPos(float3(0.0, 0.0, 0.0)).z; //原点位置 OS->VS，获得模型原点与摄像机的距离  
                o.screenUV = posVS.xy / posVS.z;    //VS空间畸变矫正  
                o.screenUV *= originDist;           //纹理大小按距离锁定  
                o.screenUV = o.screenUV * _ScreenTex_ST.xy - frac(_Time.x * _ScreenTex_ST.zw);  //启用屏幕纹理ST     
return o;  
            }  
  
            float4 frag (v2f i) : SV_Target  
            {  
                float4 MainTex = tex2D(_MainTex, i.uv);   
                float ScreenTex = tex2D(_ScreenTex, i.screenUV).r;  
                float3 finalColor = MainTex.rgb;  
                float opacity = MainTex.a * _Opacity * ScreenTex;  
                  
                return float4(finalColor * opacity, opacity);  
            }  
            ENDCG  
        }  
    }  
}
```
## 屏幕扰动
**术语：正片叠底**，意思就是乘法
![[AP01_L17_9.jpg]]

```less
Shader "Unlit/SceenWarp"  
{  
    Properties  
    {  
        _MainTex ("RGB：颜色 A：透贴", 2D) = "white" {}  
        _Opacity ("透明度",range(0,1)) = 0.5  
        _WarpMidval("扰动中间值",range(0,1)) = 0.5  
        _WarpScale("扰动强度",range(0,10)) = 1  
    }  
    SubShader  
    {  
        Tags   
{   "Queue" = "Transparent"             //调整渲染顺序  
            "RenderType"="Transparent"    //对应改为Cutout  
            "ForceNoShadowCasting" = "True"     //关闭阴影投射  
            "IgnoreProjector" = "True"          //不响应投射器  
        }  
          
        // 获取背景纹理  
        GrabPass  
        {  
            "_BackgroundTex"  
        }  
          
        // Forward Pass  
        Pass  
        {  
            Name "FORWARD"  
            Tags  
            { "LightMode" = "ForwardBase" }  
            Blend One OneMinusSrcAlpha  
              
            CGPROGRAM  
            #pragma vertex vert  
            #pragma fragment frag  
            #pragma  multi_compile_fwdbase_fullshadows  
            #include "UnityCG.cginc"  
  
            struct appdata  
            {  
                float4 vertex : POSITION;  
                float2 uv : TEXCOORD0;  
            };  
  
            struct v2f  
            {  
                float4 pos : SV_POSITION;  
                float2 uv : TEXCOORD0;  
                float4 grabPos : TEXCOORD1; //背景纹理采样坐标  
            };  
            sampler2D _MainTex;  
            float4 _MainTex_ST;  
            float _Opacity;  
            float _WarpMidval;  
            float _WarpScale;  
            sampler2D _BackgroundTex;  
              
            v2f vert (appdata v)  
            {  
                v2f o;  
                o.pos = UnityObjectToClipPos(v.vertex);  
                o.uv = v.uv;  
                o.grabPos = ComputeGrabScreenPos(o.pos);  //背景纹理采样坐标  
                return o;  
            }  
  
            float4 frag (v2f i) : SV_Target  
            {  
                float4 MainTex = tex2D(_MainTex, i.uv);  
                // 扰动背景纹理坐标采样  
                i.grabPos.xy += (MainTex.r - _WarpMidval) * _WarpScale;  
                // 采样背景 tex2Dproj                float3 BackgroundTex = tex2Dproj(_BackgroundTex, i.grabPos.xyzw).rgb;  
                  
                float3 finalColor = lerp(1.0, MainTex.rgb, _Opacity) * BackgroundTex;  
                float opacity = MainTex.a;  
                  
                return float4(finalColor * opacity, opacity);  
            }  
            ENDCG  
        }  
    }  
}
```
### tex2Dproj
**tex2Dproj和tex2D这两个功能几乎相同。**
唯一的区别是，在对纹理进行采样之前，`tex2Dproj`将输入的UV `xy`坐标除以其`w`坐标。**这是将坐标从正交投影转换为透视投影**。

例如 以下段代码的返回值是相同的.
```c
float existingDepth01 = tex2Dproj(_CameraDepthTexture, UNITY_PROJ_COORD(i.screenPosition)).r;
```
  
```c
float existingDepth01 = tex2D(_CameraDepthTexture, UNITY_PROJ_COORD(i.screenPosition.xy / i.screenPosition.w)).r;
```
**具体什么情况下使用tex2Dproj呢?**

我们知道,裁剪空间的坐标经过缩放和偏移后就变成了(0,ｗ),而当分量除以分量W以后,就变成了(0,1),这样在计算需要返回(0,1)值的时候,就可以直接使用tex2Dproj了.
### 获取背景纹理的方法
![[AP01_L17_12 1.jpg]]
# 第18课 序列帧与极坐标Polar
## 序列帧

![[polar.gif|300]]

**原理：将一序列帧图片存贮在一张图中，通过uv的缩放移动来获取每一帧图像，达到动画效果

**帧序列图：**从左到右，从上到下


![[3996f590767a5bd1c02c505b605ffb22_MD5.jpg]]
**方法：**

1.  通过行数、列数计算出**步长**
2.  通过当前所在的第几帧(帧id)计算**当前帧的行列值(位置)**
3.  通过**步长**和**当前帧的行列值**来位移uv

当前帧是第几帧，除以每列个数，商是当前所在行，余数是所在列

![[Pasted image 20221022193113.png|300]]
序列帧先缩放uv（在左下角的原因：uv原点在左下角）
![[Pasted image 20221022200141.png|300]]
然后进行偏移，使其从左上角开始

```less
Shader "L18/Sequence" {  
    Properties  
    {  
        _MainTex ("RGB：颜色 A：透贴", 2D) = "white" {}  
        _Opacity ("透明度", range(0, 1)) = 0.5  
        _Sequence ("序列帧", 2d) = "grey"{}  
        _Row ("行数",int) = 1  
        _Column ("列数",int) = 1  
        _Speed      ("速度", range(0.0, 15.0)) = 1  
    }  
    SubShader  
    {  
        Tags   
{   "Queue" = "Transparent"             //调整渲染顺序  
            "RenderType"="Transparent"    //对应改为Cutout  
            "ForceNoShadowCasting" = "True"     //关闭阴影投射  
            "IgnoreProjector" = "True"          //不响应投射器  
        }     
          
        //第一个Pass AB  
        Pass  
        {  
            Name "FORWARD_AB"  
            Tags  
            { "LightMode" = "ForwardBase" }  
            Blend One OneMinusSrcAlpha  
              
            CGPROGRAM  
            #pragma vertex vert  
            #pragma fragment frag  
            #pragma  multi_compile_fwdbase_fullshadows  
            #include "UnityCG.cginc"  
  
            struct appdata  
            {  
                float4 vertex : POSITION;  
                float2 uv : TEXCOORD0;  
            };  
  
            struct v2f  
            {  
                float4 pos : SV_POSITION;  
                float2 uv : TEXCOORD0;  
            };  
  
            sampler2D _MainTex;  
            float  _Opacity;  
              
              
            v2f vert (appdata v)  
            {  
                v2f o;  
                o.pos = UnityObjectToClipPos(v.vertex);  
                o.uv = v.uv;  
                return o;  
            }  
  
            fixed4 frag (v2f i) : SV_Target  
            {  
                float4 MainTex = tex2D(_MainTex, i.uv);       
                half3 finalColor = MainTex.rgb;  
                half opacity = MainTex.a * _Opacity;  
                return float4(finalColor * opacity, opacity);             
            }  
            ENDCG  
        }  
        //第二个Pass AD  
        Pass  
        {  
            Name "FORWARD_AD"  
            Tags  
            { "LightMode" = "ForwardBase" }  
            Blend One One  
            //Cull Off //更改Cull可以出现不同效果  
            CGPROGRAM  
            #pragma vertex vert  
            #pragma fragment frag  
            #pragma  multi_compile_fwdbase_fullshadows   
            #include "UnityCG.cginc"  
  
            struct appdata  
            {  
                float4 vertex : POSITION;  
                float2 uv : TEXCOORD0;  
                float3 normal : NORMAL; //法线偏移，用于偏移  
            };  
  
            struct v2f  
            {  
                float4 pos : SV_POSITION;  
                float2 uv : TEXCOORD0;  
            };  
  
            sampler2D _Sequence;  
            float4 _Sequence_ST;  
            float _Row;  
            float _Column;  
            float _Speed;  
              
            v2f vert (appdata v)  
            {  
                v2f o;  
                v.vertex.xyz += v.normal * 0.1; //顶点位置法向挤出  
                o.pos = UnityObjectToClipPos(v.vertex);  
                  
                o.uv = TRANSFORM_TEX(v.uv, _Sequence);  
                float id = floor(_Time.z * _Speed);  
                  
                float idV = floor(id / _Column);    //floor得商，舍弃余数  
                float idU = id - idV * _Column;     //计算余数  
                float stepU = 1.0 / _Column;    //行的步幅  
                float stepV = 1.0/ _Row;        //列的步幅  
                float2 initUV = o.uv * float2(stepU, stepV) + float2(0.0, stepV * ( _Column - 1.0 )); //缩小UV，只保留一帧的大小。然后进行V轴进行偏移，从左上角开始  
                o.uv = initUV + float2(idU * stepU, -idV * stepV);  //计算序列帧UV  
                return o;  
            }  
  
            fixed4 frag (v2f i) : SV_Target  
            {  
                float4 Sequence = tex2D(_Sequence, i.uv);  
                float3 finalColor = Sequence.rgb;  
                float opacity = Sequence.a;  
                return float4(finalColor * opacity, opacity);  
            }  
            ENDCG  
        }  
    }  
}
```
## 极坐标
极坐标不是笛卡尔坐标系，一般只在片元着色器中使用

**将得到的值Remap到（0，1）**
![[Pasted image 20221022214919.png|300]]
**模型顶点色**：根据这个颜色实现渐入渐出
顶点色是模型自带的数据，下图为Blender里面绘制的模型顶点色
**为什么要用顶点色**：用顶点色虽然效果不是很好，但是其是在“应用阶段”就生成的数据，非常的省性能。
我们当然可以画张Mask，用uv去采样，但是这样太费性能。
![[Pasted image 20221022215652.png|300]]
```less
Shader "L18/Polar" {  
    Properties  
    {  
        _MainTex ("RGB：颜色 A：透贴", 2D) = "white" {}  
        [HDR]_Color("混合颜色", color) = (1.0, 1.0, 1.0, 1.0)  
        _Opacity ("透明度", range(0, 1)) = 0.5  
    }  
    SubShader  
    {  
        Tags   
{   "Queue" = "Transparent"             //调整渲染顺序  
            "RenderType"="Transparent"          //对应改为Cutout  
            "ForceNoShadowCasting" = "True"     //关闭阴影投射  
            "IgnoreProjector" = "True"          //不响应投射器  
        }     
          
        Pass  
        {  
            Name "FORWARD"  
            Tags  
            { "LightMode" = "ForwardBase" }  
            Blend One OneMinusSrcAlpha  
              
            CGPROGRAM  
            #pragma vertex vert  
            #pragma fragment frag  
            #pragma  multi_compile_fwdbase_fullshadows  
            #include "UnityCG.cginc"  
  
            struct appdata  
            {  
                float4 vertex : POSITION;  
                float2 uv : TEXCOORD0;  
                float4 color : COLOR;   //顶点颜色  
            };  
  
            struct v2f  
            {  
                float4 pos : SV_POSITION;  
                float2 uv : TEXCOORD0;  
                float4 color : COLOR;  
            };  
  
            sampler2D _MainTex;  
            float4 _MainTex_ST;  
            float  _Opacity;  
            float4 _Color;  
              
            v2f vert (appdata v)  
            {  
                v2f o;  
                o.pos = UnityObjectToClipPos(v.vertex);  
                o.uv = v.uv;  
                o.color = v.color;  
                return o;  
            }  
  
            fixed4 frag (v2f i) : SV_Target  
            {  
                i.uv = i.uv - float2(0.5, 0.5); //把uv原点从左下角移到中心点  
  
                // 反正切(两种不同方法) 求角度  
                // atan()值域[-π/2, π/2]一般不用; atan2()值域[-π, π]  
                // float2 theta = atan(i.uv.y/ i.uv.x);float theta = atan2(i.uv.y, i.uv.x);   
                // 值域转成（0，1）  
                theta = theta / UNITY_PI * 0.5 + 0.5;  
                // 求半径  
                float r = length(i.uv) + frac(_Time.x * 3);   
                i.uv = float2(theta, r);  
  
                float4 MainTex = tex2D(_MainTex, i.uv);  
                // 最后乘顶点色，实现渐入渐出（效果和模型本身顶点色有关）  
                half3 finalColor = MainTex.rgb * _Color;       
                half opacity = MainTex.a * _Opacity;      
                return float4(finalColor * opacity, opacity);              
            }  
            ENDCG  
        }  
    }  
    }
```

## 补充1：顶点色

**在Blender中画顶点色：**

教程推荐[Blender游戏建模04_顶点色](https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av83584001)

**绘制顶点色：**字面意思，绘制顶点的颜色，如下图平面只有4个顶点(4个角上)，只能绘制这4个顶点的颜色

![[264aecb691c6b9e794aef5894967c4bf_MD5.webp]]

只有4给顶点的平面模型

**Blender的顶点绘制**

![[e3226b65bc2be6def4232f69bdeb515c_MD5.webp]]

**可以新建材质查看顶点色RGB**

![[9bf03cb1886ed45e0b56139bf9ecc911_MD5.webp]]

注意：导出模型的格式要用**fbx.格式**，所以还需要坐标系的转换(右Blender->左Unity)

若为**obj.格式**，则得不到模型顶点色

## 三、补充2：PhotoShop导出带a通道的图

在PhotoShop新建一个alpha通道后要导出**tga.格式**的，且必须为**32位/像素**

导出**png.格式**的无alpha通道

# 第19课 平移、缩放、旋转
## 平移
![[AP01_L19_7.jpg]]
对于sin函数，乘2PI让括号内的值域为[0~2PI]，这样sin值域才能成为[-1~1]，走完一个周期。
```less
Shader "Unlit/Translation"  
{  
    Properties  
    {  
        _MainTex ("RGB：颜色 A：透贴", 2D) = "white" {}  
         _Opacity    ("透明度", range(0, 1))     = 0.5  
        _MoveRange("移动范围", range(0.0,3.0)) = 1.0  
        _MoveSpeed("移动速度", range(0.0,3.0)) = 1.0  
    }  
    SubShader  
    {  
        Tags   
{   "Queue" = "Transparent"             //调整渲染顺序  
            "RenderType"="Transparent"    //对应改为Cutout  
            "ForceNoShadowCasting" = "True"     //关闭阴影投射  
            "IgnoreProjector" = "True"          //不响应投射器  
        }  
  
        Pass  
        {  
            Name "FORWARD"  
            Tags  
            { "LightMode" = "ForwardBase" }  
              
            Blend One OneMinusSrcAlpha  
              
            CGPROGRAM  
            #pragma vertex vert  
            #pragma fragment frag  
            #pragma  multi_compile_fwdbase_fullshadows  
            #include "UnityCG.cginc"  
  
            struct appdata  
            {  
                float4 vertex : POSITION;  
                float2 uv : TEXCOORD0;  
            };  
  
            struct v2f  
            {  
                float4 pos : SV_POSITION;  
                float2 uv : TEXCOORD0;  
            };  
  
            sampler2D _MainTex;  
            float4 _MainTex_ST;  
            float _Opacity;  
            float _MoveRange;  
            float _MoveSpeed;  
  
            //平移方法  
            //text
			   //inout是CG语言的一种"引用传递"方式,形参既用于输入时初始化，也用于输出数据 
            void Translation(inout float3 vertex)  
            {  
                vertex.y += _MoveRange * sin(frac(_Time.z * _MoveSpeed) * UNITY_TWO_PI);  
            }  
            v2f vert (appdata v)  
            {  
                v2f o;  
                Translation(v.vertex.xyz);  
                o.pos = UnityObjectToClipPos(v.vertex);  
                o.uv = TRANSFORM_TEX(v.uv, _MainTex);  
                return o;  
            }  
  
            fixed4 frag (v2f i) : SV_Target  
            {  
                float4 MainTex = tex2D(_MainTex, i.uv);  
                float3 finalColor = MainTex.rgb;  
                float opacity = MainTex.a * _Opacity;  
                return float4(finalColor, opacity);  
            }  
            ENDCG  
        }  
    }  
}
```
## 缩放
为了防止朝负方向缩放，+1.0作为基础值，使原点永远乘以正值
```less
void Scale(inout float3 vertex)  
{  
    vertex.xyz *= 1.0 + _ScaleRange * sin(frac(_Time.z * _ScaleSpeed) * UNITY_TWO_PI);  
}
```
## 旋转
```less
// 旋转方法  
void Rotate(inout float3 vertex)  
{  
    //计算旋转角度  
    float angleY = _RotateRange * sin(frac(_Time.z * _RotateSpeed) * UNITY_TWO_PI);  
    //角度转为弧度  
    float radY = radians(angleY);  
  
    //sincos()方法节省性能，效果相同  
    //float sinY = sin(radY);  
    //float cosY = cos(radY);    float sinY, cosY = 0;  
    sincos(radY, sinY, cosY);  
  
    // 这里就是应用旋转公式  
    vertex.xz = float2(  
        vertex.x * cosY - vertex.z * sinY,  
        vertex.x * sinY + vertex.z * cosY  
    );  
}
```
## 综合案例
美术向：blender刷模型顶点色（待学习）
![[AP01_L19_25.jpg]]
![[AP01_L19_26.jpg]]
![[Pasted image 20221022230537.png]]
1. 通过顶点色作为Mask来对模型的不同部位做不同的顶点运动
2. 通过给定sin函数的初相角达到运动 超前/滞后 的效果
```less
Shader "AP1/L19/AnimGhost" {
	Properties{
        _MainTex ("RGB：颜色 ； A：透贴" , 2D) = "white"{}
		_Opacity ("不透明度" , range( 0.0 , 1.0 )) = 1.0
        _ScalePara ("天使圈缩放 ；x:范围 ， y：速度 ， z：校正" , Vector) = (0.5 , 3.0 , 0.0 , 0.0)
        _MoveParaX ("身体x轴移动 ； x:范围 ，y:速度 ，z：波长" , Vector) = (1.0 , 3.0 , 1.0 , 0.0)
        _MoveParaZ ("身体z轴移动 ； x:范围 ，y:速度 ，z：波长" , Vector) = (1.0 , 3.0 , 1.0 , 0.0) 
        _MoveParaY ("全身y轴起伏 ； x:范围 ，y:速度 ，z：滞后" , Vector) = (1.0 , 3.0 , 0.0 , 0.0) 
        _RotParaY  ("头部旋转 ； x:范围 ， y:速度 ， z:滞后" , Vector)   = (30.0 , 3.0 , 0.0 , 0.0)
	}
	SubShader{
		Tags {
			"Queue" = "Transparent"              //渲染队列3000
            "RenderType" = "Transparent"         //把Shader归入到提前定义的组(这里是Transparent组)
                                                 //以指明该Shader使用了透明度测试
                                                 //RenderType标签通常被用于着色器替换功能
            "IgnoreProjector" = "True"           //shader不会受到投影器(Projectors)的影响
            "ForceNoShadowCasting" = "True"      //关闭阴影投射

		}
		Pass {
			Name "FORWARD"
			Tags {
				"LightMode" = "ForwardBase"
			}
			ZWrite Off
            Blend One OneMinusSrcAlpha          //修改混合方式


			CGPROGRAM
			#pragma vertex vert
			#pragma fragment frag
			#include "UnityCG.cginc"
			#pragma multi_compile_fwdbase_fullshadows
			#pragma target 3.0

            uniform sampler2D _MainTex; uniform float4 _MainTex_ST;
			uniform half _Opacity;
            uniform float3 _ScalePara;
            uniform float3 _MoveParaX;
            uniform float3 _MoveParaZ;
            uniform float3 _MoveParaY;
            uniform float3 _RotParaY;

			struct VertexInput {
				float4 vertex  : POSITION;
                float2 uv0     : TEXCOORD0;
                float4 color0  : COLOR;
			};
			struct VertexOutput {
				float4 pos : SV_POSITION;
                float2 uv0 : TEXCOORD0;
                float4 color0  : COLOR;
			};

            //【宏定义】------------
            #define Two_PI 6.2831852
            //【动画函数】---------
            void AnimGhost(inout float3 vertex , inout float3 color)
            {   
                //【天使圈缩放】
                float scale = _ScalePara.x * color.g * sin(frac(_Time.y * _ScalePara.y) * Two_PI);  //缩放值,color.g作为遮罩,因为该模型g通道只有绿色部位有值，其他部位为0，所以起到只缩放绿色部位的效果。
                vertex *= 1.0 + scale;              //缩放顶点
                vertex.y -= _ScalePara.z * scale;   //因为天使圈位置不再模型的中心，所以y轴增加一个校正偏移；放大时，减小y值，缩小时，增大y值。当_ScalePara.z设置为天使圈到模型原点的高度时，天使圈正好为中心缩放
                //【身体摇摆：正弦运动】
                float moveX = _MoveParaX.x * sin(frac(_Time.x * _MoveParaX.y) * Two_PI + vertex.y * _MoveParaX.z);  //x移动，vertex.y * _MoveParaX.z是根据顶点高度确定不同的初相角，实现正弦波运动路径效果
                float moveZ = _MoveParaZ.x * sin(frac(_Time.x * _MoveParaZ.y) * Two_PI + vertex.y * _MoveParaZ.z);  //z移动，vertex.y * _MoveParaX.z是根据顶点高度确定不同的初相角，实现正弦波运动路径效果
                vertex.xz += float2(moveX , moveZ) * color.r;       //顶点左右和前后正弦运动
                //【摇头动画：天使圈相对于头有个惯性滞后性】
                //角度计算:  (1.0 - color.r)作为Mask；color.g * _RotParaY.z使天使圈滞后头部运动，_RotParaY.z设为0.5则正好差半个周期
                float radianY  = radians(_RotParaY.x * (1.0 - color.r) * sin(frac(_Time.x * _RotParaY.y - color.g * _RotParaY.z) * Two_PI ));	
                //角度应用
                float sin_radianY , cos_radianY = 0.0;			
				sincos(radianY , sin_radianY , cos_radianY);	//计算三角函数
                float2x2 Rotate_Matrix_Y = float2x2(cos_radianY , sin_radianY , -sin_radianY , cos_radianY);    //旋转矩阵
				vertex.xz = mul(Rotate_Matrix_Y , float2(vertex.x , vertex.z));     //旋转变换
                //【整体上下移动:天使圈同样有滞后性，】
                float moveY = _MoveParaY.x * sin(frac(_Time.x * _MoveParaY.y - color.g * _MoveParaY.z) * Two_PI);   //移动值，_MoveParaY.z=0.5时正好差半个周期
                vertex.y += moveY;
                //【新顶点色计算】
                float lightness = 1.0 + color.g * scale;            //天使圈变大，天使圈部分的顶点色变亮
                color = float3(lightness , lightness , lightness);        //更新顶点色
            }

			VertexOutput vert(VertexInput v) {
				VertexOutput o = (VertexOutput)0;
                    AnimGhost(v.vertex.xyz , v.color0.rgb);      //调用动画函数，输入的顶点色作为遮罩
                    o.pos = UnityObjectToClipPos(v.vertex);
                    o.uv0 = v.uv0 * _MainTex_ST.xy + _MainTex_ST.zw;
                    o.color0 = v.color0;                         //传递新的顶点色，用于片元着色器
				return o;
			}

			float4 frag(VertexOutput i) : SV_TARGET {
                half4 var_MainTex = tex2D(_MainTex , i.uv0);	
                half3 finalRGB = var_MainTex.rgb * i.color0.rgb;    //乘顶点色
				half opacity = 	var_MainTex.a * _Opacity;
				return float4(finalRGB * opacity , opacity);	        
			}
				ENDCG
		}
	}
		FallBack "Diffuse"						
}
```
# 第20~26（未学习）综合流程
需要学DCC工具：blender/SD之后再来看，加油！
待续。。。。。
