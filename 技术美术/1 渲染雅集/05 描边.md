
# 0 轮廓线渲染方法一览

在 《RTR3》 中，作者分成了 5 种类型：

1. **基于观察方向 $V$ 和表面法线 $N$** 。
    - 通过观察方向和表面法线点乘结果来得到轮廓线信息。简单快速，但局限性大。  
2. **过程式几何轮廓线渲染**。
   - 核心是两个 Pass：
      - 第一个 Pass 只渲染背面并且让轮廓可见（比如通过顶点外扩）；
      - 第二个 Pass 正常渲染正面。快速有效，适应于大多数表面平滑的模型，但不适合立方体等平整模型。  
3. **基于图像处理**。
    - 可以适用于任何种类的模型。但是一些深度和法线变化很小的轮廓无法检测出来，如桌子上一张纸。  
4. **基于轮廓边检测**。
    * 上述方法无法控制轮廓线的风格渲染，例如水墨风格等，**使用该方法可以进行风格化渲染**。缺点是实现相对复杂，会有动画连贯性问题，因为是逐帧单独提取轮廓，所以帧与帧之间会出现跳跃性。
    * <mark style="background: #FFB8EBA6;">检测一条边是否是轮廓边的方法</mark>：检查这条边相邻的两个三角面片是否满足：$(n_0·v> 0) ≠ (n_1·v > 0)$。
        *  $n_0$ 和 $n_1$ 表示两个相邻三角面片的法向，$v$ 是从视角到该边上任意顶点的方向。**本质是检查相邻两个三角是否一个面向视角，另一个背向视角**。可以使用几何着色器实现该功能
5. **混合上述方法**。例如，首先找到精确的轮廓线，把模型和轮廓边渲染到纹理中，再使用图像处理识别轮廓线，并在图像空间进行风格化渲染。  
# 1 基于观察方向和表面法线
通过观察方向 $V$ 和表面法线 $N$ 点乘结果来得到轮廓线信息。简单快速，但局限性大。  
![[Pasted image 20230725171335.png|550]]
>Edge=0.5 时

![[Pasted image 20230725161022.png|750]]

```cs
float NdotV = dot(N,V);
float color = step(_Edge, NdotV); //_Edge越大线越粗，_Edge大于NdotV返回0
```

# 2 模板测试描边

模板测试选项设置思路很灵活，我这里只写了一种设置方法。
- **模板缓冲区设置**
```cs
Stencil 
{
    Ref 0
    Comp Equal   
    Pass IncrSat //通过则stencilBuffer Value加1
    Fail Keep    //保留当前缓冲区中的内容，即stencilBUfferValue不变
    ZFail keep
}
```
- **第一个 pass** ：渲染前屏幕上所有像素的 stencil 值都是默认值 0，在该 pass 的 fragment shader 结束后，所有进行了渲染的像素都通过了 Ref 0 和 Comp Equal 的测试，并执行 Pass IncrSat 将 stencil 值加 1。
- **第二个 Pass** ：
    - **把每个顶点沿法线方向外扩。有两种方案：**
        - **在模型空间外扩**：**远近描边的粗细不同**。造成这个问题的原因：在裁剪之前做的变换，最后长度都会符合世界空间下因为相机透视造成的近大远小的效果。
        - **【矫正】在裁剪空间外扩**：[(38条消息) 【Unity URP】2种描边方案：模板测试和正面剔除_unity urp描边_九九345的博客-CSDN博客](https://blog.csdn.net/qq_41835314/article/details/129963711)
    - 随后设置法线的 z 分量，对其归一化后再将顶点沿其方向扩张，得到扩张后的顶点坐标。对法线的处理是为了尽可能避免背面扩张后的顶点挡住正面的面片。
    - 最后，我们把顶点从视角空间变换到裁剪空间。进行同样的 stencil 测试，上一个 pass 渲染过的像素 stencil 值已经变为 1，无法通过 Ref 0+Comp Equal 测试，那么现在只会在放大后的既是 stencil 值仍然为 0 的边缘区域进行渲染。
![[Pasted image 20221031201004.png|300]]
```less
Shader "Unlit/outline"
{
    Properties
    {
        _MainTex ("Texture", 2D) = "white" {}
        [HDR]_EdgeColor("EdgeColor",Color) = (1,1,1,1)
    }
    SubShader
    {
        Tags { "RenderType"="Opaque" }
        LOD 100
        
        Stencil 
        {
            Ref 0
            Comp Equal   
            Pass IncrSat //通过则stencilBufferValue加1
            Fail Keep    //保留当前缓冲区中的内容，即stencilBUfferValue不变
            ZFail keep
        }
        
        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            
            #include "UnityCG.cginc"

            struct appdata
            {
                float4 vertex : POSITION;
                float2 uv : TEXCOORD0;
            };

            struct v2f
            {
                float2 uv : TEXCOORD0;
                float4 pos : SV_POSITION;
            };

            sampler2D _MainTex;
            float4 _MainTex_ST;
            
            v2f vert (appdata v)
            {
                v2f o;
                o.pos = UnityObjectToClipPos(v.vertex);
                o.uv = TRANSFORM_TEX(v.uv, _MainTex);
                UNITY_TRANSFER_FOG(o,o.vertex);
                return o;
            }

            fixed4 frag (v2f i) : SV_Target
            {
                fixed4 col = tex2D(_MainTex, i.uv);
                return col;
            }
            ENDCG
        }
        // 第二个pass 描边
        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            
            #include "UnityCG.cginc"

            struct appdata
            {
                float4 vertex : POSITION;
                float4 normal : NORMAL;
                float2 uv : TEXCOORD0;
            };

            struct v2f
            {
                float2 uv : TEXCOORD0;
                float4 pos : SV_POSITION;
            };

            float4 _EdgeColor;
            
            v2f vert (appdata v)
            {
                v2f o;
                o.pos = UnityObjectToClipPos (v.vertex + normalize (v.normal)*0.01f);
                o.uv = v.uv;
                UNITY_TRANSFER_FOG (o,o.vertex);
                return o;
            }

            fixed4 frag (v2f i) : SV_Target
            {
                return _EdgeColor;
            }
            ENDCG
        }
    }
}
```


# 3 过程式几何轮廓线渲染

实现原理：

其实就是把前面的模板测试换成了剔除操作。正常渲染的时候剔除背面渲染正面，第二次顶点扩张之后剔除正面渲染背面，这样渲染背面时由于顶点外扩的那一部分就将被我们所看见，而原来的部分则由于是背面且不透明所以不会被看见，形成轮廓线渲染原理。因此从原理上也能看出，这里得到的轮廓线不单单是外轮廓线。

实现效果：

![[43304e962aac52ea1de18183d092c485_MD5.jpg]]

完整代码：

```
Shader "Hbh Shader/Cull Outline Shading" 
{
    Properties 
    {
        _Outline ("Outline", Range (0, 1)) = 0.1
        _OutlineColor ("Outline Color", Color) = (0, 0, 0, 1)
    }
    SubShader 
    {
        Pass 
        {
            Cull Back

            CGPROGRAM
 #pragma vertex vert
 #pragma fragment frag

            float4 vert (float4 v : POSITION) : SV_POSITION 
            {       
                return UnityObjectToClipPos(v); 
            }

            float4 frag() : SV_Target 
            { 
                return float4(1, 1, 1, 1);
            }

            ENDCG
        }

        Pass 
        {
            Cull Front

            CGPROGRAM
 #pragma vertex vert
 #pragma fragment frag

            float _Outline;
            fixed4 _OutlineColor;

            struct a2v 
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
            }; 

            struct v2f 
            {
                float4 pos : SV_POSITION;
            };

            v2f vert (a2v v) 
            {
                v2f o;

                float4 pos = mul (UNITY_MATRIX_MV, v.vertex); 
                float3 normal = mul((float3x3)UNITY_MATRIX_IT_MV, v.normal); 
                normal.z = -0.5;
                pos = pos + float4(normalize(normal), 0) * _Outline;
                o.pos = mul(UNITY_MATRIX_P, pos);

                return o;
            }

            float4 frag(v2f i) : SV_Target 
            { 
                return float4(_OutlineColor.rgb, 1); 
            }

            ENDCG
        }
    }
}
```

# 4 边缘检测

这种方法其实是用屏幕后处理效果去实现的（也就是基于图像处理）。

屏幕后处理，通常指的是在渲染完整个场景得到屏幕图像后再对这个图像进行一系列操作实现各种特效。这里实现的原理其实是使用特定的材质去渲染一个可以刚好填充整个屏幕的四边形面片。

而边缘检测的原理其实就是用一个特定的卷积核去对一张图像卷积，得到梯度值，再根据梯度值的大小去判断是否为边界。

![[dae617ea28bf736d24c53f850d391047_MD5.png]]

实现效果：

![[a61b10015edf8fe9a404e61593c279a5_MD5.png]]

具体代码可以看《Unity Shader 入门精要》源码，场景为 Scene_12_3：

[https://github.com/candycat1992/Unity_Shaders_Book](https://github.com/candycat1992/Unity_Shaders_Book)

# 5 SDF 方法

关于 SDF 我在之前的文章中有过分析：

[何博航：Signed Distance Field 与 Multi-channel signed distance field](https://zhuanlan.zhihu.com/p/398656596)

之前也在 UE4 中实现过，但是还是刚接触 Unity Shader 没几天，对 shaderlab 还不熟悉。这里主要参考了前辈的文章，在其基础上稍作修改：

[拳四郎：Signed Distance Field](https://zhuanlan.zhihu.com/p/26217154)

描边结果：

![[5babaf79a82fcafdfc07dfa7529f2dcd_MD5.png]]

原理其实很简单，这里的圆是在 shader 中根据 SDF 值绘制的。SDF 值在边界处接近 0，于是我们就通过 SDF 的 fwidth 值与当前像素的 SDF 值去判断，因为 fwidth 为相邻像素的 SDF 差值和，那么必然很小。所以判断的结果用于 lerp，就可以检测哪里的 SDF 值接近 0，亦即检测到轮廓。而 aa 也是简单地用 smoothstep 处理就好。

给出完整代码：

```
Shader "OutlineShader/sdfOutline"
{
    Properties
    {
        _Color ("Color", Color) = (1, 1, 1, 1)
        _BackgroundColor ("BackgroundColor", Color) = (0, 0, 0, 1)
    }
    SubShader
    {
        Pass
        {
            CGPROGRAM
 #pragma vertex vert
 #pragma fragment frag
 #include "UnityCG. cginc"

            float sdfCircle(float2 coord, float2 center, float radius)
            {
                float2 offset = coord - center;
                return sqrt((offset.x * offset.x) + (offset.y * offset.y)) - radius;
            }

            float4 render(float d, float3 color, float stroke) 
            {
                float anti = fwidth(d) * 1.0;
                float4 colorLayer = float4(color, 1.0 - smoothstep(-anti, anti, d));
                bool flag = step(0.000001, stroke);
                float4 strokeLayer = float4(float3(0.05, 0.05, 0.05), 1.0 - smoothstep(-anti, anti, d - stroke));
                return float4(lerp(strokeLayer.rgb, colorLayer.rgb, colorLayer.a), strokeLayer.a) * flag + colorLayer * (1 - flag);
            }

            struct appdata
            {
                float4 vertex : POSITION;
            };

            struct v2f
            {
                float4 pos : SV_POSITION;
                float4 screenPos : TEXCOORD0;
            };

            fixed4 _Color;
            fixed4 _BackgroundColor;

            v2f vert (appdata v)
            {
                v2f o;
                o.pos = UnityObjectToClipPos (v.vertex);
                o.screenPos = ComputeScreenPos(o.pos);
                return o;
            }

            fixed4 frag(v2f i) : SV_Target
            {
                float2 pixelPos = (i.screenPos.xy / i.screenPos.w) * _ScreenParams.xy;
                float a = sdfCircle(pixelPos, float2(0.5, 0.5) * _ScreenParams.xy, 100);
                float4 layer1 = render(a, _Color, fwidth(a) * 2.0);
                return lerp(_BackgroundColor, layer1, layer1.a);
            }
            ENDCG
        }
    }
}
```

# 关于基于轮廓边检测的方法

再来回顾一下之前所述的原理：

检查这条边相邻的两个三角面片是否满足：(n0·v> 0) ≠ (n1·v > 0)。这里 n0 和 n1 分别表示两个相邻三角面片的法向，v 是从视角到该边上任意顶点的方向。本质是检查相邻两个三角是否一个面向视角，另一个背向视角。

于是这里我想到用几何着色器去做，但是不知道怎么获得相邻的三角面片，在 OpenGL 中有 GL_LINES_ADJACENCY 去得到线段以及相邻顶点，就正好四个顶点两个相邻面片，从而可以去处理。但是 Unity Shader 中我没有找到怎么做。但是在谷歌中搜索出了一个解决方法： [https://forum.unity.com/threads/does-unity-support-triangleadj-in-geometry-shaders.930306/](https://forum.unity.com/threads/does-unity-support-triangleadj-in-geometry-shaders.930306/)

先给他的链接，还没来得及细看：

[https://github.com/Milun/unity-solidwire-shader/blob/master/Assets/Shaders/SolidWire.shader](https://github.com/Milun/unity-solidwire-shader/blob/master/Assets/Shaders/SolidWire.shader)

### 关于可选顶点着色器

之前我整理了渲染管线：

[何博航：渲染管线与渲染路径详解](https://zhuanlan.zhihu.com/p/408238134)

但是关于曲面细分着色器和几何着色器没有详细说明，这里补充一下：

![[173a69a697743ca9581cb0ba15aa24f9_MD5.png]]

如上图，曲面细分又分为：Hull shader 、Tessellation Primitive Generator 、 Domain shader，这些名称在不同的 API 中可能不一样。

对于曲面细分着色器，输入是 Patch，可以看成是多个顶点的集合，包含每个顶点的属性。功能是可以将图元细分。输出为细分后的顶点。

对于几何着色器，输入为渲染图元，输出则为一个或者多个图元，同时还要定义输出的最大顶点数，并且输出的图元需要自己构建（顺序很重要）。在知乎上找到一个最简单的入门：[https://zhuanlan.zhihu.com/p/141036227](https://zhuanlan.zhihu.com/p/141036227)

不过还是比较推荐 may 佬的百人计划：

[【技术美术百人计划】图形 3.3 曲面细分与几何着色器 大规模草渲染_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1XX4y1A7Ns?p=2)



# 方案总结
## 描边

**单 Pass 思路**

*   一般用于接触式显示描边。
*   全局设置一个外描边预制体（参数含外描边）
*   当触碰到物体时，将外描边预制体放到对应物体下，并将其 Mesh 或者 Sprite 替换为对应物体。
*   离开时，隐藏。

**多 Pass 思路**

*   一般用于物体就要外描边。

**Vert 法线描边**

![[c5bc4dae2b42ba0cdd0e78e96ac10242_MD5.jpg]]

**Frag 判断边缘描边**

![[39aaf7cdc4c3072bb098bfd997d205fa_MD5.jpg]]

### 控制 Scale 的纯色描边

*   Frag 阶段直接返回所需颜色。
*   然后控制物体的 Scale。

```
float4 frag(VertexOutput i) : SV_Target
	{
		return _OutlineColor;
	}
```

## 基于观察角度和表面法线**描边（Vert）**

[Unity3D Shader 系列之描边](https://blog.csdn.net/sinat_25415095/article/details/124053368)

[hebh：在 shader 中实现五种描边方法](https://zhuanlan.zhihu.com/p/410710318)

法线外拓 + 深度测试 Always（存在：模型自身会穿透自身和物体将会永远再最前面问题，一般不使用这种方案）  
法线外拓 + Cull Front  
法线外拓 + ZWrite Off（存在：两个模型重叠部分没有描边的问题：控制渲染队列解决）  
法线外拓 + 模板测试（存在：两个模型重叠部分没有描边的问题：无解）  
[法线不是连续的时候，描边就会中断的问题](https://zhuanlan.zhihu.com/p/427742656)

**计算法线，最基础方案**

```
v2f vert(appdata_base v)
{
      v2f o;
      v.vertex.xyz += v.normal * _OutlineWidth;
      o.vertex = UnityObjectToClipPos(v.vertex);
      return o;
}
```

**无论相机距离物体多远或者观察视角的变化，都让描边的宽度保持等比例的近似方法解决**

```
v2f vert (appdata v)
{
	o.vertex = UnityObjectToClipPos(v.vertex);
	float3 clipNormal = mul((float3x3) UNITY_MATRIX_VP, mul((float3x3) UNITY_MATRIX_M, v.normal));
	o.vertex.xy += normalize(clipNormal).xy * _OutlineWidth;
}
```

## SDF 描边（Frag）

*   [Signed Distance Field 与 Multi-channel signed distance field - hebh 的文章 - 知乎](https://zhuanlan.zhihu.com/p/398656596)（SDF 介绍）
*   [用 SDF 处理卡通内描线的锯齿问题 - flashyiyi 的文章 - 知乎](https://zhuanlan.zhihu.com/p/113190695)

通过 SDF 的 fwidth 值与当前像素的 SDF 值去判断，哪里 SDF 值在边界处接近 0。  
因为 fwidth 为相邻像素的 SDF 差值和，那么必然很小，可以用 lerp 检测哪里的 SDF 值接近 0，亦即检测到轮廓。

```
Shader "OutlineShader/sdfOutline"
{
    Properties
    {
        _Color ("Color", Color) = (1, 1, 1, 1)
        _BackgroundColor ("BackgroundColor", Color) = (0, 0, 0, 1)
    }
    SubShader
    {
        Pass
        {
            CGPROGRAM
 #pragma vertex vert
 #pragma fragment frag
 #include "UnityCG.cginc"

            float sdfCircle(float2 coord, float2 center, float radius)
            {
                float2 offset = coord - center;
                return sqrt((offset.x * offset.x) + (offset.y * offset.y)) - radius;
            }

            float4 render(float d, float3 color, float stroke) 
            {
                float anti = fwidth(d) * 1.0;
                float4 colorLayer = float4(color, 1.0 - smoothstep(-anti, anti, d));
                bool flag = step(0.000001, stroke);
                float4 strokeLayer = float4(float3(0.05, 0.05, 0.05), 1.0 - smoothstep(-anti, anti, d - stroke));
                return float4(lerp(strokeLayer.rgb, colorLayer.rgb, colorLayer.a), strokeLayer.a) * flag + colorLayer * (1 - flag);
            }

            struct appdata
            {
                float4 vertex : POSITION;
            };

            struct v2f
            {
                float4 pos : SV_POSITION;
                float4 screenPos : TEXCOORD0;
            };

            fixed4 _Color;
            fixed4 _BackgroundColor;

            v2f vert (appdata v)
            {
                v2f o;
                o.pos = UnityObjectToClipPos(v.vertex);
                o.screenPos = ComputeScreenPos(o.pos);
                return o;
            }

            fixed4 frag(v2f i) : SV_Target
            {
                float2 pixelPos = (i.screenPos.xy / i.screenPos.w) * _ScreenParams.xy;
                float a = sdfCircle(pixelPos, float2(0.5, 0.5) * _ScreenParams.xy, 100);
                float4 layer1 = render(a, _Color, fwidth(a) * 2.0);
                return lerp(_BackgroundColor, layer1, layer1.a);
            }
            ENDCG
        }
    }
}
```

## 边缘检测描边 (Frag)

*   2D 常用。也可用于 2D 的边缘光。

```c
float4 UnlitFragment(Varyings i) : SV_Target
{
	float4 mainTex = i.color * SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv);

	// 采样周围4个点
	float2 up_uv = i.uv + float2(0, 1) * _LineWidth * 1 / 10 * _MainTex_ST.xy;
	float2 down_uv = i.uv + float2(0, -1) * _LineWidth * 1 / 10 * _MainTex_ST.xy;
	float2 left_uv = i.uv + float2(-1, 0) * _LineWidth * 1 / 10 * _MainTex_ST.xy;
	float2 right_uv = i.uv + float2(1, 0) * _LineWidth * 1 / 10 * _MainTex_ST.xy;
	// 如果有一个点透明度为0 说明是边缘
	float4 up = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, up_uv);
	float4 down = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, down_uv);
	float4 left = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, left_uv);
	float4 right = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, right_uv);
	float w = up.a * down.a * left.a * right.a;
	if (w == 0) {
		mainTex.rgb = lerp(_LineColor * _Intensity, mainTex.rgb, w);
	}
	return mainTex;
}
```

## 后处理描边（不建议使用）

比较费性能，且难维护。也叫：边缘检测法。

*   需要额外相机
*   需要 RenderTexture
*   需要额外加快控制 OnRenderImage 等

## UI 描边

[UIEffect](https://gitee.com/gamejzb/UIEffect?_from=gitee_search) 里的方案，利用 Unity 的 [UI.IMeshModifier](https://docs.unity3d.com/cn/2017.2/ScriptReference/UI.IMeshModifier.html) 机制，绘制图形前，添加处理更多相同的图片 Mesh。

![[f815745098c34de8d721b647473cb5e7_MD5.jpg]]

## 扩展阅读

**MKToon 的描边**（放大法）

```
float3 scaleOrigin = 1 + _OutlineWidth * 0.01f;
        float3x3 scale = float3x3(scaleOrigin.x, 0, 0,0, scaleOrigin.y, 0,0, 0, scaleOrigin.z);
        float3 positionWorld = mul(scale, input.vertex.xyz);
        positionWorld = mul(UNITY_MATRIX_M, float4(positionWorld, 1.0)).xyz;
        output.pos = mul(UNITY_MATRIX_VP, float4(positionWorld, 1.0));
```

**ToonyColorsPro2 的描边**（法线计算法）

```
output.pos = UnityObjectToClipPos(input.vertex.xyz);
        normal = mul(unity_ObjectToWorld, float4(normal, 0)).xyz;
        float2 clipNormals = normalize(mul(UNITY_MATRIX_VP, float4(normal,0)).xy);
        float outlineWidth = _OutlineWidth * 10;
        float3 sp = float3(1920, 1080, 0);//基准分辨率
        clipNormals.xy = (clipNormals.xy / sp.xy) * 2.0;
        output.pos.xy += clipNormals.xy * outlineWidth;
```
#  Sobel 算子进行描边

本文基于冯乐乐《shader 入门精要》并基于 Unity 2022.3.0 lts，URP14 改写

URP 14 带来了一个新 Feature，FullScreenPassRendererFeature，可以很方便的写各种自定义的后处理特效，本文使用 Sobel 算子进行边缘检测并描边。

Sobel 算子的思想是在某个像素的临近 9 宫格内采样，计算 x 和 y 方向的梯度，如果梯度越大，表示这个地方颜色突变越强，越接近于一个边缘点。

在 Renderer 中添加 FullScreenPassRendererFeature，新建一个材质，命名为 SobelOutline，拖入 Pass Material 即可

![](https://pic2.zhimg.com/v2-8bdf3034f0f046238159d81ab2a11075_r.jpg)

新建一个 Shader，命名为 SobelOutline，拖入 Material 中，Shader 写法如下：

```
Shader "Outline"
​
{
    Properties
    {
        _EdgeColor("EdgeColor",Color)=(0,0,0,1)
    }
    SubShader
    {
        Tags
        {
​
            "RenderType" = "Transparent" "RenderPipeline" = "UniversalPipeline"
        }
        Cull Off
        Blend Off
        ZTest Off
        ZWrite Off
        Pass
        {
            Name "Outline"
            HLSLPROGRAM
 #pragma vertex Vert
 #pragma fragment Frag
            //这两个头文件包括了大多数需要用到的变量
 #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
 #include "Packages/com.unity.render-pipelines.universal/Shaders/PostProcessing/Common.hlsl"
            //这个需要自己声明，xy表示纹素的长宽，zw表示整个BlitTexture的长宽，BlitTexture就是当前摄像机的颜色缓冲区
            float4 _BlitTexture_TexelSize;
​
            float2 uvs[9];
            //常规CBUFFER，上面自定义的属性要写在这里
            CBUFFER_START(UnityPerMaterial)
            half4 _EdgeColor;
            CBUFFER_END
​
            half Sobel()
            {
                const half Gx[9] = {-1, -2, -1, 0, 0, 0, 1, 2, 1};
                const half Gy[9] = {-1, 0, 1, -2, 0, 2, -1, 0, 1};
                half texColor;
                half edgeX = 0, edgeY = 0;
                for (int it = 0; it < 9; it++)
                {
                    //RGB转亮度
                    texColor = Luminance(SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uvs[it]));
                    //计算亮度在XY方向的导数，如果导数越大，越接近一个边缘点
                    edgeX += texColor * Gx[it];
                    edgeY += texColor * Gy[it];
                }
                //edge越小，越可能是个边缘点
                half edge = 1 - abs(edgeX) - abs(edgeY);
                return edge;
            }
​
            half4 Frag(Varyings i) : SV_TARGET
            {
                half2 uv = i.texcoord;
                uvs[0] = uv + _BlitTexture_TexelSize.xy * half2(-1, -1);
                uvs[1] = uv + _BlitTexture_TexelSize.xy * half2(0, -1);
                uvs[2] = uv + _BlitTexture_TexelSize.xy * half2(1, -1);
                uvs[3] = uv + _BlitTexture_TexelSize.xy * half2(-1, 0);
                uvs[4] = uv + _BlitTexture_TexelSize.xy * half2(0, 0);
                uvs[5] = uv + _BlitTexture_TexelSize.xy * half2(1, 0);
                uvs[6] = uv + _BlitTexture_TexelSize.xy * half2(-1, 1);
                uvs[7] = uv + _BlitTexture_TexelSize.xy * half2(0, 1);
                uvs[8] = uv + _BlitTexture_TexelSize.xy * half2(1, -1);
                half edge = Sobel();
                //根据edge的大小，在边缘颜色和原本颜色之间插值，edge为0时，完全是边缘，edge为1时，完全是原始颜色
                half4 withEdgeColor = lerp(_EdgeColor,SAMPLE_TEXTURE2D_X(_BlitTexture, sampler_LinearClamp, uv), edge);
                return withEdgeColor;
            }
            ENDHLSL
        }
    }
    //后处理不需要Fallback，不满足的时候不显示即可
    Fallback off
}
```

效果：可见这种方法下如果两个物体颜色接近，就检测不出来了。

![](https://pic2.zhimg.com/v2-91813942b14226f72936b98783a03749_r.jpg)