主要内容：**多边形光源下快速求shading的LTC算法,Disney's principle BRDF和Non-Photorealistic Rendering**

## **Linearly Transformed Cosines(LTC-> 线性变换的余弦)**

**LTC 是为了解决 microfacet models 的 shading 问题, 但是它有一些限制:**

![[5766f428cd49f75b3322eb06660bff25_MD5.jpg]]

1.  _主要是针对 GGX 模型, 对于其他模型原理也同样适用._
2.  _做的是不考虑 shadow 的 shading_
3.  _光源是多边形光源, 且发出的 radiance 时 uniform 的._

**LTC 就是在多边形光源的照射下快速求出在 ggx 模型上不考虑 shadow 的任意一点的 Shading.**

_首先我们要解释一下什么是 Lobe波瓣:

Lobe 就是在固定一边方向下的 brdf 的函数图象, 由于 BRDF 是一个 4 维的函数, 在固定一边之后就变为了 2 维的函数.

大多数高光 brdf，都是在半角向量接近宏表面法线时反射亮度最大, 向上或向下时其值都会减小, 使得其函数图象像叶片，故称为 lobe。

![[a9dc9bd61a4c8c9e72f81e2d6c12415b_MD5.jpg]]

如图在光源方向 L 固定的情况下，你移动反射方向 R，当 **L 和 R 的半角向量 = 向量 N** 时反射亮度最强，就是图中所示情况。如果继续向上或向下改变 R，反射亮度都会减弱。就形成了那条绿色的极坐标曲线, 也就是 Lobe。  

![[9f79b3c8b567101eb55d6cbc48011c99_MD5.jpg]]

我们知道 LTC 是在多边形光源照射下求出微表面模型上一点的 shading 值

如果没有 Ltc 这个方法我们需要采样, 在多边形光源上我们需要取很多采样点, 并且与 shaing point 连线, 如果不考虑连线是否与场景有交点则不考虑 shadow, 如果需要考虑 shadow 还需要做一下 shadow test. 但不论如何都需要采样, 那么不可避免地会使速度变慢, 因此为了不采样产生了 LTC 这个方法.

LTC 和 split sum 本质上的区别是, split sum 做的是环境光下的 shading.

**LTC 核心方法:**

**1. 在固定入射方向后, 我们将出射的 lobe(brdf 的 lobe) 转变为一个余弦函数**

**球面的所有方向**经过这个**线性变换**后使得 brdf 的 lobe 朝向向上.

![[2b36e4428d018a8d46fb4152907145de_MD5.jpg]]

左边我们固定了入射方向, 知道了反射方向的 lobe, 通过一个线性变换, 我们将 lobe 内的所有朝向转变为右图中, 其朝向向上的范围, 并且它的覆盖是从正中间是最大值, 依次向周围衰减, 也就是像余弦函数一样.

**2. 在转换 Brdf 的 lobe 时, 将多边形光源也进行变换**

![[ab64fe5718fce5f6ee1e064efda3b0b9_MD5.jpg]]

以图的四边形光源为例, 将四边形光源的四个顶点与 shading point 相连得到四个方向 (向量), 让这四个向量也进行相同的线性变换, 从而形成新的四边形光源, 此时我们发现:

原光源与 brdf 结合去照亮 shading point = 新光源与 cos 函数结合去照亮 shading point

3. **我们将 shading point 点任意 brdf 的 lobe 在任意多边形光源下积分求 shading 的问题转变为在一个固定 cos 函数下对任意的多边形光源积分求 shading**

因此我们要积分的东西只是 cos, 积分的范围虽然各不相同, 但可以保证这个范围是一个多边形, 而且在这个范围内积分是有解析解的, 因此可以帮助我们快速求出 shading.

**思路:**

![[01b8f5a8c6a97eedc7a7237fec801b50_MD5.jpg]]

![[aed25da8e66e66414233fac465713a67_MD5.jpg]]

我们需要把

1. 任意 brdf 的 lobe 变为固定的 cos lobe

2. 我们需要所有的方向ωi 进行变换, 变为新的ωi', 从而使得 brdf 的 lobe 变为固定的 cos.

3. 原本的多边形光源所覆盖的方向也需要进行变换, 从而产生新的多边形光源覆盖的区域, 然后我们再新的区域内对 cos 进行积分求出 shading 值.

**(个人理解, 我本人数学知识很差所以这部分有点拿不准, 如果有错误希望能大家指出来)**

![[226806e246829ae3e043e4031375e03f_MD5.jpg]]

至此我们知道了整体思路, 具体步骤我们需要做的就是改变变量:

我们从 rendering equation 开始:

![[f8615a086c500e9b16dc429212a26522_MD5.jpg]]

由于我们认为多边形光源内的任意 radiance 都是 uinform 的, 因此 lighting 项可以拆出来, 我们把剩下的 brdf 和 cos 合在一起机座 F(ωi), 我们需要把 F(ωi) 通过某种线性变换把所有的ωi 变为新的方向ωi', 从而使 F(ωi) 的形象变为 cos.

![[55e84a0be8724c12eb6e8d24f7179088_MD5.jpg]]

假设在单位球面上有一点我们经过了线性变换后, 新的点可能不在单位球面上, 也就是将一个方向经过单位变换后, 它的长度可能会发生变化, 因此如果像仍然让他是一个方向我们需要进行归一化处理.

由于我们是按照 paper 中来说的, paper 中 brdf 是经过 M 的逆变换得到的, 因此新的方向ωi'经过 M 才是ωi.

因此我们将其替换进去:

![[d544990c418ae46e63fcf7d08b63487d_MD5.jpg]]

做完变量替换后我们会发现解不了积分, 我们需要将 $d\frac{Mωi'}{\left|\left| Mωi' \right| \right|}$ 变为 dωi', 这部分是纯微积分, 我们需要引入一个雅克布项 - J.

![[e4c29c4cca336984c9c080f63dbc1172_MD5.jpg]]

从而我们得到了在 P'范围内对 cos 的一个积分, 这个积分是有解析解的. 这就是 LTC 方法的基本思路.

Q:cos 不是一个一维的函数吗?

A:cos 确实是一个一维的函数, 我们把他认为是θ的函数而不是φ, 但是我们还是可以把他以一个 2D 的形式显示在球面上, 方便我们去理解.

$cos(\theta_s)$ 是一个球面分布函数（**余弦分布函数**），$f(p,w_i,w_o)$ 也是一个球面分布函数. 因此其实我们是让一个球面分布函数通过线性变化变成了另一个球面分布函数.

![[88b2b780ab69d07f2fde492ab9314685_MD5.jpg]]

我们可以看到 LTC 可以得到一个很好的结果:

![[54e6dcc26db30100b4f2cf11b577d89f_MD5.jpg]]

由于 LTC 里面涉及的内容比较复杂, 因此这里只讲了基本思路.

总结: LTC 就是把 变化 brdf 和 变化光源 通过线性变换 变成了在固定的 brdf 下变化的光源问题的一个方法.

## **Disney's principle BRDF**

首先我们来讨论一下为什么还需要 Disney's principle BRDF:

因为微表面模型是由一些问题的:

**1. 微表面模型无法解释多层材质**
我们来举个例子, 我们有一个木头桌子, 我们知道木头是 diffuse 的, 在桌子的表面刷一层清漆。从而我们的桌子变成了多层材质: 清漆 + 木头。清漆是无色的, 由于清漆是平坦的, 因此在光线打入时, 一部分反射出去产生了高光现象。另一部分打入内部并打到桌子上以 diffuse 发散出去, 因此我们应该会看到高光和 diffuse.这是微表面模型无法做到的, 因为**微表面模型无法解释多层材质。**
>清漆ClearCoat，又名[凡立水](https://baike.baidu.com/item/%E5%87%A1%E7%AB%8B%E6%B0%B4/9978483)，是由[树脂](https://baike.baidu.com/item/%E6%A0%91%E8%84%82/281282)为主要[成膜物质](https://baike.baidu.com/item/%E6%88%90%E8%86%9C%E7%89%A9%E8%B4%A8)再加上溶剂组成的[涂料](https://baike.baidu.com/item/%E6%B6%82%E6%96%99/2503539)。由于涂料和涂膜都是透明的，因而也称透明涂料。涂在物体表面，干燥后形成光滑薄膜，显出物面原有的纹理。

**2. 微表面模型对艺术家来说并不好用**

我们知道 PBR,PBR, 都是基于物理的, 我们以金属反射率来说，反射率由 n 和 k 这两个参数定义。对于 artist 来说, 他们是不知道的怎么调。因此 PBR 材质对于艺术家来说不好用。
*   Disney's principle BRDF 诞生的首要目的就是为了让 artist 使用方便, 因此它并不要求在物理上完全正确.
*   但是在 RTR 中我们认为 Disney's principle BRDF 也算是 PBR 材质.

**Disney's principle BRDF 有几个重要的设计原则:**=
1.  应该使用更直观的名词而不是使用物理名词参数, 比如使用平缓, 饱和度等
2.  让 brdf 框架不太复杂, 也就是让参数数量少一点
3.  最好有一个拖动条左边最小值, 右边最大值供艺术家们进行调整
4.  有时候为了特殊的效果允许将参数值超过范围, 也就是允许小于 0 或大于 1
5.  所有参数的组合应尽可能可靠和合理, 也就是不论如何调整参数最后的结果应该是正常的.

因此在这套设计原则下, artist 可以根据自己需要去定义自己想得到的 BRDF:
![[Pasted image 20230710213136.png]]

*   subsurface: 次表面反射, 为了在 BRDF 中给你一种比 diffuse 还要平的效果. 可以看出当 subsurface 为 1 时与 0 相比像是被压扁了一样.

![[2551fe83ada6e138c25626fe73749a96_MD5.png]]

*   metallic: 金属性, 顾名思义看起来像金属的程度.

![[bc4a549ff7fbdc5d159a481651c53d96_MD5.png]]

*   specular: 控制有多少镜面反射的内容, 0 为完全没有镜面反射内容, diffuse,1 则表示全是镜面反射内容.

![[e4d933eae00a5ad3f4df0846b52821d3_MD5.png]]

*   specular tint: 镜面反射出的颜色无色 (为 0), 还是偏向于自己物体本身的颜色 (1).

![[671ef64bfd5f8d2c97526a43c4f22482_MD5.png]]

*   roughness: 粗糙度, 为 0 表示全是镜面反射, 为 1 表示没有镜面反射.

![[ce23c41e089a420eb52b7eda260f68c6_MD5.png]]

*   anisotropic: 各向异性程度, 可以理解为当为 1 的时候带来一种像是被刷过一样的效果.

![[e791eeb270d82ab760161a1fbede89fa_MD5.png]]

*   sheen: 可以理解为, 在物体表面法线方向上长了绒毛, 这让你在 grazing angle(外圈) 处看起来有一种雾化的感觉.

![[8b09eed3621623e4dbe668359e661671_MD5.png]]

*   sheen tint: 可以理解为绒毛造成的雾化效果颜色是无色, 还是偏向物体本身的颜色.

![[0f0858a058d023ab34408103752c9795_MD5.png]]

*   clearcoat: 可以理解为透明层的明显程度, 0 时表示没有透明层, 1 则表示有一层透明层 (涂了一层清漆).

![[2cee53fe70af566ce4635a27d0146bb0_MD5.png]]

*   clearcoat gloss: 透明层的光泽层度, 为 0 就像被磨砂了一样, 为 1 则表示完全光滑.

![[21607352efb99fcaaa82648a04312b72_MD5.png]]


**Disney's principle BRDF 的优点:**

1. 容易理解和使用各参数 (属性)
2. 参数的混合组合使得可以在一个模型上显示出很多不同的材质.
3. 开源

**Disney's principle BRDF 的缺点:**
1. 并不是完全基于物理的
2. 巨大的参数空间使得拥有强大的表示能力, 但是会造成冗余现象.


## **Non-Photorealistic Rendering(NPR)**

首先我们需要知道 NPR 做的是什么, 我们知道游戏的画风是各不相同的, 有些游戏比如 COD, 战地等他们追求的时画面的真实从而让玩家有良好的代入感, 而有些游戏比如原神, 塞尔达的画风明显是与真实不相干的卡通风, 也就是风格化 (stylization)

NPR 的任务就是为了把渲染出的结果偏向于这种卡通的风格.

闫神认为, 在 RTR 中的 NPR 需要是一个**快速** 且 **可靠的**风格化操作.

因此 NPR 通常是一些轻量级的处理, 一般是在 shader 中做一些简单但是很聪明的处理从而完成风格化.

### **Photorealistic Rendering**

那么我首先要从 Photorealistic Rendering 开始了解

Photorealistic Rendering 强调画面的真实感, 因此他的目的很明确:

1. 无法分辨是照片还是渲染出来的

2. 光照, 阴影, 材质等效果需要无限接近于真实的.

![[3c7ff5db37a7d7284609a0b59c734812_MD5.jpg]]

![[f1e93036523bfe503bc68a4d48b4f3a8_MD5.png]]

### **Non-Photorealistic Rendering**

![[adbd3d52a172e6f2c9b8be12e5286ff7_MD5.jpg]]

NPR 的目的是为了制造一种 artistic 的效果, 从而使得渲染结果虽然远离真实感, 但是有自己独特的风格和特点, 且能够能清晰了解图想表达的是什么.

如图非常不真实, 但是通过将区域变暗我们可以很清楚的知道暗下去的区域是阴影.

**NPR 思路:**

**1. 我们要先得到真实渲染的结果**

**2. 通过观察, 把 Photorealistic 变为 Non-Photorealistic**

**NPR 的一些应用:**

1. 艺术

![[d12562741532b1b38261902dfb1008cc_MD5.jpg]]

2. 可视化

![[0f0100223e36f175b8a296758119ac76_MD5.jpg]]

3. 指示, 示意图, 在这里 NPR 可以比 PR 更直观的指出问题或者关键.

![[d78bccae4829f852a687b78b37a2afcc_MD5.jpg]]

4. 教育

![[8798ca6cadcfb13f74a3988bdfaa37fd_MD5.jpg]]

5. 娱乐

![[159fb470116a5fdadc810915ab4cec49_MD5.jpg]]

NPR 在游戏领域运用的其实是很广泛的, 比如之前提到的原神, 塞尔达, 以及大佬图中的莱莎的炼金工坊 2(被种草了回头得去玩玩)

![[7c0afaa683c4270967a38cfacb7878fd_MD5.jpg]]

我们可以看到在大腿.... 啊不炼金工坊中, 人物是 3D 的, 光照, 着色, 阴影等都有, 只是应用的不是真实感渲染而是非真实感.

同样的 NPR 在动漫领域, 在经历过纯手绘的时期之后, 现在的几乎所有动漫都是在通过渲染 + 部分人工工作这么一种协同来得到的.

我们可以看到图中莱纳的脸上有明显的由左侧点光源照亮而得到的阴影, 也就是拥有全局光照, 至此我们可以知道 NPR 保留了很多 photorealistic 的东西.

![[de231ad1407132023db2a0c66b80e727_MD5.jpg]]

以无主之地系列为例, 它具有很明显的美漫风格, 以他们的身体旁的边缘轮框描边为例, 我们想得到这个效果, 在实际中需要思考这些边缘是什么, 在 NPR 中如何找到这些边缘并且加粗从而产生一个轮廓描边的效果, 不只是轮廓描边, 在 NPR 中做任何一种效果都应该这么去分析, 分析的好坏决定了结果.

### **outline rendering(轮廓渲染):**

首先我们要说一下, 平常我们说的边缘指的是 contours: 整个人物轮廓外围的一圈.

Outline 的概念范围很大, contours 是 outline 的子集.

![[83ddb892dde3af786f20be5b99bcaffe_MD5.jpg]]

如图, 将一个盒子细分为各种类型的 "边缘":

*   1Boundary/border edge-> 物体外边界上
*   2.Crease-> 折痕, 通常是在两个表面之间的
*   3.material-> 材质边界
*   4.Sihouette edge-> 必须是在物体外边界上且由多个面共享的.

到此我们知道了边界的各种类型, 接下来我们进行描边操作:

描边有两种做法:

*   shading
*   后期处理

**基于法线着色:**

大体意思是在 Pixel Shader 中对观察方向向量和着色表面法线向量点乘, 如果得到的值接近于 0, 说明着色区域是 contour edges.

![[6de1473da21bec767e7a72089ed3556d_MD5.jpg]]

这里我们做的是 Sihouette edge

正常情况下我们认为整个物件的不同物件是各自封闭的

以图为例, 我们如何去判断哪些像素点在 Sihouette edge 上让我们去进行描边这个操作呢?

首先我们要先找到 Sihouette edge, 我们看向物体 grazing angle 的地方就是 Sihouette edge 所在的地方.

因此在渲染时我们只需要做一个判断, 判断观察方向与 Shading point 的法线的夹角是否接近 90 度, 我们可以设定一个范围来认为是否在 Sihouette edge 上

比如超过 89 度小于 90 度, 我们就认为这个 shading point 在 Sihouette edge 上, 我们需要把这一点的颜色变为黑色从而达到描边效果.

我们可以更改设定的范围从而改变容忍度, 比如超过 60 度的点都被认为在 Sihouette edge 上, 那么容忍度就提高了, 可想而知将会得到更多的黑色部分, 也就是得到的效果变得更粗.

但是这样做有一个问题, 不同的位置描述出来的边的粗细可能不一样, 因为我们通过判断角度来进行描边操作的, 无法固定粗细, 因此法线变化平缓的地方就必须粗, 法线变化尖锐的地方就会比较细. 故而我们得到的效果可能不是很好

还有就是在一些类似正方体的模型上会失败, 因为正方体的模型边缘是 crease edges, 这种方式无法识别. 在一些法线分布不均匀的模型上, 也会产生奇怪的效果.

**基于几何**:

我们这么去想, 我们想得到的不就是一个轮廓分明点的描边效果嘛, 那么我们不去区分什么 Sihouette edge,Boundary/border edge 之类的

当我们去渲染一个物体 / 模型时候, 如果我们把模型加大一圈, 然后大模型放在原模型背后并且把新模型完全渲染成黑, 就像你背后站了一个就比宽一点高一点的替身使者, 但这个替身使者是全黑的, 这不就是描边了吗.

这是一个想法, 实际操作中有更聪明的实现方法.

![[287fbc9ecac2da282e0164994eafef0c_MD5.jpg]]

一个封闭模型分为看得见的面为正面, 看不见的面为背面

我们刚才的思路不是将整个模型放大一圈放在身后嘛, 那样太麻烦

封闭模型正面和背面所能看到的区域是完全一样的, 也就是看不到模型背面的任何信息, 因此我们将模型背面给扩大一圈, 也就是把背面的每个三角形扩大了一圈, 并渲染成黑色, 从而得到描边的效果.

![[992699e7ae8e21769b49f1e15ccece54_MD5.jpg]]

但是主流的方法是将我们将背面的每个顶点沿着顶点的法线方向向外偏移, 从而达到背面外拓

这种实现方式简单稳定, 不需要获取三角形的邻接信息, 不过只能显示 contour edge.

因为是需要将整个背部的面都渲染, 所以这种方式可能造成一些资源浪费. 对于半透明物体的渲染描边, 也会产生影响.

**基于图像的后期处理:**

我们先生成未描边的正常渲染结果, 再通过一些图像处理的方法从而得到这些边并且标上颜色.

![[32fae2cdf5fd5da094563ed5d9c2b493_MD5.jpg]]

我们以 Sobel detector 为例, 他的做法是做了图像的 filter(卷积).

我们知道卷积是在一个像素, 取周围一圈的值做一个加权平均, 因此我们可以自己设计 filter kernel 得到我们想要的边.

我们以 left sobel 为例:

![[f47e395da0140f809c6c52fc31aec4b8_MD5.jpg]]

我们可以看到这个 kernel 竖着几乎没有变换而横着变化非常强烈, 当一个像素周围是很平滑的, 可以认为值几乎不变, 因此在经过这个 kernel 后左右两边的值可以认为被抵消掉了.

![[5d0458e899a2dc4330f4f5aa95075a41_MD5.jpg]]

而如果在墙缝上我们可以知道, 左边是白色的墙, 右边是黑色的墙缝, 因此他们之间的差距在经过 kernel 之后会被拉的更大, 依次对整个图所有的进行处理, 从而得到一个提取边的图.

除了在最后的渲染结果上进行图像处理, 我们还可以在其他的图中进行处理:

![[ce502ccdbd79ee2aa6376777ccec1582_MD5.jpg]]

![[de231ad1407132023db2a0c66b80e727_MD5.jpg]]

任然以无主之地系列为例, 除了轮廓之外我么可以看到他们很多明显的色块, color blocks.

![[e43b28b3b41d6cc77cd89aedeae78769_MD5.jpg]]

我们如果想要得到最右边的这种效果, 我们该怎么得到呢?

首先得到正常的 Shading model 算出来的结果, 之后我们进行一个阈值化的操作 (thresholding),

![[92d3d0751862dac0ce04ac6cb674e8d2_MD5.jpg]]

以高光为例, 如果一些值值超过了 1.5, 则认为全是 1.5,

没超过但大于 0 的, 我们认为全都是 0.8,

而那些本来就是 0 的依旧是 0.

![[4b7614690945aa701bf1fc1a51de9c99_MD5.jpg]]

阈值化操作可以设定多个值, 如图, 小于 0.5 的是一个颜色, 大于等于 0.5 的是一个颜色, 大于等于 0.85 的又是一个颜色, 从而拥有更多的色块.

![[f431bf1ce80e0660b4ff31d03918644b_MD5.jpg]]

我们可以根据自己需要去将不同风格的结果组合在一起, 比如 diffuse 和 specular 都进行阈值化处理, 或者只处理 spcular 不处理 diffuse 等组合.

**Stroke surface stylization**

但是有时候我们并不想得到色块的感觉, 而是想得到素描一样的效果.

![[6c6486da1288e75aecd39b44ab2ecd79_MD5.jpg]]

我们知道在素描上, 往往越暗的地方需要更多的涂抹, 我们把它理解成小格子, 越暗的地方格子越多也就是密度越大, 因此我们把格子密度与明暗度联系在一起

TAMs 方法是一种实现类似手绘素描风格渲染的方法

主要分为两步

*   第一步是关于不同明暗设计不同的纹理
*   第二步是对于不同明暗的纹理设计其密度不变的 mipmap，利用密度不变来保证距离远近不改变纹理的明暗, 因为如果物体开始远离 camera, 由于纹理是贴在物体上的, 由于距离越远导致图变小了, 也就是密度变小了, 为了让距离不影响到贴图, 所以使用 mipmap.

如下图所示：

![[18f9e2ae6361b91bd5b8b1dd64188b88_MD5.jpg]]

![[9b820306bb24836c3896e5e3cc65796c_MD5.jpg]]

总结:

NPR 是一个 art driven 问题

因此我们要做出什么样的效果是 artist 们决定的, 我们要思考和实现的是如何做出这种效果: 比如边界

因此在这里沟通是最重要的, 需要及时与美工他们沟通.

NPR 做的效果好与坏, 其实根本上取决于 photorealistic 模型, 而不是后期的各种处理。

