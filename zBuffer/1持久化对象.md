
---
title: 1æŒä¹…åŒ–å¯¹è±¡
aliases: []
tags: []
create_time: 2023-06-15 21:26
uid: 202306152126
banner: "![[1686835479404.png]]"
---

åˆ›å»ºä¿å­˜å’ŒåŠ è½½ï¼š
- æ ¹æ®æŒ‰é”®äº§ç”Ÿéšæœºç«‹æ–¹ä½“ã€‚
- ä½¿ç”¨æ³›å‹ç±»å‹å’Œè™šæ–¹æ³•ã€‚
- å°†æ•°æ®å†™å…¥æ–‡ä»¶å¹¶è¯»å›ã€‚
- ä¿å­˜æ¸¸æˆçŠ¶æ€ï¼Œä»¥ä¾¿ç¨ååŠ è½½ã€‚

## æŒ‰éœ€åˆ›å»ºå¯¹è±¡

### æ¸¸æˆé€»è¾‘

å› ä¸ºæˆ‘ä»¬çš„æ¸¸æˆéå¸¸ç®€å•ï¼Œæ‰€ä»¥æˆ‘ä»¬å°†ä½¿ç”¨ä¸€ä¸ª `Game` ç»„ä»¶è„šæœ¬æ¥æ§åˆ¶å®ƒã€‚å®ƒä¼šäº§ç”Ÿç«‹æ–¹ä½“ï¼Œä¸ºæ­¤æˆ‘ä»¬å°†ä½¿ç”¨é¢„åˆ¶ä»¶ã€‚å› æ­¤ï¼Œå®ƒåº”è¯¥åŒ…å«ä¸€ä¸ªå…¬å…±å­—æ®µæ¥è¿æ¥é¢„åˆ¶å®ä¾‹ã€‚

```
using UnityEngine;

public class Game : MonoBehaviour {

	public Transform prefab;
}
```

å°†ä¸€ä¸ªæ¸¸æˆå¯¹è±¡æ·»åŠ åˆ°åœºæ™¯ä¸­ï¼Œå¹¶å°†æ­¤ç»„ä»¶é™„åŠ åˆ°åœºæ™¯ä¸­ã€‚ç„¶ååˆ›å»ºä¸€ä¸ªé»˜è®¤ç«‹æ–¹ä½“ï¼Œå°†å…¶å˜æˆé¢„åˆ¶ä½“ï¼Œå¹¶ä¸ºæ¸¸æˆå¯¹è±¡æä¾›ä¸€ä¸ªå¼•ç”¨ã€‚

![](<images/1686835479985.png>)

![](<images/1686835480539.png>)


```
void Update () {
		if (Input.GetKeyDown(createKey)) {
			Instantiate(prefab);
		}
	}
```

###  éšæœºåŒ–ç«‹æ–¹ä½“

è®©æˆ‘ä»¬éšæœºåŒ–æˆ‘ä»¬åˆ›å»ºçš„æ¯ä¸ªç«‹æ–¹ä½“çš„ä½ç½®ã€‚

ä½¿ç”¨é™æ€ [Random](http://docs.unity3d.com/Documentation/ScriptReference/Random.html).insideUnitSphereå±æ€§è·å–ä¸€ä¸ªéšæœºç‚¹ï¼Œå°†å…¶æ”¾å¤§åˆ°äº”ä¸ªå•ä½çš„åŠå¾„ï¼Œå¹¶å°†å…¶ç”¨ä½œæœ€ç»ˆä½ç½®ã€‚å› ä¸ºè¿™ä¸ä»…ä»…æ˜¯ä¸€ä¸ªå¾®ä¸è¶³é“çš„å®ä¾‹åŒ–ï¼Œæ‰€ä»¥å°†ä»£ç æ”¾åœ¨ä¸€ä¸ªå•ç‹¬çš„ `CreateObject` æ–¹æ³•ä¸­ï¼Œå¹¶åœ¨æŒ‰é”®æ—¶è°ƒç”¨å®ƒã€‚

```
void Update () {
		if (Input.GetKeyDown(createKey)) {

			CreateObject();
		}
	}

	void CreateObject () {
		Transform t = Instantiate(prefab);
		t.localPosition = Random.insideUnitSphere * 5f;
	}
```

![](<images/1686835481678.png>)

Randomly placed cubes. éšæœºæ”¾ç½®çš„ç«‹æ–¹ä½“ã€‚

è®©æˆ‘ä»¬ç»™æ¯ä¸ªç«‹æ–¹ä½“ä¸€ä¸ªéšæœºæ—‹è½¬ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨é™æ€ [Random](http://docs.unity3d.com/Documentation/ScriptReference/Random.html).rotation å±æ€§ã€‚

```
void CreateObject () {
		Transform t = Instantiate(prefab);
		t.localPosition = Random.insideUnitSphere * 5f;
		t.localRotation = Random.rotation;
	}
```

![](<images/1686835482240.png>)

Randomized rotations. éšæœºæ—‹è½¬ã€‚

æœ€åï¼Œæˆ‘ä»¬è¿˜å¯ä»¥æ”¹å˜ç«‹æ–¹ä½“çš„å¤§å°ã€‚æˆ‘ä»¬å°†ä½¿ç”¨å‡åŒ€ç¼©æ”¾çš„ç«‹æ–¹ä½“ï¼Œæ‰€ä»¥å®ƒä»¬æ€»æ˜¯å®Œç¾çš„ç«‹æ–¹ä½“ï¼Œåªæ˜¯å¤§å°ä¸åŒã€‚é™æ€ [Random](http://docs.unity3d.com/Documentation/ScriptReference/Random.html). [Range](http://docs.unity3d.com/Documentation/ScriptReference/RangeAttribute.html) æ–¹æ³•å¯ç”¨äºè·å–æŸä¸ªèŒƒå›´å†…çš„éšæœº float å€¼ ã€‚è®©æˆ‘ä»¬ä»0.1å·çš„å°ç«‹æ–¹ä½“åˆ°1å·çš„å¸¸è§„ç«‹æ–¹ä½“ã€‚è¦å°†è¯¥å€¼ç”¨äºåˆ»åº¦çš„æ‰€æœ‰ä¸‰ä¸ªç»´åº¦ï¼Œåªéœ€å°† [Vector3](http://docs.unity3d.com/Documentation/ScriptReference/Vector3.html).one ä¸ä¹‹ç›¸ä¹˜ï¼Œç„¶åå°†ç»“æœæŒ‡å®šç»™å±€éƒ¨åˆ»åº¦ã€‚

```
void CreateObject () {
		Transform t = Instantiate(prefab);
		t.localPosition = Random.insideUnitSphere * 5f;
		t.localRotation = Random.rotation;
		t.localScale = Vector3.one * Random.Range(0.1f, 1f);
	}
```

![](<images/1686835482807.png>)


### å¼€å§‹æ–°æ¸¸æˆ

å¦‚æœæˆ‘ä»¬æƒ³å¼€å§‹ä¸€ä¸ªæ–°çš„æ¸¸æˆï¼Œæˆ‘ä»¬å¿…é¡»é€€å‡ºæ¸¸æˆæ¨¡å¼ï¼Œç„¶åå†æ¬¡è¿›å…¥ã€‚ä½†è¿™åªæœ‰åœ¨Unity Editorä¸­æ‰æœ‰å¯èƒ½ã€‚ç©å®¶éœ€è¦é€€å‡ºæˆ‘ä»¬çš„åº”ç”¨ç¨‹åºå¹¶é‡æ–°å¯åŠ¨å®ƒæ‰èƒ½ç©æ–°æ¸¸æˆã€‚**å¦‚æœæˆ‘ä»¬èƒ½åœ¨ä¿æŒæ¸¸æˆæ¨¡å¼çš„åŒæ—¶å¼€å§‹ä¸€ä¸ªæ–°çš„æ¸¸æˆï¼Œé‚£å°±æ›´å¥½äº†ã€‚**
å¦‚æœæŒ‰ä¸‹äº†ä¸€ä¸ªé”®ï¼Œåˆ™è°ƒç”¨æ–°çš„ `BeginNewGame` æ–¹æ³•ã€‚æˆ‘ä»¬ä¸€æ¬¡åªèƒ½å¤„ç†ä¸€ä¸ªé”®ï¼Œæ‰€ä»¥å¦‚æœæ²¡æœ‰æŒ‰ C é”®ï¼Œåªæ£€æŸ¥ N é”®ã€‚

```
void Update () {
		if (Input.GetKeyDown(createKey)) {
			CreateObject();
		}
		else if (Input.GetKey(newGameKey)) {
			BeginNewGame();
		}
	}

	void BeginNewGame () {}
```

### è·Ÿè¸ªå¯¹è±¡

æˆ‘ä»¬çš„æ¸¸æˆå¯ä»¥ç”Ÿæˆä»»æ„æ•°é‡çš„éšæœºç«‹æ–¹ä½“ï¼Œè¿™äº›ç«‹æ–¹ä½“éƒ½ä¼šæ·»åŠ åˆ°åœºæ™¯ä¸­ã€‚ä½† `Game` å¯¹å®ƒäº§ç”Ÿçš„ä¸œè¥¿æ²¡æœ‰è®°å¿†ã€‚ä¸ºäº†æ‘§æ¯ç«‹æ–¹ä½“ï¼Œæˆ‘ä»¬é¦–å…ˆéœ€è¦æ‰¾åˆ°å®ƒä»¬ã€‚ä¸ºäº†å®ç°è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬å°†è®© `Game` è·Ÿè¸ªå®ƒå®ä¾‹åŒ–çš„å¯¹è±¡çš„å¼•ç”¨åˆ—è¡¨ã€‚

```
List<Transform> objects;
```


```
void Awake () {
		objects = new List<Transform>();
	}
```

æ¥ä¸‹æ¥ï¼Œé€šè¿‡çš„ `Add` æ–¹æ³•ï¼Œæ¯æ¬¡å®ä¾‹åŒ–ä¸€ä¸ªæ–°çš„åˆ—è¡¨æ—¶ï¼Œéƒ½ä¼šå‘åˆ—è¡¨æ·»åŠ  Transformå¼•ç”¨ã€‚

```
void CreateObject () {
		Transform t = Instantiate(prefab);
		t.localPosition = Random.insideUnitSphere * 5f;
		t.localRotation = Random.rotation;
		t.localScale = Vector3.one * Random.Range(0.1f, 1f);
		objects.Add(t);
	}
```

### æ¸…é™¤ List

ç°åœ¨æˆ‘ä»¬å¯ä»¥å¾ªç¯æµè§ˆ `BeginNewGame` ä¸­çš„åˆ—è¡¨ï¼Œå¹¶é”€æ¯æ‰€æœ‰å®ä¾‹åŒ–çš„æ¸¸æˆå¯¹è±¡ã€‚è¿™ä¸æ•°ç»„çš„å·¥ä½œåŸç†ç›¸åŒï¼Œåªæ˜¯åˆ—è¡¨çš„é•¿åº¦æ˜¯é€šè¿‡å…¶ `Count` å±æ€§æ‰¾åˆ°çš„ã€‚

```
void BeginNewGame () {
		for (int i = 0; i < objects.Count; i++) {
			Destroy(objects[i].gameObject);
		}
	}
```

è¿™ç»™æˆ‘ä»¬ç•™ä¸‹äº†ä¸€ä¸ªè¢«ç ´åå¯¹è±¡çš„å¼•ç”¨åˆ—è¡¨ã€‚æˆ‘ä»¬ä¹Ÿå¿…é¡»é€šè¿‡è°ƒç”¨ `Clear` æ–¹æ³•æ¸…ç©ºåˆ—è¡¨æ¥æ¶ˆé™¤è¿™äº›é—®é¢˜ã€‚

```
void BeginNewGame () {
		for (int i = 0; i < objects.Count; i++) {
			Destroy(objects[i].gameObject);
		}
		objects.Clear();
	}
```

## ä¿å­˜å’ŒåŠ è½½

çœŸæ­£çš„ä¿å­˜ç³»ç»Ÿå³ä½¿åœ¨æ¸¸æˆç»ˆæ­¢ä¹‹åä¹Ÿèƒ½å¤Ÿè®°ä½æ¸¸æˆçŠ¶æ€ã€‚è¿™éœ€è¦åœ¨æ¸¸æˆä¹‹å¤–çš„æŸä¸ªåœ°æ–¹ä¿æŒæ¸¸æˆçŠ¶æ€ã€‚æœ€ç®€å•çš„æ–¹æ³•æ˜¯å°†æ•°æ®å­˜å‚¨åœ¨æ–‡ä»¶ä¸­ã€‚

###  ä¿å­˜è·¯å¾„


æ¸¸æˆæ–‡ä»¶åº”è¯¥å­˜å‚¨åœ¨å“ªé‡Œå–å†³äºæ–‡ä»¶ç³»ç»Ÿã€‚Unityä¸ºæˆ‘ä»¬è§£å†³äº†è¿™äº›å·®å¼‚ï¼Œä½¿æˆ‘ä»¬å¯ä»¥é€šè¿‡ [Application](http://docs.unity3d.com/Documentation/ScriptReference/Application.html).persistentDataPath å±æ€§ä½¿ç”¨çš„æ–‡ä»¶å¤¹è·¯å¾„å¯ç”¨ã€‚æˆ‘ä»¬å¯ä»¥ä»è¿™ä¸ªå±æ€§ä¸­è·å–æ–‡æœ¬å­—ç¬¦ä¸²ï¼Œå¹¶å°†å…¶å­˜å‚¨åœ¨#2ä¸­çš„ `savePath` å­—æ®µä¸­ï¼Œå› æ­¤æˆ‘ä»¬åªéœ€è¦æ£€ç´¢ä¸€æ¬¡ã€‚

```
string savePath;

	void Awake () {
		objects = new List<Transform>();
		savePath = Application.persistentDataPath;
	}
```

### æ‰“å¼€è¦å†™å…¥çš„æ–‡ä»¶



ä¸ºäº†èƒ½å¤Ÿå°†æ•°æ®å†™å…¥ä¿å­˜æ–‡ä»¶ï¼Œæˆ‘ä»¬é¦–å…ˆå¿…é¡»æ‰“å¼€å®ƒã€‚è¿™æ˜¯é€šè¿‡ [File](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=File).Openæ–¹æ³•å®Œæˆçš„ï¼Œå¹¶ä¸ºå…¶æä¾›ä¸€ä¸ªè·¯å¾„å‚æ•°ã€‚å®ƒè¿˜éœ€è¦çŸ¥é“æˆ‘ä»¬æ‰“å¼€æ–‡ä»¶çš„åŸå› ã€‚æˆ‘ä»¬å¸Œæœ›å°†æ•°æ®å†™å…¥å…¶ä¸­ï¼Œå¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ï¼Œåˆ™åˆ›å»ºè¯¥æ–‡ä»¶ï¼Œæˆ–è€…æ›¿æ¢å·²å­˜åœ¨çš„æ–‡ä»¶ã€‚æˆ‘ä»¬é€šè¿‡æä¾› [FileMode](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=FileMode).Createä½œä¸ºç¬¬äºŒä¸ªå‚æ•°æ¥æŒ‡å®šè¿™ä¸€ç‚¹ã€‚åœ¨æ–°çš„æ–¹æ³•ä¸­æ‰§è¡Œæ­¤æ“ä½œã€‚

```
void Save () {
		File.Open(savePath, FileMode.Create);
	}
```

`[File](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=File).Open` returns a file stream, which isn't useful on its own. We need a data stream that we could write data into. This data has to be of a certain format. We'll use the most compact uncompressed format available, which is raw binary data. The `System.IO` namespace has the `[BinaryWriter](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=BinaryWriter)` class to make this possible. Create a new instance of this class, using its constructor method, providing the file stream as an argument. We don't need to keep a reference to the file stream, so we can directly use the `[File](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=File).Open` invocation as the argument. We do need to keep a reference to the writer, so assign it to a variable.  
[File](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=File).Open è¿”å›ä¸€ä¸ªæ–‡ä»¶æµï¼Œè¿™æœ¬èº«æ²¡æœ‰ç”¨å¤„ã€‚æˆ‘ä»¬éœ€è¦ä¸€ä¸ªå¯ä»¥å†™å…¥æ•°æ®çš„æ•°æ®æµã€‚è¿™äº›æ•°æ®å¿…é¡»å…·æœ‰ç‰¹å®šçš„æ ¼å¼ã€‚æˆ‘ä»¬å°†ä½¿ç”¨æœ€ç´§å‡‘çš„æœªå‹ç¼©æ ¼å¼ï¼Œå³åŸå§‹äºŒè¿›åˆ¶æ•°æ®ã€‚ `System.IO` åç§°ç©ºé—´å…·æœ‰ [BinaryWriter](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=BinaryWriter) ç±»ï¼Œå¯ä»¥å®ç°è¿™ä¸€ç‚¹ã€‚ä½¿ç”¨è¯¥ç±»çš„æ„é€ å‡½æ•°æ–¹æ³•åˆ›å»ºä¸€ä¸ªæ–°å®ä¾‹ï¼Œå¹¶æä¾›æ–‡ä»¶æµä½œä¸ºå‚æ•°ã€‚æˆ‘ä»¬ä¸éœ€è¦ä¿ç•™å¯¹æ–‡ä»¶æµçš„å¼•ç”¨ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç›´æ¥ä½¿ç”¨ [File](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=File).Open è°ƒç”¨ä½œä¸ºå‚æ•°ã€‚æˆ‘ä»¬ç¡®å®éœ€è¦ä¿ç•™å¯¹ç¼–å†™å™¨çš„å¼•ç”¨ï¼Œå› æ­¤å°†å…¶åˆ†é…ç»™ä¸€ä¸ªå˜é‡ã€‚

```
void Save () {
		BinaryWriter writer =
			new BinaryWriter(File.Open(savePath, FileMode.Create));
	}
```

We now have a binary writer variable named writer that references a new binary writer. That's using the word"writer"three times in one expression, which is a bit much. As we're explicitly creating a new `[BinaryWriter](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=BinaryWriter)`, it is redundant to explicitly declare the variable's type as well. Instead, we can use the `**var**` keyword. This implicitly declares the variable's type to match whatever is immediately assigned to it, which is something that the compiler can figure out in this case. â— ğŸ”„

```
void Save () {
		var writer = new BinaryWriter(File.Open(savePath, FileMode.Create));
	}
```

We now have a writer variable that references a new binary writer. Its type is obvious.  
æˆ‘ä»¬ç°åœ¨æœ‰äº†ä¸€ä¸ªå¼•ç”¨æ–°çš„äºŒè¿›åˆ¶ç¼–å†™å™¨çš„ç¼–å†™å™¨å˜é‡ã€‚å®ƒçš„ç±»å‹æ˜¯æ˜¾è€Œæ˜“è§çš„ã€‚

### Closing the File å…³é—­æ–‡ä»¶

If we open a file, we must make sure that we also close it. It's possible to do this via a `Close` method, but this isn't safe. If something goes wrong between opening and closing the file, an exception could be raised and execution of the method could be terminated before it got to closing the file. We have to carefully handle exceptions to ensure that the file is always closed. There is syntactic sugar to make this easy. Put the declaration and assignment of the `writer` variable inside round brackets, place the `**using**` keyword in front of it, and a code block after it. The variable is available inside that block, just like the iterator variable `i` of a standard `**for**` loop.  
å¦‚æœæˆ‘ä»¬æ‰“å¼€ä¸€ä¸ªæ–‡ä»¶ï¼Œæˆ‘ä»¬å¿…é¡»ç¡®ä¿åŒæ—¶å…³é—­å®ƒã€‚é€šè¿‡ `Close` æ–¹æ³•å¯ä»¥åšåˆ°è¿™ä¸€ç‚¹ï¼Œä½†è¿™æ˜¯ä¸å®‰å…¨çš„ã€‚å¦‚æœåœ¨æ‰“å¼€å’Œå…³é—­æ–‡ä»¶ä¹‹é—´å‡ºç°é—®é¢˜ï¼Œåˆ™å¯èƒ½ä¼šå¼•å‘å¼‚å¸¸ï¼Œå¹¶ä¸”æ–¹æ³•çš„æ‰§è¡Œå¯èƒ½ä¼šåœ¨å…³é—­æ–‡ä»¶ä¹‹å‰ç»ˆæ­¢ã€‚æˆ‘ä»¬å¿…é¡»å°å¿ƒå¤„ç†å¼‚å¸¸ï¼Œä»¥ç¡®ä¿æ–‡ä»¶å§‹ç»ˆå¤„äºå…³é—­çŠ¶æ€ã€‚æœ‰è¯­æ³•ä¸Šçš„ç³–ä½¿è¿™å˜å¾—å®¹æ˜“ã€‚å°† `writer` å˜é‡çš„å£°æ˜å’Œèµ‹å€¼æ”¾åœ¨åœ†æ‹¬å·å†…ï¼Œå°† `**using**` å…³é”®å­—æ”¾åœ¨å®ƒå‰é¢ï¼Œç„¶åæ”¾ä¸€ä¸ªä»£ç å—ã€‚è¯¥å˜é‡åœ¨è¯¥å—å†…å¯ç”¨ï¼Œå°±åƒæ ‡å‡† `**for**` å¾ªç¯çš„è¿­ä»£å™¨å˜é‡ `i` ä¸€æ ·ã€‚

```
void Save () {
		using (
			var writer = new BinaryWriter(File.Open(savePath, FileMode.Create))
		) {}
	}
```

This will ensure that whatever `writer` references will be properly disposed of, after code execution exits the block, no matter how. This works for special disposable types, which the writer and stream are.  
è¿™å°†ç¡®ä¿åœ¨ä»£ç æ‰§è¡Œé€€å‡ºå—ä¹‹åï¼Œæ— è®ºå¦‚ä½•ï¼Œä»»ä½• `writer` å¼•ç”¨éƒ½å°†è¢«æ­£ç¡®å¤„ç†ã€‚è¿™é€‚ç”¨äºç‰¹æ®Šçš„ä¸€æ¬¡æ€§ç±»å‹ï¼Œå³ä½œå®¶å’Œæµã€‚

### Writing Data å†™å…¥æ•°æ®

We can write data to our file by invoking our writer's `Write` method. It is possible to write simple values, like a boolean, integer, and so on, one at a time. Let's begin by writing only how many objects we have instantiated.  
æˆ‘ä»¬å¯ä»¥é€šè¿‡è°ƒç”¨ç¼–å†™å™¨çš„ `Write` æ–¹æ³•å°†æ•°æ®å†™å…¥æ–‡ä»¶ã€‚å¯ä»¥ä¸€æ¬¡å†™ä¸€ä¸ªç®€å•çš„å€¼ï¼Œæ¯”å¦‚å¸ƒå°”å€¼ã€æ•´æ•°ç­‰ç­‰ã€‚è®©æˆ‘ä»¬ä»åªå†™æˆ‘ä»¬å®ä¾‹åŒ–äº†å¤šå°‘å¯¹è±¡å¼€å§‹ã€‚

```
void Save () {
		using (
			var writer = new BinaryWriter(File.Open(savePath, FileMode.Create))
		) {
			writer.Write(objects.Count);
		}
	}
```

To actually save this data, we have to invoke the `Save` method. We'll again control this via a key, in this case using S as the default.  
ä¸ºäº†å®é™…ä¿å­˜è¿™äº›æ•°æ®ï¼Œæˆ‘ä»¬å¿…é¡»è°ƒç”¨ `Save` æ–¹æ³•ã€‚æˆ‘ä»¬å°†å†æ¬¡é€šè¿‡ä¸€ä¸ªé”®æ¥æ§åˆ¶å®ƒï¼Œåœ¨æœ¬ä¾‹ä¸­ä½¿ç”¨Sä½œä¸ºé»˜è®¤å€¼ã€‚

```
public KeyCode createKey = KeyCode.C;
	public KeyCode saveKey = KeyCode.S;

	â€¦

	void Update () {
		if (Input.GetKeyDown(createKey)) {
			CreateObject();
		}
		else if (Input.GetKey(newGameKey)) {
			BeginNewGame();
		}
		else if (Input.GetKeyDown(saveKey)) {
			Save();
		}
	}
```

![](<images/1686835483903.png>)

Save key set to S.  
å°†å¯†é’¥é›†ä¿å­˜åˆ°Sã€‚

Enter play mode, create a few cubes, then save the game by pressing the key. This will have created a _saveFile_ file on your file system. If you're not sure where it is located, you can use `[Debug](http://docs.unity3d.com/Documentation/ScriptReference/Debug.html).Log` to write the file's path to the Unity console.  
è¿›å…¥æ¸¸æˆæ¨¡å¼ï¼Œåˆ›å»ºå‡ ä¸ªç«‹æ–¹ä½“ï¼Œç„¶åæŒ‰é”®ä¿å­˜æ¸¸æˆã€‚è¿™å°†åœ¨æ‚¨çš„æ–‡ä»¶ç³»ç»Ÿä¸Šåˆ›å»ºä¸€ä¸ªæ–‡ä»¶ã€‚å¦‚æœæ‚¨ä¸ç¡®å®šå®ƒçš„ä½ç½®ï¼Œå¯ä»¥ä½¿ç”¨ `[Debug](http://docs.unity3d.com/Documentation/ScriptReference/Debug.html).Log` å°†æ–‡ä»¶çš„è·¯å¾„å†™å…¥Unityæ§åˆ¶å°ã€‚

You'll find that the file contains four bytes of data. Opening the file in a text editor will show nothing useful, because the data is binary. It might show nothing at all, or might interpret the data as weird characters. There are four bytes because that's the size of an integer.  
æ‚¨ä¼šå‘ç°è¯¥æ–‡ä»¶åŒ…å«å››ä¸ªå­—èŠ‚çš„æ•°æ®ã€‚åœ¨æ–‡æœ¬ç¼–è¾‘å™¨ä¸­æ‰“å¼€æ–‡ä»¶å°†ä¸ä¼šæ˜¾ç¤ºä»»ä½•æœ‰ç”¨çš„å†…å®¹ï¼Œå› ä¸ºæ•°æ®æ˜¯äºŒè¿›åˆ¶çš„ã€‚å®ƒå¯èƒ½ä»€ä¹ˆéƒ½ä¸æ˜¾ç¤ºï¼Œæˆ–è€…å¯èƒ½å°†æ•°æ®è§£é‡Šä¸ºå¥‡æ€ªçš„å­—ç¬¦ã€‚æœ‰å››ä¸ªå­—èŠ‚ï¼Œå› ä¸ºè¿™æ˜¯ä¸€ä¸ªæ•´æ•°çš„å¤§å°ã€‚

Besides writing how many cubes we have, we must also store the transformation data of each cube. We do this by looping through the objects and writing their data, one number at a time. For now, we'll limit ourselves to just their positions. So write the X, Y, and Z components of each cube's position, in that order.  
é™¤äº†å†™æˆ‘ä»¬æœ‰å¤šå°‘ä¸ªCubeï¼Œæˆ‘ä»¬è¿˜å¿…é¡»å­˜å‚¨æ¯ä¸ªCubeçš„è½¬æ¢æ•°æ®ã€‚æˆ‘ä»¬é€šè¿‡å¾ªç¯éå†å¯¹è±¡å¹¶ä¸€æ¬¡å†™å…¥ä¸€ä¸ªæ•°å­—æ¥å®ç°è¿™ä¸€ç‚¹ã€‚ç›®å‰ï¼Œæˆ‘ä»¬å°†ä»…é™äºä»–ä»¬çš„ç«‹åœºã€‚å› æ­¤ï¼ŒæŒ‰ç…§è¿™ä¸ªé¡ºåºå†™å‡ºæ¯ä¸ªç«‹æ–¹ä½“ä½ç½®çš„Xã€Yå’ŒZåˆ†é‡ã€‚

```
writer.Write(objects.Count);
			for (int i = 0; i < objects.Count; i++) {
				Transform t = objects[i];
				writer.Write(t.localPosition.x);
				writer.Write(t.localPosition.y);
				writer.Write(t.localPosition.z);
			}
```

![](<images/1686835484431.png>)

File containing seven positions, in four-byte blocks.  
åŒ…å«ä¸ƒä¸ªä½ç½®çš„æ–‡ä»¶ï¼Œä»¥å››å­—èŠ‚å—ä¸ºå•ä½ã€‚

### Loading Data æ­£åœ¨åŠ è½½æ•°æ®

To load the data that we just saved, we have to again open the file, this time with `[FileMode](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=FileMode).Open` as the second argument. Instead of a `[BinaryWriter](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=BinaryWriter)`, we have to use a `[BinaryReader](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=BinaryReader)`. Do this in a new `Load` method, once again with a `**using**` statement.  
è¦åŠ è½½æˆ‘ä»¬åˆšåˆšä¿å­˜çš„æ•°æ®ï¼Œæˆ‘ä»¬å¿…é¡»å†æ¬¡æ‰“å¼€æ–‡ä»¶ï¼Œè¿™æ¬¡ä½¿ç”¨ `[FileMode](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=FileMode).Open` ä½œä¸ºç¬¬äºŒä¸ªå‚æ•°ã€‚æˆ‘ä»¬å¿…é¡»ä½¿ç”¨#2è€Œä¸æ˜¯ `[BinaryWriter](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=BinaryWriter)` ã€‚åœ¨ä¸€ä¸ªæ–°çš„#3æ–¹æ³•ä¸­æ‰§è¡Œæ­¤æ“ä½œï¼Œå†æ¬¡ä½¿ç”¨#4è¯­å¥ã€‚

```
void Load () {
		using (
			var reader = new BinaryReader(File.Open(savePath, FileMode.Open))
		) {}
	}
```

The first thing we wrote to the file was the count property of our list, so that is also the first thing to read. We do this with the `ReadInt32` method of our reader. We have to be explicit what we read, because there is no parameter that makes this clear. The suffix 32 refers to the size of the integer, which is four bytes, thus 32 bits. There are also larger and smaller integer variants, but we don't use those.  
æˆ‘ä»¬å†™å…¥æ–‡ä»¶çš„ç¬¬ä¸€ä»¶äº‹æ˜¯åˆ—è¡¨çš„countå±æ€§ï¼Œæ‰€ä»¥è¿™ä¹Ÿæ˜¯è¦è¯»å–çš„ç¬¬ä¸€ä»¶äº‹æƒ…ã€‚æˆ‘ä»¬ä½¿ç”¨é˜…è¯»å™¨çš„ `ReadInt32` æ–¹æ³•æ¥å®Œæˆæ­¤æ“ä½œã€‚æˆ‘ä»¬å¿…é¡»æ˜ç¡®æˆ‘ä»¬è¯»åˆ°çš„å†…å®¹ï¼Œå› ä¸ºæ²¡æœ‰ä»»ä½•å‚æ•°å¯ä»¥æ˜ç¡®è¿™ä¸€ç‚¹ã€‚åç¼€32æŒ‡çš„æ˜¯æ•´æ•°çš„å¤§å°ï¼Œå®ƒæ˜¯å››ä¸ªå­—èŠ‚ï¼Œå› æ­¤æ˜¯32ä½ã€‚ä¹Ÿæœ‰è¾ƒå¤§å’Œè¾ƒå°çš„æ•´æ•°å˜ä½“ï¼Œä½†æˆ‘ä»¬ä¸ä½¿ç”¨å®ƒä»¬ã€‚

```
using (
			var reader = new BinaryReader(File.Open(savePath, FileMode.Open))
		) {
			int count = reader.ReadInt32();
		}
```

After reading the count, we know how many objects were saved. We have to read that many positions from the file. Do this with a loop, reading three floats per iteration, for the X, Y, and Z components of a position vector. A single-precision `**float**` is read with the `ReadSingle` method. A double-precision `**double**` would be read with the `ReadDouble` method.  
çœ‹å®Œè®¡æ•°åï¼Œæˆ‘ä»¬çŸ¥é“æœ‰å¤šå°‘ç‰©ä½“è¢«ä¿å­˜äº†ä¸‹æ¥ã€‚æˆ‘ä»¬ä¸å¾—ä¸ä»æ–‡ä»¶ä¸­è¯»åˆ°è¿™ä¹ˆå¤šçš„ç«‹åœºã€‚ä½¿ç”¨å¾ªç¯æ‰§è¡Œæ­¤æ“ä½œï¼Œæ¯æ¬¡è¿­ä»£è¯»å–ä½ç½®å‘é‡çš„Xã€Yå’ŒZåˆ†é‡çš„ä¸‰ä¸ªæµ®ç‚¹å€¼ã€‚ä½¿ç”¨ `ReadSingle` æ–¹æ³•è¯»å–å•ä¸ªç²¾åº¦ `**float**` ã€‚å°†ä½¿ç”¨#3æ–¹æ³•è¯»å–åŒå€ç²¾åº¦çš„#2ã€‚

```
int count = reader.ReadInt32();
			for (int i = 0; i < count; i++) {
				Vector3 p;
				p.x = reader.ReadSingle();
				p.y = reader.ReadSingle();
				p.z = reader.ReadSingle();
			}
```

Use the vector to set the position of a newly instantiated cube, and add it to the list.  
ä½¿ç”¨å‘é‡è®¾ç½®æ–°å®ä¾‹åŒ–çš„Cubeçš„ä½ç½®ï¼Œå¹¶å°†å…¶æ·»åŠ åˆ°åˆ—è¡¨ä¸­ã€‚

```
for (int i = 0; i < count; i++) {
				Vector3 p;
				p.x = reader.ReadSingle();
				p.y = reader.ReadSingle();
				p.z = reader.ReadSingle();
				Transform t = Instantiate(prefab);
				t.localPosition = p;
				objects.Add(t);
			}
```

At this point we can recreate all cubes that we saved, but they get added to the cubes that were already in the scene. To properly load a previously saved game, we have to reset the game before recreating it. We can do this by invoking `BeginNewGame` before loading the data.  
æ­¤æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥é‡æ–°åˆ›å»ºæˆ‘ä»¬ä¿å­˜çš„æ‰€æœ‰Cubeï¼Œä½†å®ƒä»¬ä¼šæ·»åŠ åˆ°åœºæ™¯ä¸­å·²ç»å­˜åœ¨çš„Cubeä¸­ã€‚ä¸ºäº†æ­£ç¡®åŠ è½½ä¹‹å‰ä¿å­˜çš„æ¸¸æˆï¼Œæˆ‘ä»¬å¿…é¡»åœ¨é‡æ–°åˆ›å»ºæ¸¸æˆä¹‹å‰é‡ç½®æ¸¸æˆã€‚æˆ‘ä»¬å¯ä»¥åœ¨åŠ è½½æ•°æ®ä¹‹å‰è°ƒç”¨ `BeginNewGame` æ¥å®Œæˆè¿™ä¸€æ“ä½œã€‚

```
void Load () {
		BeginNewGame();
		using (
			var reader = new BinaryReader(File.Open(savePath, FileMode.Open))
		) {
			â€¦
		}
	}
```

Have `**Game**` invoke `Load` when a key is pressed, using L as the default.  
è®© `**Game**` åœ¨æŒ‰é”®æ—¶è°ƒç”¨ `Load` ï¼Œä½¿ç”¨Lä½œä¸ºé»˜è®¤å€¼ã€‚

```
public KeyCode createKey = KeyCode.C;
	public KeyCode saveKey = KeyCode.S;
	public KeyCode loadKey = KeyCode.L;

	â€¦

	void Update () {
		â€¦
		else if (Input.GetKeyDown(saveKey)) {
			Save();
		}
		else if (Input.GetKeyDown(loadKey)) {
			Load();
		}
	}
```

![](<images/1686835484959.png>)

Load key set to L.  
åŠ è½½é”®è®¾ç½®ä¸ºLã€‚

Now the player can save their cubes and later load them, either during the same play session or another one. But because we're only storing the position data, the rotation and scale of cubes are not stored. As a result, loaded cubes all end up with the default rotation and scale of the prefab.  
ç°åœ¨ï¼Œç©å®¶å¯ä»¥ä¿å­˜ä»–ä»¬çš„Cubeï¼Œç„¶ååœ¨åŒä¸€æ¬¡æˆ–å¦ä¸€æ¬¡æ¸¸æˆä¸­åŠ è½½å®ƒä»¬ã€‚ä½†å› ä¸ºæˆ‘ä»¬åªå­˜å‚¨ä½ç½®æ•°æ®ï¼Œæ‰€ä»¥ä¸å­˜å‚¨ç«‹æ–¹ä½“çš„æ—‹è½¬å’Œç¼©æ”¾ã€‚ç»“æœï¼ŒåŠ è½½çš„Cubeéƒ½ä»¥é¢„åˆ¶ä»¶çš„é»˜è®¤æ—‹è½¬å’Œæ¯”ä¾‹ç»“æŸã€‚

## Abstracting Storage æŠ½è±¡å­˜å‚¨

Although we need to know the specifics of reading and writing binary data, that's rather low-level. Writing a single 3D vector requires three invocations of `Write`. When saving and loading our objects, it's more convenient if we could work at a slightly higher level, reading or writing an entire 3D vector with a single method invocation. Also, it would be nice if we could just use `ReadInt` and `ReadFloat`, instead of having to worry about all the different variants that we don't use. Finally, it shouldn't matter whether the data is stored in binary, plain text, base-64, or another encoding method. `**Game**` doesn't need to know such details.  
å°½ç®¡æˆ‘ä»¬éœ€è¦äº†è§£è¯»å–å’Œå†™å…¥äºŒè¿›åˆ¶æ•°æ®çš„ç»†èŠ‚ï¼Œä½†è¿™æ˜¯ç›¸å½“ä½çº§çš„ã€‚ç¼–å†™å•ä¸ªä¸‰ç»´çŸ¢é‡éœ€è¦è°ƒç”¨ä¸‰æ¬¡ `Write` ã€‚åœ¨ä¿å­˜å’ŒåŠ è½½å¯¹è±¡æ—¶ï¼Œå¦‚æœæˆ‘ä»¬å¯ä»¥åœ¨ç¨é«˜çš„çº§åˆ«ä¸Šå·¥ä½œï¼Œåªéœ€ä¸€ä¸ªæ–¹æ³•è°ƒç”¨å³å¯è¯»å–æˆ–å†™å…¥æ•´ä¸ª3Då‘é‡ï¼Œé‚£ä¹ˆä¼šæ›´æ–¹ä¾¿ã€‚æ­¤å¤–ï¼Œå¦‚æœæˆ‘ä»¬å¯ä»¥åªä½¿ç”¨ `ReadInt` å’Œ `ReadFloat` ï¼Œè€Œä¸å¿…æ‹…å¿ƒæˆ‘ä»¬æ²¡æœ‰ä½¿ç”¨çš„æ‰€æœ‰ä¸åŒå˜ä½“ï¼Œé‚£å°±å¤ªå¥½äº†ã€‚æœ€åï¼Œæ•°æ®æ˜¯ä»¥äºŒè¿›åˆ¶ã€çº¯æ–‡æœ¬ã€base-64è¿˜æ˜¯å…¶ä»–ç¼–ç æ–¹æ³•å­˜å‚¨éƒ½ä¸é‡è¦ `**Game**` ä¸éœ€è¦çŸ¥é“è¿™äº›ç»†èŠ‚ã€‚

### Game Data Writer and Reader  
æ¸¸æˆæ•°æ®ç¼–å†™å™¨å’Œé˜…è¯»å™¨

To hide the details of reading and writing data, we're going to create our own reader and writer classes. Let's begin with the writer, naming it `**GameDataWriter**`.  
ä¸ºäº†éšè—è¯»å–å’Œå†™å…¥æ•°æ®çš„ç»†èŠ‚ï¼Œæˆ‘ä»¬å°†åˆ›å»ºè‡ªå·±çš„è¯»å–å™¨å’Œç¼–å†™å™¨ç±»ã€‚è®©æˆ‘ä»¬ä»ç¼–å†™å™¨å¼€å§‹ï¼Œå°†å…¶å‘½åä¸º `**GameDataWriter**` ã€‚

`**GameDataWriter**` does not extend `[MonoBehaviour](http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.html)`, because we won't attach it to a game object. It will act as a wrapper for `[BinaryWriter](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=BinaryWriter)`, so give it a single writer field.  
`**GameDataWriter**` ä¸ä¼šæ‰©å±• `[MonoBehaviour](http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.html)` ï¼Œå› ä¸ºæˆ‘ä»¬ä¸ä¼šå°†å…¶é™„åŠ åˆ°æ¸¸æˆå¯¹è±¡ã€‚å®ƒå°†å……å½“#2çš„åŒ…è£…å™¨ï¼Œæ‰€ä»¥ç»™å®ƒä¸€ä¸ªå•ç‹¬çš„ç¼–å†™å™¨å­—æ®µã€‚

```
using System.IO;
using UnityEngine;

public class GameDataWriter {

	BinaryWriter writer;
}
```

A new object instance of our custom writer type can be created via `**new** **GameDataWriter**()`. But this only makes sense if we have a writer to wrap. So create a custom constructor method with a `[BinaryWriter](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=BinaryWriter)` parameter. This is a method with the type name of its class as its own name, which also acts as its return type. It replaces the implicit default constructor method.  
æˆ‘ä»¬çš„è‡ªå®šä¹‰ç¼–å†™å™¨ç±»å‹çš„æ–°å¯¹è±¡å®ä¾‹å¯ä»¥é€šè¿‡ `**new** **GameDataWriter**()` åˆ›å»ºã€‚ä½†è¿™åªæœ‰åœ¨æˆ‘ä»¬æœ‰ä¸€ä¸ªä½œå®¶çš„æƒ…å†µä¸‹æ‰æœ‰æ„ä¹‰ã€‚å› æ­¤ï¼Œåˆ›å»ºä¸€ä¸ªå¸¦æœ‰ `[BinaryWriter](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=BinaryWriter)` å‚æ•°çš„è‡ªå®šä¹‰æ„é€ å‡½æ•°æ–¹æ³•ã€‚è¿™æ˜¯ä¸€ä¸ªæ–¹æ³•ï¼Œå…¶ç±»çš„ç±»å‹åä½œä¸ºè‡ªå·±çš„åç§°ï¼Œä¹Ÿä½œä¸ºå…¶è¿”å›ç±»å‹ã€‚å®ƒæ›¿æ¢äº†éšå¼é»˜è®¤æ„é€ å‡½æ•°æ–¹æ³•ã€‚

```
public GameDataWriter (BinaryWriter writer) {
	}
```

Although invoking a constructor method results in a new object instance, such methods don't explicitly return anything. The object gets created before the constructor is invoked, which can then take care of any required initialization. In our case, that's simply assigning the writer parameter to the object's field. As I've used the same name for both, I have to use the `**this**` keyword to explicitly indicate that I'm referring to the object's field instead of the parameter.  
å°½ç®¡è°ƒç”¨æ„é€ å‡½æ•°æ–¹æ³•ä¼šäº§ç”Ÿä¸€ä¸ªæ–°çš„å¯¹è±¡å®ä¾‹ï¼Œä½†è¿™æ ·çš„æ–¹æ³•ä¸ä¼šæ˜¾å¼è¿”å›ä»»ä½•å†…å®¹ã€‚åœ¨è°ƒç”¨æ„é€ å‡½æ•°ä¹‹å‰åˆ›å»ºå¯¹è±¡ï¼Œç„¶åæ„é€ å‡½æ•°å¯ä»¥å¤„ç†ä»»ä½•æ‰€éœ€çš„åˆå§‹åŒ–ã€‚åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œè¿™åªæ˜¯å°†writerå‚æ•°åˆ†é…ç»™å¯¹è±¡çš„å­—æ®µã€‚ç”±äºæˆ‘å¯¹ä¸¤è€…ä½¿ç”¨äº†ç›¸åŒçš„åç§°ï¼Œæ‰€ä»¥æˆ‘å¿…é¡»ä½¿ç”¨ `**this**` å…³é”®å­—æ¥æ˜ç¡®è¡¨ç¤ºæˆ‘æŒ‡çš„æ˜¯å¯¹è±¡çš„å­—æ®µï¼Œè€Œä¸æ˜¯å‚æ•°ã€‚

```
public GameDataWriter (BinaryWriter writer) {
		this.writer = writer;
	}
```

The most basic functionality is to write a single `**float**` or `**int**` value. Add public `Write` methods for this, simply forwarding the invocation to the actual writer.  
æœ€åŸºæœ¬çš„åŠŸèƒ½æ˜¯å†™å…¥ä¸€ä¸ª `**float**` æˆ– `**int**` å€¼ã€‚ä¸ºæ­¤æ·»åŠ å…¬å…±#2æ–¹æ³•ï¼Œåªéœ€å°†è°ƒç”¨è½¬å‘ç»™å®é™…çš„ç¼–å†™å™¨å³å¯ã€‚

```
public void Write (float value) {
		writer.Write(value);
	}

	public void Write (int value) {
		writer.Write(value);
	}
```

Besides that, also add methods to write a `[Quaternion](http://docs.unity3d.com/Documentation/ScriptReference/Quaternion.html)`â€”for rotationsâ€”and a `[Vector3](http://docs.unity3d.com/Documentation/ScriptReference/Vector3.html)`. These methods have to write all the components of their parameter. In the case of a quaternion, that's four components.  
é™¤æ­¤ä¹‹å¤–ï¼Œè¿˜æ·»åŠ äº†ä¸€äº›æ–¹æ³•æ¥ç¼–å†™ `[Quaternion](http://docs.unity3d.com/Documentation/ScriptReference/Quaternion.html)` -ç”¨äºæ—‹è½¬å’Œ `[Vector3](http://docs.unity3d.com/Documentation/ScriptReference/Vector3.html)` ã€‚è¿™äº›æ–¹æ³•å¿…é¡»å†™å…¥å…¶å‚æ•°çš„æ‰€æœ‰ç»„ä»¶ã€‚åœ¨å››å…ƒæ•°çš„æƒ…å†µä¸‹ï¼Œè¿™æ˜¯å››ä¸ªåˆ†é‡ã€‚

```
public void Write (Quaternion value) {
		writer.Write(value.x);
		writer.Write(value.y);
		writer.Write(value.z);
		writer.Write(value.w);
	}
	
	public void Write (Vector3 value) {
		writer.Write(value.x);
		writer.Write(value.y);
		writer.Write(value.z);
	}
```

Next, create a new `**GameDataReader**` class, using the same approach as for the writer. In this case, we wrap a `[BinaryReader](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=BinaryReader)`.  
æ¥ä¸‹æ¥ï¼Œä½¿ç”¨ä¸ç¼–å†™å™¨ç›¸åŒçš„æ–¹æ³•åˆ›å»ºä¸€ä¸ªæ–°çš„ `**GameDataReader**` ç±»ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬åŒ…è£…ä¸€ä¸ª `[BinaryReader](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=BinaryReader)` ã€‚

```
using System.IO;
using UnityEngine;

public class GameDataReader {

	BinaryReader reader;

	public GameDataReader (BinaryReader reader) {
		this.reader = reader;
	}
}
```

Give it methods that are simply named `ReadFloat` and `ReadInt`, that forward the invocations to `ReadSingle` and `ReadInt32`.  
ç»™å®ƒç®€å•å‘½åä¸º `ReadFloat` å’Œ `ReadInt` çš„æ–¹æ³•ï¼Œå°†è°ƒç”¨è½¬å‘åˆ° `ReadSingle` å’Œ `ReadInt32` ã€‚

```
public float ReadFloat () {
		return reader.ReadSingle();
	}

	public int ReadInt () {
		return reader.ReadInt32();
	}
```

Also create `ReadQuaternion` and `ReadVector3` methods. Read their components in the same order that we write them.  
åŒæ—¶åˆ›å»º `ReadQuaternion` å’Œ `ReadVector3` æ–¹æ³•ã€‚æŒ‰ç…§æˆ‘ä»¬ç¼–å†™å®ƒä»¬çš„ç›¸åŒé¡ºåºè¯»å–å®ƒä»¬çš„ç»„ä»¶ã€‚

```
public Quaternion ReadQuaternion () {
		Quaternion value;
		value.x = reader.ReadSingle();
		value.y = reader.ReadSingle();
		value.z = reader.ReadSingle();
		value.w = reader.ReadSingle();
		return value;
	}

	public Vector3 ReadVector3 () {
		Vector3 value;
		value.x = reader.ReadSingle();
		value.y = reader.ReadSingle();
		value.z = reader.ReadSingle();
		return value;
	}
```

### Persistable Objects æŒä¹…æ€§å¯¹è±¡

Now it's a lot simpler to write the transform data of cubes in `**Game**`. But we can go one step further. What if `**Game**` could simply invoke `writer.Write(objects[i])`? That would be very convenient, but would require `**GameDataWriter**` to know the details of writing a game object. But it's better to keep the writer simple, limited to primitive values and simple structs.  
ç°åœ¨ï¼Œåœ¨ `**Game**` ä¸­ç¼–å†™Cubeçš„è½¬æ¢æ•°æ®è¦ç®€å•å¾—å¤šã€‚ä½†æˆ‘ä»¬å¯ä»¥æ›´è¿›ä¸€æ­¥ã€‚å¦‚æœ `**Game**` å¯ä»¥ç®€å•åœ°è°ƒç”¨ `writer.Write(objects[i])` å‘¢ï¼Ÿè¿™å°†æ˜¯éå¸¸æ–¹ä¾¿çš„ï¼Œä½†éœ€è¦#3çŸ¥é“ç¼–å†™æ¸¸æˆå¯¹è±¡çš„ç»†èŠ‚ã€‚ä½†æœ€å¥½ä¿æŒä½œè€…çš„ç®€å•ï¼Œä»…é™äºåŸå§‹å€¼å’Œç®€å•çš„ç»“æ„ã€‚

We can turn this reasoning around. `**Game**` doesn't need to know how to save a game object, that's the responsibility of the object itself. All the object needs is a writer to save itself. Then `**Game**` could use `objects[i].Save(writer)`.  
æˆ‘ä»¬å¯ä»¥æ‰­è½¬è¿™ç§æ¨ç† `**Game**` ä¸éœ€è¦çŸ¥é“å¦‚ä½•ä¿å­˜æ¸¸æˆå¯¹è±¡ï¼Œè¿™æ˜¯å¯¹è±¡æœ¬èº«çš„è´£ä»»ã€‚å¯¹è±¡æ‰€éœ€è¦çš„åªæ˜¯ä¸€ä¸ªå†™å…¥ç¨‹åºæ¥ä¿å­˜è‡ªå·±ã€‚é‚£ä¹ˆ#1å¯ä»¥ä½¿ç”¨#2ã€‚

Our cubes are simple objects, without any custom components attached. So the only thing that's to save is the transform component. Let's create a `**PersistableObject**` component script that knows how to save and load that data. It simply extends `[MonoBehaviour](http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.html)` and has a public `Save` method and `Load` method with a `**GameDataWriter**` or `**GameDataReader**` parameter respectively. Have it save the transform position, rotation, and scale, and load them in the same order.  
æˆ‘ä»¬çš„Cubeæ˜¯ç®€å•çš„å¯¹è±¡ï¼Œæ²¡æœ‰é™„åŠ ä»»ä½•è‡ªå®šä¹‰ç»„ä»¶ã€‚å› æ­¤ï¼Œå”¯ä¸€è¦ä¿å­˜çš„æ˜¯å˜æ¢ç»„ä»¶ã€‚è®©æˆ‘ä»¬åˆ›å»ºä¸€ä¸ª `**PersistableObject**` ç»„ä»¶è„šæœ¬ï¼Œå®ƒçŸ¥é“å¦‚ä½•ä¿å­˜å’ŒåŠ è½½æ•°æ®ã€‚å®ƒåªæ˜¯æ‰©å±•äº† `[MonoBehaviour](http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.html)` ï¼Œå¹¶æœ‰ä¸€ä¸ªå…¬å…±çš„ `Save` æ–¹æ³•å’Œ `Load` æ–¹æ³•ï¼Œåˆ†åˆ«å¸¦æœ‰ `**GameDataWriter**` æˆ– `**GameDataReader**` å‚æ•°ã€‚è®©å®ƒä¿å­˜å˜æ¢ä½ç½®ã€æ—‹è½¬å’Œç¼©æ”¾ï¼Œå¹¶æŒ‰ç›¸åŒé¡ºåºåŠ è½½å®ƒä»¬ã€‚

```
using UnityEngine;

public class PersistableObject : MonoBehaviour {

	public void Save (GameDataWriter writer) {
		writer.Write(transform.localPosition);
		writer.Write(transform.localRotation);
		writer.Write(transform.localScale);
	}

	public void Load (GameDataReader reader) {
		transform.localPosition = reader.ReadVector3();
		transform.localRotation = reader.ReadQuaternion();
		transform.localScale = reader.ReadVector3();
	}
}
```

The idea is that a game object that can be persisted only has one `**PersistableObject**` component attached to it. Having multiple such components makes no sense. We can enforce this by adding the `[DisallowMultipleComponent](http://docs.unity3d.com/Documentation/ScriptReference/DisallowMultipleComponent.html)` attribute to the class.  
è¿™ä¸ªæƒ³æ³•æ˜¯ï¼Œä¸€ä¸ªå¯ä»¥æŒä¹…åŒ–çš„æ¸¸æˆå¯¹è±¡åªæœ‰ä¸€ä¸ª `**PersistableObject**` ç»„ä»¶ã€‚æ‹¥æœ‰å¤šä¸ªè¿™æ ·çš„ç»„ä»¶æ˜¯æ²¡æœ‰æ„ä¹‰çš„ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡å°† `[DisallowMultipleComponent](http://docs.unity3d.com/Documentation/ScriptReference/DisallowMultipleComponent.html)` å±æ€§æ·»åŠ åˆ°ç±»ä¸­æ¥å¼ºåˆ¶å®ç°è¿™ä¸€ç‚¹ã€‚

```
[DisallowMultipleComponent]
public class PersistableObject : MonoBehaviour {

	â€¦
}
```

Add this component to our cube prefab.  
å°†æ­¤ç»„ä»¶æ·»åŠ åˆ°æˆ‘ä»¬çš„ç«‹æ–¹ä½“é¢„åˆ¶ä»¶ä¸­ã€‚

![](<images/1686835485537.png>)

Persistable prefab. æŒä¹…é¢„åˆ¶ã€‚

### Persistent Storage æŒä¹…æ€§å­˜å‚¨

Now that we have a persistent object type, let's also create a `**PersistentStorage**` class to save such an object. It contains the same saving and loading logic as `**Game**`, except that it only saves and loads a single `**PersistableObject**` instance, provided via a parameter to public `Save` and `Load` methods. Make it a `[MonoBehaviour](http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.html)`, so we can attach it to a game object and it can initialize its save path.  
æ—¢ç„¶æˆ‘ä»¬æœ‰äº†ä¸€ä¸ªæŒä¹…å¯¹è±¡ç±»å‹ï¼Œé‚£ä¹ˆè®©æˆ‘ä»¬åˆ›å»ºä¸€ä¸ª `**PersistentStorage**` ç±»æ¥ä¿å­˜è¿™æ ·çš„å¯¹è±¡ã€‚å®ƒåŒ…å«ä¸ `**Game**` ç›¸åŒçš„ä¿å­˜å’ŒåŠ è½½é€»è¾‘ï¼Œåªæ˜¯å®ƒåªä¿å­˜å’ŒåŠ è½½ä¸€ä¸ª `**PersistableObject**` å®ä¾‹ï¼Œè¯¥å®ä¾‹é€šè¿‡å‚æ•°æä¾›ç»™å…¬å…± `Save` å’Œ `Load` æ–¹æ³•ã€‚è®©å®ƒæˆä¸º `[MonoBehaviour](http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.html)` ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥å°†å®ƒé™„åŠ åˆ°æ¸¸æˆå¯¹è±¡ä¸Šï¼Œå®ƒå°±å¯ä»¥åˆå§‹åŒ–å…¶ä¿å­˜è·¯å¾„ã€‚

```
using System.IO;
using UnityEngine;

public class PersistentStorage : MonoBehaviour {

	string savePath;

	void Awake () {
		savePath = Path.Combine(Application.persistentDataPath, "saveFile");
	}

	public void Save (PersistableObject o) {
		using (
			var writer = new BinaryWriter(File.Open(savePath, FileMode.Create))
		) {
			o.Save(new GameDataWriter(writer));
		}
	}

	public void Load (PersistableObject o) {
		using (
			var reader = new BinaryReader(File.Open(savePath, FileMode.Open))
		) {
			o.Load(new GameDataReader(reader));
		}
	}
}
```

Add a new game object to the scene with this component attached. It represents the persistent storage of our game. Theoretically, we could have multiple such storage objects, used to store different things, or to provide access to different storage types. But in this tutorial we use just this single file storage object.  
å°†ä¸€ä¸ªæ–°çš„æ¸¸æˆå¯¹è±¡æ·»åŠ åˆ°é™„åŠ äº†è¯¥ç»„ä»¶çš„åœºæ™¯ä¸­ã€‚å®ƒä»£è¡¨äº†æˆ‘ä»¬æ¸¸æˆçš„æŒä¹…å­˜å‚¨ã€‚ç†è®ºä¸Šï¼Œæˆ‘ä»¬å¯ä»¥æœ‰å¤šä¸ªè¿™æ ·çš„å­˜å‚¨å¯¹è±¡ï¼Œç”¨äºå­˜å‚¨ä¸åŒçš„ä¸œè¥¿ï¼Œæˆ–è€…æä¾›å¯¹ä¸åŒå­˜å‚¨ç±»å‹çš„è®¿é—®ã€‚ä½†æ˜¯åœ¨æœ¬æ•™ç¨‹ä¸­ï¼Œæˆ‘ä»¬åªä½¿ç”¨äº†è¿™ä¸ªå•ç‹¬çš„æ–‡ä»¶å­˜å‚¨å¯¹è±¡ã€‚

![](<images/1686835486080.png>)

Storage object. å­˜å‚¨å¯¹è±¡ã€‚

### Persistable Game æŒä¹…æ€§æ¸¸æˆ

To make use of the new persistable object approach, we have to rewrite `**Game**`. Change the `prefab` and `objects` content type to `**PersistableObject**`. Adjust `CreateObject` so it can deal with this type change. Then remove all the code specific to reading from and writing to files.  
ä¸ºäº†ä½¿ç”¨æ–°çš„æŒä¹…åŒ–å¯¹è±¡æ–¹æ³•ï¼Œæˆ‘ä»¬å¿…é¡»é‡å†™ `**Game**` ã€‚å°† `prefab` å’Œ `objects` å†…å®¹ç±»å‹æ›´æ”¹ä¸º `**PersistableObject**` ã€‚è°ƒæ•´#4ï¼Œä½¿å…¶èƒ½å¤Ÿå¤„ç†æ­¤ç±»å‹çš„æ›´æ”¹ã€‚ç„¶ååˆ é™¤æ‰€æœ‰ç‰¹å®šäºè¯»å–å’Œå†™å…¥æ–‡ä»¶çš„ä»£ç ã€‚

```
using System.Collections.Generic;

using UnityEngine;

public class Game : MonoBehaviour {

	public PersistableObject prefab;

	â€¦

	List<PersistableObject> objects;



	void Awake () {
		objects = new List<PersistableObject>();

	}

	void Update () {
		â€¦
		else if (Input.GetKeyDown(saveKey)) {

		}
		else if (Input.GetKeyDown(loadKey)) {

		}
	}
	
	â€¦

	void CreateObject () {
		PersistableObject o = Instantiate(prefab);
		Transform t = o.transform;
		â€¦
		objects.Add(o);
	}








}
```

We'll have `**Game**` rely on a `**PersistentStorage**` instance to take care of the details of storing data. Add a public `storage` field of this type, so we can give `**Game**` a reference to our storage object. To again save and load the game state, we have `**Game**` itself extend `**PersistableObject**`. Then it can load and save itself, using the storage.  
æˆ‘ä»¬å°†è®© `**Game**` ä¾èµ– `**PersistentStorage**` å®ä¾‹æ¥å¤„ç†å­˜å‚¨æ•°æ®çš„ç»†èŠ‚ã€‚æ·»åŠ ä¸€ä¸ªè¿™ç§ç±»å‹çš„å…¬å…±#2å­—æ®µï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥ç»™#3ä¸€ä¸ªå¯¹å­˜å‚¨å¯¹è±¡çš„å¼•ç”¨ã€‚ä¸ºäº†å†æ¬¡ä¿å­˜å’ŒåŠ è½½æ¸¸æˆçŠ¶æ€ï¼Œæˆ‘ä»¬æœ‰#4æœ¬èº«æ‰©å±• `**PersistableObject**` ã€‚ç„¶åï¼Œå®ƒå¯ä»¥ä½¿ç”¨å­˜å‚¨æ¥åŠ è½½å’Œä¿å­˜è‡ªå·±ã€‚

```
public class Game : PersistableObject {

	â€¦

	public PersistentStorage storage;

	â€¦

	void Update () {
		if (Input.GetKeyDown(createKey)) {
			CreateObject();
		}
		else if (Input.GetKeyDown(saveKey)) {
			storage.Save(this);
		}
		else if (Input.GetKeyDown(loadKey)) {
			BeginNewGame();
			storage.Load(this);
		}
	}

	â€¦
}
```

Connect the storage via the inspector. Also reconnect the prefab, as its reference was lost due to the field's type change.  
é€šè¿‡æ£€æŸ¥å‘˜è¿æ¥å­˜å‚¨å™¨ã€‚åŒæ—¶é‡æ–°è¿æ¥é¢„åˆ¶ä»¶ï¼Œå› ä¸ºå­—æ®µçš„ç±»å‹æ›´æ”¹å¯¼è‡´å…¶å¼•ç”¨ä¸¢å¤±ã€‚

![](<images/1686835486646.png>)

Game connected to prefab and storage.  
æ¸¸æˆè¿æ¥åˆ°é¢„åˆ¶å’Œå­˜å‚¨ã€‚

### Overriding Methods è¦†ç›–æ–¹æ³•

When we save and load the game now, we end up writing and reading the transformation data of our main game object. This is useless. Instead, we have to save and load its list of objects.  
å½“æˆ‘ä»¬ç°åœ¨ä¿å­˜å’ŒåŠ è½½æ¸¸æˆæ—¶ï¼Œæˆ‘ä»¬æœ€ç»ˆä¼šå†™å…¥å’Œè¯»å–ä¸»æ¸¸æˆå¯¹è±¡çš„è½¬æ¢æ•°æ®ã€‚è¿™æ²¡ç”¨ã€‚ç›¸åï¼Œæˆ‘ä»¬å¿…é¡»ä¿å­˜å¹¶åŠ è½½å®ƒçš„å¯¹è±¡åˆ—è¡¨ã€‚

Instead of relying on the `Save` method defined in `**PersistableObject**`, we have to give `**Game**` its own public version of `Save` with a `**GameDataWriter**` parameter. In it, write the list as we did before, now using the convenient `Save` method of the objects.  
æˆ‘ä»¬ä¸ä¾èµ–äº `**PersistableObject**` ä¸­å®šä¹‰çš„ `Save` æ–¹æ³•ï¼Œè€Œæ˜¯å¿…é¡»ç»™ `**Game**` ä¸€ä¸ª `**GameDataWriter**` å‚æ•°æ¥æä¾›å…¶è‡ªå·±çš„#3çš„å…¬å…±ç‰ˆæœ¬ã€‚åœ¨å…¶ä¸­ï¼Œåƒä»¥å‰ä¸€æ ·ç¼–å†™åˆ—è¡¨ï¼Œç°åœ¨ä½¿ç”¨å¯¹è±¡çš„ä¾¿æ· `Save` æ–¹æ³•ã€‚

```
public void Save (GameDataWriter writer) {
		writer.Write(objects.Count);
		for (int i = 0; i < objects.Count; i++) {
			objects[i].Save(writer);
		}
	}
```

This is not yet enough to make it work. The compiler complains that `**Game**.Save` hides the inherited member `**PersistableObject**.Save`. While `**Game**` can work with its own `Save` version, `**PersistentStorage**` only knows about `**PersistableObject**.Save`. So it would invoke this method, not the one from `**Game**`. To make sure that the correct `Save` method gets invoked, we have to explicitly declare that we override the method that `**Game**` inherited from `**PersistableObject**`. That's done by adding the `**override**` keyword to the method declaration.  
è¿™è¿˜ä¸è¶³ä»¥ä½¿å…¶å‘æŒ¥ä½œç”¨ã€‚ç¼–è¯‘å™¨æŠ±æ€¨ `**Game**.Save` éšè—äº†ç»§æ‰¿çš„æˆå‘˜ `**PersistableObject**.Save` ã€‚è™½ç„¶#2å¯ä»¥ä½¿ç”¨è‡ªå·±çš„#3ç‰ˆæœ¬ï¼Œä½†#4åªçŸ¥é“ `**PersistableObject**.Save` ã€‚æ‰€ä»¥å®ƒä¼šè°ƒç”¨è¿™ä¸ªæ–¹æ³•ï¼Œè€Œä¸æ˜¯æ¥è‡ª `**Game**` çš„æ–¹æ³•ã€‚ä¸ºäº†ç¡®ä¿æ­£ç¡®çš„ `Save` æ–¹æ³•è¢«è°ƒç”¨ï¼Œæˆ‘ä»¬å¿…é¡»æ˜ç¡®å£°æ˜æˆ‘ä»¬è¦†ç›–äº† `**Game**` ä» `**PersistableObject**` ç»§æ‰¿çš„æ–¹æ³•ã€‚è¿™æ˜¯é€šè¿‡å°† `**override**` å…³é”®å­—æ·»åŠ åˆ°æ–¹æ³•å£°æ˜ä¸­æ¥å®Œæˆçš„ã€‚

```
public override void Save (GameDataWriter writer) {
		â€¦
	}
```

However, we cannot just override any method we like. By default, we're not allowed to do this. We have to explicitly enable it, by adding the `**virtual**` keyword to the `Save` and `Load` method declarations in `**PersistableObject**`.  
ç„¶è€Œï¼Œæˆ‘ä»¬ä¸èƒ½åªæ˜¯è¦†ç›–æˆ‘ä»¬å–œæ¬¢çš„ä»»ä½•æ–¹æ³•ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬ä¸å…è®¸è¿™æ ·åšã€‚æˆ‘ä»¬å¿…é¡»æ˜¾å¼åœ°å¯ç”¨å®ƒï¼Œæ–¹æ³•æ˜¯å°† `**virtual**` å…³é”®å­—æ·»åŠ åˆ°#3ä¸­çš„ `Save` å’Œ `Load` æ–¹æ³•å£°æ˜ä¸­ã€‚

```
public virtual void Save (GameDataWriter writer) {
		writer.Write(transform.localPosition);
		writer.Write(transform.localRotation);
		writer.Write(transform.localScale);
	}

	public virtual void Load (GameDataReader reader) {
		transform.localPosition = reader.ReadVector3();
		transform.localRotation = reader.ReadQuaternion();
		transform.localScale = reader.ReadVector3();
	}
```

`**PersistentStorage**` will now end up invoking our `**Game**.Save` method, even though it's passed to it as a `**PersistableObject**` argument. Also have `**Game**` override the `Load` method.  
`**PersistentStorage**` ç°åœ¨å°†æœ€ç»ˆè°ƒç”¨æˆ‘ä»¬çš„ `**Game**.Save` æ–¹æ³•ï¼Œå³ä½¿å®ƒæ˜¯ä½œä¸º `**PersistableObject**` å‚æ•°ä¼ é€’ç»™å®ƒçš„ã€‚åŒæ—¶è®©#3è¦†ç›–#4æ–¹æ³•ã€‚

```
public override void Load (GameDataReader reader) {
		int count = reader.ReadInt();
		for (int i = 0; i < count; i++) {
			PersistableObject o = Instantiate(prefab);
			o.Load(reader);
			objects.Add(o);
		}
	}
```

![](<images/1686835487185.png>)

File containing two transforms.  
åŒ…å«ä¸¤ä¸ªå˜æ¢çš„æ–‡ä»¶ã€‚

The next tutorial is [Object Variety](https://catlikecoding.com/unity/tutorials/object-management/object-variety/).  
ä¸‹ä¸€ä¸ªæ•™ç¨‹æ˜¯â€œå¯¹è±¡å¤šæ ·æ€§â€ã€‚

[repository](https://bitbucket.org/catlikecodingunitytutorials/object-management-01-persisting-objects) [PDF](https://catlikecoding.com/unity/tutorials/object-management/persisting-objects/Persisting-Objects.pdf)