

**-Microfacet models 微表面模型**

接下来我们开始进入 Microfacet models 微表面模型, 首先我们来回顾一下 Games101 中的一些微表面知识:

![[50ab2c75e851af17dff6243ee362d709_MD5.jpg]]

什么是微表面 BRDF?

我们认为在宏观上看上去是平的, 但是在微观上看去会看到各种各样的微表面, 这些微表面的朝向, 也就是法线各不相同, 这些微表面法线的分布导致的渲染出的结果各不相同。

微表面 BRDF 中有几个至关重要的项:

1.  **F 项：菲涅尔项**，表示观察角度与反射的关系 (从一个角度看去会有多少的能量被反射)

有多少能量被反射取决于入射光的角度，当入射方向接近 grazing angle 掠射角度的时候，光线是被反射的最多的, 也就是当你的入射方向与法线几乎垂直时候, 反射的 radiance 是最多的.

由于光路的可逆性，我们可以认为眼睛看过去的方向是光线入射方向。

![[dcd0d23e817e4d360aa8f62e7eb60554_MD5.jpg]]

下面是对于绝缘体反射率与角度的关系:

以河面为例, 让你入射方向与河面法线平行, 则会直接看到河底; 如果入射方向与河面法线垂直, 则能最大程度看到反射出的天空之类的.

![[3bca64c4b771b7e6283deeca18b5b4bb_MD5.jpg]]

下面是对于导体反射率与角度的关系，与绝缘体不同，部分会出现反常现象

![[c67a03596a097fc24dd05508f582b077_MD5.jpg]]

**菲涅尔项告诉我们有百分之多少的能量会被反射出来.**

菲涅尔项的推导时要考虑光线的 S 极化和 P 极化效果，公式比较复杂, 因为要考虑不同介质, 如从空气到物体表面, 各自的折射率和入射角折射角，最终推导出下图中的公式。

![[7b7cf8294bd3bd9008a1bc608736ddb4_MD5.jpg]]

但我们平常不用这个, 而是用一个简单的近似：Schlick’s approximation

![[3b3bc5f858460a1e449b9613e0242ad9_MD5.jpg]]

我们之前讲过:

当θ->90 度, cosθ=0, 则 R(θ)=1;

当θ->0 度, cosθ=1, 则 R(θ)=R0;

其中 R0(基础反射率) 取决于物体, 不同物体的 R0 各不相同.

**2.D 项：微表面的法线分布**

决定这一项的是不同微表面朝向的法线分布；

当朝向比较集中的时候会得到 Glossy 的结果, 如果朝向特别集中指向时认为是 specular 的.

![[d3bf2d2e2d3ebeeea4a0f226aa72ffa5_MD5.jpg]]

当分布杂乱无章时候，因此认为表面也非常复杂, 得到的结果也就类似 diffuse 的.

![[04c2bbd34852d8db5bc74df594a4bf7f_MD5.jpg]]

当 NDF 变得十分复杂时, 我们可以这么理解, 从 glossy 变为 diffuse 的, 我们认为把 glossy 物体围观的高度场拉大, 导致微观上的表面们变得倾斜 (做了一个 scale), 从而让之间的沟壑变深且改变法线分布朝向, 从而成为 diffuse 的.

![[b3b0ca2bcb100af415dc122325b4f890_MD5.jpg]]

![[61d075aba201c5351c121900338572cf_MD5.jpg]]

**NDF->Normal Distribution Function**

1. 我们把为表面法线分布的函数定义为 Normal Distribution Function（NDF)

2. 我们有有很多不同的模型来描述法线分布:

*   常用的 Beckmann，GGX 等等模型；
*   闫神自己的一系列模型.(2014,2016,2018)

![[fad5bc060613fcd5623a7f131649a05d_MD5.jpg]]

我们主要讲 Beckmann 和 GGX 这两个 NDF 模型:

**-Beckmann 模型**

其目的为了描述法线分布，因此肯定是一个关于法线方向 h 的函数，而 h 是半球上的任意一个方向，然后描述这一方向对应的值是多少，这就是 NDF。

举个例子，给定向量 h，如果我们的微平面中有 35% 与向量 hℎ取向一致，则法线分布函数或者说 NDF 将会返回 0.35。

我们来深入理解一下这个函数:

这个函数可以描述不同粗糙程度的表面, 不同粗糙程度的意思是 NDF 中 lobe 是集中在一个点上, 还是分布的比较开.

我们想一下高斯函数中用 $\sigma$ 来控制胖瘦, 也就是标准差, 同样对应到 D(h) 中:

![[8a3894193a33a58a36066e7f9c333660_MD5.jpg]]

α描述的是法线粗糙程度，粗糙程度这个值越小，表面就越光滑

_θh_：微表面半程向量法线与宏观表面法线（0，0，1）方向 n 的夹角

到现在为止发现定义只与_θ_有关，与_φ_无关，因此表述的是各向同性的结果，也就是沿着中心旋转是相同的结果。

**分子上面为什么用 tan_θh_，而不直接用_θh_？**

因为是定义在 Slope space 坡度空间上的：

![[7d0244f188833d1c363f88478425c434_MD5.jpg]]

tan_θ_与_θh_ 关系如图所示，一维中 tan_θ_就是法线延长到切线的交点到宏观法线顶端的距离，二维中则是与切表面的交点到宏观法线顶端的距离.

在 tan_θ_上定义一个高斯函数，也就是在切平面这么一个无限大平面上定义的一个高斯函数，在平面上定义和在角度上定义的含义差不多

由于高斯函数的定义域是非常大的，但在过了 3σ之后会缩减到非常小但不是 0, 为了满足这一性质定义在坡度空间, 因为虽然距离非常远，但是一定对应着单位球（圆）上一个有限的角度, 从而保证在 slope space 中无限大的函数无论如何也不会出现面朝下的微表面.

因为如果你定义在θ的一个高斯, 无论用多小的高斯, 当θ超过 90 度, 仍然会有值, 但是定义在 slope space 上则不会出现这一情况, 从而保证微表面不会朝下, 但是无法避免反射光朝下

**-GGX 模型（TR 模型）**

Beckmann 模型的 NDF 曲线与 GGX 模型的 NDF 曲线相比有一个明显的特点:

Long tail 长尾性质:

会很快衰减，但是衰减到一定程度的时候衰减速度会变慢, 可以看到即使到了 grazing angle(90 度) 时仍不为 0。

![[1d3dbf8bd52449079c8d73c793cf1b88_MD5.jpg]]

这会带来两个好处:

1.  Beckmann 的高光会逐渐消失, 而 GGX 的高光会减少而不会消失, 这就意味着高光的周围我们看到一种光晕的现象.
2.  GGX 除了高光部分, 其余部分会像 Diffuse 的感觉.

![[1e5ec808c22e769fb86a49754ee6af15_MD5.jpg]]

Beckmann 模型与 GGX 模型的实际效果对比如图。

相同的粗糙程度下 GGX 的效果更加自然, 因为 long tail 性质导致高光到非高光有一个柔和的过渡状态, 而非 Beckmann 的高光到达 grazing angle 后戛然而止, 我们希望的是像 GGX 一样的效果.

![[bbc1d251fa8f84b0520d33bab8843944_MD5.jpg]]

-**GGX 模型的扩展**

GTR（Generalized Trowbridge-Reitz），多了参数γ，根据γ不同可以调节拖尾长度；

*   包括了本身 GGX，当γ=2 时候就是 GGX，当γ超过 10 会接近 Beckmann；
*   具有更长的拖尾。

![[1f5c034a98837e35d46aa34e6d8207d8_MD5.jpg]]

**3.G 项：Shadiowing-Masking(也是非常重要的一项)**

Shadiowing-Masking 有另外一个名称 ->Geometry Term, 这也是缩写为 G 的原因.

解决的问题就是微表面之间的自遮挡问题, 尤其是在角度接近 grazing angle 时.

![[7df6f0ba5e172832bf4158c6c05fcef0_MD5.jpg]]

如图, 由于在微观上有不同的微表面, 因此虚线部分本该入射的光被遮挡了, 由于光线时可逆的, 因此不只是看过去被遮挡, 往外看时也被遮挡.

分为两种情况:

左边这中从 light 出发发生的微表面遮挡现象叫做 Shadiowing

右边这种从 eye 出发发生的微表面遮挡现象被称为 Masking；

我们之所以引入 G 项就是为了考虑由于遮挡产生的 darkening 现象 (由于微表面自遮挡, 因此实际计算出的结果会比理想结果亮, 所以加上 G 项使得结果变暗接近理想结果)

因此由于在接近 grazing angle 时遮挡现象最大也就是接近于 0, 垂直看向时无遮挡也就是 1.

**那么当不考虑 G 项时，在掠射角度会发生什么情况？**

![[e9114c7b50d34c6ffbcf198cf443ba42_MD5.jpg]]

我们以图为例, 我在此假设我们从 grazing angle 处看向 F0 旁边的白圈里的点, 即我们的观察方向与表面法线接近垂直. 我们代入公式考虑:

![[39e3e104384609c27ab5e499be2ca45b_MD5.jpg]]

当在 grazing angle 处时, F 则 = 1, 不考虑 G 项, 那 G 项 = 1,D 是一个法线分布, 是一个正常的函数没有什么特别大的值, 到此分子部分考虑完毕.

我们来考虑分母, 分母中存在的两个法线与入射方向（_n,i_）法线与出射方向（_n,o_）的点乘，当在 grazing angle 时入射方向、出射方向与法线角度接近 90°，因此点乘结果会非常小接近 0，分子除以一个接近于 0 的值会导致结果变的巨大，就会导致我们看到的这张图整个外圈是白的。

![[87ec65006d0ecb4b19d30bbcae1a990e_MD5.jpg]]

引入 G 项, Shadiowing-Masking 项也就是为了避免这种情况产生的

**常用的 The Smith Shadowing-Masking 项:**

在 The Smith Shadowing-Masking 中, 我们把 shadowing 和 masking 分开考虑

![[5ce1f6c2d10445559868a4779a578954_MD5.jpg]]

我们看下面这张图, 绿线是 GGX, 红线是 Beckmann.

在两种不同 NDF 下预测出的 G 项有一些细微差别但其实相差不大垂直入射的时候 Shadowing-Masking 不起作用，在 grazing angle 时, G 项变得非常小接近于 0, 从而我们解决了分子除以分母导致函数结果过大, 整体发白的问题.

我们来举一个很简单的例子

*   未添加 G 项前 = 1 / 0.4 = 2.5
*   添加 G 项后 = 0.6 / 0.4 =1.5

很显而易见的在添加了 G 项后整体的值变小解决了外圈发白的问题.

![[faff746876fd16fadf9ea0ff78ebcad8_MD5.jpg]]

**但是在我们正确考虑了 F 项, G 项, NDF 项仍然有一些问题:**

![[cc067f6741855ed15e42372f7362e6cc_MD5.jpg]]

在这个图中没有发现任何 grazing angle 的问题, 但是随着粗糙程度变大, 我们渲染得到的结果却越暗, 即使认为最左边是抛光, 最右边的是哑光, 这个结果也是错误的, 因此再怎么哑光也不能让白金变成跟石头一样的光泽.

如下图, 在 uniform 的环境光照下即使物体再粗糙我们再这样的光照下得到的结果也应该都是接近于背景的一个颜色, 而不是这种.

![[a887e574b91184cc23216c4706717b2e_MD5.jpg]]

这是因为由于没有考虑光线在表面上的多次弹射，只考虑了微表面遮挡的情况，当粗糙度越来越大的时候，能量是不守恒的, 因此才导致了粗糙度增大引起了能量损失这一现象.

当表面越粗糙的时候，反射光更容易会被表面挡住，同时越粗糙的表面在表面之间弹射的次数越多，我个人理解闫老师说的是 G 项只考虑了一次 BOUNCE, 因此当只考虑一次弹射的时候，越粗糙的表面就损失的能量越多, 才会产生这个现象。

![[9960914c3458421486b1838defbb5601_MD5.jpg]]

**因此我们需要把丢失的能量补回去.**

在离线渲染中, 我们去考虑多次 bounce, 在微表面做一个类似光线追踪的东西, 结果准确但速度很慢, 更不要提在 RTR 中了.

在 RTR 中有自己的方法去补足丢失的能量

**其核心思路是将**反射光看作两种情况:

*   当不被遮挡的时候，这些光就会被看到；
*   当反射光被微表面遮挡的时候，认为这些被挡住的光将进行后续的弹射, 直到能被看到

![[c0be83d1bcff526e4b1f84fb3e8731ba_MD5.jpg]]

通过 basic ieda 从而有了工业界中的处理方法:

**--The Kulla-Conty Approximation**

这种方法是通过经验去补全多次反射丢失的能量, 其实是创建一个模拟多次反射表面反射的附加 BRDF 波瓣 ->fms，利用这个 BRDF 算出消失的能量作为能量补偿项（Energy Compensation Term）, 那么我需要考虑两件事:

1.  **在反射时有多少能量丢失了？**
2.  **最后反射出的能量有多少?**

首先我们先来算最后反射出了多少的能量:

下面的式子是把 BRDF（这里的 BRDF 指的是考虑了 Shadowing-Masking 的 BRDF）、Lighting、cos 在一起在整个半球上进行了积分，来计算射出的总能量

![[8d40a00f6bbb71ae3e58f896b10ea6d2_MD5.jpg]]

**这里非常复杂：**

*   我们认为任何方向入射的 Radiance 是 1, 也就是 rendering equation 中的 Lighting 项是 1（因为是 1 所以式子中没有出现）
*   同样假设 BRDF 是各向同性的，也就是与 i、o 无关的；
*   因此最终积分的结果意义是, 在 uniform 的 lighting=1 的情况下, 在经历了 1 bounce 之后射出的总能量 E(uo).

至于 cosθ去了哪里?

由于我们积分中是 $BRDF \cdot COSθ \cdot sinθdθd\varphi$ ,sinθdθdφ是单位立体角

我们将 cosθ sinθdθdφ放在一起

由于:

*   df（x）/dx=f’（x）
*   df（x）=f‘（x）dx
*   我们把 sinx 看为 f(x), 所以 d（sinx）=cosxdx

所以 sinθcosθdθ =sinθd(sinθ)

变成了 $BRDF \cdot sinθd(sinθ)d\varphi$

最后我们用 u=sinθ进行一个换元操作, 得出最后的公式.

![[4e4415142449e405fe07bd07061c2dec_MD5.jpg]]

看一下最终详细推导过程（过程中需要换元）:

![[072ecb46aece6fca5f5ad5785b3c507e_MD5.jpg]]

由于得到的射出的总能量 E(uo) 是在 0-1 之间的

*   那么有多少能量被遮挡就是 $1 - E(u_{o})$
*   不同方向积分出来的值是不同的，因此不同观察方向损失的能量 1-_E_(_μ0_) 我们可以求出来了, 那么只需要加上这一部分能量就解决问题了.

由于 BRDF 的可逆性，因此除了考虑 o 方向, 还要考虑 i 方向（也就是要考虑入射丢失的和出射丢失的）, 同时要乘一个归一化的量 c（可以是常量或函数）得出一个 brdf 也就是：

$c(1- E(μ_{o}) )(1- E(μ_{i}))$

通过这个 brdf 积分后得到的结果要等于消失的能量 ->1 - E(uo)

之所以这么做是因为简单, 我们保留下需要求出来的积分值 1 - E(uo), 并且考虑由于 brdf 可逆性的另外半边的 1-E(ui), 剩下的部分我们写成一个常数 c 不去管他, 这个 C 是可以求出来的:$C = \frac{1}{π(1-Eavg)}$

![[a8f5e99ce7a27182a5e9a10a8073a54d_MD5.jpg]]

![[be8daefe911ec43b4a72c6d727e416e0_MD5.jpg]]

我们来验证一下 fms 是否是正确的:

![[87113acbc6cf17070501985fd5706f93_MD5.jpg]]

代入后发现求出的 E 正好是消失的能量

它的原理是希望设计一种可以交换输入输出方向的 brdf->fms, 使得它的积分结果正是我们所失去的能量, 因此用失去的 + 射出的能量达到能量守恒.

那么到目前为止_Eavg_的积分如下式

![[c83bfb70d8d00e2505db7952d5e56306_MD5.png]]

其中_E_(_μ_) 已经是一个二重积分了，计算是非常困难的，因此计算仍然比较复杂

但是对于一个很复杂的、不一定有解析解的积分可以通过预计算或打表格的方式来解决。

由于考虑到存储的开销, 对于这个积分，维度不能太高，这就取决于这个积分依赖的参数，

_Eavg_经过观察积分式可知不管计算多复杂，_Eavg_只依赖于_μ0_与粗糙度, 于是我们根据 uo 和粗糙度打出一张表格:

![[d829207a6aca4f362fee19b2fa1bd485_MD5.jpg]]

从而可以很快地知道对应的_Eavg_的积分值, 知道了 Eavg 的积分值后就可以带入到 fms 中, 从而求出 Ems(消失的能量).

![[28dbfa11b0e7c20dfa2e8930bc9d03a1_MD5.jpg]]

我们将算出的损失的能量加上后可以看到效果很好.

**当单次反射的 BRDF 是有颜色情况怎么办？**

*   有颜色就意味着，物体发生了能量吸收的情况，也就是有额外能量损失，也就是单次反射的积分结果不是 1.
*   因此我们可以先考虑没有颜色的情况，然后再去考虑他的颜色是什么。

_Favg->_平均菲涅尔项:

**_不管入射角多大，平均每次反射会有多少能量反射_**

因此平均菲涅尔项的计算就是计算在所有角度下，菲涅尔项的平均值。

![[4b5fbbe67a17f953e60a3e5afd354a57_MD5.jpg]]

之前的 Euo 是固定方向上看，整个出去的能量是多少，也就是说这些能量是不会参与到后续多次的反射中的, 因此我在后续需要的能参与到后续 bounce 的是 (1_-Euo_)。

因此我们能看到的能量就能够被分为不同的类型：

*   能够直接看到的能量：_Favg * Euo_
*   一次弹射后能看到的能量_Favg *_ (1_-Euo_) * _FavgEavg_
*   …….
*   k 次反射后能看到的能量_Favg ^k*_ (1_-Euo_))^k * _FavgEavg_

那么把 0 次到 k 次弹射的结果相加后，能够得到一个无穷级数，最终得到了下式中的颜色项，

$\frac{F_{avg}E_{(u)}}{1-F_{avg}(1-E_{(u)})}$

这个颜色项需要直接乘进没有颜色的 BRDF->fms 中从而得到有颜色的时候除去吸收能量外应该补足的能量.

增加了颜色项后的结果如下图所示。

![[e9b6be56c2354783952c999b79caa3e4_MD5.png]]

*   目前存在的不正确的 Hack / 近似方法

- 最近几年有人不考虑能量损失直接加 Diffuse 项, 也就是用一个 diffuse + 一个 Microfacet, 这种写法在计算机视觉里尤其常见

对此闫神给予了三个评价:

![[d0a4148c9f61af3996a32b7bbffa3575_MD5.jpg]]

*   这是完全错误的方法
*   不能更糟的方法
*   闫神没有教过你。。。。。

这是因为已经采用了微表面模型，就不能在与宏观表面模型 Diffuse 的假设一同采用，同样在物理上也是错误的，能量不能保证守恒，可能会出现发光的 BRDF 的情况。由于不同角度、不同粗糙度损失的能量是完全不同的，因此直接加一个 Diffuse 是完全错误的。

总结起来就是:

1. 这样做没有物理依据

2. 无法保持能量守恒