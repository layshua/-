
---
title: 09 阴影
aliases: []
tags: []
create_time: 2023-06-20 10:42
uid: 202306201042
banner: "![[Pasted image 20230620104207.png]]"
---

需要补一下 games202 阴影内容
[实时阴影技术总结 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/45805097)
[实时渲染中的软阴影技术 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/26853641)
# 非基于图像的实时阴影
## 平面投影阴影
平面投影映射不是一个基于图像的解决方案

**内容**：根据光的方向，把物体的每个顶点投影到平面地面上。
![[Pasted image 20221209130631.png]]
**数学原理**：相似三角形
光 Light 所在的点 L 已知，V 已知，P 很容易就能求得

**缺点**：
- 只能投影到平面（阴影的接收物只能是平面）
- 投影物体必须在光线和平面之间
## 投影阴影

平面投影阴影的阴影接收物只能是平面，为了**在曲面上得到阴影**，做了以下改进：

**投影阴影**：
1. 把光源当做一个相机/投影器
2. 然后将阴影投影渲染到一张纹理
3. 最后**渲染阴影接收者时**，将上一步得到的阴影合并进去
- ![[Pasted image 20221209144815.png]]

**投影阴影在 Unity 中的实现**
![[Pasted image 20221209144939.png]]
-   第一步，设置 Project 组件，通过它的参数使用给它的材质生成一个视锥体
-   第二步，使用 Render Texture 生成一张纹理，将阴影绘制到纹理中
-   第三步，将设置 Project 组件的物体和阴影纹理进行混合

# 一、基于图像的实时阴影技术
**shadow mapping 是一个完全在图像空间 (images space)中的算法**
**优点:**
一旦 shadow Map 已经生成, 就可以利用 shadow map 来获取场景中的几何表示
**缺点:**
会产生自遮挡 (self occlusion)和走样 (aliasing) 现象.

## 2、阴影映射（ShadowMapping）
### 理解阴影

-   **如何确定“是不是阴影”**
	-   我们能看见+光能看见 = 正常渲染
	-   我们能看见 + 光看不见 = 阴影

-   **GAMES101 中，讲过的关于阴影的理解：**
	-   是一个经典的双 Pass 做法
	-   Pass1：从光源看向场景，记录看到点的深度
		-   需要从光源的位置渲染整个场景的深度图（这张图就是**shadowmap**）

	-   Pass2：从相机看向场景
		-   再从相机位置渲染这个场景

	- 在投影回光源所在的图像上，比较在相机位置渲染和光位置的深度，结果可以这样理解：
		-   **深度一致：说明相机和光都能看到**
		-   **深度不一致：我们能看到，但是光看不到 =>阴影**
		![[Pasted image 20221209145349.png]]
### 阴影图/深度图（Shadow Map）
![[Pasted image 20221209145547.png]]
-   光源视角下（shadowmap）
-   我们从光源看向场景的角度渲出一张深度图，这张深度图：
-   离光源越近就越黑（0）；越远就越白（1）
-   这张图就反映出了场景中物体的远近关系

![[Pasted image 20221209145655.png]]
**阴影映射的流程**
-  1. 从光源的位置生成一张深度图，这一步称之为阴影映射（ShadowMap）。
-  2. 从摄像机的视角，渲染整个渲染整个场景的物体。每次渲染时，需要和 shadowmap 的深度做比较（深度测试）。
>比如左下角红色点的位置，他的深度是摄像机视角的深度，所以要先转换成阴影映射的坐标系，保证坐标系是一致的。然后比较深度值，如果一个**片元的深度>它在 shadowmap 中的深度**，那么就认为它在阴影中。

**总结/注意事项：**
-   ShadowMapping 本质上是一种图像空间做法，也就是说生成 shadow 这一步不需要这个场景的几何信息
-   ShadowMapping 只能做**硬阴影**

**软硬阴影的区别**：硬阴影没有一个明显的从有阴影到没有的过度/界限（因为绝大多数的生活中的光源是面光源）
![[Pasted image 20221209164343.png]]
## 3、Unity 中的屏幕空间阴影映射
### 步骤
1.  渲染屏幕空间的深度贴图
2.  从光源方向渲染出 shadowmap
3.  **在屏幕空间**做一次阴影收集计算（Shadows Collector，将前两步生成的图做深度比较），
		a.  **这次计算会得到一张屏幕空间的 shadowmap（Collect Shadows）**
		b.  //实际上就是对前两步的深度图做一个比较，得到一张新的深度图
4.  在绘制物体时，用物体的**屏幕坐标 uv**采样第三步中生成的屏幕空间 shadowmap

从 FrameDebugger 查看过程
![[Pasted image 20221209151539.png]]
![[Pasted image 20221209151553.png]]
# 二、阴影映射的问题与优化
## 1、问题 1：自阴影/自遮挡
### 自阴影 self-shadowing：
自阴影/自遮挡也被称为**阴影粉刺（Surface Acne）

![[6ead296a05b80777473845429dcbbef8_MD5.png]] ![[6368ed87749ac4a26550234e84ff7c15_MD5.png]]
- 地板上的东西会感觉像摩尔纹, 但并不是**它是由数值精度造成的一种现象。**
- 因为 shadowmapping 的分辨率有限，离散的采样点以及数值上的偏差可能造成不正确的自遮挡效果


 **出现自阴影的原因：**
-   如下图所示，在映射 shadowmap 的过程中，用表面上**点的 uv**采样阴影映射的深度值都是一个值（shadowmap 的一格代表的是一个纹素，在这一格里面采样阴影映射得到的值都是一样的）
- 例如：红点和蓝点采样后得到的深度值都是一样的，这一段所有点采样得到的深度值都和红线（代表深度值）相等。
![[Pasted image 20221209153218.png]]
当比较深度时，为了避免表面自阴影，需要设置容错阈值：
- 深度偏移（Depth Bias），增加深度偏移会使该像素向光源靠近
- 法线偏移（Normal Bias），沿着表面法线方向向外偏移
- 偏移单位是 shadowmap 的纹素

**深度偏移会造成的问题（Peter Panning）**
-   当 Bias 设置过大时，会导致漏光现象，即阴影与投影者之间发生脱节：也叫做**Peter panning 问题（学术界叫作 detached shadow）**
-   //Peter Panning 名称的由来：Peter 是西方漫画中的人物，他和影子是可以分开的
![[Pasted image 20221209152205.png]]
### GAMES101 补充理解
![[Pasted image 20221209152350.png]]
-   从 light 往场景看（左边太阳的线）时，比如沿着某一个像素往过看，看到的位置（红色斜线）就是像素所代表的深度，（假设任何一个像素是一个常值的深度）。也就是说，在 shadowmap 看来，场景离散成了图中红色斜线形成的结果。
-   第二个 pass 渲染的时候，从 camera 出发（右边连着眼睛的蓝色虚线），常规操作：连向 light （左边蓝色虚线），这段虚线长度就是它的深度
-   **问题**：在 shadowmap 记录的对应的深度是橙色的部分（更浅），而实际上从相机看向这个像素，它的深度应该是被橙色部分遮挡住的点（两条蓝色虚线的交点）→这就是自遮挡情况
-   **特殊情况**：

-   光垂直的，从上往下照时候，不存在问题
-   光非常偏的时候，问题最大（例如：塞尔达中夕阳西下时）
-   //不难理解，斜着的时候就完全被挡住了，垂直的时候就不会被遮挡，图已经画的很清楚了

**如何解决这个问题：**
![[Pasted image 20221209153545.png]]
-   加上一个所谓的 Bias 避免自遮挡（图中橙色那段）
	-   认为 shadowmap 上的深度，明显比实际的深度小的情况下，橙色的这一段障碍物就不算了。
	-   bias 可以不是一个常数，可调整，如果垂直打光，可以非常小，夹角很大的情况，可以更长一点。
### Unity 中实现自阴影的优化
-   思路：
-   在生成 shadowmap 时去做 Bias（偏移）
![[Pasted image 20221209153656.png]]
## 2、问题 2：走样
### ①走样问题
-   走样，最明显的表现就是锯齿，我们可以看下边的例图
![[Pasted image 20221209153803.png]]
### ②走样问题的具体内容和解决方法
**在什么阶段会走样？**
-   初始采样：渲染 shadowmap 时
-   重采样：从相机位置对 shadowmap 进行重采样时

**初始采样阶段**
-   最严重的问题：**透视走样**
-   透视走样是如何形成的？
![[Pasted image 20221209162811.png]]
-   shadowmap 在世界空间均匀分配（左图的三段纹素对应的世界空间的一个像素大小是一样的）
-   **经过透视投影后**，根据近大远小的原理，原来大小不一样的近平面和远平面，在屏幕内占的像素便一样了。（右图）
-   这时远平面对应在 shadowmap 中的纹素就比近平面大了
-   这种离相机近的部分走样的情况一般称为**透视误差**。

-   **如何解决**？
-   思路 1：
-   因为我们在使用 shadowmap 时，相机是经过透视投影的，但生成 shadowmap 时并没有经过透视投影
-   所以我们在生成 shadowmap 时就进行一次透视投影

-   思路 2：
-   尽量减少近平面和远平面之间的像素差距
-   Unity 中的**级联阴影映射**（投影走样最有效的解决方案）就是用的这个思路
![[Pasted image 20221209163324.png]]

### 级联阴影映射
(Cascaded Shadow Map)
- 投影走样最有效的解决方案
- 把视锥体分割为多个子视锥体；
- 为每个子视锥体计算独立的相等大小的阴影映射；
-   //就是给 shadowmap 不同位置不同的分辨率
### 重采样误差
-   shadowmap 可以理解为一张动态生成的纹理
-   重采样误差的解决方法：**滤波（Filter）**
 ![[Pasted image 20221209163546.png]]
-   滤波：在图像处理中，通过滤波强调一些特征或者去除图像中一些不需要的部分 (高斯模糊就是一种滤波方式)
-   滤波是一个**领域操作算子**，利用给定像素周围的像素的值决定该像素的最终输出值

-   **补充**：
-   滤波就是抹掉特殊频率的东西
-   高通滤波 = 边界
-   低通滤波 = 模糊
-   //滤波（Filtering）=卷积（Convolution）=平均（Averaging）

-   **阴影滤波**：
-   使用一部分 shadowmap 采样点来计算某个指定 View 采样点的最终阴影结果的方法

### PCF 滤波
![[Pasted image 20221209163837.png]]
-   **一句话总结**：PCF 中，不是取 shadowmap 上一个点的深度去比较，而是：取 shadowmap 上任意一个点的周围一个 Filter 大小的区域（滤波核），将**这个区域的所有点都去做一次**深度比较（0 或 1 的结果），最后再对这些结果做一个平均（不是非 0 即 1 的结果，而是一个权重值/像素的颜色值）
-   **采样数 K**（其实就是 Filter 的大小）
-   可以是规则滤波，3x3 或者 5x5 等
-   也可以采用泊松滤波（Poisson DIsk）的形式来分布一定数量的采样点 ![[Pasted image 20221209164052.png]]
**Filter 的大小重要吗？**
-   如果小（比如 1×1 = 没做 Filter），结果是锐利（sharpener）对应硬阴影
-   如果大，结果是 softer，对应软阴影
-   既然 Filter 的大小可以决定阴影的软硬，我们不妨这样理解：
-   软阴影 = 硬阴影做一个非常大的 Filter
**现实世界的软硬阴影**
![[Pasted image 20221209164914.png]]
-   阴影在笔尖的地方是硬的，远的地方就很虚（软）
-   也就是说：**阴影的软硬和遮挡物的距离有关（注意：不是和光源的距离）**
-   **关键结论**：
-   要想做一个软阴影的效果，应该给硬阴影各个位置不同大小的 filter

-   **那么这个不同位置不同的 Filter 的大小怎么解决呢？**
-   既然阴影的软硬和遮挡物距离有关，那么我们就做一个定义
-   定义一个**blocker distance（遮挡物和阴影接收物的距离**）
-   //更准确的说法：相对的、平均的、投射的遮挡物的深度

-   **到此为止我们做个总结：**
-   我们知道了 PCF 怎么做
-   要做 PCF，我们还需要知道 Filter 的大小，接下来就是 PCSS 的舞台了

### PCSS
-   PCSS 是古老的方法，是经过探索之后最终的选择（因为现在的降噪技术 ok）
-   **PCSS 是产生真正软阴影的方法**

-   值得注意的是，PCF 最早研究出来是为了做阴影边缘的反走样的
-   **用 PCF 做软阴影就是 PCSS**

![[Pasted image 20221209165125.png]]
-   上方黄色线段表示 Light（光），中间绿色线段表示 Blocker（遮挡物），下边蓝色线段就是 Receiver（阴影的接收物）
-   将 Light 和 Blocker 连到 Receiver 上，就可以看到很明显的相似三角形
-   通过相似三角形关系我们就可以得到以下信息：

-   蓝色虚线=dReceiver，绿色虚线 = dBlocker
-   **绿色虚线 /（蓝色虚线 - 绿色虚线） = WLight/ WPenumbra
-   当遮挡物（Blocker）离接收阴影物的距离变小，WPenumbra 也会变小（阴影变硬），反之变大（阴影更软）
-   WPenumbra 就是 filter 的范围

-   我们继续分析
-   现在唯一的问题就是：该 Filter 多大？

-   **这取决于 light 的大小，也取决于 blocker depth dblocker
-   平常指的 blocker depth 是说 average blocker depth，意思就是：对于一个 shading point，要看在一定的范围内，有多少能够挡住它的，在 shadowmap 上记录的像素，这些像素记录的深度的平均值是什么

-   这样一来，人们就可以把 PCF 的思想用在 PCSS 上了

**PCSS 的核心思想**
-   为了知道 Filter 要多大，得知道 blocker 到 shading point 的距离是多少

-   **Step1：Blocker search**
-   从 shading point 连向点光源，找到一个点，去周围的某一个区域，来判断是不是在阴影里，如果在，那个像素就是一个 blocker，记下来。所有的都走一遍，记下所有的 blocker 的深度记下来，然后取一个平均。

-   **Step2：Penumbra estimation**
-   用 average blocker 计算 filter size

-   **Step3：做 PCF**
-   既然知道了 Filter 的大小，就可以计算 PCF 了

-   //第 2、 3 步和 PCF 没有区别：第一步之后，知道了 blocker 的距离，就可以计算 filter size，知道 filter 多大，就和之前 PCF 做法完全一样。

-   在第一步 Blocker search 时，在多大的范围内 search 呢（在多大的范围找 blocker）？

-   是一个鸡生蛋蛋生鸡的问题：
-   本来就是为了确定在 shadowmap 的周围多大的范围做 PCF，为了知道这个信息，就要知道 average blocker depth 信息。要知道 average blocker depth 的话，也得先取一个区域找 average blocker，再把他们平均起来。

-   取多大？
-   ①可以取固定大小的范围
-   ②更好的方法：shading point 连向 light，覆盖 shadowmap 的区域（红色区域），我们只在这个区域范围内找 blocker
![[Pasted image 20221209165510.png]]
### VSSM

-   针对解决了 PCSS 中第一步和第三步慢的问题（甚至不用做任何采样和循环，但是做了大量的近似）
-   对应的是 GAMES202-L4 部分
-   考虑的篇幅问题，就不再整理了，我直接贴笔记地址，感兴趣的自行扩展
-   [https://www.yuque.com/sugelameiyoudi-jadcc/okgm7e/gcuczo](https://www.yuque.com/sugelameiyoudi-jadcc/okgm7e/gcuczo)

### Moment Shadowmapping
-   VSSM 的发明是为了解决 PCSS 的问题，其实 VSSM 自己同样会有问题
-   当分布非常简单的情况下，就会出错（分布描述的不准）
-   Moment Shad