![[5eb2c82a394fc475af5cb9c43d08389b_MD5.webp]]

多光源的阴影处理

 在上一篇的文章里，我们实现了主光源的阴影的发射和接收；在上上一篇的文章中，我们实现了多光源；然后在这一章里，我们要把前面的综合起来，并实现额外灯光的光源的阴影，这样所有类型的灯光光源都可以支持，所有类型的灯光光源的阴影都可以支持。但是要注意，目前版本的 urp，本人撰写专栏时是 unity2019.4.0f1 的版本，也就是 urp7.4.1 的版本，是不支持点光源的实时阴影的，估计 unity2020.1.0f1 会增加上？

![[055253f9ef4530d2da1f52096bb21a44_MD5.webp]]

urp7.4 目前未能支持点光源实时阴影

      开始说明一下本次要用到的函数。

      在主光源的获取函数 GetMainLight（）中，我们通过它的重载函数得到的主光源的阴影衰减；同样在计算额外灯光时，我们用类似的函数得到额外灯光的结构体：GetAdditionalPerObjectLight(int perObjectLightIndex, float3 positionWS)，该函数的定义如下，它是定义在 Lightling.hlsl 库函数里的。

![[4b7d608ad7ec5c2111a8523cf0ab9fac_MD5.webp]]

获取额外灯光的函数定义

    从该函数里，我们发现计算灯光衰减是调用了另外一个专门用于计算实时灯光的衰减的函数：AdditionalLightRealtimeShadow(perObjectLightIndex, positionWS)，该函数定义在 Shadow.hlsl 里，它的定义如下图。  

![[02705f46310b091521808481d8b108ef_MD5.webp]]

额外灯光实时阴影衰减计算函数

     观察该函数，我们发现它是要定义关键字 MAIN_LIGHT_CALCULATE_SHADOWS，才能得到正确的阴影衰减值，故我们需要在 shader 里，multi compile 里添加该段关键字。以上，我们已经完成了对需要用到的函数和关键字的了解，开始说明 shader。

![[810199f289bebd9ec480fac954fc104f_MD5.webp]]

关键字说明

` #pragma shader_feature _ADD_LIGHT_ON _ADD_LIGHT_OFF`，这个是本人自定义的 shader feather，配合 keywordEnum 来在材质面板去控制效果。这里用来控制是否计算额外灯光的全部内容，非必须内容。

`#pragma multi_compile _ _MAIN_LIGHT_SHADOWS`，该段关键字是会自己再定义一个 MAIN_LIGHT_CALCULATE_SHADOWS，用于在 MainLightRealtimeShadow(float4 shadowCoord) 函数里计算得到正确的阴影衰减，是必须内容。

`#pragma multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE`，该关键字是为了让函数 TransformWorldToShadowCoord(float3 positionWS) 得到正确的阴影坐标，是必须内容。

`#pragma multi_compile _ _ADDITIONAL_LIGHT_SHADOWS`，该关键字是为了函数 AdditionalLightRealtimeShadow(int lightIndex, float3 positionWS) 得到正确的阴影衰减，是必须内容。

`#pragma multi_compile _ _SHADOWS_SOFT` 该关键字是为了得到柔软的阴影，是非必须内容。

   而我们打开官方的 lit shader 时，会发现它除了定义以上 4 个关键字之外，还额外定义了一个#pragma multi_compile _ _ADDITIONAL_LIGHTS_VERTEX _ADDITIONAL_LIGHTS，本人能力有限，尚且不知它的作用如何，姑且猜测和计算精度有关？如有大佬知道望指出，是非必须内容。

![[e96172f5e1611c7f512df58b788d31c7_MD5.webp]]

官方 lit shader 定义的关键字

    在后面即顶点着色器的内容，内容简单，大家一看就懂，这里不做说明了。

![[f5e164d6ba75aa3ab5dfee39e3d16a4f_MD5.webp]]

顶点着色器

   最后是片元着色器，先计算阴影坐标用于主光源的阴影计算，然后计算贴图，主光源等等一系列内容，和上一章一致；下面的 for 循环遍历所有额外灯光，额外灯光的最终的结果要乘以距离衰减和阴影衰减，累加起来和主光源的结果相加，即可得到我们想要的结果。

![[3689a139b11af6b63c6f0d6fc257e6f5_MD5.webp]]

片元着色器

    别忘了使用官方写好的 ShadowCaster 作为我们的 pass 写入 shadowmap。

![[a7f9b4ea5e349bd0c366a1bf82bf859f_MD5.webp]]

    官方目前未对点光源支持 shadowmap，猜测是因为主光源和聚光灯都是一个普通相机去采样 shadowmap 得到一张 2d 的深度图，而点光源是一个全景相机采样 shadowmap 得到的是一张 360° 的全景深度图，目前没有得到较好处理，但是在官方的未来计划里，已经提上了日程，希望 urp 能早日达到 build in 的内容。

![[79155e6fa06a713e12190267657d2af2_MD5.webp]]

URP 官方计划日程

最后的最后，附上代码

Shader "URP/multi_Light_And_Shadow"

{

    Properties

    {

        _MainTex("MainTex",2D)="white"{}

        _BaseColor("BaseColor",Color)=(1,1,1,1)

        [KeywordEnum(ON,OFF)]_ADD_LIGHT("AddLight",float)=1

    }

    SubShader

    {

        Tags{

        "RenderPipeline"="UniversalRenderPipeline"

        "RenderType"="Opaque"

        }

        HLSLINCLUDE

        #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

        #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"

        CBUFFER_START(UnityPerMaterial)

        float4 _MainTex_ST;

        half4 _BaseColor;

        CBUFFER_END

        TEXTURE2D(_MainTex);

        SAMPLER(sampler_MainTex);

         struct a2v

         {

             float4 positionOS:POSITION;

             float4 normalOS:NORMAL;

             float2 texcoord:TEXCOORD;

         };

         struct v2f

         {

             float4 positionCS:SV_POSITION;

             float2 texcoord:TEXCOORD;

             float3 WS_N:NORMAL;

             float3 WS_V:TEXCOORD1; 

             float3 WS_P:TEXCOORD2; 

         };

        ENDHLSL

        pass

        {

        Tags{

         "LightMode"="UniversalForward"

        }

            HLSLPROGRAM

            #pragma vertex VERT

            #pragma fragment FRAG

            #pragma shader_feature _ADD_LIGHT_ON _ADD_LIGHT_OFF

            #pragma multi_compile _ _MAIN_LIGHT_SHADOWS

            #pragma multi_compile _ _MAIN_LIGHT_SHADOWS_CASCADE

            #pragma multi_compile _ _ADDITIONAL_LIGHT_SHADOWS

            #pragma multi_compile _ _SHADOWS_SOFT

            v2f VERT(a2v i)

            {

                v2f o;

                o.positionCS=TransformObjectToHClip(i.positionOS.xyz);

                o.texcoord=TRANSFORM_TEX(i.texcoord,_MainTex);

                o.WS_N=normalize(TransformObjectToWorldNormal(i.normalOS.xyz));

                o.WS_V=normalize(_WorldSpaceCameraPos-TransformObjectToWorld(i.positionOS.xyz));

                o.WS_P=TransformObjectToWorld(i.positionOS.xyz);

                return o;

            }

            real4 FRAG(v2f i):SV_TARGET

            {  //Properties need

            half4 shadowTexcoord=TransformWorldToShadowCoord(i.WS_P);

                half4 tex=SAMPLE_TEXTURE2D(_MainTex,sampler_MainTex,i.texcoord)*_BaseColor;

                Light mylight=GetMainLight(shadowTexcoord);

                float3 WS_Light=normalize(mylight.direction);

                float3 WS_Normal=i.WS_N;

                float3 WS_View=i.WS_V;

                float3 WS_H=normalize(WS_View+WS_Light);

                float3 WS_Pos=i.WS_P;

                //calcute mainlight

                float4 maincolor=(dot(WS_Light,WS_Normal)*0.5+0.5)*tex*float4( mylight.color,1)*mylight.shadowAttenuation;

                //calcute addlight

                real4 addcolor=real4(0,0,0,1);

                #if _ADD_LIGHT_ON

                int addLightsCount = GetAdditionalLightsCount(); 

                for(int i=0;i<addLightsCount;i++)

                {

                    Light addlight=GetAdditionalLight(i,WS_Pos);

                    float3 WS_addLightDir=normalize(addlight.direction);

                    addcolor+=(dot(WS_Normal,WS_addLightDir)*0.5+0.5)*real4(addlight.color,1)*tex*addlight.distanceAttenuation*addlight.shadowAttenuation;

                }//half Lambert

                #else

                addcolor=real4(0,0,0,1);

                #endif

                return maincolor+addcolor;

            }

            ENDHLSL

        }

        UsePass "Universal Render Pipeline/Lit/ShadowCaster"

    }

}