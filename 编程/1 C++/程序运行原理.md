---
title: " C++原理 "
create_time: " 2023-09-28 20:43 "
uid: "202309282043"
reference: []
---

# 概念
## 三个级别的语言
1. **机器语言**。又称二进制代码，是计算机唯一可以直接识别和执行的语言。
2. **汇编语言**。汇编语言用英文单词和其缩写（助记符）代替二进制的指令代码。使用汇编语言编辑的程序，必须经过一个称为**汇编程序**的系统软件的编译，将其转换为机器语言，才能在计算机的硬件系统上执行。
3. **高级语言**。C++等，需要经过**编译程序**编译成汇编语言程序，经过**汇编**操作得到机器语言程序，或直接由高级语言程序翻译成机器语言程序。

## 翻译程序
- **编译程序（由编译器生成）**：将高级语言编写的源程序全部语句一次全部编译成机器语言程序，而后再执行机器语言程序（只需要编译一次，如 C/C++）
- **汇编程序（由汇编器生成）**：汇编语言转换为机器语言
- **解释程序（由解释器生成）**：将源程序的一条语句翻译成对应于机器语言的语句并立即执行。紧接着翻译下一句（每次执行都要编译，如 python，js）
- **翻译程序**：编译、汇编、解释程序统称翻译程序


## 从源程序到可执行文件
![[Pasted image 20230928215219.png]]

```c++ file:hello.c
#include <stdio.h>

int main(){
    printf("Hellow World.\n");
    return 0;
}

```
对于一个 C++源文件，从文本到可执行文件一般需要四个过程：
### 1 预处理阶段
**预处理器（cpp）** 对源程序 `hello. c` 中以字符 `#` 字节开头的命令进行处理，例如将 `#include` 命令后面的 `.h` 文件内容插入程序文件。输出修改后的源程序 `hello. i` 

- 删除所有的 `#define` ，展开所有的宏定义。
- 处理所有的条件预编译指令，如 `#if` 、`#endif` 、 `#ifdef` 、`#elif` 和 `#else` 。
- 处理 `#include` 预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。
- 删除所有的注释，`“//”`和`“/**/”`。
- 保留所有的 `#pragma` 编译器指令，编译器需要用到他们，如： `#pragma once`  是为了防止有文件被重复引用。
- 添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是能够显示行号。
```c++ file:hello.i
# 1 "hello.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 31 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 32 "<command-line>" 2
# 1 "hello.c"
# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 424 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 427 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 428 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 429 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 425 "/usr/include/features.h" 2 3 4
# 448 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 449 "/usr/include/features.h" 2 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 2 3 4
# 28 "/usr/include/stdio.h" 2 3 4

```
### 2 编译阶段
**编译器（ccl）** 对预处理后的源程序进行编译，生成汇编语言程序 ` hello.s`

编译过程一般分为6步：扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化。
![[2037768-20ef368560491608.webp]]
```c++ file:hello.s
	.file	"hello.c"
	.text
	.section	.rodata
.LC0:
	.string	"Hellow World."
	.text
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	leaq	.LC0(%rip), %rdi
	call	puts@PLT
	movl	$0, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.ident	"GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0"
	.section	.note.GNU-stack,"",@progbits
```
### 3 汇编阶段
汇编器（as）将 `hello.s` 翻译成机器语言指令，把这些指令打包成一种叫做**可重定位目标程序**的格式，并保存在 `hello.o` 文件中，这是一个二进制文件，用文本编辑器打开会显示为乱码。

汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器 as 完成。经汇编之后，产生目标文件 (与可执行文件格式几乎一样) xxx.o (Windows 下)、xxx.obj (Linux 下)。

### 4 链接阶段
**链接器（ld）** 将多个可重定位目标文件和标准库函数链接为一个可执行目标文件（简称可执行文件，`.exe`）。
`hello` 程序调用了 `printf` 函数，它是 C 标准库函数，具体存在于一个已经预编译好的 `printf.o` 文件，链接器（ld）负责将这个文件与我们的 hello 文件合并起来。

- **链接分为静态链接和动态链接,** 两者最大的区别就在于链接的时机不一样：
    - 静态链接：形成可执行程序前
    - 动态链接：在程序执行时
#### 静态链接
函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。

在我们的实际开发中，代码会有多个源文件，而且多个源文件之间不是独立的，而会存在多种依赖关系，如一个源文件可能要调用另一个源文件中定义的函数，**但是每个源文件都是独立编译的，即每个 `*.c` 文件会形成一个 `*.o` 文件，为了满足前面说的依赖关系，则需要将这些源文件产生的目标文件进行链接，从而形成一个可以执行的程序**。这个链接的过程就是**静态链接**  

##### 静态链接原理

由很多目标文件进行链接形成的是静态库，反之静态库也可以简单地看成是一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件，如下图，使用 ar 命令的 - a 参数查看静态库的组成：

![](https://img-blog.csdn.net/20180505234059214)

以下面这个图来简单说明一下从静态链接到可执行文件的过程，根据在源文件中包含的头文件和程序中使用到的库函数，如 stdio. h 中定义的 printf () 函数，在 libc. a 中找到目标文件 printf.o (这里暂且不考虑 printf () 函数的依赖关系)，然后将这个目标文件和我们 hello. o 这个文件进行链接形成我们的可执行文件。  

![](https://img-blog.csdn.net/20180505235327609)


这里有一个小问题，就是从上面的图中可以看到**静态运行库里面的一个目标文件只包含一个函数**，如 libc. a 里面的 printf. o 只有 printf () 函数，strlen. o 里面只有 strlen () 函数。  

我们知道，链接器在链接静态链接库的时候是以目标文件为单位的。比如我们引用了静态库中的 printf () 函数，那么链接器就会把库中包含 printf () 函数的那个目标文件链接进来，如果很多函数都放在一个目标文件中，很可能很多没用的函数都被一起链接进了输出结果中。由于运行库有成百上千个函数，数量非常庞大，每个函数独立地放在一个目标文件中可以尽量减少空间的浪费，那些没有被用到的目标文件就不要链接到最终的输出文件中。  

##### 优缺点
- **运行速度快**：在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。
- **空间浪费**：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本：如多个程序中都调用了 printf () 函数，则这多个程序中都含有 printf. o
- **更新困难**：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。

#### **动态链接**
动态链接出现的原因就是为了解决静态链接中提到的两个问题，一方面是空间浪费，另外一方面是更新困难。下面介绍一下如何解决这两个问题。
##### 原理
动态链接的基本思想是**把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序**，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。

假设现在有两个程序 `program1.o` 和 `program2.o`，这两者共用同一个库 `lib.o`, 假设首先运行程序 `program1`，系统首先加载 `program1.o`，当系统发现 `program1. o` 中用到了 `lib.o`，即 `program1.o` 依赖于 `lib.o`，那么系统接着加载 `lib.o`，如果 `program1.o` 和 `lib.o` 还依赖于其他目标文件，则依次全部加载到内存中。**当 `program2` 运行时，同样的加载 `program2.o`，然后发现 `program2.o` 依赖于 `lib.o`，但是此时 `lib.o` 已经存在于内存中，这个时候就不再进行重新加载，而是将内存中已经存在的 `lib.o` 映射到 `program2` 的虚拟地址空间中，从而进行链接（这个链接过程和静态链接类似）形成可执行程序。**   

##### 优缺点
- **共享库**：即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本；
- **更新方便**：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。
- **性能损耗**：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。

据估算，动态链接和静态链接相比，性能损失大约在 5% 以下。经过实践证明，这点性能损失用来换区程序在空间上的节省和程序构建和升级时的灵活性是值得的。  

##### 动态链接地址是如何重定位的？

虽然动态链接把链接过程推迟到了程序运行时，但是在形成可执行文件时（注意形成可执行文件和执行程序是两个概念），还是需要用到动态链接库。比如我们在形成可执行程序时，发现引用了一个外部的函数，此时会检查动态链接库，发现这个函数名是一个动态链接符号，此时可执行程序就不对这个符号进行重定位，而把这个过程留到装载时再进行。
#### LIB、DLL
LIB：libary 库

静态库（静态链接库）和动态库（动态链接库）都是代码共享的方式。
- **静态链接库**：在链接步骤中，连接器将从库文件取得所需的代码，复制到生成的可执行文件中，这种库称为静态库。
    - 其特点是可执行文件中包含了库代码的一份完整拷贝；
    - 缺点就是被多次使用就会有多份冗余拷贝。即静态库中的指令都全部被直接包含在最终生成的 EXE 文件中了。
    - 在 vs 中新建生成静态库的工程，编译生成成功后，只产生一个.lib 文件

- **动态连接库**：动态链接库是一个**包含可由多个程序同时使用的代码和数据**的库。
    - 动态链接提供了一种方法，使进程可以调用不属于其可执行代码的函数。函数的可执行代码位于一个 DLL 中，该 DLL 包含一个或多个已被编译、链接并与使用它们的进程分开存储的函数。
    - DLL 不是可执行文件。
    - 在 vs 中新建生成动态库的工程，编译成功后，产生一个.lib 文件和一个.dll 文件

> [!NOTE] 静态库和动态库中的 lib 的区别
> **静态库中的lib**：该LIB包含函数代码本身（即包括函数的索引，也包括实现），在编译时直接将代码加入程序当中
> 
> **动态库中的 lib**：该 LIB 包含了函数所在的 DLL 文件和文件中函数位置的信息（索引），函数实现代码由运行时加载在进程空间中的 DLL 提供

**静态链接**使用静态链接库，链接器从静态链接库 LIB 获取所有被引用函数，并将库同代码一起放到可执行文件中。
**动态链接**使用动态链接库，允许可执行模块（. dll 文件或. exe 文件）仅包含在运行时定位 DLL 函数的可执行代码所需的信息。  

**总之，lib 是编译时用到的，dll 是运行时用到的。如果要完成源代码的编译，只需要 lib；如果要使动态链接的程序运行起来，只需要 dll**。

# 一、运行原理
## 内存分区模型
C++程序在执行时，将内存大方向划分为**4 个区域**

-   **程序代码区**：存放**函数体（类的成员函数、全局函数）的二进制代码**，由操作系统进行管理的
-   **全局/静态区**：存放**全局变量和静态变量**
-   **文字常量区**：存放**常量字符串**。
-   **栈区**：由编译器自动分配释放, 存放**函数的参数值, 局部变量**等
-   **堆区**：由程序员分配和释放 (malloc/new), 若程序员不释放, 程序结束时由操作系统回收（不是数据结构中的堆）

### 程序运行前
在程序编译后，生成了 exe 可执行程序，**未执行该程序前**分为两个区域

**代码区：**
**存放 CPU 执行的机器指令**
代码区是**共享**的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可
代码区是**只读**的，使其只读的原因是防止程序意外地修改了它的指令

**全局区：**
全局变量和静态变量存放在此.
全局区还包含了常量区, 字符串常量和其他常量也存放在此.
该区域的数据在程序结束后由操作系统释放.

总结：
-   C++中在程序运行前分为全局区和代码区
-   代码区特点是共享和只读
-   全局区中存放全局变量、静态变量、常量
-   常量区中存放 const 修饰的全局常量和字符串常量
### 程序运行后
**栈区：**
由编译器自动分配释放, 存放函数的参数值, 局部变量等
注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放

**堆区：**
由程序员分配释放, 若程序员不释放, 程序结束时由操作系统回收
在 C++中主要利用 new 在堆区开辟内存

## 编译器是如何工作的

编译器实际上需要做的唯一一件事，就是将我们的文本文件拿来转换他们，转换成一种称为目标文件格式的中间格式。这些 obj 文件可以传递到链接器，这个链接器可以做它所有的要链接的事情。

编译器在生成这些 obj 时实际上做了几件事：  
首先，预处理我们的代码，这意味着所有的预处理语句都会先处理。一旦我们的代码被预处理，接下来我们将或多或少地进行记号化和解析，基本上整理成编译器能够真正理解和推理的格式。这基本上导致了所谓的抽象语法树被创建。它基本上是我们代码的一种表示，但是是抽象的语法树。一旦编译器创建了抽象语法树，它可以开始实际生成代码。这段代码就是实际的机器，我们的 CPU，将执行的代码。  
我们还得到了其他各种数据，比如一个存储所有常量、变量的地方，这基本上就是编译器所做的一切。
Aaaa
每一个 CPP 文件将产生一个目标文件，这些 CPP 文件被称为翻译单元。本质上必须意识到 C++ 不关心文件，文件不是存在于 C++ 中的东西。在 C++ 中，文件只是提供给编译器源代码的一种方式，你负责告诉编译器你输入的是什么类型的文件，以及编译器应该如何处理它。比如说把 a.cpp 改为 b.hbh，只要告诉编译器这是个 c++ 文件亦可，所以文件是没有意义的。

预处理到文件：（生成. i，但是就不生成. obj 了）  

![](1671805718710.png)

  
OBJ 为二进制文件，不易读，我们可以在 VS 中选择生成汇编：  

![](1671805718846.png)

  
默认的 Debug 优化：  

![](1671805718977.png)

  
运行时检查：  

![](1671805719168.png)

  
如果开氧气优化则会报错：

```
Error	D8016	'/O2' and '/RTC1' command-line options are incompatible	Project2
```

要把运行时检查修改为 default：  

![](1671805719276.png)

  
它基本上不会执行运行时检查。

## 链接器是如何工作的

现在链接的主要焦点是找到每个符号和函数在哪里，并把他们连接起来。应用程序需要知道入口点（entry point，一般为 main）在哪里，当你实际运行你的应用程序的时候，C++ 运行时库（run time library）会说：这是 main 函数，我要跳到这里，然后开始执行代码。

在 VS 中按下 ctrl + F7，只有编译会发生，链接将永远不会发生。但是如果是 build 或者是 F5 运行，它会编译然后链接。

语法错误（syntax error）以 C 打头（compile），告诉我们错误在编译阶段。LNK 则代表链接 link，告诉我们错误在链接阶段。

自定义 entry point（一个 exe 一定有 entry point）：  

![](1671805719404.png)

  
链接错误：  
未解决的外部符号 unresolved external symbol——当链接器找不到它需要的东西时发生。（如果从来没调用某个函数，则根本无需链接）  

![](1671805719540.png)

  
如上图，在一段程序中，如果我们在函数中调用 Log，但是 main 中并没有调用 multiply，如果 log 没有被链接器找到，则仍然会报错——因为 multiply 函数是有可能被别的翻译单元调用的！因此仍然需要进行链接。  
那么只要我们让 multiply 函数变为 static 的，即 static int Multiply (int a, int b)，那么这就表明这个函数只被声明在这个翻译单元中。因此即使 Log 函数在其他翻译单元是没有定义的，由于其只存在于 Multiply 中，而 Multiply 是 static 的且当前翻译单元未被调用，就表明 Multiply 从来没有被调用过！因此无需链接，也就不会得到任何链接错误。

当然，重复定义，会让链接器不知道链接到哪一个函数，因此也会出错。比如在一个头文件中定义了一个函数：  

![](1671805719690.png)

  
而在 Log. cpp 和 Math. cpp 中都调用了 Log 函数并且包含了 Log. h 头文件（注意，头文件 include 仅仅是把头文件内容复制粘贴过来而已），那么由于各自为翻译单元，有两个 Log 函数的定义存在，链接器仍然将不知道去调用哪个函数，会出现错误：

```
。。。。。 already defined in Log.obj
```

告诉我们 Log 函数已经在 log. obj 被定义了。

修复措施：

1.  static  
    表明头文件代码贴进来的时候，这个函数只是文件的内部函数，所以 Log. cpp 和 Math. cpp 都有他们各自的 Log 函数且对其他的 obj 文件不可见。  
    
    ![](1671805719815.png)
    
2.  inline  
    inline 的意思是获取我们实际的函数体并将函数调用替换为函数体（直接贴进去）。
3.  放到其他的翻译单元中，头文件只声明

链接器需要带走我们所有的目标文件，并将它们链接在一起。它也将拉进我们可能用到的其他任何其他库，例如 C run time library、C++ 标准库、平台的 api 等等，从许多不同的地方 linking 是很常见的。

还有其他不同的链接：静态链接和动态链接（第 49 节课和第 50 节课，动态库 dll 静态库 lib）


## 在 Visual Studio 中调试代码

断点和读取内存——这是调试的两大部分。当然会同时使用，换句话说你要设置断点就是为了读取内存。

断点 break point 是程序中调试器将中断的点。这里 break 的意思是暂停。当我们的程序执行到断点处时它将暂停。在我们这个例子的整个项目中它会挂起执行线程，让我们来看看这个程序的 state。说到 state，cherno 指的是内存，我们可以暂停程序看看它的内存中发生了什么。

一个运行中的程序所需的内存是相当大的，包括你设置的每个变量、要调用的函数等等。当你将程序中断后，内存数据实际上还在，能查看内存对诊断你的程序出问题的原因非常有用。通过查看内存可以看到每一个变量的值。

确保在将会被执行的代码行打上断点（空行的断点不起作用）。

visual studio：

*   step into——F11  
    进入到这行代码上的函数里面（如果这一行有一个函数的话）。
*   step over——F10  
    从当前函数跳到下一行代码。
*   step out——shift + F11  
    跳出当前函数，回到调用这个函数的位置。



![](1671805720035.png)

  
如上图这样的代码，黄色箭头表示将要执行这行代码，调试器显示的是，a 将要被设置的内存位置的数字被显示出来了。因为我们没有把这个变量设置成任何东西，它只是未初始化的内存，这意味着这个值只是给我们展示了内存中实际包含的内容。

内存视图（VS 中，alt + 6，或是 debug-Windows-memory-memory1）：  

![](1671805720148.png)
  

![](1671805720269.png)

  
最左边是内存地址以十六进制格式表示的实际值。在中间为实际的数据，右边为 ASCII 码对这些数字的解释。  
变量名取地址，即可在内存视图中找到对应位置：  

![](1671805720456.png)

  

![](1671805720675.png)
这里内存是大量的 CC，意味着它是未初始化的栈内存。


