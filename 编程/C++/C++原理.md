# 一、运行原理
## 内存分区模型
C++程序在执行时，将内存大方向划分为**4 个区域**

-   **程序代码区**：存放**函数体（类的成员函数、全局函数）的二进制代码**，由操作系统进行管理的
-   **全局/静态区**：存放**全局变量和静态变量**
-   **文字常量区**：存放**常量字符串**。
-   **栈区**：由编译器自动分配释放, 存放**函数的参数值, 局部变量**等
-   **堆区**：由程序员分配和释放 (malloc/new), 若程序员不释放, 程序结束时由操作系统回收（不是数据结构中的堆）

### 程序运行前
在程序编译后，生成了 exe 可执行程序，**未执行该程序前**分为两个区域

**代码区：**
**存放 CPU 执行的机器指令**
代码区是**共享**的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可
代码区是**只读**的，使其只读的原因是防止程序意外地修改了它的指令

**全局区：**
全局变量和静态变量存放在此.
全局区还包含了常量区, 字符串常量和其他常量也存放在此.
该区域的数据在程序结束后由操作系统释放.

总结：
-   C++中在程序运行前分为全局区和代码区
-   代码区特点是共享和只读
-   全局区中存放全局变量、静态变量、常量
-   常量区中存放 const 修饰的全局常量和字符串常量
### 程序运行后
**栈区：**
由编译器自动分配释放, 存放函数的参数值, 局部变量等
注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放

**堆区：**
由程序员分配释放, 若程序员不释放, 程序结束时由操作系统回收
在 C++中主要利用 new 在堆区开辟内存

## 编译器是如何工作的


C++ 编译器实际上需要做的唯一一件事，就是将我们的文本文件拿来转换他们，转换成一种称为目标文件格式的中间格式。这些 obj 文件可以传递到链接器，这个链接器可以做它所有的要链接的事情。

编译器在生成这些 obj 时实际上做了几件事：  
首先，预处理我们的代码，这意味着所有的预处理语句都会先处理。一旦我们的代码被预处理，接下来我们将或多或少地进行记号化和解析，基本上整理成编译器能够真正理解和推理的格式。这基本上导致了所谓的抽象语法树被创建。它基本上是我们代码的一种表示，但是是抽象的语法树。一旦编译器创建了抽象语法树，它可以开始实际生成代码。这段代码就是实际的机器，我们的 CPU，将执行的代码。  
我们还得到了其他各种数据，比如一个存储所有常量、变量的地方，这基本上就是编译器所做的一切。
Aaaa
每一个 CPP 文件将产生一个目标文件，这些 CPP 文件被称为翻译单元。本质上必须意识到 C++ 不关心文件，文件不是存在于 C++ 中的东西。在 C++ 中，文件只是提供给编译器源代码的一种方式，你负责告诉编译器你输入的是什么类型的文件，以及编译器应该如何处理它。比如说把 a.cpp 改为 b.hbh，只要告诉编译器这是个 c++ 文件亦可，所以文件是没有意义的。

预处理到文件：（生成. i，但是就不生成. obj 了）  

![](1671805718710.png)

  
OBJ 为二进制文件，不易读，我们可以在 VS 中选择生成汇编：  

![](1671805718846.png)

  
默认的 Debug 优化：  

![](1671805718977.png)

  
运行时检查：  

![](1671805719168.png)

  
如果开氧气优化则会报错：

```
Error	D8016	'/O2' and '/RTC1' command-line options are incompatible	Project2
```

要把运行时检查修改为 default：  

![](1671805719276.png)

  
它基本上不会执行运行时检查。

## 链接器是如何工作的

现在链接的主要焦点是找到每个符号和函数在哪里，并把他们连接起来。应用程序需要知道入口点（entry point，一般为 main）在哪里，当你实际运行你的应用程序的时候，C++ 运行时库（run time library）会说：这是 main 函数，我要跳到这里，然后开始执行代码。

在 VS 中按下 ctrl + F7，只有编译会发生，链接将永远不会发生。但是如果是 build 或者是 F5 运行，它会编译然后链接。

语法错误（syntax error）以 C 打头（compile），告诉我们错误在编译阶段。LNK 则代表链接 link，告诉我们错误在链接阶段。

自定义 entry point（一个 exe 一定有 entry point）：  

![](1671805719404.png)

  
链接错误：  
未解决的外部符号 unresolved external symbol——当链接器找不到它需要的东西时发生。（如果从来没调用某个函数，则根本无需链接）  

![](1671805719540.png)

  
如上图，在一段程序中，如果我们在函数中调用 Log，但是 main 中并没有调用 multiply，如果 log 没有被链接器找到，则仍然会报错——因为 multiply 函数是有可能被别的翻译单元调用的！因此仍然需要进行链接。  
那么只要我们让 multiply 函数变为 static 的，即 static int Multiply (int a, int b)，那么这就表明这个函数只被声明在这个翻译单元中。因此即使 Log 函数在其他翻译单元是没有定义的，由于其只存在于 Multiply 中，而 Multiply 是 static 的且当前翻译单元未被调用，就表明 Multiply 从来没有被调用过！因此无需链接，也就不会得到任何链接错误。

当然，重复定义，会让链接器不知道链接到哪一个函数，因此也会出错。比如在一个头文件中定义了一个函数：  

![](1671805719690.png)

  
而在 Log. cpp 和 Math. cpp 中都调用了 Log 函数并且包含了 Log. h 头文件（注意，头文件 include 仅仅是把头文件内容复制粘贴过来而已），那么由于各自为翻译单元，有两个 Log 函数的定义存在，链接器仍然将不知道去调用哪个函数，会出现错误：

```
。。。。。 already defined in Log.obj
```

告诉我们 Log 函数已经在 log. obj 被定义了。

修复措施：

1.  static  
    表明头文件代码贴进来的时候，这个函数只是文件的内部函数，所以 Log. cpp 和 Math. cpp 都有他们各自的 Log 函数且对其他的 obj 文件不可见。  
    
    ![](1671805719815.png)
    
2.  inline  
    inline 的意思是获取我们实际的函数体并将函数调用替换为函数体（直接贴进去）。
3.  放到其他的翻译单元中，头文件只声明

链接器需要带走我们所有的目标文件，并将它们链接在一起。它也将拉进我们可能用到的其他任何其他库，例如 C run time library、C++ 标准库、平台的 api 等等，从许多不同的地方 linking 是很常见的。

还有其他不同的链接：静态链接和动态链接（第 49 节课和第 50 节课，动态库 dll 静态库 lib）




## 预处理器

确保头文件多次包含仍能安全工作的常用技术是**预处理器**，预处理器是在编译之前执行的一段程序，任何以 # 开头的东西，都被称为预处理器命令或者预处理器指令。如 #include ，当预处理器看到 #include标记时就会用指定的头文件内容代替 #include 。

### 头文件保护符

下面来说 `# pargma once`

pragma 本质上是一个被发送到编译器或预处理器的预处理指令。
**pargma once 阻止我们单个头文件多次被 include 在同一个 cpp 文件里。**

```c++ nums
//新方法
#pargma once

//旧方法
#ifndef  _PROJECT_A
#define  _PROJECT_A
...
#endif
```

**有的 include 是 <> 有的是“”，原因是**：  
当我们编译程序的时候，它们有两种不同的含义，我们有能力告诉编译器，包含文件的路径是什么。  
如果我们要包含的文件是在其中的一个文件夹里（在包含路径文件夹里），我们可以使用尖括号在所有 include 路径里搜索文件； 
而引号用于 include 文件存在于该文件的相对位置（相对路径），现在也有尖括号的功能，所以作用范围更大。

**所以尖括号只用于编译器包含路径，引号可以做一切。不过 cherno 一般引号中都是只用当前路径，即不用…/ 啥的，其他都是用尖括号。**  
建议：如果包含了一些 visual studio 解决方案之外的东西，就会用尖括号，也就是一些完全与项目无关的外部依赖项。
而像 `#include <iostream>`，iostream 其实是一个文件（虽然没有后缀。。）这是写 C++ 标准库的人决定要这样做的。将 C++ 标准库与 C 标准库进行区分。（有没有. h，如 stdlib. h，这是一种区分 C 标准库和 C++ 标准库的方法）
### 宏 macro 
#define #宏 #macro
1. **预处理阶段** ：当编译 C++ 代码时，首先**预处理器**会过一遍 C++ 所有的**以 # 符号开头（这是预编译指令符号）的语句，当预编译器将这些代码评估完后给到编译器去进行实际的编译**。

2. **宏和模板的区别**：**发生时间**不同，宏是在**预处理阶段**就被评估了，而模板会被评估的更晚一点。

3. **用宏的目的：**写一些宏将代码中的文本**替换**为其他东西（**纯文本替换**）（不一定是简单的替换，是可以自定义调用宏的方式的）

```c++ nums
#defind WAIT std::cin.get()
//这里可以不用放分号，如果放分号就会加入宏里面了
int main() {
    WAIT;
    //等效于std::cin.get()，属于纯文本替换
    //但单纯做这种操作是很愚蠢的，除了自己以外别人读代码会特别痛苦
}
```

4. 宏的用法之一：**宏是可以发送参数的**

```c++ nums
#include <iostream>
//宏是可以传递参数的，虽然参数也是复制粘贴替换上去的，并没有像函数那样讲究
#define log(x) std::cout << x << std::endl
int main() {
    log("hello");
    //这样子会输出“hello”
    return 0;
}
```

5. 宏可以辅助调试

在 Debug 模式下会有很多日志的输出，但是在 Release 模式下就不需要日志的输出了。正常的方法可能会删掉好多的输出日志的语句或者函数，**但是用宏可以直接取消掉这些语句**

利用宏中的 `#if，#else`，`endif` 来实现。如：

```c++ nums
#include <iostream>

#defind PR_DEBUG 1 //可以在这里切换成0，作为一个开关
#if PR_DEBUG == 1   //如果PR_DEBUG为1
#defind LOG(x) std::cout << x << std::endl  //则执行这个宏
#else   //反之
#defind LOG(x)   //这个宏什么也不定义，即是无意义
#endif    //结束

int main() {
    LOG("hello");
    return 0;
}
```

如果在 Debug (PR_DEBUG == 1) 模式下，则会打印日志，如果在 Release (PR_DEBUG == 0) 模式，则在**预处理阶段就会把日志语句给删除掉**。

利用 `#if 0` 和 `#endif` 删除一段宏.

```c++ nums
#include <iostream>

#if 0   //从这里到最后的endif的宏都被无视掉了，某种意义上的删除

#defind PR_DEBUG 1 
#if PR_DEBUG == 1 
#defind LOG(x) std::cout << x << std::endl 
#else 
#defind LOG(x) 
#endif 

#endif  //结束

int main() {
    LOG("hello");
    return 0;
}
```

## 在 Visual Studio 中调试代码

断点和读取内存——这是调试的两大部分。当然会同时使用，换句话说你要设置断点就是为了读取内存。

断点 break point 是程序中调试器将中断的点。这里 break 的意思是暂停。当我们的程序执行到断点处时它将暂停。在我们这个例子的整个项目中它会挂起执行线程，让我们来看看这个程序的 state。说到 state，cherno 指的是内存，我们可以暂停程序看看它的内存中发生了什么。

一个运行中的程序所需的内存是相当大的，包括你设置的每个变量、要调用的函数等等。当你将程序中断后，内存数据实际上还在，能查看内存对诊断你的程序出问题的原因非常有用。通过查看内存可以看到每一个变量的值。

确保在将会被执行的代码行打上断点（空行的断点不起作用）。

visual studio：

*   step into——F11  
    进入到这行代码上的函数里面（如果这一行有一个函数的话）。
*   step over——F10  
    从当前函数跳到下一行代码。
*   step out——shift + F11  
    跳出当前函数，回到调用这个函数的位置。



![](1671805720035.png)

  
如上图这样的代码，黄色箭头表示将要执行这行代码，调试器显示的是，a 将要被设置的内存位置的数字被显示出来了。因为我们没有把这个变量设置成任何东西，它只是未初始化的内存，这意味着这个值只是给我们展示了内存中实际包含的内容。

内存视图（VS 中，alt + 6，或是 debug-Windows-memory-memory1）：  

![](1671805720148.png)
  

![](1671805720269.png)

  
最左边是内存地址以十六进制格式表示的实际值。在中间为实际的数据，右边为 ASCII 码对这些数字的解释。  
变量名取地址，即可在内存视图中找到对应位置：  

![](1671805720456.png)

  

![](1671805720675.png)
这里内存是大量的 CC，意味着它是未初始化的栈内存。


# LIB、DLL
共有两种库：  
一种是 LIB 包含了函数所在的 DLL 文件和文件中函数位置的信息（入口），代码由运行时加载在进程空间中的 DLL 提供，称为**动态链接库 dynamic link library**。  
一种是 LIB 包含函数代码本身，在编译时直接将代码加入程序当中，称为**静态链接库 static link library**。  

共有两种链接方式：  
**动态链接**使用动态链接库，允许可执行模块（. dll 文件或. exe 文件）仅包含在运行时定位 DLL 函数的可执行代码所需的信息。  
**静态链接**使用静态链接库，链接器从静态链接库 LIB 获取所有被引用函数，并将库同代码一起放到可执行文件中。

**关于 lib 和 dll 的区别如下：**  
（1）lib 是编译时用到的，dll 是运行时用到的。如果要完成源代码的编译，只需要 lib；如果要使动态链接的程序运行起来，只需要 dll。  
（2）如果有 dll 文件，那么 lib 一般是一些索引信息，记录了 dll 中函数的入口和位置，dll 中是函数的具体内容；**如果只有 lib 文件，那么这个 lib 文件是静态编译出来的，索引和实现都在其中。使用静态编译的 lib 文件，在运行程序时不需要再挂动态库，缺点是导致应用程序比较大，而且失去了动态库的灵活性，发布新版本时要发布新的应用程序才行。**  
（3）动态链接的情况下，有两个文件：一个是 LIB 文件，一个是 DLL 文件。LIB 包含被 DLL 导出的函数名称和位置，DLL 包含实际的函数和数据，应用程序使用 LIB 文件链接到 DLL 文件。在应用程序的可执行文件中，存放的不是被调用的函数代码，而是 DLL 中相应函数代码的地址，从而节省了内存资源。DLL 和 LIB 文件必须随应用程序一起发行，否则应用程序会产生错误。如果不想用 lib 文件或者没有 lib 文件，可以用 WIN32 API 函数 LoadLibrary、GetProcAddress 装载。

**使用 lib 需注意两个文件：**  
（1）. h 头文件，包含 lib 中说明输出的类或符号原型或数据结构。应用程序调用 lib 时，需要将该文件包含入应用程序的源文件中。  
（2）. LIB 文件，略。

**使用 dll 需注意三个文件：**  
（1）. h 头文件，包含 dll 中说明输出的类或符号原型或数据结构的. h 文件。应用程序调用 dll 时，需要将该文件包含入应用程序的源文件中。  
（2）. LIB 文件，是 dll 在编译、链接成功之后生成的文件，作用是当其他应用程序调用 dll 时，需要将该文件引入应用程序，否则产生错误。如果不想用 lib 文件或者没有 lib 文件，可以用 WIN32 API 函数 LoadLibrary、GetProcAddress 装载。  
（3）. dll 文件，真正的可执行文件，开发成功后的应用程序在发布时，只需要有. exe 文件和. dll 文件，并不需要. lib 文件和. h 头文件。

**使用 lib 的方法：**  
静态 lib 中，一个 lib 文件实际上是任意个 obj 文件的集合，obj 文件是 cpp 文件编译生成的。在编译这种静态库工程时，根本不会遇到链接错误；即使有错，也只会在使用这个 lib 的 EXT 文件或者 DLL 工程里暴露出来。  
在 VC 中新建一个 static library 类型的工程 Lib，加入 test. cpp 文件和 test. h 文件（头文件内包括函数声明），然后编译，就生成了 Lib. lib 文件。  
别的工程要使用这个 lib 有两种方式：  
（1）在 project->link->Object/Library Module 中加入 Lib. lib 文件（先查询工程目录，再查询系统 Lib 目录）；或者在源代码中加入指令 
```c++ nums
#pragma comment (lib, “Lib. lib”)
```
（2）将 Lib. lib 拷入工程所在目录，或者执行文件生成的目录，或者系统 Lib 目录中。  
（3）加入相应的头文件 test. h。

使用 DLL 的方法：  
使用动态链接中的 lib，不是 obj 文件的集合，即里面不会有实际的实现，它只是提供动态链接到 DLL 所需要的信息，这种 lib 可以在编译一个 DLL 工程时由编译器生成。  
创建 DLL 工程的方法（略）。  
**（1）隐式链接**  
第一种方法是：通过 project->link->Object/Library Module 中加入. lib 文件（或者在源代码中加入指令 #pragma comment (lib, “Lib. lib”)），并将. dll 文件置入工程所在目录，然后添加对应的. h 头文件。
```c++ nums
#include "stdafx.h"  
#include "DLLSample.h"  
#pragma comment(lib, "DLLSample.lib") // 你也可以在项目属性中设置库的链接  
int main()  
{
	 TestDLL(123); //dll 中的函数，在 DllSample.h 中声明  
	 return(1);  
}  

```
![](<assets/1680873907645.png>)

**（2）显式链接**  
需要函数指针和 WIN32 API 函数 LoadLibrary、GetProcAddress 装载，使用这种载入方法，不需要. lib 文件和. h 头文件，只需要. dll 文件即可（将. dll 文件置入工程目录中）。
```c++ nums
#include <iostream>  
#include <windows.h> // 使用函数和某些特殊变量  
typedef void (*DLLFunc)(int);  
int main() 
{
		DLLFunc dllFunc; 
		HINSTANCE hInstLibrary = LoadLibrary("DLLSample.dll");  
		
		if (hInstLibrary == NULL)  
		{  
			 FreeLibrary(hInstLibrary);  
		}
		
		dllFunc = (DLLFunc)GetProcAddress(hInstLibrary, "TestDLL");
		  
		if (dllFunc == NULL)  
		{  
			FreeLibrary(hInstLibrary);  
		}  

		dllFunc(123);  
		std::cin.get();  
		FreeLibrary(hInstLibrary);  
		return(1);  
}  
```
LoadLibrary 函数利用一个名称作为参数，获得 DLL 的实例（HINSTANCE 类型是实例的句柄），通常调用该函数后需要查看一下函数返回是否成功，如果不成功则返回 NULL（句柄无效），此时调用函数 FreeLibrary 释放 DLL 获得的内存。  
GetProcAddress 函数利用 DLL 的句柄和函数的名称作为参数，返回相应的函数指针，同时必须使用强转；判断函数指针是否为 NULL，如果是则调用函数 FreeLibrary 释放 DLL 获得的内存。此后，可以使用函数指针来调用实际的函数。  
最后要记得使用 FreeLibrary 函数释放内存。

注意：应用程序如何找到 DLL 文件？  
使用 LoadLibrary 显式链接，那么在函数的参数中可以指定 DLL 文件的完整路径；如果不指定路径，或者进行隐式链接，Windows 将遵循下面的搜索顺序来定位 DLL：  
（1）包含 EXE 文件的目录  
（2）工程目录  
（3）Windows 系统目录  
（4）Windows 目录  
（5）列在 Path 环境变量中的一系列目录


.h 头文件是编译时必须的，lib 是链接时需要的，dll 是运行时需要的。

附加依赖项的是. lib 不是. dll，若生成了 DLL, 则肯定也生成 LIB 文件。如果要完成源代码的编译和链接，有头文件和 lib 就够了。如果也使动态连接的程序运行起来，有 dll 就够了。在开发和调试阶段，当然最好都有。

.h .lib .dll 三者的关系是：

H 文件作用是: 声明函数接口 

DLL 文件作用是: 函数可执行代码 

当我们在自己的程序中引用了一个 H 文件里的函数, 编链器怎么知道该调用哪个 DLL 文件呢? 这就是 LIB 文件的作用: 告诉链接器调用的函数在哪个 DLL 中，函数执行代码在 DLL 中的什么位置，这也就是为什么需要附加依赖项 .LIB 文件，它起到桥梁的作用。如果生成静态库文件，则没有 DLL ，只有 lib，这时函数可执行代码部分也在 lib 文件中

目前以 lib 后缀的库有两种，一种为静态链接库 (Static Libary，以下简称“静态库”)，另一种为动态连接库 (DLL，以下简称“动态库”) 的导入库 (Import Libary，以下简称“导入库”）。静态库是一个或者多个 obj 文件的打包，所以有人干脆把从 obj 文件生成 lib 的过程称为 Archive，即合并到一起。比如你链接一个静态库，如果其中有错，它会准确的找到是哪个 obj 有错，即静态 lib 只是壳子。动态库一般会有对应的导入库，方便程序静态载入动态链接库，否则你可能就需要自己 LoadLibary 调入 DLL 文件，然后再手工 GetProcAddress 获得对应函数了。有了导入库，你只需要链接导入库后按照头文件函数接口的声明调用函数就可以了。导入库和静态库的区别很大，他们实质是不一样的东西。静态库本身就包含了实际执行代码、符号表等等，而对于导入库而言，其实际的执行代码位于动态库中，导入库只包含了地址符号表等，确保程序找到对应函数的一些基本地址信息。

一般的动态库程序有 lib 文件和 dll 文件。lib 文件是必须在编译期就连接到应用程序中的，而 dll 文件是运行期才会被调用的。如果有 dll 文件，那么对应的 lib 文件一般是一些索引信息，具体的实现在 dll 文件中。如果只有 lib 文件，那么这个 lib 文件是静态编译出来的，索引和实现都在其中。静态编译的 lib 文件有好处：给用户安装时就不需要再挂动态库了。但也有缺点，就是导致应用程序比较大，而且失去了动态库的灵活性，在版本升级时，同时要发布新的应用程序才行。在动态库的情况下，有两个文件，而一个是引入库（. LIB）文件，一个是 DLL 文件，引入库文件包含被 DLL 导出的函数的名称和位置，DLL 包含实际的函数和数据，应用程序使用 LIB 文件链接到所需要使用的 DLL 文件，库中的函数和数据并不复制到可执行文件中，因此在应用程序的可执行文件中，存放的不是被调用的函数代码，而是 DLL 中所要调用的函数的内存地址，这样当一个或多个应用程序运行是再把程序代码和被调用的函数代码链接起来，从而节省了内存资源。从上面的说明可以看出，DLL 和. LIB 文件必须随应用程序一起发行，否则应用程序将会产生错误。

静态库和共享库都是一个 obj 文件的集合，但静态链接后，执行程序中存在自己所需 obj 的一份拷贝，而动态链接后，执行程序仅仅是包含对共享库的一个引用。共享库相当于一个由多个 obj 文件组合而成的 obj 文件，在链接后其所有代码被加载，不管需要的还是不需要的。  
似乎可以得出一个结论：  
 静态链接后的程序比动态链接的所用存储空间大，因为执行程序中包含了库中代码拷贝；  
 而动态链接的程序比静态链接的所用的运行空间大，因为它将不需要的代码也加载到运行空间。

  
针对上面的知识 2 个问题：1） DLL 和. LIB 文件必须随应用程序一起发行，否则应用程序将会产生错误。我的答案：lib 应该不需要吧。2）如果是某个程序中调用了一个动态库（通过 header 文件，lib+dll 来调用），则对动态库的某个函数的内容修改了，但接口不改，则调用此动态库的程序需重新编译连接吗？如果是通过 loadlibary 动态加载，需要重新编译连接吗？  

我的答案：通过 header+lib+dll 调用的话需要重新编译连接，但是通过 loadlibrary 来使用的话，不需要重新编译连接。

第 2 个答案错了应该是不需要重新编译接口不变的话 .lib 都不用更新  
From: 

[ http://www.cppblog.com/mzty/archive/2010/11/28/134901.html

 1） 节省内存。同一个软件模块，若是以源代码的形式重用，则会被编译到不同的可执行程序中，同时运行这些 exe 时这些模块的二进制码会被重复加载到内存中。如果使用 dll, 则只在内存中加载一次，所有使用该 dll 的进程会共享此块内存（当然，像 dll 中的全局变量这种东西是会被每个进程复制一份的）。  
   
 2） 不需编译的软件系统升级，若一个软件系统使用了 dll, 则该 dll 被改变（函数名不变）时，系统升级只需要更换此 dll 即可，不需要重新编译整个系统。事实上，很多软件都是以这种方式升级的。例如我们经常玩的星际、魔兽等游戏也是这样进行版本升级的。  
   
 3） Dll 库可以供多种编程语言使用，例如用 c 编写的 dll 可以在 vb 中调用。这一点上 DLL 还做得很不够，因此在 dll 的基础上发明了 COM 技术，更好的解决了一系列问题。

]( http://www.cppblog.com/mzty/archive/2010/11/28/134901.html )