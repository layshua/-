# 平移、缩放、旋转
## 平移
![[AP01_L19_7.jpg]]
对于 sin 函数，乘 2PI 让括号内的值域为[0~2PI]，这样 sin 值域才能成为[-1~1]，走完一个周期。
```less
Shader "Unlit/Translation"  
{  
    Properties  
    {  
        _MainTex ("RGB：颜色 A：透贴", 2D) = "white" {}  
         _Opacity    ("透明度", range(0, 1))     = 0.5  
        _MoveRange("移动范围", range(0.0,3.0)) = 1.0  
        _MoveSpeed("移动速度", range(0.0,3.0)) = 1.0  
    }  
    SubShader  
    {  
        Tags   
{   "Queue" = "Transparent"             //调整渲染顺序  
            "RenderType"="Transparent"    //对应改为Cutout  
            "ForceNoShadowCasting" = "True"     //关闭阴影投射  
            "IgnoreProjector" = "True"          //不响应投射器  
        }  
  
        Pass  
        {  
            Name "FORWARD"  
            Tags  
            { "LightMode" = "ForwardBase" }  
              
            Blend One OneMinusSrcAlpha  
              
            CGPROGRAM  
            #pragma vertex vert  
            #pragma fragment frag  
            #pragma  multi_compile_fwdbase_fullshadows  
            #include "UnityCG.cginc"  
  
            struct appdata  
            {  
                float4 vertex : POSITION;  
                float2 uv : TEXCOORD0;  
            };  
  
            struct v2f  
            {  
                float4 pos : SV_POSITION;  
                float2 uv : TEXCOORD0;  
            };  
  
            sampler2D _MainTex;  
            float4 _MainTex_ST;  
            float _Opacity;  
            float _MoveRange;  
            float _MoveSpeed;  
  
            //平移方法  
            //text
			   //inout是CG语言的一种"引用传递"方式,形参既用于输入时初始化，也用于输出数据 
            void Translation(inout float3 vertex)  
            {  
                vertex.y += _MoveRange * sin(frac(_Time.z * _MoveSpeed) * UNITY_TWO_PI);  
            }  
            v2f vert (appdata v)  
            {  
                v2f o;  
                Translation(v.vertex.xyz);  
                o.pos = UnityObjectToClipPos(v.vertex);  
                o.uv = TRANSFORM_TEX(v.uv, _MainTex);  
                return o;  
            }  
  
            fixed4 frag (v2f i) : SV_Target  
            {  
                float4 MainTex = tex2D(_MainTex, i.uv);  
                float3 finalColor = MainTex.rgb;  
                float opacity = MainTex.a * _Opacity;  
                return float4(finalColor, opacity);  
            }  
            ENDCG  
        }  
    }  
}
```
## 缩放
为了防止朝负方向缩放，+1.0 作为基础值，使原点永远乘以正值
```less
void Scale(inout float3 vertex)  
{  
    vertex.xyz *= 1.0 + _ScaleRange * sin(frac(_Time.z * _ScaleSpeed) * UNITY_TWO_PI);  
}
```
## 旋转
```less
// 旋转方法  
void Rotate(inout float3 vertex)  
{  
    //计算旋转角度  
    float angleY = _RotateRange * sin(frac(_Time.z * _RotateSpeed) * UNITY_TWO_PI);  
    //角度转为弧度  
    float radY = radians(angleY);  
  
    //sincos()方法节省性能，效果相同  
    //float sinY = sin(radY);  
    //float cosY = cos(radY);    float sinY, cosY = 0;  
    sincos(radY, sinY, cosY);  
  
    // 这里就是应用旋转公式  
    vertex.xz = float2(  
        vertex.x * cosY - vertex.z * sinY,  
        vertex.x * sinY + vertex.z * cosY  
    );  
}
```
## 综合案例
美术向：blender 刷模型顶点色（待学习）
![[AP01_L19_25.jpg]]
![[AP01_L19_26.jpg]]
![[Pasted image 20221022230537.png]]
1. 通过顶点色作为 Mask 来对模型的不同部位做不同的顶点运动
2. 通过给定 sin 函数的初相角达到运动超前/滞后的效果
```less
Shader "AP1/L19/AnimGhost" {
	Properties{
        _MainTex ("RGB：颜色 ； A：透贴" , 2D) = "white"{}
		_Opacity ("不透明度" , range( 0.0 , 1.0 )) = 1.0
        _ScalePara ("天使圈缩放 ；x:范围 ， y：速度 ， z：校正" , Vector) = (0.5 , 3.0 , 0.0 , 0.0)
        _MoveParaX ("身体x轴移动 ； x:范围 ，y:速度 ，z：波长" , Vector) = (1.0 , 3.0 , 1.0 , 0.0)
        _MoveParaZ ("身体z轴移动 ； x:范围 ，y:速度 ，z：波长" , Vector) = (1.0 , 3.0 , 1.0 , 0.0) 
        _MoveParaY ("全身y轴起伏 ； x:范围 ，y:速度 ，z：滞后" , Vector) = (1.0 , 3.0 , 0.0 , 0.0) 
        _RotParaY  ("头部旋转 ； x:范围 ， y:速度 ， z:滞后" , Vector)   = (30.0 , 3.0 , 0.0 , 0.0)
	}
	SubShader{
		Tags {
			"Queue" = "Transparent"              //渲染队列3000
            "RenderType" = "Transparent"         //把Shader归入到提前定义的组(这里是Transparent组)
                                                 //以指明该Shader使用了透明度测试
                                                 //RenderType标签通常被用于着色器替换功能
            "IgnoreProjector" = "True"           //shader不会受到投影器(Projectors)的影响
            "ForceNoShadowCasting" = "True"      //关闭阴影投射

		}
		Pass {
			Name "FORWARD"
			Tags {
				"LightMode" = "ForwardBase"
			}
			ZWrite Off
            Blend One OneMinusSrcAlpha          //修改混合方式


			CGPROGRAM
			#pragma vertex vert
			#pragma fragment frag
			#include "UnityCG.cginc"
			#pragma multi_compile_fwdbase_fullshadows
			#pragma target 3.0

            uniform sampler2D _MainTex; uniform float4 _MainTex_ST;
			uniform half _Opacity;
            uniform float3 _ScalePara;
            uniform float3 _MoveParaX;
            uniform float3 _MoveParaZ;
            uniform float3 _MoveParaY;
            uniform float3 _RotParaY;

			struct VertexInput {
				float4 vertex  : POSITION;
                float2 uv0     : TEXCOORD0;
                float4 color0  : COLOR;
			};
			struct VertexOutput {
				float4 pos : SV_POSITION;
                float2 uv0 : TEXCOORD0;
                float4 color0  : COLOR;
			};

            //【宏定义】------------
            #define Two_PI 6.2831852
            //【动画函数】---------
            void AnimGhost(inout float3 vertex , inout float3 color)
            {   
                //【天使圈缩放】
                float scale = _ScalePara.x * color.g * sin(frac(_Time.y * _ScalePara.y) * Two_PI);  //缩放值,color.g作为遮罩,因为该模型g通道只有绿色部位有值，其他部位为0，所以起到只缩放绿色部位的效果。
                vertex *= 1.0 + scale;              //缩放顶点
                vertex.y -= _ScalePara.z * scale;   //因为天使圈位置不再模型的中心，所以y轴增加一个校正偏移；放大时，减小y值，缩小时，增大y值。当_ScalePara.z设置为天使圈到模型原点的高度时，天使圈正好为中心缩放
                //【身体摇摆：正弦运动】
                float moveX = _MoveParaX.x * sin(frac(_Time.x * _MoveParaX.y) * Two_PI + vertex.y * _MoveParaX.z);  //x移动，vertex.y * _MoveParaX.z是根据顶点高度确定不同的初相角，实现正弦波运动路径效果
                float moveZ = _MoveParaZ. x * sin (frac (_Time. x * _MoveParaZ. y) * Two_PI + vertex. y * _MoveParaZ. z);  //z 移动，vertex. y * _MoveParaX. z 是根据顶点高度确定不同的初相角，实现正弦波运动路径效果
                vertex. xz += float2 (moveX , moveZ) * color. r;       //顶点左右和前后正弦运动
                //【摇头动画：天使圈相对于头有个惯性滞后性】
                //角度计算:  (1.0 - color.r)作为Mask；color.g * _RotParaY.z使天使圈滞后头部运动，_RotParaY.z设为0.5则正好差半个周期
                float radianY  = radians(_RotParaY.x * (1.0 - color.r) * sin(frac(_Time.x * _RotParaY.y - color.g * _RotParaY.z) * Two_PI ));	
                //角度应用
                float sin_radianY , cos_radianY = 0.0;			
				sincos(radianY , sin_radianY , cos_radianY);	//计算三角函数
                float2x2 Rotate_Matrix_Y = float2x2(cos_radianY , sin_radianY , -sin_radianY , cos_radianY);    //旋转矩阵
				vertex.xz = mul(Rotate_Matrix_Y , float2(vertex.x , vertex.z));     //旋转变换
                //【整体上下移动:天使圈同样有滞后性，】
                float moveY = _MoveParaY.x * sin(frac(_Time.x * _MoveParaY.y - color.g * _MoveParaY.z) * Two_PI);   //移动值，_MoveParaY.z=0.5时正好差半个周期
                vertex.y += moveY;
                //【新顶点色计算】
                float lightness = 1.0 + color.g * scale;            //天使圈变大，天使圈部分的顶点色变亮
                color = float3(lightness , lightness , lightness);        //更新顶点色
            }

			VertexOutput vert(VertexInput v) {
				VertexOutput o = (VertexOutput)0;
                    AnimGhost(v.vertex.xyz , v.color0.rgb);      //调用动画函数，输入的顶点色作为遮罩
                    o.pos = UnityObjectToClipPos(v.vertex);
                    o.uv0 = v.uv0 * _MainTex_ST.xy + _MainTex_ST.zw;
                    o.color0 = v.color0;                         //传递新的顶点色，用于片元着色器
				return o;
			}

			float4 frag(VertexOutput i) : SV_TARGET {
                half4 var_MainTex = tex2D(_MainTex , i.uv0);	
                half3 finalRGB = var_MainTex.rgb * i.color0.rgb;    //乘顶点色
				half opacity = 	var_MainTex.a * _Opacity;
				return float4(finalRGB * opacity , opacity);	        
			}
				ENDCG
		}
	}
		FallBack "Diffuse"						
}
```