主要内容：**预计算glossy材质下的环境光照 和 通过RSM算法来实现全局光照**

本文是闫令琪教授所教授的 Games-202:Real-Time High Quality Rendrting 学习笔记的第七讲 Real-Time Global Illumination (In 3D)，本人属于新手上路暂无驾照，有错误欢迎各位大佬指正.

[GAMES202 - 高质量实时渲染_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1YK4y1T7yY?p=7)

在上节课我们讲了如何在已知环境光照和物体的 brdf 是 Diffuse 的情况下通过 prt 计算出任意一个 shading point 在考虑 shadow 后的 shading result.

**注意: 此处的 shading point 指的是几何形体上的 vertex.**

PRT 预计算了两部分, 一部分是 lighting 项, 一部分是除了 lighting 项以外的部分, 称其为 light transports 项.

1.brdf 是 diffuse 相当于是一个常数, 因此可以提到外面.

2. 由于环境光照是一个球面函数, 因此可以用 sh 基函数的线性组合表示, 把其代入, 由于 li 相对于积分是一个常数, 可以提出.

![[55e2bf0d2c1bdf006c6b11d82d1b1b80_MD5.jpg]]

3. 剩下的 light transport 项也可以看作一个球面函数, 现如今积分里剩基函数和球面函数, 相当于函数投影到基函数求系数, 因此变为了一个系数.

![[4fad000ebf556bbbd55c223f51a5e33f_MD5.jpg]]

最终我们在任意一个 shading point 点求得的 shading result, 在实际计算时只是 lighting 项投影到 sh 基函数上求得的 li 系数组成的 vector 和 Light transport 项投影到 SH 基函数上求得的 Ti 系数组成的 vector 做了个点乘而已.

在实际运算时, 我们对每个顶点预计算出它的 shading result, 三角形内部任一点则通过插值得到它的 shading result, 这种叫做 **per vertex shading.**

或者我们在三角形内部先插值好 lighting 的 vector 和 light transport 的 vector, 然后再去计算 pixel 上的 shading result, 这种叫做 **per pixel shading.**

今天首先我们从另外一个角度重新来看，怎么对 Light transport 做预计算:

1.  理解一：上节课是我们先把 Light 写成基函数的表示方法，把 Light 的系数拆分出去，然后剩下的部分看做把 Light transport 投影到基函数上得到系数, 最后做一个点乘得到 Shading result.
2.  理解二：直接把渲染方程中的 lighting 和 light transport，都用 sh 基函数表示

![[c6450df99ee2b7d79ca6f68cc5107d77_MD5.png]]

![[88e26056ab59c43a80329cf67d04bf34_MD5.jpg]]

然后把两个都展开成求和，然后把求和符号拆出去，然后就变成了一个双重求和的结果, 每个求和要乘三样东西:

1. 对应的两个系数

2. 积分值 (**积分与实际场景无关, 是两个基函数的 product integral**)

这样就会发现这样推导的结果与上一节课的结果不太一样  

![[2df86ca763eb4e3d3dc9ec6d52278250_MD5.jpg]]

如果基函数的个数为 n 的话, 做一个向量点乘的复杂度应该是 O(n), 为什么在这里是双重求和变成了 O( $n^{2}$ ) 了呢?

这是因为 SH 具有正交性, 也就是当 p=q 时候,$B_p(w_i)B_q(w_i)$ 才不为 0，也就是这个二维矩阵上只有对角线上有值, 因此只需要计算对角线上的值就行了, 所以算法复杂度仍然是 O(N)。

## **对于 glossy 的物体做预计算**

Diffuse 和 glossy 的区别在于, diffuse 的 brdf 是一个常数, 而 glossy 的 brdf 是一个 4 维的 brdf(2 维的输入方向, 2 维的输出方向).

如果仍然按照上面的办法投影到 sh 上会出现一些问题, 因为 light transport 包含 visibility 和 brdf,brdf 又是一个 4 维的函数 (关于 i 和 o 的函数), 给一个 O 就会有一个不同的 brdf, 给定一个任意的观察方向 O,light transport 都会投影出一组完全不同的 VECTOR, 且 vector 中的每一个元素都是一个 o 的函数.

或者直观一点来说, glossy 物体有一个很重要的性质, 它是和视点有关的. diffuse 的物体不管视角如何旋转改变, 你看到的 Shading point 的 result 是不会改变的, 因为整个 Diffuse shading 和视角是无关的.

但是 glossy 不是这样的, glossy 是和视角有关的, 不同的视角得到的 shading result 也是不一样的, 因此 O 不一样, L(O) 也不一样. 所以即使 light transport 即使投影到了 i 方向上的基函数, 所得到的仍然是一个关于 O 的函数而不是系数.

![[78686bf8b9d89767e43a76acec4cface_MD5.jpg]]

我们将 4D 的函数投影在 2D 上之后, 虽然得到的是一个关于 O 的函数, 但是现在这个函数也只是关于 O 了, 因此我们在 O 的方向上将其投影到 SH 基函数上.

![[c1749010897ff2a894f8cd37080803f6_MD5.jpg]]

![[7c0a3f056325931521d0ab844a808a52_MD5.jpg]]

因此, light transport 上就不再认为得到的是向量了, 而是一个矩阵, 也就是对于任意一个 O 都会得到一串 VECTOR, 最后把所有不同 O 得到的 VECTOR 摆在一起, 自然而然就形成了一个矩阵.

或者这样理解, 我们最后得到的是不同方向上的 radiance, 自然而然是一个向量, 我们将 lighting 投影到 SH 上得到的是一个向量, 只有向量 * 矩阵 得到的结果才是向量, 因此这里只能是矩阵.

可想而知, 这样的话将会产生巨大的存储.

![[7ca5cc47908a71915da9ea5a87be01ac_MD5.jpg]]

正常情况下人们会用多少阶的基函数呢？

基函数个数：9 个（三阶）16（四阶）25 个（五阶）

我们以四阶为例:

Diffuse 物体：每个点需要两个长度为 16 的向量点乘；(diffuse 情况下一般三阶就足够了)

Glossy 物体：每个点需要 16 阶向量与 16*16 矩阵乘。(一般需要高阶一点)

![[c4e184988c86b6dbbb4594ebee4398c3_MD5.jpg]]

这里看出来 PRT Glossy 比 Diffuse 效率要差很多, 而当 Glossy 非常高频的时候, 也就是接近镜面反射的情况的时候, PRT 就没有那么好用，我们虽然可以采用更高阶的 SH 来描述高频信息, 但是使用 SH 甚至远不如直接采样方便。

图二中脚下关于阴影的遮挡充分考虑了 visibility（也就是考虑了阴影）效果就非常好；

图三考虑了多次光线 Bounce 的结果。

**那么怎样考虑把多次 bounce 当作 Light transport 的一部分呢？**

我们可以用一系列的表达式来描述不同光线传播的路径都是一种什么类。

区分材质区分为三种：

1.  Diffuse
2.  Specular 镜面反射
3.  Glossy 介于两者之间

![[aacc4f6b9dfda6d4d9f5b7d812ccb1b4_MD5.jpg]]

1.  LE：Light 直接到眼镜；
2.  LGE：light 打到 Glossy 物体然后到眼镜。
3.  LGGE：多 bounce 一次, 就是 light 先打到壶嘴, 在 bounce 到壶身, 最后到 eye。(L->glossy->glossy->eye)
4.  L（D|G）E：Light 从光源出发, 打到一个物体, 可能是 diffuse 也可能是 glossy,* 表示 bounce 次数, 最后到达 EYE.
5.  LS（D|G）*E：打到 Specular 面上，然后聚焦到 Diffuse 物体上, 最后被眼睛看到。也就是 caustics.

![[cae43d8f03ed39c3f40b51e73b3f7693_MD5.jpg]]

从上面可以看出所有路径开始都是 L 最后都是 E，因此我们在运用 PRT 时候，拆分为 light 和 light transport 之后, 不管中间 boucne 几次, 我们只需要预计算算出 Light transport 就行，不论多么复杂的 bounce, 我们只需要计算出 light transport 就能得出最后的 shading result。

所以说，只要采用了 PRT 的思路，把 light 和 light transport, 不管 light transport 有多复杂, bounce 了多少次, 只要进行了预计算, 渲染时实际跑的时候是很简单的, 因为实际跑的时间是与 transport 的复杂度无关的.

**overall, 这一页只是为了告诉我们, 可以把任意复杂的 light transport 给预计算出来, 只是 light transport 越复杂在预计算时花费的时间多而实际跑时候是很快的.**

**那么怎么算呢?**

![[5211396630d7ea7e196fd9d216f205c7_MD5.jpg]]

理解方式 1：把 light transport 和 sh 基函数做了一个 **Product Integral**

理解方式 2：把 light transport 的预计算看作是一个在一些奇怪 lighting 下做的渲染过程.

如果我们把基函数看为 lighting 项, 那么这就是 rendering equation, 我们把 light transport 投影到 basis 上, 相当于用 basis 这个 Lighting 照亮物体, 每个 basis 得到一个渲染图, 最后我们进行重建从而得出最后的 shaing 值.

下图是不同 BRDF 的渲染结果:

*   各项异性的 BRDF
*   普通的 BRDF
*   不同位置 BRDF 不同的物体（BRDF 维度增加）。

![[ebb722974b587f7c459174f45de8b3a1_MD5.jpg]]

Sloan 在 02 年提出的这个方法（即 PRT），使用球谐函数估计光照和光线传输，将光照变成光照系数，将光线传输变成系数或者矩阵的形式，通过预计算和存储光线传输将渲染问题变为每个 vertex/shading point：点乘（diffuse 表面）、向量矩阵乘法（glossy 表面）。

![[684d05b78a8d2801f3c550ea4351161a_MD5.jpg]]

  
但该方法也有其缺点：

*   由于球谐函数的性质，该方法比较适合使用于低频的情况（可用于高频但不合适, 如图即使使用了 26*26 阶的 sh 仍然得不到比较好的效果）
*   当改变场景或者材质时需要重新预计算 light transport，此外预计算的数据比较大。

![[6daa4a332c22711406a2585283f39ee6_MD5.jpg]]

**更多的基函数**

此外，基函数除了可以使用球谐函数外，还有很多选择，比如 Wavelet、Zonal Harmonics、Spherical Gaussian、Piecewise Constant 等。

![[5908515c0f9c57b31cf0f0f7ff421b2f_MD5.jpg]]

这里以 Haar 小波为例，小波变换的过程就是投影过程，相比于球谐函数对低频内容友好（球谐函数使用少量的基去表示），小波变换可以全频率表示，但是只有很少的系数是非零的.

![[0fb7468b6f90d043368609c6ee75db51_MD5.jpg]]

由于小波是平面上的函数，为了防止变换后在球面上出现缝隙，所以采用了 Cubemap 来作为环境光而不是 sphereical map。

从图中可以看到, 小波变化是把每张图的高频信息留在这张图的左下, 右上和右下三部分, 而把剩余的低频信息放在左上角, 左上角的信息可以继续进行小波变换, 我们会发现高频的东西很少, 对于绝大部分来说是 0, 不断地进行小波变换可以得到一个很不错的既保留了低频又保留了高频的压缩.

![[5ab2cd5bcdc667c438b2bc3a616d5d74_MD5.jpg]]

但是小波也有自己的缺陷：不支持旋转（使用球谐函数进行表示时，由于球谐函数具有 **simple rotation** 的性质，所以支持光源的旋转）。

![[61c6d37378f1b355c791886163dd4c16_MD5.jpg]]

## Real-Time Global Illumination (in 3D)

全局光照是增强真实感的重要部分, 因此也是十分复杂的一部分.

从下图中我们会发现, 没有任何一处是全黑的看不见东西的, 比如书本的下方, 蜡烛内部等. 也就是光线 bounce 了很多次才到达我们的眼里, 在 GAMES101 中我们在布林冯模型中, 假设 ambient term, 认为来自四面八方的间接光照都是相同的, 且最后的 shading 和 normal 是无关的, 这样得到的结果是十分不真实的.

下图中的全局光照就不能这么假设了, 大家可以看到书本下方各位置的亮度不同, 还可以看到一些 caustics 等从金属球反射出的间接光, 他们之间是不一样的, 如果还做 Ambient term 那种假设从而只提升了一点亮度是无法得到图中的结果的.

**Overall, 全局光照很复杂.**

## **Reflective Shadow Map(RSM)**

![[9ebe091cb9361a52bad8173848c635ac_MD5.jpg]]

在实时渲染中, 全局光照是**比直接光照多一次 bounce 的间接光照.**

如图中, 光线弹射两次, 先打到红色的墙壁上, 在达到 box 面上, 最后被 camera/eye 看到, 这就是在 rtr 中要解决的所谓的 "全局光照".

我们希望他:

**①简单 -> 实现起来不麻烦**

**②快速 -> 因为全局光照非常难算**

![[7892b5fc089d2feb45acaa2a1f6e36bc_MD5.jpg]]

**我们通过这幅图来理解什么是一次 bounce 的间接光照:**

![[e7c0fc8110c059148c054456a3c3bc25_MD5.jpg]]

在 games101 lecture16 中我们讲 path tracing 时说, 在做 tracing 时, 从 camera 出发打出一条光线到点 P,P 点又往场景中不同的方向发射光线, 如果打到光源则表示接受的是**直接光照.**

如果没打到光源而是打到了点 Q, 那么我们认为 P 点接收到的光照是从 Q 点反射到 P 点的 Radiance, 也就是 Q 点接收到的直接光照所反射出的光照打到 P 点上.

点 Q 接受的是直接光照, 我们则认为接收到直接光照的表面可以被当作次级光源 (Secondary Light Sourse) 用自身反射的光照来照亮其他物体.

![[7272db0e3d700db34647c2685606082b_MD5.jpg]]

我们可以看到 P 点在柱子后面, 不可能接收到直接光照, 我们稀疏的标示出次级光源.

![[def7c012709fdb3a0d19310869b53be0_MD5.jpg]]

现在的 P 点就是所有标示次级光源反射出的光照来照亮 P 点所得到的结果。

![[a81eadd8dfac9018a70c95c5ff256f82_MD5.jpg]]

那么为了计算点 P 的 shading 需要知道什么？

**1：哪些表面会被直接照到？**

**2：如何计算每个 surface patch 对着色点 p 的贡献？**

**首先我们来解决问题 1-----> 哪些表面会被直接照到？**

这里可以使用 shadow map，shadow map 上每一个像素可以看成是一个小 surface patch。

![[cb37864c4dd13dbb60fd9a51eb4bf867_MD5.jpg]]

![[cf82a4b1ad0defef9010d4ac1dd8632c_MD5.jpg]]

## 假设: 所有的反射物 (次级光源) 都是 diffuse 的:

次级光源如果想照亮点 P, 观察方向是从 P 点去观察次级光源的, 也就是对于不同的 P 点来说出射方向是 unknown 的, 因此是无法计算 P 点的 shading 的, 为了不依赖于观察方向, 在 RSM 中我们假设，所有次级光源 (reflector) 都是 diffuse(这里是假设 reflector，没有要求 receiver 也是 diffuse)，故 outgoing radiance 在所有方向上都是 uniform 的, 这样不管从 camera 看过去还是从点 p 看过去所得到的结果是一样的.

**接下来我们来解决问题 2----------> 如何计算每个 surface patch 对着色点 p 的贡献？**

考虑所有 surface patch 的贡献，进行求和；并且每个 surface patch 可以看成是一个 area light。

在此我们需要复习一下 GAMES101 中的一些辐射度量学的知识:

![[6c60758809d997d6b796875c6b5a7b21_MD5.jpg]]

*   **Radiant Engery: 光能 --> 一个区域内光子能量的总和, 用 Q 来表示, 单位是焦耳 (J).**

![[051a2cb85f43bb4e101308084ba70dd1_MD5.jpg]]

*   **Radiant Flux: 光通量 --> 在单位时间内穿过单位截面积的光能.**

![[9c42837a46c70625d19d924000ec5b4a_MD5.jpg]]

*   **Radiant Intensity：一个单位立体角上对应的能量。(单位立体角上的光通量)**
*   **Irrdiance：在一个单位面积下对应的能量。(单位面积上的光通量)**
*   **Radiance：一个单位立体角下单位面积上的能量。(个人理解是, 单位立体角上通过单位投影面积的光通量)**

回到问题本身, 我们之前说过每一个小的 patch 都可能对照亮 p 点做出贡献, 因此我们可以先计算出一个 patch 做出的贡献, 之后用求和的形式将所有 patch 的贡献加在一起.

![[fe87d3d9f98021b041d4f87aa0cf87f1_MD5.jpg]]

我们可以看到 q 是一个 patch 去照亮点 P

q 其实就是 RSM 中一个 Texel 所对应的 patch, 在 games101 中我们说过, 原本计算 q 对 p 点的贡献, 我们应该是对整个立体角进行采样, 但是这样的话很浪费很多的 sample, 为何不直接在 light 处采样然后去计算 p 点的 shading 值呢.

![[d3ef30b418b849db92a51399ba3c963e_MD5.jpg]]

也就是把立体角的积分变成了对 light 区域面积的积分, 如果当区域足够小的时候 dA 甚至不用积分，直接相乘后相加就行, 现在我们要解的是 patch 在接受直接光照后反射出的 radiance 是多少, 也就是从 q 点到 p 点的 radiance, 那么如何解呢?

![[a8632c9547fa648e72256a821a9b5900_MD5.jpg]]

对于每个次级光源点来说, 由于我们假设它的 brdf 是 diffuse 的, 因此次级光源的 fr 积分后是个常数, 此时我们把 Li 代入到式子中会发现 dA 刚好会被抵消. 之后式子会少去 dA, 多了个 $\phi_{p}$ , 然后$\phi_{p}$ 和 $\frac{cos\theta_{p}cos\theta_{q}}{\left| \left|q - p \right| \right|^{2}}$ 又组成了下列公式中的 Ep 与剩余部分结合求出了一个次级光源 p 对着色点所得到的 shading 结果, 再将积分域中所有的结果加在一起, 就是着色点最后被间接光照照亮所得到的 shading 值.

![[4f46b930d7919c45ec10acd98522233b_MD5.png]]

公式求的是次级光源的光线贡献在着色点上的 Irradiance,Ep 表示次级光源对着色点贡献的入射 irradiance.

在此仍然存在一些问题:

次级光源能否看到着色点?

*   渲染方程中的 V 是指次级光源到着色点是否可见，如果想解决这个问题，需要为每个次级光源算一次 shadow map，这个运算不好算也是很难算的, 这个时候我们要学习乌鸦的精神:**" 难办, 那就别办了.**
*   值得注意的是原文公式中的分母是 4 次方，闫老师认为是作者考虑了次级光源发射的光线有衰减，这里应该是 2 次形式。(他们后来说闫老师吃键盘了, 我毕竟还没看到后面所以我先留着.) 更新: **闫老师确实吃键盘了, 但是老师没有错, paper 也没有错, 因为在分子中有两个 Xp-X，当把这两个放到分母中后，结果与我们推导的结果一致，同为 2 次方。**

![[4349ad391293d2efe75b48c4643753a9_MD5.jpg]]

由于可见性、方向性以及距离的不同，对于某一个着色点，认为 shadow map 上所有的 pixel 不可能都有贡献:

*   -Visibility（仍然非常难算）；
*   - 方向：比如 X-1 点在 SM 中记录的是桌子的表面，而且这个表面的点法线方向是朝上的，因此根本不可能照亮 X 点；
*   - 距离：因为远处的次级光源贡献很少，通常只要找距离足够近的次级光源就行了。

因此为了加速这一过程, 我们认为在 shadow map 中着色点 $x$ 的位置和间接光源 $x_p$ 的距离可以近似为它们在世界空间中的距离。所以我们认为，对着色点 $x$ 影响大的间接光源在 shadow map 中一定也是接近的。

于是我们决定先获取着色点 $x$ 在 shadow map 中的投影位置 $(s,t)$，在该位置附近采样间接光源，多选取一点离着色点近的 VPL，并且为了弥补越往外采样数越少可能会带来的问题，引入了权重，越近了权重越小，越远的权重越大。那么对于一个 shading point 差不多找 400 个次级光源来计算是比较合适的。如下图所示。

![[22460703afbf468da094b344ead8a937_MD5.jpg]]

**数据存储:**

RSM 在每一个像素 $p$ 中都需要存储深度值 $d_p$，世界坐标 $x_p$，法线 $n_p$，反射光功率$\phi _p$，如下图的可视化效果，四个 map 对应像素 p 的四个参数.

![[e64145f9c3a27bcc60c8831b9b276982_MD5.jpg]]

RSM 效果通常应用于游戏中手电筒的次级光照，如图:

![[96d94721b441e925d1265fe33774371d_MD5.jpg]]

在此可以更加理解我上文写的对于式子的理解

屋顶某个点亮了的区域就是手电筒直接照亮区域对屋顶那个点的贡献, 屋顶点积分的时候积分域就是手电筒直接照亮的位置.

**优点：**

*   易于实现

**缺点：**

*   性能随着直接光源数的增加而降低 (因为需要计算更多的 shadow map)
*   对于间接光照，没有做可见性检查
*   有许多假设：反射物需要是 diffuse 等
*   需要在质量和采样率上做一个平衡

  
全局光照这里, 其实是最折磨我的, 因为数学底子不好所以在理解 paper 中的式子时很难让我迷糊过来, 还好在看了很多大佬的笔记和咨询了大佬

[@沙滩 Beachc](https://www.zhihu.com/people/d12a94f4ac827bba2b25e1af2444b73f)

之后才让我恍然大悟, 计算机图形学真的是很难又很有趣........... 我还有很长的路要走啊.

**引用：**

[1] Reflective Shadow Maps - Carsten Dachsbacher, Marc Stamminger

[2] GAMES202 - 高质量实时渲染 - 闫令琪

[3] GAMES202 高质量实时渲染笔记 Lecture07：Real-Time Global Illumination (In 3D) - 沙滩 beachc

[4] 【论文复现】Reflective Shadow Maps

[Monica 的小甜甜：【论文复现】Reflective Shadow Maps](https://zhuanlan.zhihu.com/p/357259069)