

---
title: 03 光照向量
aliases: []
tags: []
create_time: 2023-05-08 22:18
uid: 202305082218
cssclass: academia, academia-rounded
banner: "![[Pasted image 20230508221932.png]]"
banner_y: 0.7725
banner_x: 0.49692
---


[反射向量和折射向量的推导 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/91129191)

# 法线
法线主要用于计算光照
## 法线变换
法向量的变换比较特殊，简单来说就是法向量左乘变换矩阵的逆转置矩阵，这样可以在非统一变换中保持法线和切线垂直。
### Unity shader 中的法线变换

> [!NOTE] Title
> 总结：两种方法将法线从模型空间转换到世界空间
> 1. 使用顶点变换矩阵的逆转置矩阵对法线进行变换，首先的得到模型空间到世界空间的逆矩阵 `unity_WorldToObject`，然后通过调换他在 `mul` 函数中的位置得到和转置矩阵相同的矩阵乘法。由于法线是一个三维矢量，所以需要用（float3x3）截取。
`o.worldNormal =  mul (v.normal, (float3x3) unity_WorldToObject); `
>2. 直接使用 unity 内置函数
`o.worldNormal = UnityObjectToWorldNormal (v.normal);`

在做 blinn-phong 光照计算时，法线信息必不可少。而在 shader 中，可以得到 app 传入 vertex shader 的模型空间的的法线信息（一个顶点含有一个法向量），但是计算时往往需要**将法线从模型空间转换为世界空间**，同时模型顶点的坐标也需要转换到世界空间，只有坐标空间一致才能进行计算。

**对比顶点与法线的空间变换会产生疑问：**

```c
o.worldNormal =  mul(v.normal,(float3x3)unity_WorldToObject);//为什么这个是右乘矩阵？为什么要(float3x3)
o.worldVertexPos = mul(unity_ObjectToWorld, v.vertex).xyz;
```

-   **问题 1 ：为什么法线做变换时，需要用 (float3x3)来取得变换矩阵的前三行三列？**

产生这种差别的原因是法线是一个向量（只有方向，会进行旋转和缩放变换，而平移是不必要的），而顶点是空间中的位置。同时注意法线用于计算最终是要 normalize 的，长度是 1。因此法线变换是需要取变换矩阵的 (float3x3)，最后一列是平移变换部分，舍弃。

![[edbe940120b79257d9e58b5eeb57ce5f_MD5.webp]]

-   **问题 2 ：为什么同样是模型空间转换到世界空间，法线用的是 unity_WorldToObject 变换矩阵，且是矩阵右乘向量，而顶点用的是 unity_ObjectToWorld 矩阵，且是矩阵左乘向量？

从上述矩阵中看出，前三行列包含了缩放变换，**当向量进行不成比例的缩放时，就会影响到向量的方向：法线将不会与几何体表面垂直**（顶点的法向量是该顶点所在几个表面法向量的平均值）。如何才能让法线进行变换仍能保持正确的方向？  
![[f1475b5b6f7dd2cf8776b4470df446e7_MD5.webp]]

> [!NOTE] 
> 注：当模型只做成比例缩放，即法线没有做不成比例的缩放时，则可以直接用 unity_ObjectToWorld 的前三行三列变换到世界空间

此时要对法向量进行正确的变换, 应该是对其进行相反的缩放 (比如 xy 是 1: 2 缩放, 那么法向量 xy 就要2:1缩放。

![[2b6c42a78361d58b6db9d7f1d58dddcc_MD5.webp]]

所以法向量的变换矩阵中**缩放矩阵应该是原来顶点变换缩放矩阵的逆矩阵**，而法向量的**旋转矩阵**应**保持原本的旋转。由于旋转矩阵是正交矩阵，因此旋转矩阵的转置=其逆矩阵**。而**缩放矩阵不是正交矩阵，因此无法通过转置求得逆矩阵**。因此可以这样做：
**对 unity_ObjectToWorld 求逆矩阵**得到 unity_WorldToObject（同时得到旋转和缩放矩阵的逆），**再做转置**（得到原来的旋转矩阵的缩放矩阵的逆转置），保持了旋转矩阵，同时得到了缩放矩阵的逆。

**总结：**
1. 求逆：求逆矩阵可以得到旋转矩阵的逆矩阵，但是同时缩放矩阵变成逆矩阵了，怎么消除该影响呢？  
2. 转置：这里有个小技巧—>**变换矩阵与向量相乘的顺序，相当于向量和原矩阵的转置矩阵相乘**。

![[fabef4bd1bae1f73cf5b1135a8096048_MD5.webp]]


> [!NOTE]
> 注：unity_ObjectToWorld 是一个点从模型空间转换到世界空间的变换矩阵，unity_WorldToObject 则相反，两者是逆变换，因此两个矩阵互为逆矩阵。

**由此问题 2 也得到了解决。** 

### 法线变换矩阵公式推导

前面是用具象的理解得到矩阵，如何更加严谨地得出法线的正确变换矩阵呢？——> 利用切线进行公式推导

那么，应该使用哪个矩阵来变换法线呢? 我们可以由数学约束条件来推出这个矩阵。我们知道**同一个顶点的切线 $T_A$ 和法线 $N_A$ 必须满足垂直条件，即 $T_A·N_A=0$**。给定变换矩阵 $M_{A\rightarrow B}$，我们已经知道 $T_B=M_{A\rightarrow B}T_A$。我们现在想要找到一个矩阵 $G$ 来变换法线 $N_A$，使得变换后的法线仍然与切线垂直。即
$$
\mathrm{T}_B\cdot\mathrm{N}_B=(M_{A\rightarrow B}\mathrm{T}_A)\cdot(G\mathrm{N}_A)=0
$$
对上式进行一些推导后可得：
$$
(M_{A\to B}\mathbf{T}_{A})\cdot(G\mathbf{N}_{A})=(M_{A\to B}\mathbf{T}_{A})^{\top}(G\mathbf{N}_{A})=\mathbf{T}_{A}^{\top}M_{A\to B}^{\top}G\mathbf{N}_{A}=\mathbf{T}_{A}^{\top}(M_{A\to B}^{\top}G)\mathbf{N}_{A}=0\quad
$$
由于 $T_A\cdot N_A=0$，因此如果 $M_{A\to B}^{\top}G=E$，那么上式既可成立。

也就是说，如果 $G=\left(M_{A\to B}^{\top}\right)^{-1}=\left(M_{A\to B}^{-1}\right)^{\top}$,即使用原变换矩阵的逆转置矩阵来变换法线就可以得到正确的结果。

**三种情况：**
- 如果变换**只包括旋转变换**，那么变换矩阵 $M_{A\rightarrow B}$ 就是正交矩阵, 那么 $M_{A\to B}^{-1}=M_{A\to B}^{\top}$，因此 $\left(M_{A\to B}^{\top}\right)^{-1}=M_{A\to B}$ ，也就是说我们可以使用用于变换顶点的变换矩阵来直接变换法线。
- 如果变换**只包含旋转和统一缩放，而不包含非统一缩放**，我们利用统一缩放系数 $k$ 来得到变换矩阵 $M_{A\rightarrow B}$ 的逆转置矩阵 $\left(M_{A\rightarrow B}^{T}\right)^{-1}=\frac{1}{k}M_{A\rightarrow B}$ 。这样就可以避免计算逆矩阵的过程。
- 如果变换中**包含了非统一变换**，那么我们就必须要求解逆矩阵来得到变换法线的矩阵。

公式推导中提到了切线与法线不变的垂直关系，由此引申出图形学中十分重要的知识点：
## 切线空间
### 切线空间中的法线

法线是向量，向量则必然需要指定坐标系/坐标空间，可以用模型空间、世界空间、切线空间来表示。模型和世界空间大家一定很熟悉，那么什么是切线空间呢？

一个坐标空间就是一个坐标系，只要有三个正交坐标轴 xyz 作为基轴就可以定义坐标空间中任意一点。切线空间是位于三角形表面之上的空间，**切线空间中的 xyz 轴分别是 t 轴（切线方向）、b 轴（副切线方向）和 n（法线方向） 轴**。

确定的一点是：**切线空间的 z 轴（向上的轴）与法线 n 同向。那么 x 与 y 轴要如何定义呢？**

我们都知道，一条曲线上某点的切线只有一条，而一个曲面上某点却有一个切平面，该平面上过该点的任意一条线都是该点的切线，所以**切线有无数条**。有多种不同的 x 和 y 轴组合, 每种组合生成的点法向量是不一致的, 所以需要**规定一套固定的 x 和 y 轴**, 大家遵守同样的规则，**建模软件在计算切线的时候会选择和 UV 展开方向相同的那个方向作为切线方向。**

>根据 [[03 光照向量#UV 与 TB 的关系]] 中的证明，在 TBN 推导进行最后的正交化之前，T 的方向对应 u 的方向，B 对应 V 的方向。正交化之后则不一定
### 为什么要定义切线空间

当一个模型有很多凹凸细节时，模型的顶点网格会很密（数据量大），随之而来的就是性能问题。模型凹凸对应的是顶点的高度偏移，高度偏移影响的是法线方向，因而我们视觉上看到模型的凹凸（光影计算）其实只和模型法线有关，因此可以**修改模型原本的法线信息**，让模型**看起来有凹凸**，但是实际却是网格稀疏的低面几何体。

-   如下图，左侧是一个面很少，并不平滑的几何体，用原法线计算光照后会看到平面（红色线部分），右侧是将几何体原本的法线信息经过插值处理，经光照计算后，就会看起来像是平滑（凸出）过渡的曲面（浅紫色部分）。

![[4c56eb834105859868c0fbf67cede838_MD5.webp]]

![[57933f5cbe773bcc5cf659fa76199ed4_MD5.webp|450]]

此处我们理解了**两种法线：**
1.  模型三角面的面法线 **face normal**  ：很容易算，三角形两个边的向量进行叉积即可得到垂直于改面的法向量。
2.  用 vertex normal 经过插值得到的 **interpolated normal**：

实际工作中，模型有很多面，顶点被多个三角形公用，如何确定这个顶点的 vertex normal？
运用一种被称为**求顶点法线平均值 ( vertex normal averaging )** 的计算方法。此方法通过对网格中共享顶点 v 的多边形的平面法线求取平均值，从而获得网各中任意顶点 v 处的顶点法线 n。例如，图中网格中的四个多边形共用顶点 v，因此, v 处的顶点法线求法如下:
$$
\boldsymbol{n}_{\mathrm{avg}}=\frac{\boldsymbol{n}_0+\boldsymbol{n}_1+\boldsymbol{n}_2+\boldsymbol{n}_3}{\left\|\boldsymbol{n}_0+\boldsymbol{n}_1+\boldsymbol{n}_2+\boldsymbol{n}_3\right\|}
$$

![[Pasted image 20230508214912.png]]
为了得到更为精准的结果，我们还可以采用更加复杂的求平均值方法，比如说，根据多边形的面积来确定权重（如面积大的多边形的权重要大于面积小的多边形)，以求取加权平均值。

## 法线贴图 Normal Map
### 法线贴图的存储方式
插值就可以得到平滑过渡，那么对 **vertex normal** 做各种各样的偏移，得到用于计算的 **interpolated normal**，就能得到各种凹凸起伏的光影结果。偏移是相对于原法线信息的偏移，因此以原法线方向作为 z 轴正方向，定义一个切线空间，并在切线空间中用三个坐标值就可以表示出偏移后的法线信息，用贴图存储模型空间与切线空间的法线数据，这个贴图叫做**法线贴图**：

> [!NOTE] 模型空间和切线空间的法线贴图
> ![[Pasted image 20230106162114.png|200]] ![[Pasted image 20230106162128.png|200]]
> 左图是模型空间的法线贴图，右图是切线空间的法线贴图。使用右图时需要使用 TBN 矩阵将贴图中提取出的法线从切线空间变换到计算光照使用的空间。
> ![[Pasted image 20230508211144.png]]
> **左图是模型空间**，因法线方向各不相同，所以看起来五颜六色的；
> **右图是切线空间**，每个法线方向所在的坐标空间是不一样的，即是表面每点各自的切线空间，这种法线纹理其实存储了**每个点在各自的切线空间中的 shading 法线偏移（扰动）方向，如果一个点的法线方向不变，那么在其切线空间中，新的法线方向就是 z 轴方向。即值为（0,0,1），映射到颜色即（0.5,0.5,1)浅蓝色。蓝色说明顶点的大部分 shader 法线和模型本身法线一样，无需改变**

> [!tip] 模型空间与切线空间存储 shading normal 的优缺点对比
> 
>
> **模型空间存储：**
> -   优点：简单直观
> -   问题：当模型有顶点变化时（如骨骼动画），则面片都变化了，此时无法计算新的法线。（法线应当随着面片变化同样变化）
>
> **切线空间存储有更多优势，我们常用切线空间的法线贴图：**
> -   切线空间存储的是相对法线信息，因此换个网格（或者网格变换 deforming）应用该纹理，也能得到合理的结果。
> -   可以进行 uv 动画，通过移动该纹理的 uv 坐标实现凹凸移动的效果
> -   可以重用法线纹理，比如, 一个砖块, 我们仅使用一张法线纹理就可以用到所有的 6 个面。
> -   可以**压缩**。因为切线空间的法线 z 方向总是正方向，因此可以**仅存储 xy 方向**，从而推到 z 方向（normal 是单位向量，用勾股定理由 xy 得出 z，取 z 为正的一个即可）。而模型空间的法线纹理方向各异，无法压缩。

利用法线贴图计算光照就可以实现法线映射 Normal Mapping，法线映射与 Phong shading 的主要差别在哪呢？
在于我们掌握信息的多少。在 Phong shading 时，用到三角形每个顶点的法线(插值获取其内像素的法线)，而法线映射使用法线贴图纹理能提供相当多的法线(多到每个像素都有对应法线，而无需插值获取)，显著改善渲染细节。

### 读取法线贴图数据
切线空间中法线的每个分量的值的范围是 $[−1,1]$，而 RGB 分量的值的范围是 $[0,1]$ 。所以，在将法线存储为 RGB 图像时，需要对每个分量做一个映射，所得的 RGB 图像呈蓝紫色：
```
vec3 rgb_normal = （normal + 1）/ 2;
vec3 rgb_normal = normal ∗ 0.5 + 0.5;  // 等价
```
![[a910497ae7cffe8579620a29e1ab5132_MD5.webp|650]]

这里要注意，**将法线存储到法线贴图的过程中，需要进行上述操作。当我们从法线贴图中读取法线数据后，需要进行重映射，即上述变换的**<font color="#ff0000">逆变换</font>，即从$[0,1]$ 映射到 $[−1,1]$ 。

```
normal = 2 * vec3rgb_normal - 1
```

切线空间中的法线是相对于真实法线的偏移（又称扰动）：

![[bf88c99394c2c215b3577e05fed7a9b5_MD5.webp]]



-   补充：**法线贴图的压缩，DXT compression 压缩技术。**（unity 和 ue 会自动做此事，我们需要的是正确读取法线贴图中的数据）
-   只保留 rg 两个颜色通道
	因为 normal 是归一化向量，其大小为 1；又因为切线空间的法线 z 方向总是正方向，所以可以只存 x 和 y 就可以用勾股定理计算出 z 值（因为正方向所以取正值）。所以只保存 rg 两个通道。
	计算方法：[[101 材质大师#BC/DXTC压缩的不同]]
-   但是如果只有一个通道那向量压缩质量更好。所以只用 g 通道，并将**r 通道**的值存入**alpha 透明通道**

### 利用法线贴图的信息计算模型光照

首先要从贴图中提取出法线信息：先映射范围，所以采样纹理后，也要从像素先计算出真正的法线值才行。如果纹理是经过了压缩的，则还要再加一步，提取出真正的 pixel normal 值。

要做基于法线的光照计算，在同样的坐标空间中点乘什么的才有意义。一般**利用计算光照时，有 3 条路**：

1.  在世界空间中计算：将变量（顶点位置、光照方向、法线方向等）转换到世界空间运算。
2.  在模型空间中计算：将同上变量转换到模型空间运算。
3.  在切线空间中计算。

而从一个坐标空间变换到另一个坐标空间需要一个**变换矩阵**，如同 unity 中的 unity_WorldToObject 和 unity_ObjectToWorld 矩阵一样，用来在世界空间和模型空间之间变换。因此此处的变换则需要**TBN 矩阵（TBN_World 和 TBN_Object），将从贴图中提取出的**pixel normal 变换到世界空间或模型空间。

## TBN 矩阵 

**TBN 矩阵定义了一个点从切线空间变换到世界空间或者模型空间的变换矩阵：当 N 是模型空间中的法线时，计算出的 TBN 则是 TBN_Object，该矩阵对贴图中取得的 pixel normal 数据做变换后，会得到模型空间**的 final shading normal 。同理如果 N 是世界空间中的法线时，计算出的 TBN 则是 TBN_World，做变换会得到**世界空间**中的 final shading normal 。

-   两种 TBN 矩阵的计算流程示意（下图）：中间的绿色线条上部属于顶点着色器中的内容（法线、切线都是模型空间中的）、绿色线条下部属于像素着色器中的内容（法线、切线都是在顶点着色器中变换到世界空间，传入像素着色器计算）。**由于使用 TBN_World 的方法在片段着色器中计算量更小，因此常常用 TBN_World 做计算**（尽管顶点着色器中计算量大，但通常顶点着色器通常比片段着色器运行的少）。

![[80c01dfab4d4cb8fa085554148f0396c_MD5.webp]]

注意区分：TBN 中的 N，则是指的是，模型顶点的真实法线。而 `matrix（T，B，N）* n` 的这个 `n`，才是从法线贴图中还原出来的，通过贴图像素值计算的法线。 `final shading normal =matrix（T，B，N）* n` ;的这个 final shading normal 是转换到正确空间后的最终用于光照计算的法线。

- @ （final shading normal、pixel normal 、TBN_World、TBN_Obect 都是我自创的用于理解的名字而已，无特殊含义）

**在切线空间中计算：将光照方向、视角方向在 Vertex Shader 里面从模型空间变换到切线空间去计算光照，这样更省，可以不必再 Fragment Shader 里面进行更耗时的计算。从模型空间变换到切线空间的矩阵如何得到呢？

我们前面已经知道了从切线空间->模型空间的矩阵（即用模型空间中的法线计算 TBN_Object）。因此**模型空间转换到切线空间的矩阵是**TBN_Object 的逆矩阵，此处冯女神给出了求逆矩阵的算法：

### TBN 推导

$$
\begin{bmatrix}t_x&b_x&n_x\\ t_y&b_y&n_y\\ t_z&b_z&n_z\end{bmatrix}\begin{bmatrix}v_x\\ v_y\\ v_z\end{bmatrix}=\begin{bmatrix}t_x v_x+b_x v_y+n_x v_z\\ t_y v_x+b_y v_y+n_y v_z\\ t_z v_x+b_z v_y+n_z v_z\end{bmatrix}
$$

**我们可以根据纹理坐标和模型坐标求出 TB**

![[Pasted image 20230106224534.jpg]]

这张图描述了模型中每个三角形所在的纹理坐标系与切线空间坐标系的联系。
对于模型中每一个三角形的顶点，我们有其位置坐标以及纹理坐标，这个技术就要通过这两组坐标得到 TBN 矩阵。

如图对于每个三角形在切线中的两个边向量用 $E_1$ 和 $E_2$ (图中为 $e_1e_2$)来表示：
$$
\begin{array}{c}E_1=\Delta U_1T+\Delta V_1B\\ \\ E_2=\Delta U_2T+\Delta V_2B\end{array}
$$
使用矩阵来表示：
$$
\begin{bmatrix}E_{1x}&E_{1y}&E_{1z}\\ E_{2x}&E_{2y}&E_{2z}\end{bmatrix}=\begin{bmatrix}\Delta U_1&\Delta V_1\\ \Delta U_2&\Delta V_2\end{bmatrix}\begin{bmatrix}T_x&T_y&T_z\\ B_x&B_y&B_z\end{bmatrix}
$$

继而推导出：
$$
\begin{bmatrix}T_x&T_y&T_z\\ B_x&B_y&B_z\end{bmatrix}=\frac{1}{\Delta U_1\Delta V_2-\Delta U_2\Delta V_1}\begin{bmatrix}\Delta V_2&-\Delta V_1\\ -\Delta U_2&\Delta U_1\end{bmatrix}\begin{bmatrix}E_{1x}&E_{1y}&E_{1z}\\ E_{2x}&E_{2y}&E_{2z}\end{bmatrix}
$$

以上就是在一个三角形中，通过顶点坐标与纹理坐标获得 $T, B$ 向量的过程。

注意：这里解出的 $T$ 或者 $B$ 不是最终需要的，$T$ 向量需要进一步的与 $N$ 向量正交化，所以我们只需要解出 $T$，然后通过$B = cross（N，T）$，这才是最终的 $B$。有了 $T, B$ 就可以计算得到 $N$，从而构建出 $TBN$ 矩阵。

### 在 unity shader 中的 TBN 矩阵？
untiy 中我们可以直接拿到 tangent，进而与 normal 叉乘得到 bitangent，轻松构建出 TBN 矩阵。

unity shader 中，模型的顶点数据（包括顶点位置、顶点法线、uv 坐标、切线矢量 tangent）通过 appdata 传给顶点着色器，在顶点结构中通过语义获得，语义 TANGENT 标示切线数据（如：**float4 tangent : TANGENT，tangent 变量存储了切线矢量数据**）。

TANGENT 矢量是切线矢量，是四维向量，由 xyzw 四个分量。**v.tangent. xyz 是切线方向，即 tbn 中的 t；v.tangent. w 的值为+1 或者-1，w 分量代表了什么呢？

在 Unity 中，只有切线矢量 t 存储在顶点中，**而副切线 b（也称双切线或副法线）是从读取的法线值和该切线值做叉乘得出，叉乘能得到垂直于 t 与 n 的矢量 b。** 前面说过平面上某点的切线有无数的方向，一般模型会用模型 uv 展开相同的方向作为切线方向，因此 uv 方向（即切线的选择）就影响到了叉乘的结果 b 的方向，因此 w 会再存储一个信息。**叉乘的结果会得到一个方向，w 分量又进一步决定了取叉乘结果的正方形还是反方向。**

```c
//计算副切线 
float3 bitangent = cross( v.normal, v.tangent.xyz ) * v.tangent.w;
```

-   世界空间下的 TBN_World 的计算：

```c
// Construct a matrix that transforms a point/vector from tangent space to world space
fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);  
fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);  
fixed3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w;
float3x3 worldToTangent = float3x3(worldTangent, worldBinormal, worldNormal);
 
```

注：上述代码中此处用了 unity 内置计算方向的函数**UnityObjectToWorldNormal，因此兼容模型非均匀缩放的情况**。如果不用内置函数，则要注意向量计算时模型非均匀缩放的问题了。


## 疑难解析

1. **Tangent 轴的方向与 u 轴方向相同，Bitangent 轴的方向与 v 轴方向相同？**
   **Tangent、Bitangent 轴只在正交化前与 UV 轴方向分别相同**，因此这句话一半对，一半错。**对于规范的 TBN 矩阵而言，TB 二轴与 UV 轴方向极大多数情况很可能并不相同**。当顶点法线在建模软件中被修改为不垂直于该面片时，TB 平面甚至不在三角形面片上；当 uv 经过拉伸时，因 TB 二轴在正交化前与 UV 方向相同，故正交化后 TB 二轴必然与 uv 方向是有所偏差的，而对于一个多面片的模型 uv 展开，这种拉伸旋转的情况简直司空见惯。

2. **uv 二轴在三维面片上的映射向量相互垂直，对吗？**
   根据下图，uv 二轴在三维空间下的方向很可能不垂直。

3. **切线空间 tbn 中的 N（Normal）轴是怎么得到的，其与 uv 二轴在三维面片上的映射方向的向量是垂直吗？**
   切线空间的 N 轴就是顶点法线。（在此提及一点，建模软件中但凡是出现单个顶点包含多条法线（split vertex normal）的，在实际导出后，都是变为多个重合顶点，一个顶点只有一条法线，这是任何时候都不会改变的事实。） uv 二轴在三维平面的投影方向就是三角面片所在的平面，n 轴并不一定与其垂直。

4. **顶点法线可以直接根据相邻面的法线取平均得到，对吗？**
   这个属于常见带有误导色彩的言论，在此特意申明，顶点法线爱怎么调整怎么调整，与面法线并无关联。面法线只是垂直于面的一条向量，规定了面的正反，而顶点法线才是用于光照信息的处理。即便是建模软件中，顶点法线的最初是的默认情况也并非是面法线的平均，只有当在建模软件中对物体进行了平滑着色后，才会根据面法线平均得到顶点法线（如 blender 中为 shader smooth 命令）。这其中的逻辑不要弄混。


![](1673017408912.png)

#### UV 与 TB 的关系

我们知道，一个顶点结构中包含很多信息，其中就有顶点在三维空间中的位置信息，以及顶点在展开的 uv 中的 uv 坐标，且三维空间下三角形中的每一个点都必能在 uv 上找到对应的点，反之亦然。下图是三角形的 uv 展开图以及其俯视图，我们可以很容易的在三维空间与 uv 空间下对任意一个点进行映射，因为该 uv 没有任何拉伸旋转，甚至可以说是标准完美得过分了。

![](1673017409251.png)

若设 A（x1，y1，z1），uv 坐标为（u1，v1）、B（x2，y2，z2），uv 坐标为（u2，v2）、C（x3，y3，z3），uv 坐标为（u3，v3）。且将向量 AC 记录为 E1、向量 AB 记录为 E2，则对于这条公式而言，

![](1673017409336.png)

在这种特殊情况下，**此时的 T 显然恰好与 U 在三维空间上的映射方向相同、同理 B 也与 V 方向相同。直观上，该公式描述的数学意义是，如何将一个点从 uv 空间映射到三维空间，其中 TB 作为基矢，以 uv 空间中的 u 和 v 的增长作为控制参数。假设三角形中存在一点 P，则向量 AP=u（p）*T+v（p）*B，只要知道 P 点的 uv 坐标值，即可得到 P 点的三维坐标值。**

如果我们在三维空间下将三角形做一点拉伸，变成如下图所示，则 UV 向量在三维空间的方向将不再垂直，但是有 Color Grid 图的帮助，我们依然可以很方便的辨认出 uv 映射的位置。

![](1673017409410.png)

**不过在这种情况下，向量 T 与 B 依然会与 UV 保持方向相同吗？答案是肯定的**，将上述式子进行简单求解，可看到 T 与 B 的表达式。为了直观判断，这里笔者将该物体导入 unity，通过 geometry shader 进行可视化生成该方式计算的 TB 向量，为了连贯性，代码与步骤将放在附录 1 中提供。

![](1673017409485.png)

代码中的 TB 向量严格遵守上述推导结果，下图将计算出来的 T 以蓝线表示，B 以切线表示，可以看到该公式计算出来的 T 与 B 确实与 uv 方向相同。

![](1673017409552.png)

**目前算出来的 TB 还不是真正的切线与副切线，需要经过正交化得到 TBN 矩阵，其中的计算规范由下图给出**：

![](1673017409636.png)

其中 n 是建模软件中规定的顶点法线，可以看到 n 在正交化过程中不会受到影响，该过程是对 TB 向量进行方向的调整以及长度的归一化。TB 在此过程后会相互垂直，此时将不再一定与 UV 方向保持相同。**特别的，当调整顶点法线后，TB 平面甚至将于三维空间中的三角形平面不同，形成的切线空间实际上是不够直观的。**（值得一提的是，在 npr 渲染中，法线的更改是十分常见的，没事更改顶点法线并非太闲。）

# 反射
$i$ 入射向量
$r$ 反射向量
将向量 $v$ 在界面法线 $n$ 方向上的投影记为 $v_\perp$，在界面方向上的投影记为 $v_{||}$。
![[Pasted image 20230402195533.png]]
根据反射定律，反射角等于入射角：$\theta_i=\theta_r$

因为
$$
\begin{array}{l}i_{\perp}=-|i_{\perp}|n=(i\cdot n)n\\ i_{||}=i-i_{\perp}\end{array}
$$

然后因为 $r_{||}$ 是 $i_{||}$  的等向量， $r_⊥$ 是 $i_⊥$ 的反向量
$$
r=r_{||}+r_{\perp}=i_{||}-i_{\perp}=i-2i_{\perp}=i-2(i\cdot n)n
$$

# 折射
![[Pasted image 20230402200218.png]]
根据斯涅尔定律（Snell's law），介质折射率和正弦的乘积一定相等。
$$
\eta_{1}sin\theta_{i}=\eta_{2}sin\theta_{r}
$$

因 $r_{||}$ 和 $i_{||}$ 平行且指向相同方向
$$
r_{||}=\dfrac{|r_{||}|}{|i_{||}|}i_{||}=\dfrac{sin\theta_r}{sin\theta_i}i_{||}=\dfrac{\eta_1}{\eta_2}i_{||}=\dfrac{\eta_1}{\eta_2}(i+cos\theta_i n))\qquad(1)
$$
根据勾股定理
$$
|r_\perp|=\sqrt{|r|^2-|r_||^2}=\sqrt{1-sin^2\theta_r}
$$
所以
$$
r_{\perp}=-|r_{\perp}|n=-\sqrt{1-sin^2\theta_r}n
$$
再根据斯涅尔定律
$$
sin^2\theta_r=(\dfrac{\eta_1}{\eta_2})^2sin^2\theta_i=(\dfrac{\eta_1}{\eta_2})^2(1-cos^2\theta_i)
$$
代入得
$$
r_{\perp}=-\sqrt{1-(\dfrac{\eta_1}{\eta_2})^2(1-cos^2\theta_i)}n\quad\quad\quad(2)
$$
将式子 $(1)$ 和式子 $(2)$ 代入
$$
\begin{aligned}r&=r_{||}+r_{\perp}\\ &=\frac{\eta_1}{\eta_2}(i+cos\theta_in)-\sqrt{1-(\frac{\eta_1}{\eta_2})^2(1-cos^2\theta_i)}n\\ &=\frac{\eta_1}{\eta_2}i+(\frac{\eta_1}{\eta_2}cos\theta_i-\sqrt{1-(\frac{\eta_1}{\eta_2})^2(1-cos^2\theta_i)})n\end{aligned}
$$
最后因为
$$
cos\theta_i=-i\cdot n
$$
得到
$$
r=\dfrac{\eta_1}{\eta_2}i-(\dfrac{\eta_1}{\eta_2}(i\cdot n)+\sqrt{1-(\dfrac{\eta_1}{\eta_2})^2(1-(i\cdot n)^2)})n
$$
需要注意的是，上述式子在根号内的值大于等于 0 时才成立。当 $\eta_1\leqslant\eta_2$ 时，根号内始终不小于 0。当 $\eta_1>\eta_2$ 时，则在特定入射角度（超过临界角）会发生**全内反射**的现象。此时折射分量为 0。
$$
r=\begin{cases}\frac{\eta_1}{\eta_2}i-(\frac{\eta_1}{\eta_2}(i\cdot n)+\sqrt{1-(\frac{\eta_1}{\eta_2})^2(1-(i\cdot n)^2)})n&\text{if}\:1-(\frac{\eta_1}{\eta_2})^2(1-(i\cdot n)^2)\ge0\\ 0&\text{if}\:1-(\frac{\eta_1}{\eta_2})^2(1-(i\cdot n)^2)<0\end{cases}
$$

# 菲涅尔边缘光
## 简易版菲涅尔边缘光
```c
Shader "Test/Scan"
{
	Properties
	{
		_MainTex ("Texture", 2D) = "white" {}
		_RimColor ("Rim Color", color) = (1.0,0,0,1.0)
		_RimPower ("Rim Power", Range(0.0001, 3.0)) = 1.0
	}
	SubShader
	{
		Tags { "RenderType"="Opaque" }
		LOD 100
		Pass
		{
			CGPROGRAM
			#pragma vertex vert
			#pragma fragment frag
			#include "UnityCG.cginc"

			struct appdata
			{
				float4 vertex : POSITION;
				float2 pos : TEXCOORD0;
				float3 normal : NORMAL;
			};

			struct v2f
			{
				float2 uv : TEXCOORD0;
				float4 vertex_pos : SV_POSITION;
				float3 normal_World : TEXCOORD1;
				float3 pos_world : TEXCOORD2;
			};

			sampler2D _MainTex;
			//使用了TRANSFROM_TEX宏就需要定义XXX_ST 
			float4 _MainTex_ST;
			fixed4 _RimColor;
			half _RimPower;
			
			v2f vert (appdata v)
			{
				v2f o;
				//顶点从模型空间转换裁剪空间
				o.vertex_pos = UnityObjectToClipPos(v.vertex);
				//获取当前顶点的UV
				o.uv = TRANSFORM_TEX(v.pos,_MainTex);
				//获取当前Normal的UV
				o.normal_World = mul(v.normal,(float3x3)unity_WorldToObject);
				//获取当前顶点在世界空间的位置
				float3 worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;
				return o;
			}
			
			fixed4 frag (v2f i) : SV_Target
			{
				//归一化法线
				float3 normal_World = normalize(i.normal_World);
				//获取视线位置
				float3 view_world = normalize(_WorldSpaceCameraPos.xyz - i.pos_world);
				//计算法线与视线方向点积，求反（越靠近边缘夹角越大，值越小就越亮，越边缘越暗）
				//求反后: dot值越接近0，说明视线方向越偏离该点，也就是平视，该点越接近边缘
				half Rim = saturate(1 - dot(normal_World,view_world)); 
				//计算边缘光RimLight
				fixed4 RimColor = _RimColor * pow(Rim, 1 / _RimPower);
				//采样贴图的颜色
				fixed4 Color = tex2D(_MainTex,i.uv).rgba;
				fixed4 FinallyColor = Color + RimColor;
				return Color;
			}
			ENDCG
		}
	}
}
```
## 菲尼尔方程（Fresnel）
[从Lambert模型到PBR模型6：推导镜面反射和漫反射的菲涅尔部分 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/198201029)
随着物体表面法线与视线的角度增大，物体的反射能力增大，这种现象称之为**菲涅尔效应**，万物皆有菲涅尔效应。

角度跟法线角度越小，越容易穿透介质，发生折射、散射、漫反射。

角度跟法线角度越大，越难穿透介质，就越容易发生镜面反射。

![[8d86267f0452baa87f69a39044405bd5_MD5.webp]]

**菲涅尔方程**（Fresnel Equations），用来描述光在不同折射率的介质之间的行为的方程。

菲涅尔方程描述的是**被反射的光线所占的百分比**，这个比率会随着我们观察的角度不同而不同。

所以菲涅尔方程同时影响漫反射跟镜面反射。  

我们一般采用**Schlick 的 Fresnel 近似**，因为计算量小，精度足够：

F_Schlick (v, h) = F0 + (1-F0)(1- dot (v, h))^5

### 方程里的 F0 与 F90

**任何角度都有菲涅尔反射，我们需要计算两个特殊角度的菲尼尔反射，然后插值得到所有角度的菲尼尔反射，也就是渲染每个像素时的 F。

**F0** : 指视线与法线夹角=0 度角时，入射的菲涅尔反射率。F0 也叫基础反射率。

**F90**：指视线与法线夹角=0 度角（掠射角）时，入射的菲涅尔反射率。

![[5094948cf4ee58a5d7ee0b7adb122d75_MD5.webp]]

  

物理上对不同材质的观察，有一些结论：

1. 不同材质的 F90 基本都接近 1，所以我们一般不会暴露 F90 来给美术调节。

2. 不同材质的 F0 有一定差别，基本在 2-5％，所以如果有需要，可以给定一个 F0 来渲染不同材质。

3. 虽说大部分情况，F90 接近于 1。但对于粗糙表面，Fresnel 效果会随着物体表面的光滑度变低快速的变弱。所以后续的 F90，我们需要引入粗糙度的影响。

4. 角度越大，反射率变化越迅速。

另外，金属跟非金属的 F0 差异很大。
### 金属与非金属的 F0

由于光由电磁波组成，因此，物质的光学特性与其导电特性密切相关。

即根据导电特性，可将现实生活中的物质分为三个主要光学类别：导体（金属）和绝缘体（电解质，非金属）、半导体。

渲染和游戏领域只关注：金属和非金属。

**1. 非金属**

1.1 大部分电介质的光学性质在可见光谱上变化很小，导致无色反射率值，**它们的反射光的颜色一般跟光源颜色一致**。即非金属的 F0 是一个 float。

1.2 基本反射率，也就是 F0，大多为 0.02-0.05（线性值），基本都在 0.17 这个水平线以下，且 rgb 分量一致，所以 Unity 引擎**固定使用 0.04（线性空间）**。

1.3. 虽然非金属的 F0 很低，但 F90 也接近于 1，, 这一现象也导致了金属与非金属外观上的不同

**2 金属**

2.1 一些**金属具有**在可见光谱范围内变化的光学性质。所以反射率 rgb 分量值不一致（正是这个不一致性，使得白光照射下的不同的金属有显著的颜色差异，如金、铜、银）。因为金属表面会吸收所有折射光线而没有漫反射，而 albedo 是我们绘制的材质对于光线的反射率，

**所以我们可以使用 albedo 来作为 F0。**

**金属的镜面反射颜色都来自表面颜色纹理。**

**其实从这句话可以看出，菲尼尔反射效应，本质上也是一个特殊的镜面反射。**

2.2 导体本身的反射率就已经很强，随角度变化很小，所以 F0 较高，范围为 0.5-1.0。

2.3 金属会立即吸收任何透射光，因此它们不会出现任何次表面散射或透明感。这也意味着理论上金属不会表现出任何的漫反射，使得金属看起来很闪亮。

2.4 但实际中由于金属表面氧化等原因，还是会表现出部分散射效果，所以 PBR 用“metalness”作为输入来表示材料的金属程度，而不是 albedo（反射率） & reflectivity。 **因为金属没有透射，所以使用 BRDF 即可。**

**从上文，我们可以得到一个信息：**albedo 纹理，在漫反射里作为漫反射 rgb 系数，在镜面反射里，对于金属，作为 F0使用。

albedo 纹理在 PBR 里是个很特殊的纹理。