
---
title: 101 蓝图
aliases: []
tags: []
create_time: 2023-04-27 11:21
uid: 202304271121
banner: "![[1064722.jpg]]"
---
快捷键：[虚幻引擎蓝图编辑器速查表](https://docs.unrealengine.com/5.1/zh-CN/blueprint-editor-cheat-sheet-in-unreal-engine/)
# 0 GamePlay 框架
![[Pasted image 20230115210832.png]]
Object：虚幻引擎中对象的基类。所有其他类都是 Object 类的子类。
Actor：可以在关卡中放置或产生的对象所使用的基类。
Actor Component：所有组件的基类，这些组件定义可添加到 Actor 的可复用行为。
**因此，每个 Actor 都是 Object，但并非所有 Object 都是 Actor。例如，ActorComponent 是 Object，但不是 Actor。**
![[Pasted image 20230115222649.png]]
-   **继承**（空心箭头）
-   **聚合**（实心箭头），一个对象拥有另一个对象。Actor 拥有 Actor Component
蓝色都是 Actor，橘色是 Actor Component

## Actor 组件
`UActorComponent` 是所有组件的基类。由于组件是渲染网格体和图像、实现碰撞和播放音频的唯一方法，因此玩家游戏期间在场景中看到或进行交互的一切其实都是某一类组件的成果。

创建自己的组件时，需要了解一些主要的类：**Actor 组件**、**场景组件** 和 **Primitive 组件**。

-   **Actor 组件**（类 `UActorComponent`）最适用于抽象行为，例如移动、物品栏或属性管理，以及其他非物理概念。Actor 组件没有变换，即它们在场景中不存在任何物理位置或旋转。

-   **场景组件**（类 `USceneComponent`、`UActorComponent` 的子项）支持基于位置的行为，这类行为不需要几何表示。这包括弹簧臂、摄像机、物理力和约束（但不包括物理对象），甚至音频。
    
-   **Primitive 组件**（类 `UPrimitiveComponent`、`USceneComponent` 的子项）是拥有几何表示的场景组件，通常用于渲染视觉元素或与物理对象发生碰撞或重叠。这包括静态或骨架网格体、Sprite 或公告板、粒子系统以及盒体、胶囊体和球体碰撞体积。
## Level 与 World
一个或多个 Level 组成 World，每个 Level 保存当前所有的 Actors。
WorldSetting 并不是设置 World 的属性（不要混肴），是针对 Level 的设置。仅代表当前一个关卡，并不是所有关卡。

Level 作为 Actor 的容器，同时也划分了 World，一方面支持了 Level 的动态加载，另一方面也允许了团队的实时协作，大家可以同时并行编辑不同的 Level。一般而言，一个玩家从游戏开始到结束，UE 会创造一个 GameWorld 给玩家并一直存在。玩家切换场景或关卡，也只是在这个 World 中加载释放不同的 Level。
## GameMode
**游戏模式 GameMode**
默认设置：
![[Pasted image 20230115223623.png]]
在关卡编辑器的 WorldSetting 中重载，实际运行以重载的 GameMode 为准：
WorldSetting 并不是设置 World 的属性（不要混肴），是针对 Level 的设置。仅代表当前一个关卡，并不是所有关卡。
![[Pasted image 20230115223741.png|300]]
GameMode 类用于定义游戏的规则。
GameMode 还指定将用于创建 Pawn、玩家控制器、游戏状态、HUD 和其他类的默认类, 如上图。
每个关卡都可以有不同的 GameMode。如果不为关卡指定 GameMode，则将使用已经设置好的默认 GameMode。在多人游戏中，游戏模式仅存在于服务器上，不会复制到客户端。
## GameState
**游戏状态 GameState，主要用于联机游戏**

游戏状态类用于记录表示游戏当前状态的变量，在多人游戏中与所有客户端共享。
基本思路是通过游戏模式在服务器上定义规则，而游戏状态则管理游戏中更改的信息，并需要发送给客户端。要使用基于游戏状态类的新蓝图，必须将自定义游戏状态类分配给游戏模式的游戏状态类参数。
游戏状态类是从游戏状态基类延伸而来，会增加一些多人功能。
## PlayerController
**玩家控制器 PlayerController**

控制器类拥有两个主要子类。玩家控制器类由人类玩家使用，Al 控制器类使用人工智能来控制 Pawn。
Pawn 和角色类如果由玩家控制器支配，则仅接收输入事件。
由玩家控制器支配的 Pawn 类可以在游戏中更改。下图来自于关卡蓝图，显示了支配 **Possess 函数** 的用法。在该示例中，当按下 Enter 键时，将由玩家控制器支配关卡中的 otherPawn。
![[Pasted image 20230115225037.png]]
## PlayerState
**玩家状态 PlayerState，主要用于联机游戏**

玩家状态类用于记录特定玩家的信息，这些信息在多人游戏中需要与其他客户端共享。
玩家控制器仅存在于客户端上，而玩家状态会从服务器复制到所有客户端。
要使用基于玩家状态类的新蓝图，必须在游戏模式的玩家状态类参数中设置。
## Pawn
Pawn 是可以由控制器（(玩家或 Al)控制（支配)的 Actor。**Pawn 类表示身体，控制器类表示头脑。**
下图显示了从 Pawn 类继承的一些参数。Pawn 类可以使用支配它的控制器的旋转值。
其他属性表示控制器如何支配 Pawn。
![[Pasted image 20230115225722.png]]
## Character
![[Pasted image 20230115225829.png]]
角色类是 Pawn 类的子类，它用来表示可以行走、奔跑、跳跃、游泳和飞翔的两足角色。该类已经有一组用来帮助达到这一目的的组件。
右图显示了角色类中存在的组件。CapsuleComponent 用于碰撞测试。ArrowComponent 表示角色的当前方向。
Mesh 组件是用于视觉呈现角色的骨架网格体。Mesh 组件的动画由动画蓝图来控制。
CharacterMovement 组件用于定义各种类型的角色运动，如行走、奔跑、跳跃、游泳和飞翔。
CharacterMovement 组件是用 C++编写的，用于处理运动以及多人游戏中的复制和预测。
各种类型的运动都有很多属性可以在组件上调整。

## GameInstance
**GameInstance 游戏实例**
游戏实例类的实例会在游戏开始时创建，并仅在游戏关闭时移除。
关卡中的所有 Actor 和其他对象会完全销毁，并在每次关卡加载时重新产生。
游戏实例类和它包含的数据在各个关卡之间保持不变。游戏实例类仅存在于每个客户端上，不进行复制。
要分配游戏中使用的游戏实例类，前往"编辑”(Edit)>“项目设置”(Project Settings)>“地图和模式”(MapsModes)修改项目设置。
![[Pasted image 20230115230553.png]]

# 1 事件
特点：支持“委托”，支持时间轴
## 委托 Delegate
事件右上角有一个红色小正方形的事件称为委托。这**只是对事件的引用**。某些操作接收事件作为参数，并使用委托来实现事件。
在下图中，名为"时钟”(Clock)的自定义事件委托连线到"按事件设置定时器”(Set Timer by Event)节点的“事件”(Event)输入引脚，这样每一秒都会调用“时钟”(Clock)事件。
![[Pasted image 20230115232942.png]]
## Event Begin Play
游戏开始时将在所有 Actor 上触发此事件。游戏开始后生成的所有 Actor 上均会立即调用此事件。
## Event End Play
Actor 不存在于世界场景中时执行此事件。

Event Destroyed 函数的功能已合并到 EndPlay 函数。
## Event Tick
游戏进程中每帧调用的简单事件。
## Event Level Reset
此蓝图事件节点仅在关卡蓝图中可用。
此蓝图事件节点仅在服务器上执行。在单人游戏中，本地客户端即视为服务器。

**Level Reset** 事件在关卡重启时发出执行信号。它在关卡重新加载后进行某项触发时非常实用。如玩家角色已死亡，但关卡无需重新加载时。
![[Pasted image 20230113203029.jpg]]
## Event Actor Begin Overlap
![[Pasted image 20230113203118.jpg]]
多项条件同时满足时，将执行该事件：
-   Actor 之间的碰撞响应必须允许重叠。
-   执行事件的两个 Actor 的 **Generate Overlap Events** 均设为 true。
## Event Hit
![[Pasted image 20230113203310.jpg]]
只要其中一个相关 Actor 的碰撞设置中 **Simulation Generates Hit Events** 设为 true，该事件便会执行。

# 2 变量
**变量公开为可编辑实例：** 这样在面板上可以看到该变量
![[Pasted image 20221212143830.png]]
或
![[Pasted image 20221212143853.png]]
**Tooltip：** 设置鼠标悬停时的**提示信息**

**修改变量信息：** 搜索 set
![[Pasted image 20221212144027.png|300]]

**蓝图类通过按键操控需要修改 input：** 设置为 Player0
![[Pasted image 20221212144352.png]]

**右键分离引脚：**
![[Pasted image 20221212150227.png]]
![[Pasted image 20221212150237.png]]

**合并向量：** Make Vector
![[Pasted image 20221212151309.png]]

**合并文本：** Append
![[Pasted image 20221212151559.png]]
**文本内容判断：** 相同返回 1
![[Pasted image 20221212151802.png]]

String 类型细节面板可以勾选 multi line，值可设定为多行（alt+enter 换行）

# 3 控制流
![[Pasted image 20221212152327.png]]
## Switch
![[Pasted image 20230112115121.png]]
根据 print 函数传入的 index，如果为 0 则打印 0，如果为 0 则打印 1，如果不是 0 或 1 则打印 error


## Select
![[Pasted image 20230112115354.png]]
根据 print 函数传入的 index，如果为 0 则打印 0，如果为 0 则打印1

实现和上文 Switch 相同的功能：
![[Pasted image 20230112115646.png]]
## Branch
快捷键：B
分支：如果输入为 true，则从 true 输出；如果输入为 flase，则从 flase 输出
![[Pasted image 20221212152757.png]]

## Do Once/Do N
![[Pasted image 20221212165749.png]]
执行一次/N 次
执行次数到达上限时不可继续执行，可以通过 Reset 重制次数
## Flip Flop
![[Pasted image 20221212170353.png]]
交替执行
## Gate
单门：
![[Pasted image 20221212171213.png]]
Enter：执行 Exit 时间
open：开启 Enter
close：关闭 Enter
Toggle（开关）：可以在 open 和 close 之间切换

多门：
![[Pasted image 20221212171717.png]]
按 1 可以顺序输出 out0 和 out1，顺序执行后结束
Is Random，随机输出
Loop，循环输出
## Loop
### While Loop
while 循环
![[Pasted image 20230112121045.png]]
### For Loop
for 循环
![[Pasted image 20230112121639.png]]
### For Loop with Break
多一个 break 条件，跳出循环
![[Pasted image 20230112121904.png]]
## Sequnce
序列：顺序执行所有节点
![[Pasted image 20221212172305.png]]
## Delay
延迟后执行，Duration 单位为秒
![[Pasted image 20221212172034.png]]
可触发延迟在持续点击时，会不断刷新持续时间，直到最后一次点击才进行输出。
## Timer 定时器
![[Pasted image 20230116005635.png]]
定时器 (Timer)负责在经过指定时间后执行指定函数 (或自定义事件)。

按事件设置定时器 (Set Timer by Event): 以自定义事件引用作为输入参数。
按函数名称设置定时器 (Set Timer by Function
Name): 以函数名称和包含该函数的 Object 作为输入参数。

Set Timer for Next Tick by Event：下一帧执行 Event
Set Timer for Next Tick by Function Name：下一帧执行函数

两个函数都有以下参数:
时间 (Time): 表示 Timer 的时长，以秒为单位。
循环 (Looping): 指示 Timer 是继续执行还是仅执行一次。

## 获取控制权
**Get Player Controller** 获取 Player 控制权
**Enable Input** 开启输入
**Diable Input** 关闭输入
![[Pasted image 20221212230036.png]]
## Delay
![[Pasted image 20230112131233.png]]
Delay：如果在 Duration 时间内，Completed 指向的事件再次被调用，不会立即执行，等 duration 结束方可执行。
Retriggerable Delay：如果在 Duration 时间内，Completed 指向的事件再次被调用，会刷新 duration 时间，即连续调用会一直处于 delay 状态。

## 逻辑运算符
-   and  boolean（与）
-   or  boolean（或）
-   not  boolean（非）


# 4 空间位置变换
**获取旋转平移缩放：**
![[Pasted image 20221212182725.png]]
设置位置：
![[Pasted image 20221212183131.png]]
Sweep（扫描）：移动时发生碰撞就会停止，如果关闭碰撞则穿透物体
Sweep Hit result：输出每一步的信息
![[Pasted image 20221212183622.png]]

**移动：**
![[Pasted image 20221212190836.png]]
局部坐标和世界坐标：
![[Pasted image 20221212184820.png]]
相对坐标： 
![[Pasted image 20221212190605.png]]
相对父节点，比如类蓝图中：
![[Pasted image 20221212190646.png]]
Cube 和 Sphere 的父节点都是 DefaultSceneRoot
图中移动 Cube，但是 Sphere 不会移动

在关卡蓝图中设置偏移量：
![[Pasted image 20221212194603.png]]
# 5 碰撞
![[Pasted image 20230115201320.png|300]]
关于碰撞的处理方式，需要记住几点规则：
![[Pasted image 20230115200719.png]]

- 两个对象设置为互相阻挡 (block)才可以产生碰撞, 但是如果想要发生**Hit 事件**, 则需要勾选 `Simulation Generates Hit Events
-   将 Actor 设置为 **overlap** 往往看起来它们彼此 **iganore**，如果没有 **生成重叠事件 `Generate Overlap Events`**，则二者基本相同。
-   对于两个或更多模拟对象：如果一个设置为重叠对象，另一个设置为阻挡对象，则发生重叠，而不会发生阻挡。
-   block 同时也可以是 overlap，但是**不建议同时勾选 Simulation Generates Hit Events 和 Generate Overlap Events**。逻辑上来讲，不会有物体既能处于 Hit 状态又可以重叠，需要手动处理的部分太多。
-   如果一个对象设置为忽略，另一个设置为重叠，则不会触发重叠事件。

**追踪响应 Trace Responses**用于追踪（光线投射），例如蓝图节点 **按信道进行线迹追踪（Line Trace by Channel）**。
**可视性（Visibility）**：泛型可视性测试信道。
**摄像机（Camera）**：通常用于从摄像机到某个对象的追踪。
# 6 射线追踪 Trace
提供两个端点（一个开始位置和一个结束位置），物理系统将"追踪"两个点之间的线段，报告它命中的任何 Actor（带碰撞）
## 按信道或对象类型追踪

因为追踪使用物理系统，你可以定义需要进行追踪的对象类别。可在两个大类中进行选择：通道 Channels 和对象类型 Object Type。
通道可以是可视性（Visibility）和摄像机（Camera）等事物，且几乎只和追踪相关。
对象类型是场景中带碰撞的 Actor 物理类型，如 Pawn、载具、可破坏物 Actor 等等。

可根据需要添加更多信道和对象类型。有关具体操作的更多信息，请参阅 [为项目添加自定义物体类型](https://docs.unrealengine.com/5.1/zh-CN/add-a-custom-object-type-to-your-project-in-unreal-engine)。

## 返回单个或多个命中

追踪时，你可以选择返回与条件匹配且被追踪命中的第一个项，也可返回与条件匹配且被追踪命中的所有项。

需要特别注意 **按信道多重追踪（Multi Trace by Channel）** 和 **按对象多重追踪（Multi Trace For Objects）** 的区别。
使用 **按信道多重追踪（Muli Trace by Channel）** 时，追踪将返回包含路径上所有 **重叠（Overlaps）和第一个阻挡（Block）**，发生 hit 事件后就会结束追踪。想象射击的子弹穿过高高的草丛，然后击中墙壁。

**按对象多重追踪（Multi Trace For Objects）** 将返回与追踪查找的对象类型匹配的所有对象，不会在其命中的首个物体上停止，假定组件设置为返回追踪查询。因此它很适合于计算追踪开始和结束之间的对象数量。
![[Pasted image 20230115175124.png]]
## 使用形状追踪
![[Pasted image 20230115180252.png]]
![[Pasted image 20230115180250.jpg]]
## DrawDebugType
Trace 节点有 DrawDebugType 选项, 用于绘制测试追踪时有用的线条。绘制调试类型 (Draw Debug Type)参数可以设置为以下某个值:
无 (None): 不绘制线条。
持续一帧 (For One Frame): 线条仅出现一帧。
持续时间 (For Duration): 线条在“绘制时间”(DrawTime)参数中指定的时间保持出现。
持久 (Persistent): 线条不消失。
要显示追踪颜色 ( Trace Color) 、追踪命中颜色 ( TraceHit Color)和绘制时间 (Draw Time)参数，单击函数底部的小箭头。
## 从追踪获取 UV 坐标
Find Collision UV 节点
![[Pasted image 20230115180729.png]]
如果使用 Trace Complex，追踪可以返回它命中的 Actor 的 UV 坐标。
![[Pasted image 20230115181915.png|300]]
从 4.14 版起，此功能仅在 **静态网格体组件**、**程序式网格体组件** 和 **BSP** 上有效。它 **无法** 在 **骨架网格体组件** 上正常工作，因为你追踪的是 **物理资源**，而物理资源不具备 UV 坐标（即使你选择 Trace Complex）。

使用此功能将增大 CPU 内存使用率，因为虚幻引擎需要在主内存中保留顶点位置和 UV 坐标的额外副本。

在 **项目设置（Project Settings）** 的 **"物理（Physics）"部分** 中启用 **支持来自命中结果的 UV（Support UV From Hit Results）** 功能，启用后需要重启。
![[Pasted image 20230115180611.png]]

# 7 容器：数组/集合/映射
## 数组 Array
创建数组
![[Pasted image 20221212201825.png]]
设置初始值
![[Pasted image 20221212202237.png]]

**Add**（添加）
**ADD Unique**（增加不存在的数组值）
**Clear**（清除)
**Contains** （包含)
**Filter Array** （过滤数组)
**Find ltem**（查找）
**Get**（获取)
**lnsert ltem**（插入项目)
**Last Index**（最后一个索引值)
**Length** (长度)
**Remove lndex**（删除索引）
**Remove ltem**（删除项目）
**Resize**（调整大小）
**Set Array Elem**（设置数组元素）
**Set Array Elem**中的 Size to Fit：当 index 大于数组最大索引，则扩充至对应数目并赋值
**Shuffle** （打乱数组，洗牌）

**for each loop**
遍历数组
![[Pasted image 20221212204732.png]]
**for each loop with break**
遍历数组，多一个 break 条件
![[Pasted image 20221212205241.png]]
**Append** 追加数组
将第二个数组追加到第一个数组，第二个数组不会发生变化
![[Pasted image 20221212212104.png]]

**Filter Array（过滤数组）** 节点取入一个类型为 Actor（或其任何子项）的数组，并基于输入的 Class（类）过滤该数组。所得结果是一个新数组，仅包含原始数组中和相连的类的类型相匹配的项目。
![[Pasted image 20230115214811.jpg]]
**Find Item（查找项目）** 节点取入一个数组和一个变量，然后查找在数组中第一次找到那个变量的值时该值所处的索引编号。
![[Pasted image 20230115214822.jpg]]

## 集合 Set
![[Pasted image 20230115215753.png]]
- 元素不允许重复
- 无序

**Add** 
将一个项目添加到 Set。

**Add ltems**
从特定 Array 添加项目到 Set。

**Clear**
清除 Set 中的所有项目。

**Contains ltem**
检查 Set 是否包含某个项目。

**Difference**
获取两个 Set 的相对差，将差指定到一个结果 Set。

**lntersection**
获取两个 Set 的交集，将差指定到一个结果 Set。

**Length**
获取 Set 中的项目数量（长度)。

**Remove**
从 Set 中移除一个项目。

**Remove ltems**
从 Set 中移除 Array 中的指定项目。

**To Array**
将 Set 复制到 Array 中。

**Union**
执行两个 Set 的合并，将合并指定到一个结果 Set。

## 映射 Map
![[Pasted image 20230115214310.png]]
也可称为关联数组或者字典
- 存储键值对（Key-Value）
- Key 不能重复
- 无序

**Add** 
将一个键值对添加到 Map。

**Clear** 
清除 Map 的所有条目。

**Contains** 
此节点检查是否提供的 Map 中有键存在。

**Find** 
找到与提供的键相关联的值。

**Keys** 
输出 Map 中所有键的阵列。

**Length** 
决定提供的 Map 中的条目数量。

**Remove** 
从 Map 移除一个键值对。

**Values** 
输出 Map 中所有值的阵列。

# 8 结构体
![[Pasted image 20221212205745.png|200]]
创建结构体
![[Pasted image 20221212205836.png]]
![[Pasted image 20221212210138.png]]

**break 分解**
![[Pasted image 20221212210712.png|300]]
Set members 设置成员变量，引脚默认隐藏，可以设置开启
![[Pasted image 20221212210859.png|300]]
或者使用 Set》Make 方法：
![[Pasted image 20221212210916.png|300]]

## **结构体数组**
结构体本身可以设置为结构体数组
![[Pasted image 20221212211335.png]]
**结构体也可也添加数组变量**
![[Pasted image 20221212211141.png]]

操作和普通数组类似，注意把引脚拆开
![[Pasted image 20221212211620.png|300]]
# 9 继承/多态
![[Pasted image 20221212212301.png]]
子类中显示继承的变量：
![[Pasted image 20230110114103.png]]
多态：子类重写父类的函数 override
![[Pasted image 20230110110912.png|300]]
![[Pasted image 20230110113509.png]]

手动调用父类的函数：
![[Pasted image 20230111173106.png]]
## 创建子类
右键创建蓝图类：
![[Pasted image 20221212213216.png]]
点开子类，可以看到继承的部分
![[Pasted image 20221212213400.png]]
# 11 函数
## 数学函数
Lerp：插值

Interp To ：插值到
![[Pasted image 20230115235150.png]]
lnterp To 函数用于**平滑地更改值**, 直到达到指定目标值。一些示例包括用于浮点值的 FInterp To 函数、用于矢量的 VInterp To 和用于旋转体的 RInterp To 函数。
输入
当前 (Current) : 当前值。
目标 (Target): 要达到的目标值。
时间差量 ( Delta Time): 自上一次执行以来经过的时间间隔。
插值速度 (Interp Speed): 插值速度。输出
返回值 (Return Value): 更接近于目标值的新值。


## 纯函数
![[Pasted image 20230113204836.png]]
纯函数不修改状态或类的成员
如果执行顺序不重要且只是获得数值而不改变数值，那么就可以被标记为纯函数，不用关注什么时候执行（体现为不需要连接执行顺序白线），纯函数只能调用纯函数。
函数代码一致的情况下，两种节点可以看出不同：
纯函数
![[Pasted image 20230109175833.png]]
非纯函数
![[Pasted image 20230109175817.png]]

创建新函数，命名为 PrintFunction
编辑函数：
![[Pasted image 20221212220454.png]]
在蓝图中使用：
![[Pasted image 20221212220531.png]]
## 函数局部变量
新建一个函数，双击函数既可以在 Local variables 中添加局部变量，局部变量尽在函数内部可见
![[Pasted image 20230115220637.png|300]]
# 12 蓝图通信
## 通信类型
![[Pasted image 20221212230239.png]]
### 关卡蓝图或蓝图类各自在蓝图之内的信息交互
**Custom Event** 自定义事件
![[Pasted image 20221212230914.png]]
### 关卡蓝图和蓝图类与场景内部的对象的通信
#### 关卡蓝图
选中场景内的对象在蓝图中引用，通过 get 等获取数据
#### 蓝图类
数据类型 Static Mesh Actor，这里选择 Object Reference
对象引用：引用场景中的实例对象
类引用：引用不在场景中的蓝图类
![[Pasted image 20221212231417.png]]
在 Viewport 中拾取目标 Actor
![[Pasted image 20221212231841.png]]
这样就可以使用该变量表示拾取的 Actor

动态 Actor：
![[Pasted image 20221212232117.png]]
### 蓝图类之间的信息交互
创建两个蓝图类
![[Pasted image 20221212233610.png]]
![[Pasted image 20221212233701.png|300]]

BP TextA 蓝图新建变量，类型选为 BP TextB
![[Pasted image 20221212233743.png|300]]
用吸管吸一下 Bp TextB，这样以进行在 TextA 蓝图类中获取 TextB 的蓝图类信息
![[Pasted image 20221212234003.png|300]]
这样做是有局限性的，只能是同一关卡内的蓝图类进行通信
不在关卡内的蓝图类如何影响其他蓝图类？通过中间变量（通常是玩家操控的 Pawn）
### 通过中间变量进行信息的交互蓝图类与关卡蓝图之间的信息交互
#### 通过 Pawn 控制蓝图类

在 Pawn 的蓝图里添加两个共有变量：
![[Pasted image 20221213101252.png]]
类型分别为对应的蓝图，并拾取
![[Pasted image 20221213101322.png]]
这样 A 与 B 就通过 Pawn 联系起来，可以相互调用

在 A 的蓝图中：
**Get Player Pawn**获取 Pawn 的控制
**Cast To ThirdPersonCharacter**：转换为 Pawn 的子类 ThirdPersonCharacter
转换成功从上面引脚输出，转换失败从 CastFailed 输出

这样 A 就能访问修改 B 的信息
![[Pasted image 20221213102748.png]]

**Get Player Pawn 和 Get Player Character 区别：**
Character 范围更小，如果当前 player 是 Pawn，那么使用 Get Player Character 就获取不到信息。
![[Pasted image 20221222141738.png]]
#### 通过 Pawn 控制关卡蓝图
在关卡蓝图中，建立 Custom Event
![[Pasted image 20221213103810.png]]

在 Pawn 蓝图中，使用 Console 执行控制台命令，Command 输出 `ce 自定义事件名称`
![[Pasted image 20221213103825.png]]
#### 控制台命令
**解释控制台命令工作原理：**
关卡蓝图中自定义事件：
![[Pasted image 20230110234442.png]]
运行后按~调出控制台，按 `ce SpawnRobot` 可以执行该事件，如果该事件有 input，如图所示，按 `ce SpawnRobot 123`，即可打印出123
所以自定义事件输入的 input 可以通过控制台进行赋值

### 遍历搜索引用蓝图类
项目中，一个蓝图类可以使用多次，可能要求产生不同的交互，逐一修改比较麻烦。
在关卡蓝图中：
**Get All Actors of class**：获取指定蓝图类的所有 Actor，以数组的形式
注意这样比较耗性能，一般使用 Beginplay 而不是每帧调用
![[Pasted image 20221213105928.png]]

## 通信方法
- UE4/5 中不存在无差别通信，只能一对一、一对多 (具体)
- 因此，蓝图通信的首要任务是设法获得通信对象的引用 (reference)
- **获得通信对象引用的方式包括: 指定/碰撞/创建/get (all) + cast to** 
![[Pasted image 20221220171645.png]]
- **蓝图通信有三种方式: 直接通信/蓝图接口/事件分发器** ![[Pasted image 20221220171836.png]]
- **蓝图通信是单向的**

**蓝图接口与事件分发器的选择**
![[Pasted image 20230114140951.png]]
### 直接通信
![[Pasted image 20230114121331.png]]
- **使用变量建立引用**：打开眼睛（instace Editable）
- **关卡蓝图**
- **获取指定蓝图类的所有 Actor `Get All Actors of class`**：注意这样比较耗性能，建议在 BeginPlay 时找到想要的 Actor 储存起来。
- **获取指定 Tag 的所有 Actor `Get All Actors with Tag`**
	- 其他类似节点
	- ![[Pasted image 20230115233244.png]]
Tag 设置方式：选择视口中的 Actor 在 Detail 面板中设置
![[Pasted image 20230115232212.png]]
##  类型转换 Cast
“类型转换为”(Cast To)节点将引用变量类型转换为新指定的类型。在某些情况下，必须执行该操作才能访问类或蓝图的变量和函数。

**蓝图转换** 使用时机的几个例子：

-   **需要访问另一个蓝图的特殊版本。**
    -   角色走进火焰中，导致体力值耗尽。
        -   转换到特殊的角色蓝图，以便访问并变更体力值。
    -   角色死亡，需要重新生成。
        -   转换到特殊的游戏模式蓝图，执行重新生成脚本。
            
-   **需要访问相同类的多个蓝图，并以相同方法进行修改。**
    -   场景中拥有数盏灯，事件发生时需将它们开启或关闭。
        -   转换到灯蓝图并执行函数将灯关闭。
            
-   **需要访问一个特殊的子蓝图。**
    -   存在基于一个动物蓝图（猫、狗、鸟）的数个蓝图，需要访问其中一个动物。
        -   转换到猫、狗和鸟，访问其相应的蓝图和特有功能。
### 蓝图接口 interface
![[Pasted image 20230114124147.png]]
相当于 C++中的纯虚函数 [[《C++ Primer 5th》#29. C++ 接口（纯虚函数）]]
![[Pasted image 20230113214503.png]]
**蓝图接口（Blueprint Interface）** 是一个或多个函数的集合 **- 只有名称，没有实施（函数只可以设置 input 和 output 变量） -**  
可以添加到其他蓝图中。任何添加了该接口的蓝图都保证拥有这些函数。接口的函数可以在添加它的每个蓝图中提供功能。在本质上，这类似于一般编程中的接口概念，它允许多个不同类型的对象通过一个公共接口共享和被访问。简单地说，蓝图接口允许不同的蓝图相互共享和发送数据。

**工具函数：**
![[Pasted image 20230115233553.png|300]]

**案例：**
蓝图接口中创建一个函数 StartInterface，只有一个 input 变量（发信方）
![[Pasted image 20230114134346.png]]
**当接口中的函数没有设置 output 变量时，可以通过 event 来调用**
![[Pasted image 20230114133346.png|200]]
三个角色蓝图命名如下，将接口分别添加到 B1~B3
![[Pasted image 20230114134607.png]]
![[Pasted image 20230114134847.png]]
![[Pasted image 20230114134556.png]]
A：按 Q 使用盒体检测对象宏，如果检测到则执行接口函数
![[Pasted image 20230114134722.png]]
GetCommuObject 内部实现：
![[Pasted image 20230114135249.png]]
B1~B3：A 执行接口函数时，B1~B3 触发接口事件（当然这里可以自定义成不同的功能，如让角色进行移动等），在对话框中输出 string
![[Pasted image 20230114134939.png]]
通过接口实现了不同的功能
![[Pasted image 20230114135045.png]]

**当接口函数中有 output 变量时，则不能通过 event 调用接口，点击 interface 函数直接在图表中编辑即可实现功能。**
![[Pasted image 20230114140236.png]]
![[Pasted image 20230114140204.png]]


### 事件分发器
**Event Dispatcher**
![[Pasted image 20230114140755.png]]
**事件分配器** 使用时机的例子：
-   **需要从角色蓝图到关卡蓝图进行通信。**
    -   玩家角色升级，需要开放之前锁定的区域。
    -   玩家角色按下行动按钮，对关卡执行某种操作。
        
-   **生成的 Actor 执行某种操作时触发事件。**
    -   生成一个 Boss，Boss 被消灭时触发事件，在世界场景中生成一个奖励。
    -   在关卡中生成一个道具（武器、回复剂等）并在道具被拾起时告知道具和角色。

**案例：**
角色蓝图中创建事件分发器 EventDispatchers
![[Pasted image 20230112232816.png]]
类似变量，如果类生成了两个实例，那么这两个实例的 Dispacher 是不同的。
还可以增加变量：
![[Pasted image 20230112232856.png]]
按 1 调用事件分发器：
![[Pasted image 20230112232915.png]]


设置两个蓝图类：绑定事件分发器，触发事件设置为增加一个粒子组件
![[Pasted image 20230112233027.png]]
意思就是每次按 1，call 函数被调用都会执行 Bind 绑定的 emitter 事件
效果如下
![[Pasted image 20230112233220.png]]

**Unbind Event** 节点可以从此列表中移除事件。此外，通过 **Unbind All Events** 节点可以解除当前绑定到事件分发器上的所有事件。

# 13 角色蓝图制作

## 素材导入
使用 Maya
### 导出模型骨骼
选择模型和骨骼，导出当前选择
![[Pasted image 20221213112521.png]]
必选：
注意这里只选了模型和骨骼，没有动画文件
![[Pasted image 20221213112611.png]]
![[Pasted image 20221213112644.png]]

### 导出动画
打开动画文件：
时间范围设置成和动画相同的帧数
导出前时间滑块归 0
![[Pasted image 20221213112926.png]]

选择骨骼：
![[Pasted image 20221213112939.png]]
根骨骼》右键》选择层级
确保选择了骨骼的所有层级
![[Pasted image 20221213112957.png]]
编辑》关键帧》烘培模拟
讲所有骨骼和层级进行一次关键帧烘培，因为将角色动画导出为 fbx 格式，fbx 不支持约束绑定和 IK 绑定。
![[Pasted image 20221213113108.png]]

选择模型和骨骼》导出当前选择》导出为 fbx 动画文件
其他选项和上文描述一样，勾选动画和烘焙动画、变形模型
![[Pasted image 20221213113339.png]]
![[Pasted image 20221213113428.png]]
### 导入 ue4
**导入模型骨骼 FBX**
创建 Meshs 文件夹
注意红框的设置，其他保持默认
![[Pasted image 20221213113728.png]]
导入成功
![[Pasted image 20221213113819.png]]

**导入动画：**
创建 Anima 文件夹
导入
![[Pasted image 20221213113952.png]]
选择对应骨骼，开启导入动画，关闭导入模型，其他默认
![[Pasted image 20221213114136.png]]
![[Pasted image 20221213114123.png]]

给模型赋予材质，检查动画是否正常
## 动画混合
![[Pasted image 20221213115712.png]]
![[Pasted image 20221213115751.png]]
![[Pasted image 20221213115813.png]]
### 创建动画混合
![[Pasted image 20221213115856.png]]
Blend Space 多线性混合，多条动画混合轨迹
1D 单线性混合，我们的角色动画比较简单，是一个线性过程
### 角色移动的动画混合
![[Pasted image 20221213120414.png]]
设置奔跑时每秒 4m
![[Pasted image 20221213120659.png]]
![[Pasted image 20221213120642.png]]
### 角色释放技能的动画混合
跳跃属于技能类型
![[Pasted image 20221213120823.png]]
**创建动画蓝图**，动画蓝图可以获取动画状态并将其输入动画状态机，通过动态状态机将动画播放
![[Pasted image 20221213121019.png]]

**新建两个变量**
![[Pasted image 20221213122732.png]]
**Event Graph**
![[Pasted image 20221213122748.png]]
**Anim Graph**
![[Pasted image 20221213122808.png]]
![[Pasted image 20221213122841.png]]
拖入 speed 变量和动画混合 
![[Pasted image 20221213123157.png]]
拖入动画文件
![[Pasted image 20221213122903.png]]
![[Pasted image 20221213122912.png]]
![[Pasted image 20221213123222.png]]
修改判断机制：
![[Pasted image 20221213123316.png]]
![[Pasted image 20221213123344.png]]
![[Pasted image 20221213123355.png]]
![[Pasted image 20221213123407.png]]
![[Pasted image 20221213123415.png]]
## 角色蓝图
### 创建蓝图
![[Pasted image 20221213123648.png]]
默认模板：
![[Pasted image 20221213124050.png]]
选择 Mesh 导入模型和动画蓝图，调整和胶囊体的位置
![[Pasted image 20221213124115.png]]
Mesh 下添加 SpringArm 弹簧臂和 Camera 组件
![[Pasted image 20221213124229.png]]
### 移动属性设置
Camrea 属性中必须开启，否则鼠标不能移动视角
![[Pasted image 20221213124458.png]]
蓝图属性中必须关闭，否则人物转向的时候视角不会转向
![[Pasted image 20221213124745.png]]
移动属性中必须开启，开启后角色可以跟随旋转方向移动
![[Pasted image 20221213124954.png]]

### 设置按键
![[Pasted image 20221213125428.png]]
### 蓝图
**鼠标视角移动：**
![[Pasted image 20221213131459.png]]
**前后左右移动：**
![[Pasted image 20221213131542.png]]
**跳跃**
![[Pasted image 20221213131655.png]]
**行走/跑步切换：**
查看 Character Movement 属性：
![[Pasted image 20221213131939.png]]
![[Pasted image 20221213131924.png]]
通过控制最大行走速度就可以和状态机联动，例如当设置为 100 时就执行走路动画。
按 1 切换状态：lerp 一下速度，让状态切换更平滑
![[Pasted image 20221213132538.png]]
![[Pasted image 20221213132619.png|300]]
### 设置控制者
将蓝图拖入 viewport，设置蓝图属性
![[Pasted image 20221213130735.png]]
# 14 构造脚本
**构造脚本（Construction Script）** 会**在蓝图对象创建时调用，或者在对象出现特定情况下调用，比如当对象移动、旋转、缩放，或有属性发生变动时，构造脚本会再次调用**。构造脚本适合处理需要在游戏开始前计算的内容。
- **游戏开始后，构造脚本将停止执行。此时，构造脚本执行的所有内容都将视为完成。**
- 关卡蓝图不含构造脚本。

通过 RT 案例理解构造脚本：在蓝图对象创建时调用，比如我们需要将材质绘制到一张 RT
![[Pasted image 20230114205914.png]]
在 BP_Test 蓝图自定义事件调用 DrawMaterialToRenderTarget，并在构造脚本中调用改事件
![[Pasted image 20230114210004.png]]
![[Pasted image 20230114210059.png]]
当我们把蓝图拖入 map 中，可以法线我们能还没有 play，就已经完成了绘制，即在对象创建时就已经调用了 Bask 事件。

当我们改变材质时，我们法线 RT 没有跟随变化，我们只需要改变蓝图的属性（当对象移动、旋转、缩放，或有属性发生变动时，构造脚本会再次调用）就可以更新 RT。
# 15 RenderTarget
## 使用 RT 创建纹理
接上文，RT 可以创建材质和静态纹理
- 材质是动态的，随 RT 的改变而改变，本质就是将 RT 作为贴图传入 BaseColor
- 静态纹理是静态的
![[Pasted image 20230114210802.png|300]]

**限制：**
-   如渲染目标正在被用户指定的材质作为纹理进行采样，则无法对其进行绘制。需要使用透明度混合在原处修改渲染目标；或在两个不同渲染目标之间来回切换。
-   绘制到渲染目标时，材质只有 **Emissive Color** 和 **Opacity** 输出为有效。
-   使用渲染目标和 **World Position** 之类的材质表达式节点时不支持灯光，可能返回非预想的结果。
-   Emissive Color 默认锁定为正，但启用材质属性 **AllowNegativeEmissiveColor** 即可输出负值。
![[Pasted image 20230115151024.jpg]]
## 节点
[蓝图和渲染目标参考 | 虚幻引擎文档 (unrealengine.com)](https://docs.unrealengine.com/4.27/zh-CN/RenderingAndGraphics/RenderTargets/BlueprintRenderTargets/Reference/)
![[Pasted image 20230115151701.png]]
**Create Render Target 2D**
新建一个渲染目标并将其初始化到特定的有效维度。

**Clear Render Target 2D**
用给定的 Clear Color 清除特定的渲染目标。

**Export Render Target**
将渲染目标作为 HDR 图像导出到磁盘上。

**Begin Draw Canvas to Render Target**
返回一个可用于绘制到特定渲染目标的画布对象。需要调用 **EndDrawCanvasToRenderTarget** 完成渲染！
请注意：DrawMaterialtoRenderTarget 是更简单的版本，应尽多地替代 Begin/EndDrawCanvasToRT 使用。

**End Draw Canvas to Render Target**
必须和一个 **BeginDrawCanvasToRenderTarget** 组对，完成到渲染目标的渲染。

**Draw Material to Render Target**
用应用到特定渲染目标的材质渲染一个四边形。即时渲染目标已设置，此节点也会对其进行设置，这是一个开销大的运算。如要将多个基元渲染到相同的目标区域，请使用 **BeginDrawCanvasToRenderTarget / EndDrawCanvasToRenderTarget**。
# 16 动态材质实例
**Create Dynamic Material Instance 函数常用有两种：**
![[Pasted image 20230116001636.png]]
Parent：指定母材质

**设置材质参数值：**
![[Pasted image 20230116002748.png]]
此外还可以设置材质参数集中的值
![[Pasted image 20230118171537.png|300]]

**两种使用方式：都实现了将动态材质实例的 BaseColor 更改为蓝色，最终蓝图的 Cube 组件运行时呈现蓝色。**
![[Pasted image 20230116002107.png]]
![[Pasted image 20230116002113.png]]
母材质只是简单设置了一个 BaseColor 变量
![[Pasted image 20230116002327.png|300]]

### 访问曲线图集
在蓝图中，你可以使用 **获取曲线位置（Get Curve Position）** 节点在动态材质实例上设置标量参数值。获取曲线位置（Get Curve Position）以曲线图集为输入，将标量值传递到 **设置标量参数值（Set Scalar Parameter Value）**，然后返回一个布尔值来指示是否在图集中找到了曲线。
![[Pasted image 20230119193124.jpg]]

# 17 宏 Macro
宏和函数的区别：
- 可以自定义入口可出口数量
- 宏在预处理阶段执行
- 展开：蓝图被编译时，宏将复制所有图表节点，并将它们粘贴到宏节点所在之处。
![[Pasted image 20230112133519.png]]

总之，如果需要在各处重复使用一些功能，最好使用宏。但如果需要调整蓝图子项中的行为，或需要从另一个蓝图直接进行访问，则最好使用函数！


# 18 调试
## 断点
![[Pasted image 20230110162656.png]]
![[Pasted image 20230110162713.png]]
## 观察变量值
**运行时右键查看变量值**
![[Pasted image 20230116003239.png]]
## 蓝图调试器
略
# 19 运行时生成 Actor
SpawnActor
**生成时公开（Expose on Spawn）** 允许您设置变量是否应在生成其所在的蓝图时可访问。
![[Pasted image 20230115213840.jpg]]
上面我们有一个名为 **光源颜色（LightColor）** 的变量，它是一个设置为 **生成时公开（Expose on Spawn）** 的线性颜色属性。该变量在点光源的蓝图中实现，点光源使用 **设置光源颜色（Set LightColor）** 节点和 **光源颜色（LightColor）** 变量来确定光源的颜色。

下面，在另一个蓝图中，使用一个脚本来生成点光蓝图，由于 **光源颜色（LightColor）** 变量设置为生成时公开（Expose on Spawn），所以 **从类生成 Actor（Spawn Actor from Class）** 节点上提供了设置此值的选项，这使我们能够在游戏世界中生成光源时设置其颜色。
![[Pasted image 20230115213917.jpg]]

# 20 书签 bookmarks
bookmarks 可以保存当前区域的蓝图，合理命名，快速找到该区域
![[Pasted image 20230112215526.png]]
打开 bookmarks，还能检索注释节点！
![[Pasted image 20230112215835.png]]
![[Pasted image 20230112215821.png]]


# 21 数学表达式
操作符规则：[虚幻引擎数学表达式节点 | 虚幻引擎5.1文档 (unrealengine.com)](https://docs.unrealengine.com/5.1/zh-CN/math-expression-node-in-unreal-engine/)
![[Pasted image 20230113210157.png]]
![[Pasted image 20230113210232.jpg]]
双击可以查看生成的蓝图：
![[Pasted image 20230113210550.jpg]]
# 22 随机流 Random
**RandomStream 变量：**
![[Pasted image 20230113210659.png]]
变量开启 instance Editable，则可以在蓝图类中设置初始种子
![[Pasted image 20230113211235.png]]

**RandomStream 函数：**
![[Pasted image 20230113210807.png|300]]
# 23 时间轴 TimeLine
**只有事件支持时间轴**
![[Pasted image 20230113211527.png]]
shift+左键快速增加关键帧

创建该节点后会自动生成一个 TimeLine 变量，可以执行相应的 get set 函数
![[Pasted image 20230113212750.png]]
# 24 在编辑器中调用蓝图事件/函数
蓝图类中自定义一个事件（函数也可以），勾选**call in editor**
![[Pasted image 20230113213928.png]]
![[Pasted image 20230113214051.png]]
在运行时通过点击控制打印操作
![[Pasted image 20230113213951.png]]

# 25 编辑器中创建蓝图类
选中视口中的 actor，在右侧细节面板将 actor 转化为蓝图类
![[Pasted image 20230116003642.png]]
# 26 HUD 蓝图类
**落后了，现在都用 UMG 做 UI**

HUD 即 heads-up display，这是一类屏幕上的信息显示，用于快速访问重要信息。
.HUD 在游戏中用于向玩家显示各种信息，如分数、时间、能量等。
在虚幻引擎中，HUD 类是包含画布的基类，画布是可以绘制文本和纹理等 Primitives 的对象。
HUD 类包含名为“接收绘制 HUD”(Receive Draw HUD)的事件，该事件用于在每一帧绘制 Primitives。
HUD 类仅存在于每个客户端上，不进行网络同步。

## 创建 HUD 蓝图类
![[Pasted image 20230114215717.png]]
Event Graph 中搜索 Event Receive Draw HUD，有两个输入：
Size X：视口的宽度
Size Y：视口的高度
![[Pasted image 20230114215839.png]]

## 绘制
Draw Material 节点：在 HUD 上绘制一个材质纹理的四边形图片。![[Pasted image 20230114221528.png]]
![[Pasted image 20230114221323.png]]
由中心点的位置各减去 ScreenX 和 ScreenY 的一半，将图片绘制到屏幕中心位置。
![[Pasted image 20230114221706.png]]
![[Pasted image 20230114221809.png]]
# 27 样条线

**蓝图样条组件** 只是用于定义和使用位置数据的一个路径。可使用它在世界场景中移动 **Actors**（或其他 **组件**），或沿样条放置一系列的 **Actors**（或其他 **组件**）。它们可在蓝图视口和关卡编辑器中进行完整编辑，并能添加/移除/复制样条点，变更其切线类型、甚至按 tick 对其设置动画。此外，使用 **蓝图构造脚本** 也可对它们进行编辑，接受蓝图视口或关卡编辑器中进行的编辑并对它们进行进一步修改。

**蓝图样条网格体组件** 的使用情况则完全不同。它们将使单个 **静态网格体** 沿一个两点样条变形。无法对蓝图样条网格体组件添加更多样条点，但可通过蓝图完全控制两点。

蓝图中增加样条线组件
![[Pasted image 20230115153033.png]]

# 28 文本格式化 Format Text
![[Pasted image 20230115221522.png]]
用{}表示一个输入值，可以设置多个，变量类型也可以是其他类型。
如果把 Text 设置成“默认值”，则输出如下：
![[Pasted image 20230115221625.png]]

28 从视口中创建