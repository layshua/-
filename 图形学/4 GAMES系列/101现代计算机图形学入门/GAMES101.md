

---
title: GAMES101
aliases: []
tags: []
create_time: 2023-05-06 15:41
uid: 202305061541
cssclass: academia, academia-rounded
banner: "![[Pasted image 20230506154153.png]]"
---

# 光栅化 rasterization
光栅 raster 这个词就是德语中屏幕的意思，**光栅化的意思就是将图像绘制在屏幕上进行显示。**

> [!NOTE] 
> 要进行光栅化需要先将空间变换到屏幕空间，以下都是在屏幕空间上的操作

## 三角形-基本形状单元

三角形在图形学中有很多很好的性质：
1. 三角形是最基本的多边形，并且任何其他的多边形都可以拆分为三角形。
2. 三个点可以保证他在一个平面如果是四边形四个点就不能保证。
3. 它可以很好地用叉积判断一个点是不是在三角形内部（三角形的内外定义特别清晰）

## 采样

**采样就是给定一个连续的函数，在不同的点求它的值，也可以认为，采样是把一个连续的函数离散化的过程。**
**光栅化的过程其实就是在屏幕空间离散的像素中心点上进行采样来判断像素是否在三角形内的采样。**
比如下图中，要实现一个判断屏幕上的像素是否在三角形内的函数 inside (tri, x, y)，然后将三角形顶点构成的最大长方形区域内所有点作为函数的输入，判断这些点是否在三角形内，如果在三角形内，就将屏幕上的像素点进行点亮。这个过程就是采样。其他采样的例子包括对视频进行时间上的采样，这样就可以得到视频中的某几帧画面。
![[Pasted image 20230519213634.png]]
`inside(tri,x,y)`
1：point (x, y)在三角形内（判断方法见软光栅中的总结），如果碰巧点在三角形的边界，可以设定标准视为在内或在外
0：其余情况
遍历所有点，判断所有点是否在像素内
```cpp file:Inside函数
for(int x = 0; x < xmax; ++x)
{
    for(int y = 0; y < ymax; ++y)
    {
        image[x][y] = inside(tri, x + 0.5, y + 0.5);
    }
}
```

一张照片其实就是所有达到感光元件的光学信息，通过把它离散成图像的过程，其实这也是采样。采样不仅可以发生在不同的位置，也可以发生在不同的时间，视频就是在时间中进行采样的。
![[Pasted image 20230519213806.png|300]] ![[Pasted image 20230519213811.png|300]]
### 包围盒（bounding box）

利用包围盒 (Bounding Box)对不会包含三角形的像素进行优化
![[Pasted image 20230519213724.png]]

## Artifacts
**Artifacts 可翻译为伪影、瑕疵，** 表示了一切在图形学上的错误，异常，不希望看到的结果，看上去不对的效果以及各种瑕疵。


**a、采样产生的第一个问题就是我们刚刚提到的锯齿问题（Jaggies）**

在光栅化中表现为锯齿（Jaggies!）。我们可以看到右边的图中三角形有明显的凹凸锯齿。
![[Pasted image 20230519213743.png]]
**锯齿产生的原因**就是因为**信号的变化频率高，而相应的采样频率低**。在计算机渲染中，由于绘制的**图形在数学上是连续的**，而渲染的**像素点是离散的**，从而导致在光栅化的三角形遍历阶段，将图形打散为像素时，会不可避免的产生**锯齿（Jaggies）**。

**锯齿（Jaggies）现象也被称为走样（Aliasing）**。常见的走样有几何走样，着色走样、动画走样。**消除锯齿现象的技术就是抗锯齿，也被称为反走样（Anti- Aliasing，AA）**。
1. **几何走样**：几何覆盖函数采样不足，即俗称的边缘锯齿，一般发生在光栅化阶段。注意下图立方体边缘 ![[9a6a1f2cdd7d513757163e28ff815eea_MD5.webp]]
2. **着色走样**：渲染方程的采样不足，因为渲染方程也是连续函数，对某些部分在空间变化较快（高频部分）采样不足也会造成走样，反映在视觉上一般是图像闪烁或噪点，这类走样称之为着色走样，一般发生在各种着色阶段。注意下图中的高光，给人的感觉非常噪。![[c17a051be42e32e7fedb5beb41fa0d7b_MD5.webp]]

**走样不可避免**，只能减轻。主要通过硬件（像素点数量加倍）和软件（各种算法，如超级采样算法等）来反走样（抗锯齿）。
1. 硬件增加采样率：本质上增加了频谱之间的距离，需要更高分辨率的显示器、传感器、帧缓冲区。
2. 软件算法：先模糊后采样+各种抗锯齿算法

**b、Moiré Patterns in Imaging—（摩尔纹）**

如果我们把下面图片左图中的**奇数行和列的像素剔除**，就会出现摩尔纹效果。当我们拿手机拍显示屏的屏幕时也会出现类似的的效果，这些都是采样带来的问题。
![[Pasted image 20230519214150.png]]
**c、Wagon Wheel Illusion (车轮错觉)**

接着是车轮效应，当我们顺时针旋转纸片时，如下图所示：有些条纹显得在逆时针旋转，在生活中我们也经常能看到类似的现象，比如高速行驶的汽车，其轮子看上去在反向旋转，这是因为人眼在时间中的采样速度更不上运动的速度造成的。
![[Pasted image 20230519214201.png]]
## 反走样（抗锯齿）

### 先模糊再采样

如何进行反走样呢？可以在采样之前先做模糊再采样（模糊也可以认为是低通滤波器，把三角形边界的这种高频信号给过滤掉）。（注意：顺序不能变，先采样再模糊无法反走样）

![[5fb72113837a507894d8787b74f0a7df_MD5.webp]]

### 抗锯齿算法
[[第四章 高级扩展#4.4 抗锯齿]] 
## 信号基础
上面我们出现了走样（**Aliasing**）问题，我们是通过先模糊后采样的进行反走样（**Antialiasing** ）去优化它的。这里我们不仅不思考几个问题： 
1. **为什么采样频率低于信号变化频率就会产生走样？**
2. **为什么先模糊后采样就可以解决锯齿问题？**

> [!NOTE] 答案：
> 1. 进一步理解走样：
![[Pasted image 20230519215455.png]]
图中蓝色为高频信号，黑色为低频信号，当我们采用相同的采样频率（图中的圆圈为对应得采样点）采样时，得到的结果相同。即在给定的采样率下我们无法区分他们得信号频率，这就是走样。
>2. 模糊就是一个低通滤波先把高频的信息拿掉，这样做的原因就是让频谱覆盖的面小一些然后我们再以原本的间隔去采样它，这个时候我们发现它就不会产生信号重叠了。
![[Pasted image 20230519231332.png]]


要探究其根本原因，我们就需要了解一点信号原理。
### 时域/频域
- 频域是描述信号在频率方面特性时用到的一种坐标系。在电子学，控制系统工程和统计学中，**频域图显示了在一个频率范围内每个给定频带内的信号量** 。
- 时域是描述数学函数或物理信号对时间的关系的一种坐标系。

**1、时域（时间域）**（time domain）

自变量是时间, 即横轴是时间, 纵轴是信号的变化。其动态信号 $x(t)$ 是描述信号在不同时刻取值的函数。

![[0a28d03e344d360d277a69ecb1f8c3f2_MD5.webp]]

图 1 是正弦波的时域图，示出了振幅与时间的关系。在时域图中，横轴是时间，纵轴是振幅。时域图显示振幅随时间的变化，可以看出峰值振幅为 5V，可以算出频率 f=6 Hz。

**2、频域（频率域**）（frequency domain）

自变量是频率, 即横轴是频率, 纵轴是该频率信号的幅度, 也就是通常说的频谱图。

![[1a93ef106ce561eaca6d9ed548ca25a8_MD5.webp]]


图 2 是图 1 中正弦波的频域图，在频域图中，横轴是频率，纵轴是峰值振幅。**频域图仅仅示出峰值振幅与频率，而不显示振幅随时间的变化。**

从频域图可以看出，正弦波的频率为 6Hz，这个 6Hz 的正弦波的峰值振幅为 5V 。

频域图的优点是，从频域图中，可以一眼看出正弦波的频率和峰值振幅。整个正弦波在频域图上只是一个立柱立柱的位置显示了正弦波的频率，立柱的高度显示了正弦波的峰值振幅。

**3、时域和频域**

将时域频域一起放在一个三维的坐标系中，如图所示，与时域和频域的轴表示振幅：
![[84d2bd76b2350bd34e3a57efd74e79fd_MD5.webp]]

另外一张动图：
![[v2-809c336fd3cbe446a57e0cf09afa593b_b.gif]]


**4、时域变换到频域的意义**

对信号进行时域分析时，有时一些信号的时域参数相同，但并不能说明信号就完全相同。因为信号不仅随时间变化，还与频率、相位等信息有关，这就需要进一步分析信号的频率结构，并在频率域中对信号进行描述。

**动态信号从时间域变换到频率域主要通过傅立叶级数和傅立叶变换等来实现。** 很简单时域分析的函数是参数是 t，也就是 y=f (t)，频域分析时，参数是 w，也就是 y=F (w)两者之间可以互相转化。**时域函数通过傅立叶或者拉普拉斯变换就变成了频域函数。**

总的来说，在某种需求下将信号变换到另一种域中，有利于进行处理、计算和分析。

### 空间域/变换域
**空间域（spatial domain）**
空间域简称空域，又称图像空间 (image space)，一般这个概念会出现在数字图像处理中，指由图像像元组成的空间。在图像空间中以长度 (距离)为自变量直接对像元值进行处理称为空间域处理。
简单来说就是是以图像左上为原点，横为 y 竖为 x 的二维平面。  
![[Pasted image 20230519222221.png]]

实际上你可以简单理解为，像素空间，在空域的处理就是在像素级的处理，通过傅立叶变换后，得到的是图像的频谱。表示图像的能量梯度。

**变换域：**
在有些情况下，通过变换输入图像来表达处理任务，在变换域执行处理任务，方便我们的计算吗，然后再逆变换到空间域。比如使用傅里叶变换将图像转换到频率域进行滤波，再转换回空间域得到滤波后的图像。
简单来说，就是空间域经过傅里叶变换，变换为频域。我们在频域进行滤波等处理。这个频域我们也可以成为"变换域"，变换域是一个宽泛的概念，可以理解为一种中间状态。

> [!important] 理解
> 广义上，傅里叶变换将时域转换到频域。而在图像处理中，傅里叶变换可以将空间域转换为频域（变换域）。**下文讨论的傅里叶变换我们都认为是在图像处理中进行。**

### 频率和周期
频率是 f，周期是 T。  
频率越快，函数变化越快，如下图所示。  
![[Pasted image 20230519214316.png]]
### 傅里叶级数展开
**傅里叶级数展开：** 任何一个周期函数都可以写成一系列正弦和余弦函数的线性组合和一个常数项。
![[Pasted image 20230519214332.png]]

![[ee1231062ffc8dc28f21e594ae143109_MD5.webp]]

通过傅里叶级数展开，我们将周期函数分解为多个不同频率的段（即上式中的正弦和余弦函数），随着展开式越来越多，越来越接近我们想要表达的函数：
![[Pasted image 20230519214421.png]]
>从图中可以看出，在设置相同的周期性采样位置（对应采样频率）的条件下，低频信号的采样点连接起来更接近原函数（对应信号变化频率），而高频信号的采样点连接起来就和原函数相差很大。这说明，信号变化频率越高，我们就需要越高的采样频率。

### 傅里叶变换 Fourier Transform 
傅里叶变换（**Fourier Transform**）：空间域转换为频域

傅里叶变换，**傅里叶变换可以将信号分解为频率，并且能将满足一定条件的某个函数表示成三角函数（正弦和/或余弦函数）或者它们的积分的线性组合**（如下图）。
![[Pasted image 20230519214406.png]]
![[f760f7ce9e8cf66d2f51fbd596b267d3_MD5.webp]]
>左图：空间域图像/右图：频域图像（我们称之为**频谱**）


### 滤波 Filtering 
- 滤波：去除特定的频率的内容
- 高通滤波器（High-pass filter）：只保留高频信号（高频信号一般在边界）
- 低通滤波器（Low-pass filter）：只保留低频信号（画面变模糊）

我们之前光栅化抗锯齿做的先模糊就是采用了低通滤波器，使其高频信号边界去除然后图形就会变得模糊。

![[487b949ab2557b6eee493568fdda5db5_MD5.webp|850]]

**应用滤波器时，使用的是卷积运算。（可以说滤波=卷积）**

**在空间域上的卷积等同于在频域上的乘积。**

下图我们用了一个 33 的卷积核在实域做了一个卷积，因此图片变得模糊了。如果我用一个更大的卷积核（$9\times9$）做卷积图片会变得更模糊（我们这里可以用极限的思想来想一想，如果这个卷积核无限大比图片像素还大，那是不是每个点积值几乎都是一样的，保留的信息就越少了越接近低频。如果我们用一个无限小比图片像素还小的卷积核去做卷积，那是不是意味着它相当于没有做滤波，值没有改变，也就是说把所有的频率信息都保留下来了）。

![[Pasted image 20230519224739.png]]

### 从频域的角度看采样

接下来我们从频域的角度来看什么是采样？**采样其实就是在重复频谱上的内容。**

我们可以看到时域上的连续函数（a）, 它的频域对应的是（b）。
采样的过程就是让（a）乘以冲激函数（c）得到一系列离散点（e）。

从 S (f)中的频谱中可以看出，采样就是在重复原始信号的频谱。

![[Pasted image 20230519225709.png]]
  >左边时时域图像/右边是频域图像（频谱）
  
密集采样是没有问题的，但是如果采样频率过小（采样店数量很少），这就会导致频谱之间的距离减少，这可能导致了原始信号与重复的信号产生**频谱混叠**（也就是走样）如下图：。
![[Pasted image 20230519230142.png]]


**知道了这个走样的原理，我们就可以解释为什么先做一个模糊再进行采样可以进行反走样。模糊就是一个低通滤波先把高频的信息拿掉，这样做的原因就是让频谱覆盖的面小一些然后我们再以原本的间隔去采样它，这个时候我们发现它就不会产生信号重叠了。**
![[Pasted image 20230519231332.png]]





# 着色 shading

定义：对不同的物体应用不同的材质

在现代 GPU 中，纹理的采样与过滤方式皆已通过硬件实现，因此我们现在可以方便的使用贴图进行渲染。
## 纹理映射 TextureMapping 

首先让我们一起来观察这样一张图：

![](<images/1684499673566.png>)

无论是球上的图案，以及地板的木头纹理都呈现出了不同的颜色信息，那么回想在讲解 Blinn-Phong 反射模型的时候曾提到，一个点的颜色是由其**漫反射系数**决定的，反射什么颜色的光，人眼就能看见什么颜色。那么针对上面这幅图，难道要去**针对每一个点自己去设定一个颜色**吗？还是说有什么更方便的方法呢？那便是**纹理映射**了！

主要有两种方法可以将三维的空间坐标点转化为二维的纹理坐标点：Projector 和 UV Mapping
### Projector
对于简单的集合体，通常用投影的方式：
![](<images/1684499673628.png>)

倘若拥有从 3 维 World space 到 2 维 Texture space 的一个映射关系，那么只需要将每个点的颜色信息即漫反射系数存储在 2 维的 Texture 之上，每次利用光照模型进行计算的时候根据映射关系就能查到这个点的漫反射系数是多少，所有点计算完之后，结果就像最左边的 screen space 之中，整个 Texture 被贴在了模型之上。

一个纹理坐标使用的伪代码供参考:

![](<images/1684499674200.png>)

**简而言之就是对每个光栅化的屏幕坐标算出它的 uv 坐标 (利用三角形顶点重心坐标插值)，再利用这个 uv 坐标去查询 texture 上的颜色，把这个颜色信息当作漫反射系数 Kd。**

将矩形地图纹理均匀贴到球表面的投影函数称之为：Spherical 形式。此外还有 Plane, Cubic 和 Cylindrical，下图总结了四者差异（一张红绿相间的纹理贴到不同简单几何体的方式）：
![](<images/1684548373611.png>)

### UV Mapping

对于更复杂的几何体贴图，往往需要用到 UV Mapping：用于将 3 维模型中的每个顶点与 2 维纹理坐标一一对应。 UV map 则需要建模师精心制作：

![](<images/1684548373674.png>)

在实时渲染中，通常是将 uv 坐标保存在顶点信息中，在三角形内使用时，通过插值的方式得到每个片元具体的 uv 坐标，再从纹理中采样获得对应的值。但也有例外，比如在进行环境贴图 (Environment Mapping) 时，需要在渲染时根据投影方程再去确定每个点的纹理坐标以及纹理值

## 纹理过滤

在理解了纹理映射的基础之后，考虑如果纹理精度特别小 (reslution 低) 或者纹理精度特别大 (reslution 大) 会分别引起什么问题呢？

### 2.1 纹理过小引发的问题

纹理过小的问题相对容易理解，想想我们把一张 100x100 的纹理贴图应用在一 500x500 的屏幕之上必然会导致走样失真，因为屏幕空间的几个像素点对应在纹理贴图的坐标上都是集中在一个像素大小之内。那么如果仅仅是使用对应 (u, v) 坐标在 texture 贴图下最近的那个像素点，往往会**造成严重的走样**。
![|300](<images/1684499674257.png>)

黑点表示纹理的纹素，红点表示屏幕空间的像素采样点，采样时最简单的办法是去选择离采样点临近的纹素（该方法称为最邻近采样 Nearest neighbor），那么该采样点采样得到的颜色就是该纹素的颜色。

这种方法往往会产生严重的走样，接下来会介绍利用双线性插值的方法缓解这种走样现象。

### 2.2 双线性插值 (Bilinear Interpolation)

我们依然取上图的点作为例子，解释双线性插值。 

第一步，取出离红色点最近的 4 个黑色顶点，分别算出，该红色点在水平及竖直方向偏移的比率 $s,t$，图示如下:

![|300](<images/1684499674313.png>)

接着先利用 $s$，可以线性插值出如下图所示的 $u_0$，$u_1$ 点的颜色值
![[Pasted image 20230520102619.png]]
那么下一步相信读者也能猜到了，利用比例 $t$，颜色值 $u_0$，$u_1$ 插值出红色点的颜色值
![[Pasted image 20230520102532.png]]


如此这样利用两次线性插值，考虑到了 4 个纹素的颜色值，能够很好的缓解走样失真现象，并且计算速度较高。

(tips: 还有一种插值方法叫做双三次插值 (Bicubic), 取临近 16 个纹素，每次对 4 个纹素用三次插值，而不是线性插值，效果可能更好，但是计算速度很低不在这里具体讨论了)

最后以一张闫老师课上的例子看看这 3 种方法效果的对比
![[Pasted image 20230520102841.png|500]]

### 2.3 纹理过大引发的问题

可能对于我们的第一直觉来说，纹理小确实会引发问题，但是纹理大那不是更好吗，为什么会引发问题呢？但事实是纹理过大所引发的走样甚至会更加严重。想象一张很大的地板，在上面铺满了重复的方格贴图，我们所期望看到的结果应该是这样的：

![|500](<images/1684499674488.png>)

嗯，非常符合透视关系，不错，当然这只是一个参考。再来看看利用在第一章所提到的计算纹理颜色的伪代码来计算的结果呢：

![|500](<images/1684499674550.png>)

**近处锯齿！远处摩尔纹！** 非常严重的走样现象，为什么会导致这样的一个现象呢？这里作者尝试给出自己的两种解释:

**1 如开头所说，地板上铺满了重复的方格贴图，根据近大远小，远处的一张完整的贴图可能在屏幕空间中仅仅是几个像素的大小，那么必然屏幕空间的一个像素对应了纹理贴图上的一片范围的点，这其实就是纹理过大所导致的，直观来说想用一个点采样的结果代替纹理空间一片范围的颜色信息，必然会导致严重失真！(从信号的角度来说就是，采样频率过低无法还原信号原貌)**

**2 换一种想法，考虑离相机很远的一个三角形面，假设该三角形面真正在纹理贴图上对应的一片区域有 10 个像素点。但是由于透视的关系，距离很远的三角形面投影到近平面时可能只有 1 个或 2 个像素点的大小 (远远小于 10 个像素的原来大小)，那么这 1 个或 2 个像素采样 texture 的结果就要代表原来这个三角形面 10 个像素点的颜色信息，自然会导致失真！**
![[Pasted image 20230520103718.png]]

一种直观的解决方法就是超采样 Supersampling，如果一个像素点不足以代表一个区域的颜色信息，那么便把一个像素细分为更多个小的采样点不就可以解决这个问题了吗？对，确实是这样，可以看看如下图 512x 超采样的结果

![](<images/1684499674687.png>)

效果虽称不上完美但也极大缓解了走样现象，但问题是什么？计算量太大了，一个像素点被分为了 512x512 个采样点，计算量几乎多出了 25 万倍！这显然不是所希望看到的，并且随着屏幕空间的点离相机距离更远，更多的 texels (纹理空间的像素) 会在屏幕像素的一个覆盖面积（footprint） 里面，会要更高的超采样频率。

那么另外一种想法，如果不去超采样，仅仅是求出每个屏幕像素所对应的覆盖面积（footprint） 里所有 texels 的颜色均值呢？这也就是接下来所要介绍的著名的 Mipmap 技术了！

### 2.3 Mipmap

回顾一下屏幕像素在 Texture 空间里的覆盖面积（footprint） 的这张图:

![](<images/1684499674811.png>)

正如上文所提，一个采样点的颜色信息不足以代表 “覆盖面积（footprint）” 里一个区域的颜色信息，如果可以求出这样一个区域里面所有颜色的均值，是不是就是一种可行的方法呢？没错我们的目标就是从点查询 (point query)迈向范围查询 (range query)。但依然存在一个问题，从上图不难看出，不同的屏幕像素所对应的覆盖面积（footprint） size 是不一样大小的，看下图这样一个例子：

![](<images/1684499674849.png>)

远处圆圈里的覆盖面积（footprint） 必然比近处的要大，因此必须要准备不同 level 的范围查询才可以，而这正是 Mipmap。 

**Mipmap 允许范围查询 (快速，近似，正方形)**
![[Pasted image 20230520105340.png]]

![](<images/1684499674924.png>)

level 0 代表的是原始 texture，也是精度最高的纹理，随着 level 的提升，每提升一级将 4 个相邻像素点求均值合为一个像素点，因此越高的 level 也就代表了更大的覆盖面积（footprint） 的范围查询。接下来要做的就是根据屏幕像素的覆盖面积（footprint） 大小选定不同 level 的 texture，再进行点查询即可，而这其实就相当于在原始 texture 上进行了范围查询！


> [!NOTE] Mipmap 的额外显存开销
>原始图像开销：$128\times 128=16,384$
> mipmap 开销：$128\times 128+64\times64+32\times32+16\times16+8\times8+4\times4+2\times2+1\times1=21845$
> 额外开销：$\frac{{21845-16384}}{16384}\approx1/3$
> 即做 mipmap 比会增加原本图像 1/3 的额外存储量
>
>Mipmap 除了能消除采样率过低带来的失真问题，还有一个重要的优点是**节约显存带宽**，注意是带宽而**不是容量**。Mipmap 实际消耗的显存大约增加了 1/3，但每次仅从需要的 Mipmap 级别进行读取，而不必每次都访问原始大小的纹理，因此可以节约带宽。
>

#### 如何去确定使用哪个 level ？
利用屏幕像素的相邻像素点估算覆盖面积（footprint） 大小再确定 level D！如下图:
![[Pasted image 20230520111345.png]]
在屏幕空间中取当前像素点的右方和上方的两个相邻像素点 (4 个全取也可以)，分别查询得到这 3 个点对应在 Texture space 的坐标，计算出当前像素点与右方像素点和上方像素点在 Texture space 的距离，二者取最大值，计算公式如图中所示，那么 level D 就是这个距离的 log2 值 (D = log2L) ! 这不难理解，读者可以具体取几个例子比如 L = 1，L = 2，L = 4，看看是否符合这样的计算即可。

但是这里 D 值算出来是一个连续值，并不是一个整数，有两种对应的方法：

1. **四舍五入取得最近的那个 level D**
![[Pasted image 20230520111752.png]]
我们会发现不同 level 边缘很硬，为了解决这个问题，自然想到了插值

2. **利用 D 值在向下和向上取整的两个不同 level 进行 3 线性插值**

![](<images/1684499675056.png>)

所谓 3 线性插值，就是在向下取整的 D level 上进行一次双线性插值 (前文提过)，再在 D+1 level 之上进行一次双线性插值，这二者数据再根据实际的连续 D 值在向下和向上取整的两个不同 level 之间的比例，再来一次线性插值，而这整体就是一个三线性插值了。
![[Pasted image 20230520112104.png]]

好了！根据上述的方法算出屏幕上每一个像素点所对应的 Mipmap level，再进行三线性插值得到颜色值，是否就能很好的解决走样问题了呢？很遗憾，在本文的那个地板的例子之中，费了这么大力气依然不能完美解决，如下图结果:

![](<images/1684499675124.png>)

远处的地板产生一种模糊的现象（Overblur）。该如何解决这个最后的问题呢——各向异性过滤。

### 2.4 各向异性过滤 Mipmap
各向异性的意思是在各个方向上的表现不相同。通过各向异性可以考虑不同的方向性。

**产生 Overblur 的原因是因为，所采用的不同 level 的 Mipmap 默认的都是正方形区域的 Range Query**，然而真实情况并不是如此，见下图:

![](<images/1684499675236.png>)

可以看出不同 screen space 的像素点所对应的覆盖面积（footprint） 是不同的，有长方形，甚至是不规则图形，那么针对这种情况，有的所需要的是仅仅是水平方向的高 level，有的需要的仅仅是竖直方向上的高 level，因此这也就启发了各向异性的过滤:

![](<images/1684499675290.png>)
>从左往右看，宽度从原长逐渐缩小逼近 0
>从上往下看，高度从原长逐渐缩小逼近 0

> [!NOTE] 各向异性过滤显存开销
> ![[Pasted image 20230520144131.png]]
> 可以看出，额外 3 倍的显存开销

利用这样不同的贴图，更加精细的选择后结果就会明显好很多，基本解决了overblur:

![|300](<images/1684499675354.png>)

**各向异性过滤只能解决水平或竖直的不同大小的矩形覆盖面积（footprint），并不能解决斜向的覆盖面积（footprint）。**
![[Pasted image 20230520112744.png|323]]

解决方法：EWA 过滤
![[Pasted image 20230520112852.png|400]]
EWA 过滤就是把斜着的图形拆成很多个圆形去覆盖不规则形状，每一次就查询一个圆形，然后多次查询，自然就可以覆盖这个不规则的形状，得到好的结果。缺点是开销较大

#### 附录：各向异性过滤实现步骤

（1）计算得到 UV 在 xy 方向上的偏导数 $du_{x},du_{y},dv_{x},dv_{y}$

（2）计算得到纹理坐标偏导数 $s=du*width,t=dv*height$

（3）计算绘制图形在纹理空间的投影向量 **r1 r2 d1 d2**

$r1 = (s_{x},t_{x}),r2=(s_{y},t_{y})$

![](<images/1684499683255.png>)

其中，为了后续计算简便，将向量的模进行近似

$|r1| \approx max(|s_{x}|,|t_{x}|)$

$|r2| \approx max(|s_{y}|,|t_{y}|)$

$|d1| \approx max(|s_{x}+s_{y}|,|t_{x}+t_{y}|)$

$|d1| \approx max(|s_{x}-s_{y}|,|t_{x}-t_{y}|)$

（3）计算使用的 MipmapLevel

$j=min(|r1|,|r2|,|d1|,|d2|)$

$l = log_{2}j$ ，此为采样使用的 MipmapLevel

$f=\frac{j}{2^l}-1$ ，此为三线性过滤使用的插值系数

（4）计算各向异性比例

$N = min(2^{[log_{2}\frac{max(|r1|,|r2|)}{j}]}, maxAniso)$ 这里的 maxAniso 就是设置开启的各向异性过滤级别，方括号代表取整

（4）在上面计算出的 MipmapLevel 下进行多次三线性采样，为此需要生成一系列采样坐标

$m = max(r1,r2)$ (这里使用的是向量 r1 r2)

$du = \frac{m.x}{2^{l}N},dv = \frac{m.y}{2^{l}N}$

$u_{n} = u + (\frac{n}{2} du),v_{n} = v+(\frac{n}{2}dv)$

其中 $n = -N+1,-N+3......-3,-1,1,3......N-3,N-1$

（5）将采样获得的颜色进行平均

一般来说，我们在游戏中最高可以开启 16x 的各向异性过滤，但是实际运算时会将我们设置的各向异性级别与计算得的 N 取较小值，因此并不是开启了 16x 就一定会执行 16 次采样。各向异性过滤相比双线性的性能消耗成倍增长，好在现代 GPU 上纹理采样已不是瓶颈，在平时游戏时我们可以放心开启此选项，帧数不足时优先关闭阴影、抗锯齿等特效。


## 凹凸/法线贴图（Bump/Normal Map）

-   其最大的意义是为了表现相对高度来展示凹凸效果减少面数。
-   凹凸、法线贴图仅表示凹凸效果不会改变几何形体。

### 计算法线贴图（二维）

下图中红色线为原始的表面，蓝色曲线为使用法线贴图后的效果。，我们讨论平面上点 $p$ 的法线
-   $p$点原来的法线朝上，即$n(p) = (0, 1)$
-   通过求 $p$ 点的导数 $dp = c*[h(p+1) - h(p)]$ 求出两点的高度差。其中 c 为常数表示凹凸贴图的影响程度，h 为高度 p 点、p+1点对应高度。
-   因此切线可表示为 $t(p)=(1,dp)$。
-   切线与法线垂直，因此 $n(p) = (-dp, 1)$， $n(p)$ 要归一化

![[59188f6b18a7ca67c543bacd8a52bfac_MD5.webp]]

### 计算法线贴图（三维）

三维的情况下有 u、v 两个方向的变换。

实际情况下法线方向不一定朝上，这里的例子是基于一个局部坐标系确定的。

-    $p$ 点原来法线为： $n(p) = (0, 0,1)$
-   求 $p$ 点的倒数：
    -  $dp/du = c1 * [h(u+1) - h(u)]$
    -  $dp/dv = c2 * [h(v+1) - h(v)]$
-   $n(p) = (-dp/du, -dp/dv, 1)$, $n(p)$ 要归一化

注意以上计算发生在模型空间。
### 位移贴图（Displacement mapping）

-   位移贴图会真实改变模型，会展现出凸起部分的投影。
-   模型需要足够细致，采样需要足够高。

![[c2ab3f5019ee8a87ec734a3e338cfc09_MD5.webp]]

DirectX使用曲面细分来提高计算效率。

## 三维纹理

-   利用三维空间中的噪声函数进行纹理映射（例如Perlin Noise）
-   预先进行环境光遮蔽计算模型阴影
-   体渲染通过三维纹理记录信息，然后进行渲染

## 纹理数据源
![[Pasted image 20230517230046.png]]

> [!NOTE] 
> 艺术家使用美术软件制作贴图并导出为 TGA、PNG 等格式，最后引擎自动将其转换为 DDS 格式。

DDS (DirectDraw 图面格式，DirectDraw Surface format，DDS) 是一种针对 GPU 专门设计的图像格式。满足用于 3D 图形开发的以下特征：
1. mipmap
2. GPU 能自行解压的压缩格式
3. 纹理数组
4. 立方体贴图（cubemap）
5. 体积纹理（volume texture）

## 纹理应用


在这里，主要介绍纹理映射的应用：**Material Map、Alpha Map、Bump Map、Normal Map、Relief Map、Displacement Map、Parallax Map、Textured Light、Shadow Map、Environment Map**

我将这些应用分为六个方面：

**控制着色信息、控制片元透明度、改变法线、改变表面结构、阴影贴图、环境贴图**

### 一、控制着色信息

在之前 [《基础着色模型》](https://zhuanlan.zhihu.com/p/360222821)中，介绍了简单的 Blinn-Phong 着色模型，如下图所示：

![](<images/1684548488321.png>)

可以看到，里面有许多需要调节的参数，如表面颜色、高光强弱、高光衰减等因子，这还只是简单的着色模型，如果用基于物理的着色（PBS）模型，参数会更加复杂。

虽然可以通过赋予顶点更多信息来改变这些参数，但是要做到亚三角形的细节，就需要用各种各样纹理，来对每个片元的着色参数进行调节，我将这些纹理映射方法统称为**材质映射** (Material Map)

用得最多的是**漫反射映射** (diffuse/albedo/base color map)，比如经常用于模拟墙壁或者岩石：

![](<images/1684548488374.png>)

此外还可以改变镜面反射的系数，如**粗糙度** (决定高光衰减) 和**高光反射系数**：

![](<images/1684548488409.png>)

同时应用漫反射贴图和粗糙度贴图的效果如下：

![](<images/1684548488482.png>)

### 二、控制片元透明度

纹理都是矩形的，但当我们需要实现 **贴画** (decal) 或者 **镂空** (cutout) 效果时，往往不想让纹理贴满整个表面，也就是说，一些地方的透明度要为 0.

如下图中的血迹的贴画和镂空的树：

![](<images/1684548488520.png>)

此类纹理映射称为**透明度映射** (Alpha Map)，这种纹理通常有一个性质：texel 完全透明或者完全不透明 (其实也有半透明需要混合的情况，此处不考虑)

所以不需要把片元当作半透明进行混合，而是进行**透明度测试** (Alpha Test)，将透明度小于阈值的 texel 认为是完全透明，直接抛弃片元，否则为完全不透明

测试完成后，再用 z-buffer 算法 (可见前文 [《透明度与混合》](https://zhuanlan.zhihu.com/p/368065919)) 进行对所有完全不透明片元进行混合。

透明度测试的伪代码如下：

![](<images/1684548488587.png>)

但是简单的透明度测试在使用 Mipmap 使会存在问题：如下图，第 0 级纹理连续四个 texel 的透明度为 [0.0, 1.0, 1.0, 0.0]，第 1 级纹理就为 [0.5, 0.5]

假设我们的阈值设为 0.75，根据双线性插值，可知道第 0 级纹理中有 1.5/4 在测试中保留，但是在第 1 级纹理中由于 0.5<0.75，所以像素均被抛弃，如下图所示：

![](<images/1684548488651.png>)

于是，在不同的 Mipmap 纹理等级中，经过透明度测试留下来的像素占比 (Coverage) 也不一样，会随着 d 增大，有效像素越来越少，如下图所示：

![](<images/1684548488685.png>)

在一个镜头逐渐拉远时，可以看到树叶也在变少，到远距离时只能看到树干了：

![](<images/1684548488721.png>)

一般解决的方法有两种：

1） 手动调节每级 Mipmap 的透明度，或者在 shader 里面根据纹理等级 d 对透明度进行缩放

2） 一般严重的 artifact 出现在 d 比较大的时候，所以就限制 d 的最大值

但这两种方法都只能是近似，不能很好解决问题，出现这个 artifact 的关键在于：不同 Mipmap，用同样的透明度阈值会得到不同的 **Coverage**(代表测试留存的像素比例)

Castano 提出了一种：保证 coverage 一致的情况下，自适应确定透明度阈值，并对原透明度缩放调整的方法，详见 [[1]] ( http://the-witness.net/news/2010/09/computing-alpha-mipmaps/ )

其步骤为：

1） 先求出 d=0 纹理等级时，自定义的一个阈值 a_0 对应的 coverage = c_0，

2） 随后在 d=1,2,3… 等各级纹理中 coverage 与 c_0 相近的前提下，用二分查找求出不同等级的透明度阈值 a_d，此时理论上只需要对不同等级的纹理透明度施加不同的透明度阈值即可，但是现有管线的透明度测试中，只能用同一个透明度阈值。所以等效为：

3） 对各级纹理的透明度进行 a_0 / a_d 倍缩放，在透明度测试时，用 d=0 级处的透明度阈值 a_0 阈值即可。

此过程可用下图表示：

![](<images/1684548488777.png>)

使用此算法处理前后的效果如下，可见处理后，中远距离的树叶没有消失：

![](<images/1684548488894.png>)

除此之外，还有其他方法，考虑到本文的主旨是讲纹理映射的应用，所以关于透明度测试的一些问题就后面有机会再讲

另外在对 RGBA 值进行线性插值时，要注意先把 alpha 分量预乘到 RGB 分量上，再进行插值，比如要对很透明的绿色 (0,255,0,2) 和不透明的红色 (255,0,0,255) 进行插值，有两种情况：

![](<images/1684548488931.png>)

可以发现，无预乘插值结果更偏绿，而预乘后插值结果更偏红。

比较实际的情况是：希望插值的结果偏向于不透明那边颜色的色调，所以通常而言，**预乘后插值会比较合理**

### 三、改变法线

用于改变表面法线的贴图统称为**凹凸贴图** (Bump Mapping，虎书上面把 Bump Mapping 特指为后续的 height-field map，我此处沿用了 RTR 的说法，即 Bump Mapping 包含这一类技术，都是改变法向的技术)

为什么使用凹凸贴图呢？我们先来看三种细节层次：

1） 宏观特征 (Macro-Feature)：往往是跨三角形的，主要用几何体来表征。比如一个人的头或者胳膊，都是用三角形构成的几何体

2） 微观特征 (Micro-Feature)：往往是亚像素的，主要是用着色方程来表征。比如衣服的材质和皮肤的材质、粗糙度等不一样

3） 中观特征 (Meso-Feature)：中观特征位于宏观和微观之间，往往是在一个三角形内跨像素的，比如衣服上的褶皱或者脸上的皱纹，这些特征用细小的三角形建模显得过于浪费了，于是就用凹凸贴图的方式表征。

我们知道，一个三角形就有一个法向量，凹凸贴图在于微调三角形内每个像素的法线，但只用于着色方程中计算光照，三角形的几何体并没有改变，仍然是平的。**凹凸贴图的制作通常是从非常细节、非常多小三角形的模型中导出来**

凹凸贴图的保存有几种方式：

1） 用一个分量保存高程图 (height-field)，然后通过差分计算出法向量，称之为 **height-field map**

2） 用两个分量保存法向量在 (u, v) 两个方向的偏移 (b_u, b_v)，称之为 **offset map**

3） 用三个分量直接保存新的法向量 (x, y, z)，称之为 **normal map**

三者保存方式如下图所示：

![](<images/1684548489128.png>)

对于第一种高程 (height-field)，其纹理值高的地方对应 “高度” 也高，一般看起来是一张灰度图，如下图所示，用一张高程纹理来形成球面起伏的效果：

![](<images/1684548489196.png>)

对应第二种偏移图 (offset map)，这是 Blinn 在 1978 年提出来的，属于很老的技术，现在很少用，可参考 [[2]] ( https://www.microsoft.com/en-us/research/wp-content/uploads/1978/01/p286-blinn.pdf )

而第三种法向贴图 (normal map)，应用最广泛。直接将法向量三个分量 (x, y, z) 保存在纹理的 (R, G, B) 三个通道，用 [0,255] 表示 [-1,1]，所以在前面图中转化为减去了 128. 法向贴图及其效果可见下图，由于法向都与三角形面法向相近，所以 z 分量会比较大，贴图看上去往往是蓝色的：

![](<images/1684548489233.png>)

此外，对于法向量所处的坐标空间也有一定选择：

1） 世界空间 (world space)：法向量处于世界空间系，那么模型一旦旋转后就不能用了

2） 物体空间 (object space)：模型旋转后贴图还能用，但是不能将贴图复用于同一模型的多个不同朝向的面

3） 切线空间 (tangent space)：贴图可以复用于不同朝向的表面上，所以最常用

![](<images/1684548489323.png>)

切线空间基一般是三个分量：法向基 **n** (normal)、切线基 **t** (tangent)、双切线基 **b** (bitangent)，但为了节省存储，只在每个顶点保存 **t** 和 **b**，然后叉乘计算 **n**。

要注意的是：**在计算光照时，要保证法向量和光线向量等都在同一个坐标空间。**

若不在同一空间，乘以一个矩阵转换即可，比如将向量从物体空间转到切线空间的矩阵：

![](<images/1684548489367.png>)

另外还有一个问题，**凹凸贴图在多级纹理插值时会很困难**，因为着色方程的表达式与法向量的关系往往不是线性的。

在线性插值时，比如由两个法向量 n1, n2 插值得到新的法向量 n，记此过程为：n = a*n1 + b*n2，但在着色时，比如 Blinn-Phong 里的高光部分记为 c (n)，不是线性运算，合并计算与分别计算的光照并不相等，即：

![](<images/1684548489406.png>)

关于此问题的一个解决思路是：将着色方程的一些参数作为整体进行插值，把这个整体作为变量使得光照计算变为线性，而不仅仅是插值法向量。具体细节的话得在 PBS 里面才涉及到，此处就不深入了。

凹凸贴图的缺点在于：没有真正改变表面的几何凹凸性，所以在观察角度过于倾斜的时候，越会觉得表面像贴了一张纸上去，这是因为没有考虑由于高程带来的视差和遮挡

**Parallax Mapping (视差贴图)** 解决了这个问题

如下左图所示，当我们从相机观察到 p 点时，由于高程的存在，我们应该看到的是 p_ideal 处的着色，但实际上在凹凸贴图中用的是 p 点的着色信息，所以看起来不够真实：

![](<images/1684548489450.png>)

视差映射由 Kaneko 提出 [[3]] ( https://www.gamedevs.org/uploads/detailed-shape-representation-with-parallax-mapping.pdf )

如上右图所示，所做的事情就是：根据 p 点的高程，以及 v 的方向，对 p 点偏移一段距离到达 p_adj，以接近 p_ideal

当高程变化比较平缓时，这个方法表现较好，但是当高程在 p 点处变化剧烈时或者 v 与表面法向的角度很大时，就有可能导致 p_adj 与 p_ideal 相差很远，如下图所示：

![](<images/1684548489485.png>)

为了解决这个问题，Welsh 对此进行了改进 [[4]] ( http://page.mi.fu-berlin.de/block/htw-lehre/wise2015_2016/bel_und_rend/skripte/welsh2004.pdf )：

为了防止 p 点偏移得过于厉害，Welsh 将偏移量限制在 h 范围内，此方法对于这种局部高程变化剧烈的砖墙图能够表现得很好，见下图：

![](<images/1684548489529.png>)

即使这种方法解决了高程变化剧烈的情况，但还遗留一种遮挡的情况。

如下图所示，光线有时会被更高的其他点的高程所遮挡，但是上面并没有考虑这一点：

![](<images/1684548489569.png>)

一种类似于 Ray Marching 的思想：从 p 点出发，向前检查有限数量的点，看这些点处的高程是否与光线相交，如果相交则取离交点最近的像素点，如 p_adj，并用此处的光照去替代 p 点的光照信息。

此外还有其他很丰富的方法，这一类技术统称为 **地势贴图** (relief Mapping).

下图对比了凹凸贴图 (法线贴图)、视差贴图、地势贴图三种情况的效果：

![](<images/1684548489601.png>)

Ray Marching 很有趣，是 ShaderToy 里面很常用的技巧，它和 Ray Tracing 很相似，都需要投射光线，区别在于 RM 没有实实在在的几何体，判断光线相交情况是用 Sphere Tracing 结合 Signed Distance Functions (SDF)，之后有机会也会写一篇关于 RM 的文章

### 四、改变表面结构

第三部分中的凹凸贴图 (法线贴图)、视差贴图和地势贴图，都只是在计算光照时对法线或者其他光照方程的输入进行了微调，没有修改表面结构

此处所介绍的**移位贴图** (Displacement Mapping) 则实际性地修改了表面结构，其主要依赖于渲染管线的**曲面细分** (tessellation) 功能，即根据贴图中对三角形进行曲面细分，生成足够多更小的三角形，并对每个三角形的顶点位置都进行移位，实际上得到了更为精细的几何体。

可想而知，这种技术是效果最好的，但也是最复杂的。

Kalos 在 06 年有一篇综述 [[5]] ( https://www.researchgate.net/profile/Laszlo-Szirmay-Kalos/publication/220506016_Displacement_Mapping_on_the_GPU_-_State_of_the_Art/links/5aec48feaca2727bc003fdf9/Displacement-Mapping-on-the-GPU-State-of-the-Art.pdf )：

对比了各种技术，感觉讲得很不错，下图来源于此：

![](<images/1684548489636.png>)

### 五、改变光源

纹理还可以用于改变光源，称之为 **Textured Light**

最简单的二维光源，类似投影仪的工作原理：把一张纹理放在聚光灯下投射过来，那么光照就带有各种图案：

![](<images/1684548489675.png>)

除了二维纹理，用视锥体的方式进行投射之外，还可以用一维纹理保存光线的衰减系数，甚至用三维体纹理直接保存光在空间中的分布，但极其耗费内存。

### 六、阴影贴图

介绍阴影贴图之前，先回顾一下 z-buffer 算法：将距离相机最近的片元的深度保存起来：

![](<images/1684548489757.png>)

如果我们把相机换成点光源，那么**右边这张深度图，是否可以代表有光照片元的深度？且大于这个深度的片元都没有光照？**

这就是阴影贴图的思想，考虑以下场景：

![](<images/1684548489797.png>)

黄色区域为点光源光照示意范围，绿色区域为视锥体范围，很明显，红线处是阴影部分，实际操作时怎样确定这个红线位置呢？有以下步骤：

1） 第一次 pass，将相机放在光源位置，用 z-buffer 的方式存一张深度缓冲，称之为**阴影贴图** (Shadow Map)，并记录此时的投影变换矩阵 M

2） 第二次 pass，正式开始渲染场景，将相机放到正确的位置，对片元进行着色时，考察每个片元处是否有光照，方法为：用第一次 pass 里面的矩阵 M 将三维点 (Px, Py, Pz) 变换为二维坐标 (px, py) 和深度 pz，将 pz 与第一次 pass 里面存下来的阴影贴图对应点的深度 c (px, py) 进行对比，若 pz> c (px, py)，则认为此片元无光照，否则有光照。

此过程如下图所示：

![](<images/1684548489838.png>)

但此处的阴影贴图局限于只能生成点光源的硬阴影，对于其他光源或者软阴影的生成还需要其他方法，会在后面专门的阴影章节讲解。

### 七、环境贴图 (Environment Mapping)

相信一些人看过《楚门的世界》这部电影，里面的一个世界是被很大的一个几何体围起来的，环境贴图也是类似的做法：你所看到的四周比较远的东西不过是一整张贴图

环境贴图有多种保存形式：最常用的**立方贴图** (Cubic Map)、**经纬度贴图** (Latitude-Longitude Map)、**球面贴图** (Sphere Map)：

![](<images/1684548489874.png>)

环境贴图主要有两个应用：

一是作为场景的背景颜色，比如这个场景有一些模型，但是模型后面不可能总是灰的或者黑的背景色，那么环境贴图就充当背景的颜色

二是作为镜面反射的颜色，比如场景中有一面镜子，你从镜子里看到的，实际是反射的背景的颜色，就好比你看到的镜子的颜色，其实就是镜子里面那个虚拟摄像机朝反射方向看过去的环境贴图的颜色，比如在 Forza 游戏中，赛车上的反射效果：

![](<images/1684548489933.png>)

环境贴图有一个很重要的性质就是：**贴图很远，以至于在获取贴图纹理值的时候，不需要考虑向量的位置，只需要考虑向量的方向** 即可：

![](<images/1684548489970.png>)

如图所示，尽管两个摄像机的位置不一样，但是视线方向是一致的，那么得到的环境贴图的纹理也是一样的。这种性质可以在计算光照时，不用判断向量到底与贴图的哪一点相交，只考虑方向

本文对一些常见的纹理映射的应用进行了大致讲解，每一种应用延伸出去都有很多东西可讲，受限于自身的水平和文章的篇幅，此处没有展开。如有错误，还请多多指教！


# **几何**

### **几何表示方法的分类**

-   隐式

-   可以通过一个函数来表示的几何体。
-   例如圆可以表示为f（x，y，z）=0
-   优点：可以很容易判断某个点是否在几何体上
-   缺点：难以通过函数判断出几何体的真实形状

-   显式

-   通过参数映射表示的几何体（uv坐标转换为xyz坐标）

-   参数映射：通过某个带有u，v的函数分别表示出x，yz的坐标

-   直接给出几何体
-   缺点：难以表示出某个点是否在几何体上。
-   优点：容易看出来几何体的真实形状

**隐式表示**

![[97bd34d8bfaf5e4cb505c780361a4215_MD5.webp]]

对于复杂的几何体十分不友好。

### **隐式几何**

### **CSG(Constructive Solid Geometry)**

复杂的几何体通过简单几何体进行集合运算（交并补）得到，该操作被称之为CSG。

  

![[7523c598ed6a49e6bf8eb0ffff6ca910_MD5.webp]]

### **距离函数**

下图A与B相进行融合操作后得到blend（A,B)，左边三分之一完全被挡住，中间被挡住一半，最后边完全没被挡住。

距离函数：任何一个点到达**边界**的最短距离。

通过AB距离函数相加得到融合后的SDF图，可以转化为blend（A,B)这张图。

![[e0a6527bb726e0d2ec51da12844bc3bc_MD5.webp]]

距离函数可以将两个靠近的集合体进行融合。

![[fb5c4d2eb1ea7a2972370a4cd22892f3_MD5.webp]]

距离函数通过水平集（LevelSet）得到F(X)=0（边界）

### **分型**

![[b34b9f6168236975d9359f3078527fb6_MD5.webp]]

分型这种递归问题在渲染中会引发严重的走样

### **显式几何**

### **点云**

-   用密集的点放在空间中
-   是某个坐标系下的数据集
-   每个点包含了坐标、颜色等一系列信息
-   只要采样足够密集，理论上可以表示任意集合体
-   如果采样不够密集，将会无法分辨模型的形状
-   应用：激光扫描

### **多边形网格**

### **简介**

-   讲面拆解为多边形（大多是三角形和四边形），存储顶点和多边形信息
-   在图形学中应用的最为广泛

### **如何储存多边形信息？**

使用OBJ格式讲几何体的点、法线、纹理坐标分别表示，然后再表示，面与面的连接关系。

下图定义了一个立方体，有八个顶点（V）,六个面（Vn）多个纹理坐标（vt）表示，然后使用f表示他们之间的关系（（f V/Vt/Vn）

![[2454e4b1a82647420bc4870217ef1e6f_MD5.webp]]

### **贝塞尔曲线**

只要求一定要经过起止点，起止点之间的若干个控制点用于控制曲线弯曲的方向，最终形成一条经过起止点的光滑曲线被成为贝塞尔曲线。

### **德卡斯特里奥算法**

通过德卡斯特里奥算法法来绘制贝塞尔曲线。

-   引入参数t（范围 为0-1）
-   取b0到b1，b1到b2上t位置的点b0‘，b1’
-   将b0‘，b1’连接
-   取b0‘到b1’t位置上的带你b0‘’
-   将所有的0-1所有的b0‘’点都遍历一份相连即可得到贝塞尔曲线
-   若有n个控制点则将上面步骤进行递归操作直到找到最终位移b0n

![[65e54989019cf12b32392d8b4d9a41c9_MD5.webp]]

总结得到公式：**bn(t)=b0n(t)=Σb0Bn(t)**

可以求得一个以t为自变量的函数，由这些点形成的集合构成贝塞尔曲线

其中：

-   b为n个贝塞尔控制点
-   Bn为伯恩斯坦多项式

![[8152ebf6d30e467ab399640d4592abc2_MD5.webp]]

其中：

![[4f6ab7026632978755be11db133f13b6_MD5.webp]]

（排列组合Cni）

例子：b0、b1、b2、b3为3d空间中的点，通过函数求得n个离散的点

![[099c85c6c471a2f7b530b3dc1d881755_MD5.webp]]

-   对贝塞尔曲线做仿射变换只需要对控制点、起止点做仿射变换再重新绘制一遍即可。
-   对投影变换没有这样的性质

### **凸包**

贝塞尔曲线拥有凸包的性质。

连接贝塞尔曲线最外围的控制点，将其相互连接形成一个封闭空间，画出来的贝塞尔曲线一定在凸包范围内。

若贝塞尔曲线是一个直线则凸包也是一个直线。

![[3127856c904f7631ce41ef6a544b36fb_MD5.webp]]

### **逐段贝塞尔曲线**

当控制点太多会影响控制点的效果。

每四个控制点定义一条贝塞尔曲线，然后再将他们连接起来。

  

![[2def25503e77c453ebdc37457af1ebaa_MD5.webp]]

类似PhotoShop的钢笔工具

若想要逐段贝塞尔曲线平滑过渡则需要将相邻控制点共线（如3，5）否则会出现该曲线后边段的不平滑现象。

**CN连续**

将两个逐段贝塞尔曲线中的两部分连接，连接点被称之为C0连续

若相邻两个控制点距离连接点相同且共线则该连接点被称之为C1连续（再连接处一阶连续可导）

![[548486c606e62b55f38f6f5876e99437_MD5.webp]]

### **贝塞尔曲面**

与二维的贝塞尔曲线思想类似，但是需要定义两个参数u和v（取代之前的参数t）

先对f（u）进行遍历得到曲线，再嵌套遍历得到曲面f（u，v），类似于两层for循环进行遍历

### **网格操作**

### **网格操作的分类**

-   网格细分

-   让网格的面数更多
-   Loop细分
-   Catmull-Clark细分

-   网格简化

-   让网格面数更少
-   边坍缩

-   通过“二次误差度量”得到坍缩后最优的点

-   网格正规化

-   让网格中的三角形趋近于正三角形

![[3e838afecbde487f2cff4a1ee9dd9a2a_MD5.webp]]

### **Loop细分**

-   将每个三角形变为4个三角形
-   根据权重指定新的顶点位置

-   新的顶点和老的顶点以不同的规则来改变自己的位置

对于新的顶点：

V'=3/8 * (A + B) + 1/8 * (C + D)

-   V'为新的顶点变换后的位置
-   A、B分别为于两个面被共享边的的老顶点
-   C、D为非共享边的两个顶点。

对于旧的顶点：

V'=(1 - n*u) * V + original_position * neighbor_position_sum

-   V'为旧的顶点变换后的位置
-   n为顶点的度（链接的顶点数）
-   如果n=3则u=3/16 其他情况u=3/(8n)
-   neighbor_position_sum为邻居点的平均位置
-   original_position为旧顶点原本的位置

![[80f5e51f56e6e1d861de88de875ada37_MD5.webp]]

问题：只能对完全为三角形的几何体进行细分

### **Catmull-Clark细分**

相对于Loop细分的优势：可以用于任意不同的面的细分。

奇异点：顶点的度!=4

-   将面的中点和面上线的中点连起来

-   在第一次细分之后，非四边形面数量会加到原本奇异点的数量上

-   面上的中点（f）、边上的中点（e）、老的顶点（v）变化情况如下图

![[6be536f047576db49f4675b30487e9ce_MD5.webp]]

### **边坍缩算法**

通过不断迭代进行边坍缩操作达到简化模型的目的。

  

![[2bcc9a264fed859341b2c4d3971de815_MD5.webp]]

边坍缩面临的问题:

-   坍缩哪些面？
-   如果优先坍缩不重要的面，那如何界定不重要？
-   坍缩后的顶点位置如何描述

### **二次误差度量**

![[b6018f2a68ee3b4fe3928d5db6305e89_MD5.webp]]

如果将减面时候的点直接平均将会得到左边的图，显然不理想。

通过二次误差度量得到右边的点得到理想效果。

### **边坍缩算法的步骤**

-   对每一条边打一个分数，分数就是他坍缩后的二次误差度量
-   对分数最低（误差最小）的边做边坍缩

-   用到了Dijkstra最短路径算法

-   重新执行第一步知道完成整个模型的边坍缩

### **阴影映射（Shadows mapping）**

### **基本流程**

-   从光源看向场景并做深度测试
-   从视锥体位置看向场景，从场景中看到的点投影回光源得到该点在深度图中的位置

-   有些点可以被视锥体看到也可以被光源看到（视锥体投影到的深度图与光源中的深度图相同）
-   有些点可以被视锥体看到但**不能**被光源看到（视锥体投影到的深度图与光源中的深度图**不符**）

-   不能被光源看到的位置但可以被视锥体看到的位置就是阴影的位置

### **出现的问题**

-   只能做硬阴影不能做软阴影（目前以及有技术可以做到）
-   由于shadow map的分辨率问题，阴影可能出现锯齿
-   浮点精度问题，可能在是否能同时被视锥体与光源看到的界定上出现问题引发误差

### **软阴影**

软阴影的边缘比较模糊，没有硬阴影锐利的边缘

下图以日食为例子介绍了软阴影在真实物理中形成的原因：

![[f3c849ce02c134f1cd961538b18d42f1_MD5.webp]]

# **光线追踪**

**为什么要使用光线追踪？**

光栅化不能很好的控制**全局效果**：
![[Pasted image 20221210160907.png]]
-   软阴影
-   毛玻璃材质的反射
-   间接光照

光栅化虽然较快，但是质量较低。

**光线追踪的几个假设**
-   光沿直线传播（本课假设这么认为）
-   光线与光线之间不会发生碰撞（本课假设这么认为）
-   光线从是从光源不断传播直到视锥体的（光路的可逆性，光线的路径可以从眼睛到物体，也可以从物体到眼睛）

## **光线投射（RayCasting）**
![[Pasted image 20221210161157.png]]
光线投射的假设：
-   出射点是一个点
-   光源点光源
-   场景物体中的反射为完美的镜面反射

光线投射的步骤：
-   从初射点穿过成像平面打出一根光线到场景中
-   找到与场景的最近交点（完美解决了光栅化的深度测试问题）
-   将交点和光源连接, 判断物体是否在阴影中
-   计算着色情况写回像素中
![[v2-33789871a86c5b76463e52b508c692dc_1440w.webp]]


## **Whitted-Style光线追踪**
![[Pasted image 20221210161809.png]]
光线投射的光线只弹射一次，实际上光线会弹射很多次，这就引出了光线追踪。

 **Whitted-Style光线追踪**是一种**递归光线追踪（Recursive Ray Tracing）**

-   光线不仅仅只会反射，还会折射、然后再与其他物体进行反射
-   **计算并相加所有点的颜色**，光线每次反射折射都会有能量损耗，不然经过无限 
     次的累加只会变成白色（过曝）
-   递归过程需要设置一个最大次数
-   两次反射和折射情况如下图可视
![[v2-53d9f085fe850ece368c5d018d85dbbf_1440w.webp]]

## 确定光线与物体表面的交点

### 光线方程

对于每一束光线都满足以下方程：
其中o为开始点，d为方向（单位向量），t为时间

![[Pasted image 20221210162854.png]]

求交点：
对于任何隐式的集合体，将r(t)以p点带入隐式的方程中算出f(o+td)=0即可算出t求出交点。
![[v2-194d685244aaf670e9bce1664c70086a_1440w.webp]]

### 显式几何

-   几何体由若干个面组成
-   在几何体的面上判断是否与他的面相交
-   几何上的平面由一个法线和一个点p‘表示

**已知平面上一点p'和法线N，如何判断点p是否在平面上：**
向量p-p’与法线垂直，即(p-p)·N = 0
由此可定义任意在平面p’上的点，一系列点的集合就是面，所以也可以用来定义一个表面。

步骤：
-   可使用(p-p')·N=0表示一个平面
-   将光线方程以p带入光线方程中
-   求出t算出交点
-   判断交点在三角形的内还是外，若在内则是三角形的交点
![[Pasted image 20221210165026.png]]


### Möller Trumbore算法

中文名： 射线三角相交算法

可以**更快的求三角形与射线的交点**

-   已知 光线满足r(t)=o+td
-   P0、P1、P2为三角形三个顶点
-   可以得到以下等式，右边是重心坐标形式
-   通过以下E1、E2等的参数定义可以解出等式得到交点
-   通过重心坐标判断交点是否在三角形内：b1＞0；b2＞0；1 - b1 - b2 ＞0
![[Pasted image 20221210164908.png]]

## **光线追踪加速方法**

如果三角形面特别多，以上面的算法进行计算将会特别慢

### 轴对齐包围盒(AABB)
Axis-Aligned Bounding Box（AABB）

- 思想：如果光线和包围盒不相交，那么更不可能和物体相交
- box是三个对立面（三对无限大的平板，下图为其中一对）的交集，
- 轴对齐：边沿着xyz坐标轴
![[Pasted image 20221210165531.png]]
**如何判断光线你什么时候与box相交？**
-   先看**二维bo**：分别计算光线在x，y平面的时间内，求交集即可得到结果

-   先判断与x这对面与光线相交（进和出）的时间tmin、tmax
-   再判断y与光线的相交时间
-   取交集（求出tmin的最大值，tmax的最小值）
![[Pasted image 20221210170221.png]]

- **三维box的关键思想：**
	- 光线三个对立面都满足光线进入了，才能说光线进入了box
	- 只要离开任意对立面，就说明光线离开了box

- **计算过程：**
	- 对每一对立面分别计算t<sub>min</sub>和t<sub>max</sub>
	- t<sub>enter</sub> = <font color="#ff0000">max</font>{t<sub>min</sub>}，t<sub>exit</sub> = <font color="#ff0000">min</font>{t<sub>max</sub>}
	- 如果t<sub>enter</sub> ＜ t<sub>exit</sub>，说明光线在box中留存了一段时间（即相交）

-   **t为负值的情况：**
	-   t<sub>max</sub><0则说明box在光线的背面（无交点）
	-   t<sub>min</sub>>=0且t<sub>min</sub><0则说明光源在box中（有交点）

总结：AABB有交点当且仅当t<sub>min</sub> < t<sub>max</sub> 且 t<sub>max</sub> >= 0

#### 轴对齐的定义

三对面的交集形成的立方体，三对面分别于xyz轴平行
使用包围盒包围与光一定轴对齐，减少了计算量

原始方案中：
需要3次减法，6次乘法和1次除法。

AABB中：
每一个轴只需要一次除法和一次减法，一共只需要3次减法和三次除法
![[v2-d3d5c2da31d64ed5db75a4cd8266d49d_1440w.webp]]
这么定义包围盒的好处：

只有三对面都有光线相交（进和出）时间才能证明光线已经进入包围盒
这也定义可以先判断光线是否经过该包围盒，如果不经过就不再进行更多的操作，节省了计算时间。

### 空间划分&AABB
#### AABB的均匀划分

AABB均匀划分的步骤：
-   1. 找到box（最外层的正方体）
-   2. 建立网格（黑色网格）
-   3. 标记物体表面与box相交的网格（灰色标记）
- ![[Pasted image 20221210173123.png]]
-   4. 从光线发射方向逐个遍历网格
-   5. 将每个遍历到的网格测试与其的交点
- ![[Pasted image 20221210173553.png]]

建立网格的目的：
-   通过网格可以判断有t<sub>min</sub>、t<sub>max</sub>
-   若有则对网格内的物体进行交点判断

网格的密度认为数量大约为27x物体数量
但是这种网格定义方式对物体分布不均匀的场景中不友好（即使这样的网格也很常用）因此引入空间划分来切割网格。

#### 空间划分的分类
![[Pasted image 20221210173202.png]]
八叉树：
-   八叉树是在每个子树下面画十字，划分为四块（在二维下是分为四块，三维是八块）
-   由于是均匀划分，会出现将同一个物体划分为两块的问题。

KD树：
-   每次划分只划分为两块（类似二叉树）
-   在二维中第一次为水平的划分，第二次为竖直的，然后循环划分
-   在三维中类似，以xyz轴顺序进行划分
-   这样可以保证划分比较均匀
-   我们在AABB中主要使用KD树（曾经）

BSP树：
-   划分和kd树类似
-   由于划分不是横平竖直的不能用于AABB的划分

#### KD树

建立KD树
通过一次对x,y（二维）进行递归划分，得到下面的KD树
![[Pasted image 20221210174330.png]]


遍历KD树
-   假设有一条光线射出
-   逐个对每个子树进行判断是否有与包围盒相交
-   若相交则对他的子树继续遍历知道将找到所有与光线相交的包围盒
-   将其包围盒下的物体查找交点
![[Pasted image 20221210175324.png]]

KD树的问题：
-   难以判断物体与包围盒边界的相交问题
-   一个物体容易同时穿过多个包围盒被重复计算影响性能

因此KD树的应用场景越来越小。

目前广泛使用的技术名叫层次包围盒（BVH）

### 物体划分&层次包围盒（BVH）
Bounding Volume Hierarchy（BVH）

不是通过空间划分，而是通过**物体划分**。

BVH的特点：
-   按照三角形进行划分，因此一个物体只可能出现在一个包围盒内
-   由于按照三角形进行划分，因此不会出现那一判断包围盒边界的问题
-   BVH的思想更像**分组**，只需将三角形进行分组并对三角形较多的组进行递归分 
     组，分别计算box
-   每次的划分都选择XYZ中最长的轴进行划分，这样保证划分的大小比较平均（也有其他办法）
-   总是选择中间的三角形进行划分，这样划分出来树更加接近平衡二叉树
-   划分到一个比较小的数量后停止划分（比如5个三角形）
 ![[Pasted image 20221210175639.png]]
**一组无序数，找到第i大的数，可以使用快速划分算法，时间内复杂度O(n)。**

**BVH的存储结构：**
- 中间节点：包围盒，子节点指针
	 - 孩子节点：包围盒，物体列表
	
BVH的伪代码：

```c
Intersect(Ray ray, BVH node) 
{
    if (ray misses node.bbox) 
        return;//如果与节点光线都不相交就返回
    if (node is a leaf node)//如果相交且这是一个叶子节点
    {
        test intersection with all objs;//将节点内三角形都做判断
        return closest intersection;//返回最近的那个
    }
    hit1 = Intersect(ray, node.child1);//如果不是叶子节点则递归找到最近的那个
    hit2 = Intersect(ray, node.child2);
    return the closer of hit1, hit2;
}
```

## 辐射度量学
Basic radiometry

由于Whitted-Style形成的光线追踪体系其实并不够真实，引入辐射度量学

同时定义了以下几个属性来描述光照：

-   Radiant Energy（辐射能量）J
-   Radiant Flux（辐射通量） 功率 W（或lm=lumen，流明表示多么亮）
	- 单位时间内通过的能量
-   Radiant Intensity（辐射强度）点光源每单位立体角（solid angle）发出的功率 W/sr
-   Irradiance（辐照度）某一平面所接收到的光线亮度 W/m<sup>2</sup>
-   Radiance（辐射亮度）一条传播光线所具有的亮度 W/m<sup>2</sup>·sr
![[Pasted image 20221210185359.png]]
### 辐射能量 （Radiant Energy）

光线照射下辐射出来的能量，单位为焦耳，用Q表示。

辐射通量

-   单位时间内的能量消耗，类似于功率,单位为瓦/流明
-   单位时间内通过一个感光平面光子的数量
![[Pasted image 20221210191026.png]]

### 辐射强度（Radiant Intensity）
![[Pasted image 20221210191240.png]]
#### 立体角
**角：**
![[Pasted image 20221210191332.png|200]]
弧度制：θ=l/r 
l：弧长
r：半径
一个圆形有2π个弧度

**立体角：** 立体角是弧度制在三维上的延申

![[Pasted image 20221210191346.png|200]]
Ω=A/r2

A：球面上的面积
一个球有4π个立体弧度

**微分立体角**
-   首先确定空间中的方向θ和
-   其中rdθ是微分面积元的高，rsinθdϕ 是微分面积元的宽
-   两者相乘即可计算出球的投影面积A
![[Pasted image 20221210192542.png]]

同时可以验证立体角在球上的积分为4π
![[Pasted image 20221210192557.png]]

在辐射度量学中用Ω来表示方向，用θϕ定义方向

#### 定义

-   每微分立体角（某个方向）上的功率（光强），单位为W/sr又被称作为cd（坎德拉）
-   （光源在某个方向上的亮度）
![[Pasted image 20221210192304.png]]

#### 应用：点光源

-   定义一个点光源所有方向的亮度都相同
-   flux为I在所有方向上的积分
-   得出I=ϕ/4π
![[Pasted image 20221210192609.png]]

### 辐照度（Irradiance）

单位面积上（某个点）接收到的光照功率，单位为W/m2 或者lm/m2 又称Lux（勒克斯）
![[Pasted image 20221210193643.png]]
表面辐照度与光方向与表面法线夹角的余弦成正比。(注意:始终使用单位面积，余弦适用于Φ)
![[Pasted image 20221210193816.png]]

假设光的发射功率为均匀角分布，比较两个球体表面的辐照度（辐照度会衰减）:
![[Pasted image 20221210193912.png]]

### 辐射亮度（Radiance）
#### 定义

**单位微分立体角的单位面积的**功率，单位为nit（尼特），1nit=1 cd/m²
（所以两次微分）
 ![[Pasted image 20221210194223.png]]
**Radiance和其他名词的关系**
![[Pasted image 20221210194552.png]]
### Irradiance与Radiance的区别

-   Irradiance是对于一个点所接受到的所有的光线
-   Radiance是对于一个点面向某个方向接受到的光线

![[Pasted image 20221210194722.png]]

注意：H²为半球

### 双向反射分布函数(BRDF)
描述光的分布

![[Pasted image 20221210195723.png]]

#### 反射方程

借助BRDF可以定义出反射方程，即在某个反向接受到的所有的反射光线。
![[ccb3df7364794ef6ef2ed5866af69c8f_MD5.webp]]

如上图，反射到的光线是由入射光乘以BRDF这一反射比例得到的。

#### 渲染方程

定义

-   渲染方程由两部分组成，自发光Le和反射光
-   其中反射光可以由光源直射也可以由其他的物体反射
-   在反射方程的基础上加入自发光，定义了渲染方程
-   渲染方程定义了所有的光线传播规律

![[13df43fffefa18bd2deab8ffaaa72cfe_MD5.webp]]

-   n·ωi与cosθ一致
-   Ω为半球

#### 单个光源的反射方程
![[Pasted image 20221210200218.png]]

点光源只有一个方向有入射光，所以不用积分

#### 多个光源的反射方程
![[Pasted image 20221210200239.png]]

#### 面光源的反射方程
![[Pasted image 20221210200305.png]]
面光源是点光源的集合因此对面光源所在立体角进行积分可以得出面光源的反射方程

#### 面光源的渲染方程
-   将其他物体反射过来的光当成光源，得到渲染方程
-   只需要计算反射光源其余的自发光、BRDF（材质）、cosθ均已知


**方程简化**
-   目前只有出射点反射出去的能量和入射点反射过来的能量未知
-   可以将渲染方程最终简化为下面的形式方便理解
![[Pasted image 20221210200340.png]]

最终可以将渲染方程：**L=E+KL**

-   在一个场景内能量守恒
-   L为所有的物体辐射出的所有能量
-   E为光源分辐射出来的能量
-   KL为光源辐射出来的能量被反射出来的能量

解出L并通过二项式定理得到下面的式子。
![[Pasted image 20221210200531.png]]
-   L=E为场景内自身辐射的能量
-   L=KE为场景内辐射的能量+一次反射的能量
-   L=KE+K²E为场景内辐射的能量+一次反射的能量+二次反射的能量
-   以此类推......

![[Pasted image 20221210200804.png]]
**所有弹射加起来就是全局光照**


## 概率论基础知识
**X：随机变量。** 表示潜在值的分布
**X~p(x)：概率密度函数。** 描述随机过程选择值的相对概率
![[Pasted image 20221210201659.png]]

**随机变量的期望值：** 从随机分布中反复抽取样本所得到的平均值。
![[Pasted image 20221210201825.png]]
**概率分布函数（PDF）：** 一个随机变量X，它可以取一组连续值中的任意一个，其中某个特定值的相对概率由连续概率密度函数p(X)给出。
![[Pasted image 20221210202132.png]]
![[Pasted image 20221210202240.png]]
**求函数的期望：**
![[Pasted image 20221210202320.png]]
## **蒙特卡洛路径追踪（Path Tracing）**（第四节课没听太懂）

### 蒙特卡洛积分

对函数的积分域多次采样求均值作为积分的近似值
**每次采样的积分域为宽为b-a，高为f(x<sub>i</sub>)的长方形。**
![[Pasted image 20221210203444.png]]
![[Pasted image 20221210203737.png]]

**例子：**
![[Pasted image 20221210203754.png]]

将积分均匀采样，每个采样的概率都是1/b-a，得出以下式子。
![[Pasted image 20221210203808.png]]
其中将b-a移到后面可以得到最开始蒙特卡洛积分的式子。

**总结：**
-  采样越多，误差越小
-  在x上积分必须在x上采样
![[Pasted image 20221210204029.png]]
### Witted-Style时错误的

路径追踪解决了在Witted-Style中不正确的部分

-   无法完成Glossy的材质，在Glossy材质中光线打到材质上不完全沿着Specular的方向走
-   漫反射后仍然会多次反射，需要引入全局光照
![[Pasted image 20221210204312.png]]
![[Pasted image 20221210204404.png]]
### 蒙特卡洛积分应用到渲染方程
![[Pasted image 20221210204839.png]]

将某个渲染点p的ω<sub>i</sub>方向（作为随机变量）进行多次采样找到反射光源的角度得到蒙特卡洛积分：
![[Pasted image 20221210205204.png]]
![[Pasted image 20221210205240.png]]

通过这样的方法可以算出任意着色点的渲染方程

#### 直接光照的算法

```c
shade(p, wo)
    Randomly choose N directions wi~pdf
    Lo = 0.0
    For each wi
        Trace a ray r(p, wi)
        If ray r hit the light
            Lo += (1 / N) * L_i * f_r * cosine / pdf(wi)
    Return Lo
```

#### 全局光照的算法

```c
shade(p, wo)
    Randomly choose N directions wi~pdf
    Lo = 0.0
    For each wi
        Trace a ray r(p, wi)
        If ray r hit the light
            Lo += (1 / N) * L_i * f_r * cosine / pdf(wi)
        Else If ray r hit an object at q
            Lo += (1 / N) * shade(q, -wi) * f_r * cosine / pdf(wi)
    Return Lo
```

如果采样中反射过来的不是光源而是物体则将物体也当做光源，将物体反射过来的能量来进行计算。

### 上述算法的产生的问题

**反弹次数的上升产生射线数量爆炸**

一根光线打到物体后会反射很多个光线到同一个物体，以此类推产生指数爆炸、
![[Pasted image 20221210210818.png]]

因此**如果蒙特卡洛积分采样次数为1则不会出现指数爆炸的现象。**

路径追踪算法：

```c
shade(p, wo)
    Randomly choose ONE direction wi~pdf(w)
    Trace a ray r(p, wi)
    If ray r hit the light
        Return L_i * f_r * cosine / pdf(wi)
    Else If ray r hit an object at q
        Return shade(q, -wi) * f_r * cosine / pdf(wi
```

**只采样一次的光线追踪被称之为路径追踪，上面采样N次的被称之为分布式光线追踪（Distributed Ray Tracing）**

生成多个路径进行路径追踪：
![[Pasted image 20221210210846.png]]

对于每个像素发射N条光线（采样）做以下的算法

将每个射出去的采样接收到能量的点做蒙特卡洛积分得到平均值

```c
ray_generation(camPos, pixel)
    Uniformly choose N sample positions within the pixel
    pixel_radiance = 0.0
    For each sample in the pixel
        Shoot a ray r(camPos, cam_to_sample)
        If ray r hit the scene at p
            pixel_radiance += 1 / N * shade(p, sample_to_cam)
    Return pixel_radiance
```

### 由于路径追踪递归产生的死循环
使用俄罗斯轮盘赌的方法
![[Pasted image 20221210210633.png]]
-   首先增加一个结束的概率P_RR
-   每次调用shade函数的时候做一个随机数判断
-   若大于随机数则return0反之继续执行shade函数并返回L0/P_RR
-   这样算下来数学期望不会变，E(L0)=P∗(L0/P)+(1−P)∗0=Lo
-   且路径追踪总会停下来

```c
shade(p, wo)
    Manually specify a probability P_RR
    Randomly select ksi in a uniform dist. in [0, 1]
    If (ksi > P_RR) return 0.0;
    
    Randomly choose ONE direction wi~pdf(w)
    Trace a ray r(p, wi)
    If ray r hit the light
        Return L_i * f_r * cosine / pdf(wi) / P_RR
    Else If ray r hit an object at q
        Return shade(q, -wi) * f_r * cosine / pdf(wi) / P_RR
```

### **提高效率**

每个像素中的采样点越多，形成的效果越好，比如下图中最右边的例子需要50000个采样才能找到光线，大多数的采样被浪费了
![[Pasted image 20221210210906.png]]

因此为了提高效率我们可以通过找到光源与方向的关系，改写渲染方程，将渲染方程写成对光源的积分
![[Pasted image 20221210211248.png]]
改写的渲染方程：

![[1b663c7757ecd37156674f02fe670853_MD5.webp]]

我们最终渲染出来的光纤传播分解为两个部分

-   光源的直接光照
-   光源对其他物体的弹射（需要用到上面的随机算法）

如果光源中有物体挡住则不能渲染光源的直接光照，通过一个if来解决

```c
shade(p, wo)
    # 光源的直接光照
    L_dir = 0.0
    Uniformly sample the light at x’ (pdf_light = 1 / A)
    Shoot a ray from p to x’
    If the ray is not blocked in the middle
        L_dir = L_i * f_r * cos θ * cos θ’ / |x’ - p|^2 / pdf_light
    # 光源对其他物体的弹射
    L_indir = 0.0
    Test Russian Roulette with probability P_RR
    Uniformly sample the hemisphere toward wi (pdf_hemi = 1 / 2pi)
    Trace a ray r(p, wi)
    If ray r hit a non-emitting object at q
        L_indir = shade(q, -wi) * f_r * cos θ / pdf_hemi / P_RR
    Return L_dir + L_indir
```

### **其他的知识**

-   点光源不容易处理，因此建议写成一个很小的面光
-   路径追踪可以做到几乎100%的真实（照片级真实感）
- ![[Pasted image 20221210211823.png]]
-   光线追踪有很多类型
- ![[Pasted image 20221210211933.png]]
-   过去认为的Ray tracing就是whitted-style ray tracing
-   **现在包括：**
	- （单向和双向）路径跟踪
	-   光子映射
	-   Metropolis light transport（MLT）
	-   VCM / UPBP
- 生成照片的两种方法：光栅化\光线追踪

-   课程中光线追踪未涉及的部分
-   函数采样理论
-   选择什么样的PDF（重要性采样）
-   随机数的生成
-   结合不同的采用结果（如光源和着色点）
-   像素发出多个路径，是否平均其着色效果即可（pixel reconstruction filter）
-   像素的radiance和color的区别（伽马矫正）

# **材质与外观（BRDF）**

材质由BRDF决定，或者说材质就是BRDF。

## 漫反射材质

-   对于一个漫反射材质的物体，我们认为物体本身没有自发光（因此没有Le），且不会吸收光线，照射过来的光线会均匀的反射到四周。
-   且假设入射光是均匀的
-   因此Lo=Li，反射的能量等于收到的能量，因此fr（BRDF）=1/π
-   我们可以引入反射率（albedo）ρ，取值位于0~1让物体能够接受能量获得不同颜色的BRDF
-   下面Lo得出了漫反射材质的渲染方程

  

![[64e5be49867c085398b778638f2deb25_MD5.webp]]

## 镜面反射

-   在正视图中（左边的图），镜面反射的入射角和出射角可以通过平行四边形法则借助法线方向得出左边的关系
-   在俯视图，又称**方位角**（右边的图）可以得出右边的关系
-   通过下面的公式可以算出出射角的方向
![[Pasted image 20221211095331.png]]

## 折射定律
国内将**caustics**翻译成**焦散**，实际上焦散现象是由于光的聚焦形成的，翻译有些误导。
![[Pasted image 20221211095602.png]]
### 斯涅耳定律
![[Pasted image 20221211095449.png]]

-   引入折射率，右边是常用介质的折射率
-   比如从空气射入水则ηi为1，ηt为1.333
-   通过上面的公式可以计算出出射角的角度

### 全反射

![[Pasted image 20221211095904.png]]

-   **当出射角无意义即根号小于0**（（ηi/ηt）>1）时候，则物体**不会发生折射**，这种现象被称为**全反射**
-   例如人在水底往上看，由于发生全反射现象，只能看到一小块锥形的区域，这也被称为斯内尔窗
![[Pasted image 20221211100107.png]]
### 菲涅尔项

-   当入射角与物体相互垂直的时候，反射会更加明显
![[Pasted image 20221211100124.png]]
-   **菲涅尔项**对绝缘体会更加明显（下1图），对导体来说并不明显（下2图）-因为导体的折射率是负数。
![[Pasted image 20221211100242.png]]
![[Pasted image 20221211100250.png]]

**菲涅尔项公式：**
![[Pasted image 20221211100321.png]]

-   上面的公式是准确的，但是计算十分麻烦，需要考虑极化
-   下面的公式名为 Schlick’s approximation，是一个近似解，图形学中广泛使用。

## 微表面材质

-   物体表面即使是粗糙的，但是从远处看，我们可以将其看做是一个平的表面
-   例如在空间站中看地球，也可以看到高光反射的地方
-   **从远处看是材质，从近处看是几何**
-   **如果一个表面法线分布集中我们认为他是glossy材质，如果分布分散则认为是漫反射材质**
![[Pasted image 20221211101035.png]]
 ![[Pasted image 20221211101047.png]]

第一个F是菲涅尔项，决定多少能量被反射（垂直时候被反射的能量多，反之少）
第二个G是几何项，计算微表面上的相互遮挡（在grazing angle平着照射微表面的时候容易出现互相遮挡）
第三个D是法线分布，当微表面的法线方向与给定的出入射角的半程向量一定才证明这个微表面的入射方向出射方向正确

## 各向同性/各向异性材质
![[Pasted image 20221211101401.png]]

## BRDF的特性
材质的性质进行累加

-   可逆性，对换入射角和出射角可以得到同样的BRDF
-   能量守恒，出射的能量不可能比入射的能量少
-   各向同性和各向异性

![[Pasted image 20221211102027.png]]

## **BRDF的测量**

实际测量出来的BRDF和公式推算出来的BRDF经常会有很大差距

![[c6b0d02de07f87e308d6f7667f0e46ad_MD5.webp]]

-   可以通过仪器来枚举出测试样例的所有测试点进行BRDF的测量
-   当然这样测量十分的麻烦，我们可以利用BRDF的性质来简化测量
-   比如各向同性的材质只需要测量半圈（由于只有三维且利用可逆性可以只测量半球
-   各种不同的方法来提高BRDF的测量效率......
![[Pasted image 20221211102321.png]]

算法：

```c
foreach outgoing direction wo
    move light to illuminate surface with a thin beam from wo
    for each incoming direction wi
        move sensor to be at direction wi from surface
        measure incident radiance
```

# **高级图形渲染概要**

### **高级光线传播**

-   无偏光线传播

-   双向路径追踪（BDPT）
-   Metropolis光线传播 (MLT)

-   有偏光线传播

-   光子映射
-   Vertex connection and merging (VCM) -结合双向追踪和光子映射

-   实时辐射度算法（IR）

有偏是随着样本的增加，结果会变化，如果样本无限多，结果会收敛到正确值。

无偏是不管样本有多少，都会得到正确的结果。

只要得出的结果会模糊就是有偏。

### **双向路径追踪（BDPT）**

思想：从光源和相机各打出一条光线，然后连接端点。

应用场景：在光源由漫反射形成的场景中效果较好。

### **Metropolis光线传播 (MLT)**

思想：使用马尔科夫链和蒙特卡罗方法，通过一定的概率扰动路径的传播，得到一条新的路径，由一条路径追踪为种子生成其他的路径。

应用场景：在复杂场景中的光线追踪

缺点：难以估计渲染完成画面的时间，局部的结果可能会比较"脏"

### **光子映射**

应用场景：特别适合渲染水中焦散的现象

一种实现方法之一：

-   从光源打出光线，在路径中发生反射折射，直到打到漫反射的物体上停止
-   再从相机打出光线，在路径中发生反射折射，直到打到漫反射的物体上停止
-   做局部的密度估计，对任意一个着色点取他周围的确定光子数并通过其占据的面积计算密度

缺点：如果当光子取值，画面会很脏，如果光子取值很大，画面会变糊。

如果光子数量无限多，那么就可以收敛成正确的画面。

### **Vertex connection and merging (VCM)**

思想：结合光子映射和双向路径追踪，如果BDPT中两边打出的光线不能连接，利用光子映射将一定范围的光线做融合，提高光线利用率。

### **实时辐射度算法（IR）**

思想：光源先进行若干次弹射到某个物体上，将这些物体当做是新的光源再进行路径追踪。

优点：渲染速度快，对漫反射场景效果较好。

缺点：无法处理glossy材质且场景缝隙会产生亮点。

### **材质建模**

### **非表面模型**

散射介质：光在传播时穿过会发生散射的介质比如雾、云等，通过相位函数决定了光如何被散射。

光通过散射介质的两种情况：

-   被吸收一部分能量，被介质削减了一部分能量
-   被反射一部分能量，能量从其他地方的能量照射进来或者介质本身会发光

头发/毛发：毛发可以理解为一个柱状模型，可以直接反射，也可以发生折射进入内部。

介绍了几种模型：

-   Kajiya-Kay Model：认为头发只有反射没有折射
-   Marschner Model：认为头发是一个半透明的玻璃圆柱体，有反射也有折射
-   Double Cylinder Model：动物与人类的头发不同，动物的头发髓质很大因此更容易发生散射，所以需要重新考虑模型，增加了散射这一参考系

颗粒材质：可以制作出比如沙子城堡的材质

### **表面模型**

次表面散射（BSSRDF）：

-   光线通过材质内部发生了散射，比如皮肤、玉石等等。
-   BSSRDF是BRDF的延伸，下图为BSSRDF的渲染方程和示意图。
-   使用Dipole Approximation，让物体内外各有一个光源来模拟光的扩散。

![[22377e50e194bcf0558745633b1995a1_MD5.webp]]

衣服：

衣物的渲染主要有三种方法：

-   将衣物当作表面，根据不同的织法使用不同的BRDF，相对来说效果较差但是简单快捷
-   将衣服当做散射介质，根据单根纤维的特性与他的分布来构建散射参数
-   将衣物的每一根纤维为单位进行渲染，计算量十分巨大。

### **表面细节**

-   渲染出来的场景太过于完美，反而没那么真实，真实的世界有磨损有划痕。
-   微表面模型的BRDF的法线分布不该是均匀的，满足大体趋势的同时有自己的波动，但是会造成运算量巨大。
-   这是因为在法线分布复杂的情况下，很难建立有效的的光线通路（光源→表面→摄像机）
-   通过一个像素对应了一块表面，把整块范围内的法线分布整合起来获得（P-NDF），以此简化计算
-   如果表面足够微小，需要考虑波粒二象性使用波动光学，传统的几何光学反而不太够用了。
-   使用波动光学得到的BRDF和几何光学得到的BRDF类似又有自己的特点（光的干涉和衍射）

### **程序化生成**

-   通过使用噪声函数，不需要真正生成复杂的材质，可以通过查询的方法来简化计算
-   通过查询的方法可以生成各种各样的模型
-   工业界使用Houdini专门来做程序化生成材质

# **照相机、镜头和光场**

### **成像**

-   成像 = 合成+捕捉
-   最早的相机是通过小孔成像的原理来成像的，现在的针孔相机也是使用这个原理
-   快门控制光能在相机中待多长时间
-   传感器（Sensor）记录的是光的Irradiance信息
-   针孔摄像机没有透镜，因此做不成景深

### **视场(FOV)**

-   FOV是相机的可视角度范围
-   FOV=2arctan（h/2f）其中h为传感器高度，f为焦距
-   因此视场与传感器大小、焦距均有关
-   手机摄像头通过同时减少焦距和传感器大小以求得到和相机类似的FOV

### **曝光**

-   Exposure = time * irradiance，曝光=时间*Irradiance
-   时间由快门控制，irradiance由光圈的大小和焦距控制
-   快门速度慢，曝光时间长，光在感光器上停留时间长，会产生运动模糊的现象
-   对于机械快门，如果拍摄高速物体会产生运动扭曲的现象
-   光圈的大小控制单位时间内的进光量，光圈可以制造景深，光圈越大景深越明显
-   通过F数（F/N）来描述光圈的大小，F数是焦距/光圈直径（N=f/D）
-   因此运动模糊和景深无法同时出现
-   ISO是一个后期的处理值通过乘上ISO来改变整体的明暗
-   ISO也可以在硬件上进行改变，比如改变感光器的灵敏度
-   ISO过大会产生噪声，因此一般不直接大范围调整ISO来提高亮度
-   通过很长的曝光时间应用于延时摄影上

### **镜头（透镜）**

-   真实的透镜是由很多块玻璃叠在一起制作而成的
-   薄透镜对于平行光会集中在一个点，被称之为焦点
-   目前的相机通过多块透镜的组合可以制作出不同的焦距
-   课程中我们考虑的是理想的薄透镜，同时可以任意改变焦距
-   物距、相距、焦距之间的关系：1/f=（1/zi）+（1/z0）其中f为焦距，zi为相距，z0为物距
-   在焦点前后，光线开始聚集和扩散，点的影象变成模糊的，形成一个扩大的圆，这个圆就叫做CoC
-   离焦模糊是在拍照时，被摄物体不在焦点，使得成像不是清晰的一个点，而是变成coc，coc随着光圈的增加而增大。
-   coc的宽度：C/A=d'/zi=|zs-zi|/zi
-   其中zs为透镜到coc的距离，A为镜头的直径，d'为zs-zi的绝对值

### **光线追踪与薄透镜**

![[5fcd7aa03b5497076baa9c0541fe2cff_MD5.webp]]

实现步骤：

-   首先确定成像平面的大小、透镜本身的焦距和光圈大小
-   然后定义透镜与拍摄平面的物距z0
-   根据前两项确定的数据算出像距zi
-   在成像平面上选一个点x''
-   在透镜上选另一个点x''
-   连接x'和透镜中心点并延长，与subject plane相交得到交点x'''，这样我们就可以知道x'''→x''这条光线最终会被记录在x'点上
-   因此我们只需要考虑x''→x''这条光线上的radiance，算出来记到x'上。

### **景深**

-   场景中的光经过透镜，打到成像平面，在成像平面附近的某个区域，这个区域内CoC都是足够小的。
-   当CoC足够小，我们就认为这个地方是清晰的，而这一区域就被我们成为景深（DOF）
-   景深外的模糊的范围会因光圈大小而变化
-   下面是DOF的计算公式

![[fedbe724e6979b0725aae36daf4eb59d_MD5.webp]]

### **光场**

-   我们通过全光函数P(θ，φ)用于描述我们能看到的所有东西
-   引入波长λ让其拥有色彩，P(θ，φ ，λ)
-   引入时间t让画面可以看到不同时间的场景，P(θ，φ ，λ，t)
-   引入摄像机的位置Vx、Vy、Vz，可以在任意位置观察场景，P(θ，φ ，λ，t，Vx，Vy，Vz)
-   可以将视觉定义成一个七维的函数这个函数也就是全光函数，P(θ，φ ，λ，t，Vx，Vy，Vz)
-   光场是全光函数的一部分P(θ，φ ，Vx，Vy，Vz)，是在任意位置任意方向光的物理量
-   人们法线只需要四维信息就可以定义光的物理量: 2D位置信息（u，v）+ 2D方向信息(θ，φ)
-   我们同样可以通过获取一束光在两个平行平面（s，t）和（u，v）上的位置来确定光的位置

![[9118f458bfd47aa3f8ea7c53d7c6748c_MD5.webp]]

-   一般相机的传感器接收到信息是三维到二维的投影，损失了深度,记录的是Irradiance
-   光场相机通过棱镜分光将的每一块单位面积记录了光场的所有信息Radiance（u,v,s,t）
-   由于记录了光线的Radiance，可以通过仅观察某个方向的光线，同时可以观察特定方向的光线实现聚焦的功能
-   光场相机由于需要多个传感器才能记录一个像素的信息因此分辨率不足，同时由于棱镜精密因此高成本

![[8007ebd4bab650e95989e8147947a7f3_MD5.webp]]

# **颜色与感知**

### **颜色**

-   图形学仅关心光谱中的可见光（400~700nm）
-   谱功率密度(SPD) ：描述一束光再波长上的分布

![[9257e8d344de4a1c2df58194334aa306_MD5.webp]]

-   颜色是一种人的感知不是光的一种属性
-   人眼的结构也类似于相机，瞳孔对应光圈、晶状体调节焦距，视网膜相当于传感器
-   人眼视网膜上分为视杆和视锥细胞分别感知光强和颜色
-   其中视锥细胞分为SML三种对不同波长的光线敏感
-   SML也分别为对应光谱波长的积分

![[e05767259e732b12eafb77e70a45155f_MD5.webp]]

-   同色异谱：不同的SPD的同时拥有相同的SML因此产生相同的颜色
-   RGB：通过调整RGB三原色的比例来混合出想要的有颜色
-   有些颜色怎么混合也混不出来（红色在一段波长的贡献的负的），可以通过给原色加色的方法来混合颜色

![[47f07634c701e364d9024c9e2c6f0f9a_MD5.webp]]

### **色彩空间**

-   sRGB：广泛使用的色彩标准，色域有限，是一种加色系统
-   CIEXYZ：一种人为定义的色彩标准，覆盖了所有可见光

-   其中Y指的是亮度
-   通过归一化得到xyz，并固定Y，这样可以制作出下面的这一张图得到所有色域

![[98d639af16385c1bbf73014492e34951_MD5.webp]]

![[178300b675c20964873d620af9c726c1_MD5.webp]]

-   HSV：通过色调（H）、饱和度（S）、明度（V）来定义颜色空间的一种颜色标准
-   CIELAB：通过三个轴，分别控制亮度和两对互补色（红-绿、蓝-黄）
-   CMYK：减色系统，由靛蓝、品红、黄色三种颜色混合出其他颜色再加上黑色组成，广泛应用于印刷

# **模拟与动画**

### **简介**

动画是一种信息传递的工具。

常用帧率：

-   电影：24FPS
-   视频：30FPS、29.994FPS
-   VR：90FPS+（不晕的基本要求）
-   游戏：30、60FPS+

### **动画里程碑**

-   3200BC-远古时期人类的壁画-Shahr-e Sukhteh, 伊朗
-   1931-Phenakistoscope圆盘，通过转动圆盘来做动画
-   1878-第一部电影Sallie Gardner
-   1937-第一部剧场版手绘电影-白雪公主与七个小矮人
-   1963-第一个计算机生成的动画
-   1972-早期计算机动画，人脸动画
-   1993-侏罗纪公园
-   1995-玩具总动员，第一部完全计算机生成的动画电影（光栅化）
-   2009-天降美食
-   2019-冰雪奇缘2

### **关键帧动画**

-   最早是由最厉害的原画画出关键帧，其他助手画出之间的差值（渐变帧）
-   现在通过插值补充两个动画中的差值

-   线性插值一般过渡不那么自然
-   使用b样条之类的平滑插值技术

### **物理模拟**

### **介绍**

-   通过建立真实的物理模型来模拟出真实的动画系统
-   例子：布料模拟、流体模拟

### **质点弹簧系统**

简单定义：一系列相互连接的质点和弹簧

-   理想弹簧：

-   胡克定律：fa-b=-k·(b-a)，k：劲度系数
-   牛顿第三定律：fb-a=-fa-b
-   问题：没有初始长度

-   非零长弹簧：

-   引入原长l||b-a||
-   ||b-a||-l 为弹簧被拉伸的长度
-   b-a/||b-a||表示a->b力的方向，是归一化
-   问题：由于没有阻力会永远震荡

![[719bd6db52fcd803d4d13b3ad9dfb5f6_MD5.webp]]

-   加入阻尼力：

-   再讲内容之前先普及一点：x为位移，x上一点是速度（一阶导数）点两个点是加速度（二阶导数）
-   f是阻尼力，b加上一点是速度，kd是劲度系数
-   问题：无法描述弹簧内部的力

![[4e2dc4a31f5f56332370f019d2880d90_MD5.webp]]

-   完善的阻尼力：

-   红框为b与a相对速度在b与a方向上的投影，是一个标量
-   红框右边是a到b的方向

![[d3a629e38efb794ebf743325a992748b_MD5.webp]]

问题：这样的弹簧系统无法应对对折的情况（比如讲一块布对折）

解决：通过加入斜向的弹簧来解决这样的问题。

![[7aa026b2d3d24929128de0133e5056a4_MD5.webp]]

问题：这样的弹簧系统无法应对沿着弹簧竖着对折的情况

解决：加入跳跃连接的点，隔一个支点加一个弹簧，这个弹簧十分的弱

![[c2d50abff989b3b994479ed51c0ce249_MD5.webp]]

### **有限元法FEM**

-   方便制作力的传导
-   应用于车辆碰撞的模拟

### **粒子系统**

### **粒子生成步骤**

-   生成粒子
-   计算每个粒子的力（难点）
-   更新每个粒子的位置速度
-   将死亡的粒子移除
-   渲染

### **粒子之间的作用力**

-   引力与斥力

-   重力
-   电磁力

-   阻尼力

-   摩擦
-   空气阻力
-   粘度

-   碰撞

-   墙壁
-   容器
-   物体

### **应用**

通过制定规则让粒子表现群体的个体之间的关系

-   鸟群

-   每个个体的鸟不愿意落单
-   同时不愿意离群体太近
-   方向相对统一

-   细胞结构
-   ...

### **单个粒子的模拟**

获取单个粒子的速度场，获取场内任意位置的速度参数

计算速度场内粒子的位置需要计算一阶常微分方程

![[1fe91179e44ef6d1841fcdc5bdfabbb6_MD5.webp]]

### **欧拉方法**

对时间做离散化的操作，利用欧拉方法（前向欧拉）获取每一个时刻的速度和位移

![[ad54990c5b2d7cdc30c7671a2de7de9f_MD5.webp]]

问题：误差大、稳定性不足，如果步长不足则会不准确，且对于一些曲线的模拟十分不准确，一定会正反馈，其中不稳定的问题很致命

解决：

-   中点法
-   自适应改变步长的方法
-   隐式法
-   不基于物理的方法：基于位置法、韦尔莱积分

### **中点法**

-   在初始点使用欧拉方法计算出下一位置的a点
-   在初始点与a点总取中点b
-   再使用b点的速度来求出初始点下一位置c点

![[11e465aacac53fa57676483adcee8aa7_MD5.webp]]

中点法完整公式：

![[d96ab49c09fd4d2553e5b76c8562cd08_MD5.webp]]

### **自适应步长**

计算两遍，一次是Δt，一次是Δt/2来进行欧拉方法

若两遍的结果相差较大，则应将步长减半重新计算

### **隐式欧拉方法**

![[5a6be922a8fc20d1e4af61241ae8a4bf_MD5.webp]]

联立方程组解出结果（假设下一个时刻的加速度已知）

### **龙格库塔法**

是一种四阶的方法，稳定性相对来说比较好。

中点集合k、k2、k3、k4通过下面的方法进行计算得到下一时刻的位置。

![[b8460b8756f7eea55f63707d30c32e05_MD5.webp]]

### **不基于物理的方法**

-   比如基于位置法、韦尔莱积分等方法
-   该方法不保证能量守恒
-   只通过调整某些位置，使其能够满足模型中的一些特定性质。
-   是一种不稳定的方法，但是简单且实现时间快。

### **如何判断方法是否稳定？**

-   通过研究局部截断误差O（h2）和总体累积误差O（h）来确定稳定性
-   当在局部上讲Δt变为1/2Δt时，在全局上Δt会变为1/4Δt
-   因此阶数越高越好，减少阶数，误差可以成倍的减小

### **运动学**

分为正向和反向，模拟的是真实的骨骼运动

### **正向运动学**

关节类型：

-   可以绕着关节2维的旋转
-   可以绕着关节3维的旋转
-   可以拉长一部分的关节

我们可以通过参数很容易计算出p点的坐标，通过改变参数来实现骨骼的动画就被称为正向运动学

![[d12a3a33e9a074b7dd00d440ed3920e1_MD5.webp]]

因为这样的操作十分不直观，艺术家们不愿意通过这样的方式来调节模型的骨骼，因此逆运动学应运而生

### **逆向运动学**

通过直观的控制尖端p点来直接控制参数，这样操作的计算量相对正运动学相比明显增大

![[2d06c57c5cf7a74eceb7819272c2dfbf_MD5.webp]]

问题：

-   解并不唯一：有多个可能性造成p点在所在坐标
-   无解：p点不可能在指定的坐标

解决：我们通过随机化算法（优化方法、梯度下降）等方法来解决问题，并不使用纯数学的方法来暴力解决

例子：Style-Based IK

### **骨骼绑定**

在模型上增加控制点，让人们能够方便的调整模型的动作

对于同一个模型的两个动作，通过控制点间的位置插值计算来完成，这被称为“Blend Shapes”

### **动作捕捉**

在真人身上放置控制点

优点：

-   可以快速捕捉大量数据
-   较为真实

缺点：

-   复杂、昂贵
-   动作常常会不满足要去，需要后期调整
-   捕捉条件限制

捕捉方法：

-   光学
-   磁力
-   机械

动画的制作流程：

  

![[2304d7592777bc1785d0c9405c372dbf_MD5.webp]]

### **刚体模拟**

刚体不会发生形变，通过求得下面的参数通过上面粒子模拟的方法计算出任意时刻的位置

  

![[dc0883cd1b56a39ea1b0ba8e35f0f7da_MD5.webp]]

### **流体模拟**

### **定义**

-   水体是由多个刚体小球形成的，不可压缩
-   模拟与渲染是分开的过程

### **实现思路**

-   通过获取任意时刻小球的分布位置来获取小球单位面积的密度
-   如果密度如果发生改变（不同于平静的水面），就通过通过改变小球的位置来修正位置，让水总有一个趋于平静的趋势
-   通过加入能量损失让水最终停下来

### **质点法和网格法**

质点法和网格法流体模拟中的两个不同的思路

质点法（拉格朗日法）：逐个模拟每个粒子

网格法（欧拉方法）：将一个空间定义为一个网格，通过观察以网格为单位的时间如何变换来模拟

### **混合方法MPM**

-   质点：将不同的粒子的不同属性储存在粒子上
-   网格：模拟变换的过程在网格中完成
-   将每一个时刻网格的信息写回网格内的粒子上

# **参考资料**

[GAMES101-现代计算机图形学入门-闫令琪](https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/BV1X7411F744)