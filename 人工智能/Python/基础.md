# 一、基础部分
BIF就是Built-in Functions，内置函数
## 1 变量和字符串
变量支持中文
```python nums
// 特殊写法
x = 3  
y = 5  
x,y = y, x  
print(x, y)
```

字符串 string 必须用 `' '` 或者 `" "` 表示

字符串运算
```python nums
// 字符串加法
print('520'+'1314')
#输出
#5201314

// 字符串乘法
print("1"*5)
#输出
#11111
```

转义字符 `\` 防止引号冲突

**原始字符串**
```python nums
print("D:\three\two\one") # 错误，\斜杠被认为是转义字符  
print( "D:\\three\\two\\one" ) # 正确  
print(r"D:\three\two\one") #在引号前添加 r 或 R，称为原始字符串，原始字符串是为了解决ascii字符和正则表达式特殊字符间的冲突而产生的。

#输出
#D:	hree	wo\one
#D:\three\two\one
#D:\three\two\one
```

在使用字符串时需要注意的一点是：无论是否为原始字符串，都不能以反斜杠作为结尾（注：反斜杠放在字符串的末尾表示该字符串还没有结束，换行继续的意思）

换行
```python nums
# \n换行转义字符
print("1\n2\n3")
#输出
#1
#2
#3

# 更好的方法：长字符串，三引号（单引号双引号均可）
print("""1  
2  
3""")
#输出
#1
#2
#3
```

input() 接收用户的输入
```python nums
temp = input("请输入一个数字")  
print(temp)
```

随机数 random 模块

## 2 数据类型

1. **整数**

长度不受限制

2. **浮点数**

精确计算浮点数：`decimal`

```python
import decimal
a = decimal.Decimal('0.1')
```

**E 记法**（科学计数法）  
E的意思是指数，指底数为10，E后边的数字就是10的多少次幂。
例如，15 000等于1.5×10 000，也就是1.5×10<sup>4</sup>，E 记法写成1.5e4。

3. **复数**
x = 1 + 2j 用浮点数存储  
**获取实部**：`real`

```python
>>>x.real
1.0
```

**获取虚部**：`imag`

```python
>>>x.imag
2.0
```
4. **类型转换**
`int(x)`： 转换成整数
`float(x)`：转成浮点数  
`str()`：转换成一个字符串：
`complex(re, im)`： 转成复数
`type()`：获取变量的类型，
更建议使用 `isinstance()`这个 BIF 来判断变量的类型。
`isinstance()`函数有两个参数：第一个是待确定类型的数据；第二个是指定一个数据类型。它会根据两个参数返回一个布尔类型的值，True表示类型一致，False表示类型不一致。举个例子：
```python nums
>>> a = "小甲鱼"
>>> isinstance(a, str)
True
>>> isinstance(520, float)
False
>>> isinstance(520, int)
True
```

4. **算术操作符**： +　-　*　/　%　**　//
`x // y`： 地板除法，向下取整（等同于其他语言中的 floor）
`%`：取余
`divmod(x, y)`： 返回 (x // y, x % y)  
`abs(x)` ： 绝对值（如果是复数，返回模）  
`pow(x, y)`：计算 x^y  
`x ** y`：计算 x^y  

5. **布尔类型**

**`True`**：1 == True  
**`False`**：0 == False

定义为 False 的对象：None 和 False  
值为 0 的数字类型：0， 0.0， 0j， Decimal(0), Fraction(0, 1)  
空的序列和集合：’’, (), [], {}, set(), range(0)

6. **逻辑运算符**
and：与
or：或
not：非
```python nums
# 特殊语法 
5 > 3 < 4
5 > 3 and 3 < 4 # 等价
# 输出：true
```

**Python 中任何对象都能直接进行真值测试**  

**短路逻辑** or and  
从左往右，只有当第一个操作数的值无法确定逻辑运算的结果时，才对第二个操作数进行求值。

7. **运算符优先级**  

![[1680774386163.png]] 

`+, -, *, /, //, %` > 比较运算符 > 逻辑运算符  
not > and > or

## 3 分支结构

### 断言
`assert` 关键字翻译过来就是“断言”，当这个关键字后边的条件为假的时候，程序自动崩溃并抛出 AssertionError 异常。
```python nums
assert 3 < 4
# AssertionErroor
```
一般来说，可以用它在程序中置入检查点，当需要确保程序中的某个条件一定为真才能让程序正常工作的话，assert关键字就非常有用了。
### if   

```python nums
if condition:
		statement(s)
```


```python nums
if condition:
		statement(s)
else:
		statement(s)
```


```python nums
if condition1:
		statement(s)
elif condition2:
		statement(s)
elif condition3:
		statement(s)
...
```


```python nums
if condition1:
		statement(s)
elif condition2:
		statement(s)
elif condition3:
		statement(s)
...
else:
		statement(s)
```

**三元操作符**
```python nums
# 语法
条件成立时执行的语句 if condition else 条件不成立时执行的语句

# 原形式
if x< y:
		small =x
else:
		small =y

# 三元运算符的形式
small = x if x<y else y

```
## 4 循环结构

### while
```python nums
while condition:
		statement(s)
```

### for

```python nums
for 变量 in 可迭代对象:
		statement(s)
```
**可迭代对象**就是指那些元素可以被单独提取出来的对象，如目前最熟悉的字符串，像“FishC”就是由“F”“i”“s”“h”“C”五个字符元素构成的。那么，for循环语句每执行一次就会从该字符串（可迭代对象）中拿出其中一个字符，然后存放到变量中。
```python nums
>>>for each in 'FishC':
		print(each)
# 输出
F
i
s
h
C
```

通过for语句来实现打印1+2+3+4+…+100
```python nums
# 错误，因为100不是可迭代对象
sum=0
for i in 100:
		sum+=i
		print (sum)
	

for i in range(10):		#range(10)是左闭右开区间[0, 10)
	print(i)
```

`range()`是一个BIF函数，它可以为指定的整数生成一个数字序列（可迭代对象）
```python nums
# 注：list是将可迭代对象以列表的形式展示出来。

range(stop) # 生成[0,stop)的数字序列
# 例如 print(list(range(5))) 打印结果为 [0, 1, 2, 3, 4]

range(start, stop)  #生成[start,stop)的数字序列
# 例如 print(list(range(1,5))) 打印结果为[1, 2, 3, 4]

range(start, stop, step) #允许指定步长step（每个元素的间隔），这个步长除了可以是正整数，还可以是负整数：
# 例如list(range(0, 10, 2))，打印结果为[0, 2, 4, 6, 8]
# list(range(0, -10, -2))，打印结果为[0, -2, -4, -6, -8]

```
### break
终止当前循环，跳出循环

### continue
跳出本轮循环并开始下一轮循环（这里要注意的是：在开始下一轮循环之前，会先测试循环条件）。
### else
while 和 for 循环后面也可以跟 else，表示当条件不成立的时候执行的内容
```python nums
while 条件:
		循环体
else:
		条件不成立时执行的内容
		
for 变量 in 可迭代对象:
		循环体
else:
		条件不成立时执行的内容
```
正常境况下 else 不用写，因为本身条件不成立的时候就会结束循环执行后面的内容，但使用 break 时可能会不同：在 else 前面写 break，当 break 触发时不会执行 else 中的内容。
## 5 列表list
列表类似数组，但**可以存放不同类型的变量**

### 创建列表
格式：中括号（数据之间用逗号分隔）
```python nums
r = [1, 2, 3, 4, 5, '上山打老虎']
```

元素：1，2，3，4，5，‘上山打老虎’  
下标：0，1，2，3，4 ，5  
下标：-6，-5，-4，-3，-2，-1

### 删除元素

`remove()`：删除一个元素  
注意：
1.  如果列表中存在多个匹配的元素，只会删除第一个；
2.  如果指定的元素不存在，那么程序就会报错。

`pop()`：删除并返回最后一个元素  
`clear()`：清空列表

`del` 语句
```python nums
# 删除某个（些）元素
eggs = ["鸡蛋", "鸭蛋", "鹅蛋", "铁蛋"]  
del eggs[0]  
print(eggs)
#输出：['鸭蛋', '鹅蛋', '铁蛋']

# 删除变量
del eggs  
print(eggs)
# 报错：name 'eggs' is not defined
```

### 切片语法
用一个冒号隔开两个索引值，左边是开始位置，右边是结束位置。
**注意：结束位置上的元素是不包含的**
如果为空，左边默认为列表第一个位置，右边默认为列表最后一个位置
```python nums
>>> r[0:3]
[1, 2, 3]

>>> r[:3]
[1, 2, 3]

>>> r[3:6]
[4, 5, '上山打老虎']

>>> r[3:]
[4, 5, '上山打老虎']


>>> r[-6:]	#从-6到-1
[1, 2, 3, 4, 5, '上山打老虎']

>>> r[:-1]	#从-6到-1
[1, 2, 3, 4, 5]

>>> r[:]	#整个列表
[1, 2, 3, 4, 5, '上山打老虎']

```

**引入步长**，默认值为1
```python nums
>>> r[0:6:2] #指定步长2
[1, 3, 5]

>>> r[::2] #整个列表，指定步长2
>>> r[::-1] #翻转整个列表

```

> [!NOTE] 
> 列表切片并不会修改列表自身的组成结构和数据，它其实是为列表创建一个新的拷贝（副本）并返回。

**例外的，`del` 语句可以使用列表切片，直接作用于原始列表**
```python nums
>>> del r[::2]
>>> r
[2, 4, 6, 8]
```

为切片后的列表赋值也会作用于原始列表
```python nums
>>> r[0:2] = ['一','二']  
>>> r
['一', '二', 3, 4, 5, '上山打老虎']
```

### 添加元素

**`append()`**：列表末尾添加一个元素，在列表末尾 （只支持一个参数）
**`extend()`**：列表末尾添加另一个列表（支持多个参数）

```python nums
>>> s = [1, 2, 3, 4, 5]
>>> s[len(s):] = [6]				#和s.append(6)相同
>>> s
[1, 2, 3, 4, 5, 6]
>>> s[len(s):] = [7, 8, 9]			#和s.extend([7,8,9])相同
>>> s
[1, 2, 3, 4, 5, 6, 7, 8, 9]
```

**`insert(a, b)`**：指定位置插入一个元素（第一个参数：位置下标，第二个参数：元素值）

```python nums
>>> s = [1, 3, 4, 5]
>>> s.insert(1, 2)
>>> s
[1, 2, 3, 4, 5]

# 第一个参数支持负数，表示与列表末尾的相对距离
>>> number.insert(-1, 8.5)
>>> number
[0, 1, 2, 3, 4, 5, 6, 7, 8, 8.5, 9]
```
### 获取元素
`len()` 函数获取列表长度
`random.choice()` 随机获取一个元素
```python nums
# 通过索引值
>>> eggs = ["鸡蛋", "鸭蛋", "鹅蛋", "铁蛋"]
>>> eggs[0]
'鸡蛋'
>>> eggs[3]
'铁蛋'

# 获取列表最后一个元素
>>> eggs[len(eggs)-1] # len()函数获取列表长度
>>> eggs[-1] # 直接获取
'铁蛋'

# random.choice()随机获取一个元素
>>> random.choice(eggs) # 直接获取

# 列表中还可以包含另一个列表，如果要获取内部子列表的某个元素，应该使用两次索引：
>>> eggs =['鸡蛋'，'铁蛋'，['天鹅蛋'，'企鹅蛋'，'加拿大鹅蛋']，'鸭蛋']
>>>eggs [2] [2]
'加拿大鹅蛋'
```

### 常用操作符
**比较**：当列表包含多个元素的时候，默认是从第一个元素开始比较，只要有一个 PK 赢了，就算整个列表赢了。字符串比较也是同样的道理（字符串比较的是每一个字符对应的 ASCII 码值的大小）。

**加法**：也叫**连接操作符**，它允许把多个列表对象合并在一起，其实就相当于 `extend()` 方法实现的效果。**一般情况下建议使用 `extend()` 方法来扩展列表**，因为这样显得更为规范和专业。另外，**连接操作符并不能实现列表添加新元素的操作（只能是列表和列表相加）**：
```python nums
>>> list1 = [123, 456]
>>> list2 = [234, 123]
>>> list3 = list1 + list2
>>> list3
[123, 456, 234, 123]
```

**乘法**：又称**重复操作符**，重复列表内所有元素若干次
```python nums
>>> list1 = ["FishC"]
>>> list1 * 3
['FishC', 'FishC', 'FishC']
```

**in 和 not in**：在不在列表
```python nums
>>> list1 = ["小猪", "小猫", ["小甲鱼", "小乌龟"], "小狗"]
>>> "小甲鱼" in list1
False
>>> "小乌龟" not in list1 
True #可见in和not in只能判断一个层次的成员关系
```
**（3）改**

**列表是可变的，字符串是不可变的。**

eg：

```python nums
>>> r = [1, 2, 3, 4]
>>> r[0] = 5
>>> r
[5, 2, 3, 4]
>>> r[2:] = [6, 7]
>>> r
[5, 2, 6, 7]
```

**`sort()`**：从小到大排序 (sort() 中 reverse 默认为 False)  
**`reverse()`**：翻转列表中的元素  
①`r.sort()`  
②`r.reverse()`  
①+②：等同于`r.sort(reverse = True)`

**（4）查**

**`count()`** ： 查找某个元素在列表中有几个（参数：元素，返回值：数量）  
**`index()`** ： 查找某个元素的下标索引值（参数：元素，返回值：下标）  
当元素存在多个，返回第一个的下标索引值  
**`index(x, start, end)`** ：指定查找的开始和结束位置  
**`copy()`** ：拷贝一个列表 浅拷贝（shallow copy）


**5、嵌套列表**（创建二维列表，也就是矩阵）

**（1）访问**

```python nums
>>> matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
>>> matrix[0]				#第一行
[1, 2, 3]
>>> matrix[1][1]			#第二行第二列
```

**（2）is 运算符（同一性运算符）**：  
检验两个变量是否指向同一个对象

①

```python nums
>>> A = [0] * 3
>>> for i in range(3):
				A[i] = [0] *3				# √
>>> A
[[0, 0, 0], [0, 0, 0], [0, 0, 0]]
```

![[1680774386314.png]]

②

```python nums
>>> B = [[0] * 3] *3						#× 有bug
>>> B
[[0, 0, 0], [0, 0, 0], [0, 0, 0]]
```

![[1680774386396.png]] 

**检验**：

```
>>> A[0] is A[1]
False
>>> B[0] is B[1]
True
```

**6、浅拷贝和深拷贝**

**`y = x`** ： （引用）当 x 改变，y 也改变  
**`y = x.copy()`** ： 拷贝整个列表（浅拷贝）当 x 改变，y 不改变  
**`y = x[:]`**

**浅拷贝**：只拷贝了外层的对象，当包含嵌套列表时，只是引用

**copy 模块**:

**浅拷贝**：copy()

```
>>> import copy
>>> x = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
>>> y = copy.copy(x)
```

**深拷贝**：deepcopy()

```
>>> import copy
>>> x = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
>>> y = copy.deepcopy(x)
```

**7、列表推导式**

eg：

```
>>> oho = [1, 2, 3, 4, 5]
>>> oho = [i * 2 for i in oho]
>>> oho
[2, 4, 6, 8, 10]
```

**（1）**

```
[expression for target in iterable]
```

**`ord()`** : 将字符转换为对应的 Unicode 编码  
eg:

```
>>> code = [ord(c) for c in 'FishC']
>>> code
[70, 105, 115, 104, 67]
```

eg:

```
>>> matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
>>> col2 = [row[1] for row in matrix]
>>> col2
[2, 5, 8]
>>> diag = [matrix[i][i] for i in range(len(matrix))]
>>> diag
[1, 5, 9]
```

**改变列表内容时，用 for 循环和列表推导式是不完全一样的。**  
**for 循环**：通过迭代，逐个修改原列表中的元素。  
**列表推导式**：直接创建一个新的列表，再赋值给原来的变量。

**创建嵌套列表**：

```
s = [[0] * 3 for i in range(3)]
```

**（2）**

```
[expression for target in iterable if condition]
```

eg：

```
>>> even = [i for i in range(10) if i % 2 == 0]
>>> even
[0, 2, 4, 6, 8]
```

**（3）**

```
[expression for target in iterable1
for target in iterable2
...
for target in iterableN]
```

**（4）**

```
[expression for target in iterable1 if condition1
for target in iterable2 if condition2
...
for target in iterableN if conditionN]
```

## 六、元组

**不可以修改**

**1、创建**

```
tuple = (1, 2, 3, 4, 5, 6, 7, 8)
```

**2、访问**

```
>>> tuple[1]
>>> tuple[5:]
(6, 7, 8)
```

**元组的关键**：逗号

**创建空列表**：`temp = []`  
**创建空元组**：`temp = ()`  
**创建只有一个元素的元组**：eg：`tuple = (1,)` 或者`tuple = 1,`

**3、更新**

```
>>> temp = (3, 4, 6, 7)
>>> temp = temp[:2] + (5,) + temp[2:]		# (5,) 括号，逗号，缺一不可
>>> temp
(3, 4, 5, 6, 7)
```

**4、删除**  
删除整个元组：`del`

```
del temp
```

## 七、字符串

**1、字符串**

```
'abc' "abc" '''abc'''
```

**2、转义字符 (\)**

```
\'		\\	   \n（换行）等
```

`\`放在一行的末尾，说明还没有结束

**3、原始字符串**  
\ 没有转义的意义，在引号前加`r`

```
r"D:\three\two\one\now"
```

**4、长字符串**

```
'''abc''' """abc"""
```

换行不需要`\n`  
也可以用（）括起来 不需要`\n`

**5、字符串的加法和乘法**

**字符串的加法**：拼接  
**字符串的乘法**：复制

**6、方法：**  
[https://fishc.com.cn/forum.php?mod=viewthread&tid=38992&extra=page%3D1%26filter%3Dtypeid%26typeid%3D403](https://fishc.com.cn/forum.php?mod=viewthread&tid=38992&extra=page=1&filter=typeid&typeid=403)

**7、格式化**

**（1）format 方法**

**①位置参数**  
eg：

```
>>> "{0} love {1}.{2}".format("I","FishC","com")
'I love FishC.com'
```

**②关键字参数**  
eg：

```
>>> "{a} love {b}.{c}".format(a="I",b="FishC",c="com")
'I love FishC.com'
```

**（2）% 方法**

eg:

```
print('十进制 -> 十六进制 : %d -> 0x%x' % (num, num))
print('十进制 -> 八进制 : %d -> 0o%o' % (num, num))
print('十进制 -> 二进制 : %d ->' % (num), bin(num))
```

**8、字符串格式化符号含义及转义字符含义：**  
[https://fishc.com.cn/forum.php?mod=viewthread&tid=92997&extra=page%3D1%26filter%3Dtypeid%26typeid%3D403](https://fishc.com.cn/forum.php?mod=viewthread&tid=92997&extra=page=1&filter=typeid&typeid=403)

**9、random**

```
import random					#导入
random.randint(a, b)			#随机a~b之间的整数
```

## 八、序列

**1、列表、元组和字符串的共同点：**

(1) 都可以通过索引得到每一个元素  
(2) 默认索引值总是从 0 开始  
(3) 可以通过切片的方式得到一个范围内的元素的集合  
(4) 有很多共同的操作符（重复操作符、拼接操作符、成员关系操作符）

**2、方法**

**`list(iterable, /)`** ：把一个可迭代对象转换为列表  
**`tuple(iterable, /)`** ：把一个可迭代对象转换为元组  
**`str(obj)`** ：把 obj 对象转换为字符串  
**`len(sub)`** ：返回 sub 对象的长度  
**`max()`** ：返回序列或者参数集合中的最大值  
**`min()`** ：返回序列或者参数集合中的最小值  
**`sum(iterable[, start=0])`** ： 返回序列 iterable 和可选参数 start 的总和  
**`sorted()`** ： 从小到大排序  
**`reversed()`** ： 翻转（返回迭代器对象）, 如果想要显示，可以用`list(reversed())`

eg：

```
>>> numbers = [32, 35, 76, 29, 4, 0, -56, 17]
>>> reversed(numbers)
<list_reverseiterator object at 0x026DAFD0>
>>> list(reversed(numbers))
[17, -56, 0, 4, 29, 76, 35, 32]
```

**`enumerate()`** ： 枚举（返回迭代器对象），生成由每个元素的 index 值和 item 值组成的一个元组，如果想要显示，可以用`list(enumerate())`

eg：

```
>>> enumerate(numbers)
<enumerate object at 0x0271BC28>
>>> list(enumerate(numbers))
[(0, 32), (1, 35), (2, 76), (3, 29), (4, 4), (5, 0), (6, -56), (7, 17)]
```

**`zip()`** ：返回由各个参数组成的元组（返回迭代器对象），如果想要显示，可以用`list(zip())`  
eg：

```
>>> a = [1, 2, 3, 4, 5, 6]
>>> b = [4, 5, 6, 7]
>>> zip(a, b)
<zip object at 0x0271BC28>
>>> list(zip(a, b))
[(1, 4), (2, 5), (3, 6), (4, 7)]
```

# 函数部分

## 一、函数

**（1）定义和调用**

**定义一个函数**：

```
def  函数名(参数):
	...
```

**调用**： 函数名 (参数)  
eg：

```
>>> def add(num1, num2):
		num = num1 + num2
		print(num)
>>> add(2, 3)
```

**（2）函数的返回值（return）**  
eg：

```
>>> def add(num1, num2):
		return (num1 + num2)
>>> print(add(2, 3))
```

**（3）形参和实参**

**形参**：形式参数（parameter）指的是函数创建和定义过程中小括号里的参数  
eg： def add(num1, num2): 中 num1, num2 是形参  
**实参**：实际参数（argument）指的是函数在调用过程中传递进去的参数  
eg：`add(2, 3)`中 2，3 是实参

**（4）关键字参数和默认参数**

**关键字参数**

```
add(num1 = 2, num2 = 3)
```

**默认参数**：在定义函数时就给到的参数  
eg:

```
>>> def SaySome(name = "小甲鱼", words = "让编程改变世界！"):
		print(name + '-->' + words)
>>> SaySome()
小甲鱼-->让编程改变世界！
```

**收集参数（可变参数）**：在参数前加 *  
eg：

```
>>> def test(*params):
		print('参数的长度是：', len(params))
		print('第二个参数是：', params[1])
>>> test(1, 'Percy', 9.99, 7, 5)
参数的长度是： 5
第二个参数是： Percy
```

**（5）函数和过程**

**函数（function）**：有返回值  
**过程（procedure）**：是简单、特殊并且没有返回值的

**python 只有函数，没有过程。**

**（6）变量的作用域（可见性）**

**局部变量**（local variable）：在函数里定义的参数以及变量  
**全局变量**（global variable）：函数外的参数以及变量。函数内可以去访问全局变量，但不要去修改全局变量。

**不到万不得已不要使用全局变量**！简洁的概括为：  
a）代码可读性变差  
b）代码安全性降低

**global 关键字**：在函数内使用，将函数内的局部变量变为全局变量

**（7）内嵌函数**

在函数中再定义一个函数

```
def function1():
	print('function1()被调用')
	def function2():
		print('function2()被调用')
	function2()
	return
```

注意：  
1. 内部函数`function2()`整个作用域都在外部函数`function1()`之内。  
2. 只能在`function1()`中调用`function2()`，在`function1()`之外，不能调用`function2()`。

**（8）闭包**

如果在一个内部函数里对外部作用域（但不是在全局作用域）的变量进行引用，那么内部函数就会被认为是闭包。

```
>>> def FunX(x):
		def FunY(y):
			return x * y
		return FunY

>>> i = FunX(8)
>>> i
<function FunX.<locals>.FunY at 0x03DCAF58>
>>> type(i)
<class 'function'>
>>> i(5)
>>> FunX(8)(5)
```

变量的存储是放在栈里边的，而列表是不存在栈中的可以被内置函数所引用

将 x 改成列表，即可运行

**`nonlocal`关键字**：修饰变量后，标识该变量是上一级函数中的局部变量

**（9）lambda 表达式**

运用`lambda`关键字，创建匿名函数

eg1:

```
>>> lambda x : 2 * x + 1
<function <lambda> at 0x031AAF58>
>>> g = lambda x : 2 * x + 1
>>> g(5)
```

eg2:

```
>>> lambda x, y : x + y
<function <lambda> at 0x031AAF58>
>>> h = lambda x, y : x + y
>>> h(3, 4)
```

**lambda 表达式的作用：**  
1.Python 写一些执行脚本时，使用`lambda`就可以省下定义函数过程，`lambda`使代码更加精简。  
2. 对于一些比较抽象并且整个程序执行下来只需要调用一两次的函数，使用`lambda`不需要考虑命名问题。  
3. 简化代码的可读性。

**（10）两个厉害的 BIF**

① **`filter()`**：过滤器

filter(function or None, iterable) --> filter object

eg1：

```
>>> filter(None, [1, 0, False, True])
<filter object at 0x034CE0A0>
>>> list(filter(None, [1, 0, False, True]))
[1, True]
```

eg2：

```
>>> def odd(x):
	return x % 2

>>> temp = range(10)
>>> show = filter(odd, temp)
>>> list(show)
[1, 3, 5, 7, 9]
```

结合`lambda`关键字，修改代码 eg2：

```
>>> list(filter(lambda x : x % 2, range(10)))
[1, 3, 5, 7, 9]
```

② **`map()`**：映射

map(func, *iterables) --> map object

将序列的每一个元素作为函数的参数进行运算加工，直到可迭代序列的每个元素都加工完毕，返回所有加工后的元素构成的新序列。

eg：

```
>>> list(map(lambda x : x * 2, range(10)))
[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
```

## 二、递归

符合以下两个条件：  
1. 有调用函数自身的行为  
2. 有一个正确的返回条件（停止的条件）

eg：求 n 的阶乘

```
def factorial(n):
    if n == 1:
        return 1
    else:
        return n * factorial(n - 1)

num = int(input('请输入一个正整数：'))
print(num, '的阶乘是：', factorial(num))
```

运行：

```
请输入一个正整数：5
5 的阶乘是： 120
```

**eg：斐波那契数列**  
①运用迭代

```
>>> def fab1(n):
	a = [1, 1]
	for i in range(n - 2):
		result = a[i] + a[i + 1]
		a.append(result)
	print(a.pop())

>>> fab1(12)
```

②运用递归

```
>>> def fab2(n):
	if n < 1:
		return 0
	elif n == 1:
		return 1
	elif n == 2:
		return 1
	else:
		return fab2(n - 1) + fab2(n - 2)

>>> fab2(12)
```

递归所占内存空间大，运算慢

**eg：求解汉诺塔**

```
>>> def hanoi(n, x, y, z):
	if n == 1:
		print(x, '->', z)
	else:
		hanoi(n - 1, x, z, y)# 将前n-1个盘子从x移动到y上
		print(x, '->', z)# 将最底下的最后一个盘子从x移动到z上
		hanoi(n - 1, y, x, z)# 将y上的n-1个盘子从y移动到z上

>>> hanoi(3, 'x', 'y', 'z')
x -> z
x -> y
z -> y
x -> z
y -> x
y -> z
x -> z
```

# 字典、[集合](https://so.csdn.net/so/search?q=%E9%9B%86%E5%90%88&spm=1001.2101.3001.7020)、文件部分

## 一、字典（dict）

**字典是映射类型**

**（1）创造和访问字典**：

**关键符号：**{}  
“`:`” 前：键（key）  
“`:`” 后：值（value）  
eg：

```
>>> dict1 = {'李宁':'一切皆有可能', '耐克':'Just do it', '阿迪达斯':'Impossible is noting', '鱼C工作室':'让编程改变世界'}
>>> print('鱼C工作室的口号是：', dict1['鱼C工作室'])
鱼C工作室的口号是： 让编程改变世界
```

eg：

```
>>> dict2 = {1:'one', 2:'two', 3:'three'}
>>> dict2[2]
'two'
```

**（2）字典的方法：**

**`fromkeys(s[,v])`**：创建并返回一个新的字典  
eg：

```
>>> dict1 = {}
>>> dict1.fromkeys((1, 2, 3))
{1: None, 2: None, 3: None}
>>> dict1.fromkeys((1, 2, 3), 'Number')
{1: 'Number', 2: 'Number', 3: 'Number'}
```

**`keys()`**：访问字典的键  
eg：

```
>>> dict1 = {1: 'Number', 2: 'Number', 3: 'Number'}
>>> for eachKey in dict1.keys():
	print(eachKey)
```

**`values()`**：访问字典的值  
**`items()`**：访问字典的项（键和值）  
**`get()`**：访问字典的值（更灵活），键可以不在字典中  
eg：

```
>>> dict1 = {1: 'Number', 2: 'Number', 3: 'Number'}
>>> dict1[4]				# 会报错
Traceback (most recent call last):
  File "<pyshell#35>", line 1, in <module>
    dict1[4]
KeyError: 4
>>> dict1.get(4)			# 不会报错
>>> print(dict1.get(4))
None
>>> dict1.get(4,'无')		# 可以设置键不在字典中时的输出
'无'
>>> dict1.get(3,'无')		# 当键在字典中，正常输出该键对应的值
'Number'
```

**如果不知道一个键是否在字典中，可以用成员资格操作符来判断。**（`in` 和 `not in`）

```
>>> 3 in dict1
True
>>> 4 in dict2
False
```

注意：成员资格操作符在字典中查找的是键，不是值；而在序列中查找的是元素的值，不是索引号。

**`clear()`**：清空字典  
**`copy()`**：浅拷贝  
**`pop()`**：弹出值，参数：键  
**`popitem()`**：弹出一项（键和值） 字典没有一定的顺序，可以理解为随机弹出  
**`setdefault()`**：与 get() 类似，但当键不在字典中时，会自动添加进去

```
>>> dict1 = {1: 'Number', 2: 'Number', 3: 'Number'}
>>> dict1.setdefault(4)
>>> dict1
{1: 'Number', 2: 'Number', 3: 'Number', 4: None}
>>> dict1.setdefault(5, 'Five')
'Five'
>>> dict1
{1: 'Number', 2: 'Number', 3: 'Number', 4: None, 5: 'Five'}
```

**`update()`**：更新

```
>>> dict1
{1: 'Number', 2: 'Number', 3: 'Number', 4: None, 5: 'Five'}
>>> dict2 = {2:'Two'}
>>> dict1.update(dict2)
>>> dict1
{1: 'Number', 2: 'Two', 3: 'Number', 4: None, 5: 'Five'}
```

## 二、集合（set）

**集合里的元素具有唯一性，自动清除重复的数据  
集合是无序的**

**（1）创建：**  
直接把一堆元素用 “`{}`” 括起来

```
>>> num = {1, 2, 3, 4, 4, 5, 5}
>>> num
{1, 2, 3, 4, 5}
```

使用`set()`工厂函数

```
>>> set1 = set([1, 3, 5, 7, 9])
>>> set1
{1, 3, 5, 7, 9}
```

**（2）访问集合中的值：**  
可以使用`for`把集合中的数据一个个读取出来  
可以通过`in`和`not in`判断一个元素是否在集合中已经存在

**（3）方法：**

```
>>> num
{1, 2, 3, 4, 5}
>>> num.add(6)
>>> num
{1, 2, 3, 4, 5, 6}
>>> num.remove(5)
>>> num
{1, 2, 3, 4, 6}
```

**集合类型内建方法总结：**  
[https://fishc.com.cn/forum.php?mod=viewthread&tid=45276&extra=page%3D1%26filter%3Dtypeid%26typeid%3D403](https://fishc.com.cn/forum.php?mod=viewthread&tid=45276&extra=page=1&filter=typeid&typeid=403)

**（4）不可变集合：**  
**`frozenset()`**：创建一个不可变集合

```
>>> num2 = frozenset([1, 2, 3, 4, 5])
>>> num2.add(0)
Traceback (most recent call last):
  File "<pyshell#12>", line 1, in <module>
    num2.add(0)
AttributeError: 'frozenset' object has no attribute 'add'
```

## 三、文件（file）

扩展名：.exe .txt .ppt .jpg .mp4 .avi 等

**（1）文件打开模式：**

![](1680774411405.png)

‘x’ 和 ‘w’ 均是以 “可写入” 的模式打开文件

**（2）文件对象方法：**

![](1680774411489.png)

**注意：字节和字符是不同的！**

打印文件的每一行：

```
for each_line in f:
	print(each_line)
```

文件的写入：

```
>>> f = open('D:\\test.txt', 'w')
>>> f.write('Hello,World!')
>>> f.close()
```

## 四、文件系统

模块是一个包含所有你定义的函数和变量的文件，其后缀名是. py。  
模块可以被别的程序引入，以使用该模块中的函数等功能。

**OS：Operating System 操作系统**  
有了 OS 模块，我们不需要关心什么操作系统下使用什么模块，OS 模块会帮你选择正确的模块并调用。

**`os`、`os.path` 模块中关于文件、目录常用的函数使用方法**  
[https://fishc.com.cn/forum.php?mod=viewthread&tid=45512&extra=page%3D1%26filter%3Dtypeid%26typeid%3D403](https://fishc.com.cn/forum.php?mod=viewthread&tid=45512&extra=page=1&filter=typeid&typeid=403)

## 五、永久存储

**`pickle`模块**

**存放**：pickling  
**读取**：unpickling

eg：  
存放：

```
>>> import pickle								# 导入
>>> my_list = [123, 3.14, 'Percy', ['another list']]
>>> pickle_file = open('my_list.pkl', 'wb')			# 创建并打开文件
>>> pickle.dump(my_list, pickle_file)				# 把数据倒入文件
>>> pickle_file.close()							# 关闭文件
```

读取：

```
>>> pickle_file = open('my_list.pkl', 'rb')			# 打开文件
>>> my_list2 = pickle.load(pickle_file)				# 加载文件中的数据
>>> my_list2
[123, 3.14, 'Percy', ['another list']]
```

# 异常

## 一、Python 标准异常总结

[https://fishc.com.cn/forum.php?mod=viewthread&tid=45814&extra=page%3D1%26filter%3Dtypeid%26typeid%3D403](https://fishc.com.cn/forum.php?mod=viewthread&tid=45814&extra=page=1&filter=typeid&typeid=403)

## 二、[异常处理](https://so.csdn.net/so/search?q=%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86&spm=1001.2101.3001.7020)

**（1）`try-except`语句**

```
try:
	检测范围
except Exception[as reason]:
	出现异常（Exception）后处理代码
```

eg：

```
try:
    sum = 1 + '1'
    f = open('文件1.txt')
    print(f.read())
    f.close()
except OSError as reason:
    print('文件出错啦！！\n错误的原因是：', reason)
except TypeError as reason:
	print('类型出错啦！！\n错误的原因是：', reason)
```

注意：`try`语句检测范围一旦出现异常，剩下的语句将不会被执行！

同时对多个异常进行统一的处理：  
eg：

```
try:
    sum = 1 + '1'
    f = open('文件1.txt')
    print(f.read())
    f.close()
except (OSError, TypeError):
	print('出错啦！！')
```

**（2）`try-finally`语句**

```
try:
	检测范围
except Exception[as reason]:
	出现异常（Exception）后处理代码
finally:
	无论如何都会被执行的代码
```

eg:

```
try:
    f = open('文件1.txt', 'w')
    print(f.write('我存在了！'))
    sum = 1 + '1'
except (OSError, TypeError):
    print('出错啦！！')
finally:
	f.close()
```

## 三、引发异常

**`raise`语句**

eg：

```
>>> raise ZeroDivisionError('除数为零的异常')
Traceback (most recent call last):
  File "<pyshell#2>", line 1, in <module>
    raise ZeroDivisionError('除数为零的异常')
ZeroDivisionError: 除数为零的异常
```

## 四、丰富的 else 语句及简洁的 with 语句

**（1）丰富的`else`语句:**

当没有异常时，执行`else`语句

eg:

```
try:
    print(int('123'))
except ValueError as reason:
    print('出错啦！')
else:
    print('没有任何异常')
```

**（2）简洁的`with`语句：**

**考虑关闭文件的问题**：当文件不再需要用到的时候，with 语句会自动关闭文件。

eg：

```
try:
    with open('文件1.txt', 'w') as f:
        for each_line in f:
            print(each_line)
except OSError as reason:
    print('出错啦！！', reason)
```

# 类和对象

## 一、类和对象的简单介绍

**对象 = 属性 + 方法**

**定义一个类**：`class`关键字  
[Python](https://so.csdn.net/so/search?q=Python&spm=1001.2101.3001.7020) 中的类名约定以大写字母开头。

**面向对象的特征（Object Oriented）：**  
a. 封装：信息隐蔽技术  
b. 继承：子类自动共享父类之间数据和方法的机制  
c. 多态：不同对象对同一方法响应不同的行动

## 二、面向对象编程

**（1）`self`**：Python 的 self 相当于 C++ 的`this`指针

由同一个类可以生成无数个对象，这些对象长得都很相似，因为他们都是来源于同一个类的属性和方法，当一个对象的方法被调用的时候，对象会将自身作为第一个参数传给`self`参数，接收到`self`的时候，Python 就知道是哪一个对象在调用方法了。

eg：

```
>>> class Ball:
	def setName(self, name):
		self.name = name
	def talk(self):
		print('我是%s' % self.name)

>>> a = Ball()
>>> a.setName('足球')
>>> b = Ball()
>>> b.setName('篮球')
>>> a.talk()
我是足球
>>> b.talk()
我是篮球
```

**（2）Python 的魔法方法之一**

```
__init__(self)
__init__(self, param1, param2...)
```

在类实例化后，会自动调用`__init__(self)`方法。

eg：

```
>>> class Ball:
	def __init__(self, name):
		self.name = name
	def talk(self):
		print('我是%s' % self.name)

		
>>> a = Ball('羽毛球')
>>> a.talk()
我是羽毛球
```

**（3）公有和私有**

默认来说，对象的属性和方法都是公有的，可以通过 “.” 操作符进行访问。  
在 Python 中定义私有变量只需要在变量名或函数名前加上 “__” 两个下划线，那么这个函数或变量就会为私有的了。

## 三、继承

子类可以继承父类的属性和方法

**1、定义一个子类：**

```
class DerivedClassName(BaseClassName):
	…
```

**BaseClassName**：父类、基类或超类  
**DerivedClassName**：子类

eg：

```
import random as r

class Fish:
    def __int__(self):
        self.x = r.randint(0, 10)
        self.y = r.randint(0, 10)

    def move(self):
        self.x -= 1
        print('我的位置是：', self.x, self.y)

class Goldfish(Fish):
    pass

class Carp(Fish):
    pass

class Salmon(Fish):
pass
```

运行：

```
>>> fish = Goldfish()
>>> fish.__int__()
>>> fish.move()
我的位置是： 7 9
```

注意：  
如果子类中定义与父类同名的方法或者属性，则会自动覆盖父类对应的方法或属性。

**2、当子类中与父类同名的方法或属性覆盖掉父类中的方法或属性，但又想引用父类中的方法或属性时，我们可以采用以下两种方法：**

**a. 调用未绑定的父类方法  
b. 使用 super 函数**

eg：调用未绑定的父类方法

```
import random as r

class Fish:
    def __init__(self):
        self.x = r.randint(0, 10)
        self.y = r.randint(0, 10)

    def move(self):
        self.x -= 1
        print('我的位置是：', self.x, self.y)

class Goldfish(Fish):
    pass

class Carp(Fish):
    pass

class Salmon(Fish):
    pass

class Shark(Fish):
    def __init__(self):
        Fish.__init__(self)
        self.hungry = True

    def eat(self):
        if self.hungry == True:
            print('我饿了！我要吃饭！')
            self.hungry = False
        else:
            print('我好撑！吃不下了！')
```

eg：使用 super 函数

```
import random as r

class Fish:
    def __init__(self):
        self.x = r.randint(0, 10)
        self.y = r.randint(0, 10)

    def move(self):
        self.x -= 1
        print('我的位置是：', self.x, self.y)

class Goldfish(Fish):
    pass

class Carp(Fish):
    pass

class Salmon(Fish):
    pass

class Shark(Fish):
    def __init__(self):
        super().__init__()
        self.hungry = True

    def eat(self):
        if self.hungry == True:
            print('我饿了！我要吃饭！')
            self.hungry = False
        else:
            print('我好撑！吃不下了！')
```

## 四、多重继承

定义一个子类：

```
class DerivedClassName(Base1, Base2, Base3):
	…
```

注意：尽量避免使用多重继承！

## 五、组合

把类的实例化放在新的类里面，就把旧的类组合进去了。

eg：

```
class Turtle:
    def __init__(self, x):
        self.num = x

class Fish:
    def __init__(self, y):
        self.num = y

class Pool:
    def __init__(self, x, y):
        self.turtle = Turtle(x)
        self.fish = Fish(y)

    def print_num(self):
        print('水池中有%d只乌龟，%d条鱼。' % (self.turtle.num, self.fish.num))
```

运行：

```
>>> p = Pool(1, 5)
>>> p.print_num()
水池中有1只乌龟，5条鱼。
```

## 六、类、类对象和实例对象

```
>>> class C:
	count = 0

	
>>> a = C()
>>> b = C()
>>> c = C()
>>> a.count
>>> b.count
>>> c.count
>>> c.count += 10
>>> c.count
>>> a.count
>>> b.count
>>> C.count += 100
>>> a.count
>>> b.count
>>> c.count
```

![](1680774432595.png)

如果实例化对象的属性和类的方法名相同，属性会覆盖掉方法。

注意：  
1. 不要试图在一个类里边定义出所有能想到的特性和方法，应该利用继承和组合机制来进行扩展。  
2. 用不同的词性命名，如属性名用名词，方法名用动词。

## 七、绑定

Python 严格要求方法需要有实例才能被调用，这种限制就是 Python 所谓的绑定概念。

```
>>> class CC:
	def setXY(self, x, y):
		self.x = x
		self.y = y
	def printXY(self):
		print(self.x, self.y)

		
>>> dd = CC()
>>> dd.__dict__
{}
>>> CC.__dict__
mappingproxy({'__module__': '__main__', 'setXY': <function CC.setXY at 0x041B0FA0>, 'printXY': <function CC.printXY at 0x041B8028>, '__dict__': <attribute '__dict__' of 'CC' objects>, '__weakref__': <attribute '__weakref__' of 'CC' objects>, '__doc__': None})
```

未给实例对象`dd`赋值时，`dd`的属性是一个空字典。类对象`CC`的属性中包含实例化对象的属性，不显示类属性和特殊属性。

```
>>> dd.setXY(4, 5)
>>> dd.__dict__
{'x': 4, 'y': 5}
>>> CC.__dict__
mappingproxy({'__module__': '__main__', 'setXY': <function CC.setXY at 0x041B0FA0>, 'printXY': <function CC.printXY at 0x041B8028>, '__dict__': <attribute '__dict__' of 'CC' objects>, '__weakref__': <attribute '__weakref__' of 'CC' objects>, '__doc__': None})
```

给实例对象`dd`赋值后，dd 的属性仅属于`dd`对象，类对象`CC`中不存在`x`和`y`。

```
>>> del CC
>>> ee = CC()
Traceback (most recent call last):
  File "<pyshell#15>", line 1, in <module>
    ee = CC()
NameError: name 'CC' is not defined
>>> dd.printXY()
4 5
```

删掉类实例`CC`，不能再实例化类`CC`，但实例对象`dd`依旧能调用类`CC`中的方法。因为类中定义的属性和方法都是静态变量，就算类对象被删除了，它们依然是存放在内存中的。只有当程序被退出的时候，这个变量才会被释放。

## 八、一些相关的 BIF

**1、`issubclass(class, classinfo)`**

检查`class`是否是`classinfo`的一个子类，是，返回`True`，否，返回`False`。  
注意：  
1. 这种检查是非严格性的检查，一个类被认为是其自身的子类。  
2.`classinfo`可以是类对象组成的元组，只要`class`是其中任何一个候选类的子类，则返回`True`。如果第二个参数不是类或者由类对象组成的元组，会抛出一个`TypeError`异常。

**2、`isinstance(object, classinfo)`**

检查实例对象`object`是否属于类`classinfo`，是，返回`True`，否，返回`False`。  
注意：  
1.`classinfo`可以是类对象组成的元组，只要`object`是其中任何一个候选类的实例对象，则返回`True`。  
2. 如果第一个参数不是对象，则永远返回`False`。  
3. 如果第二个参数不是类或者由类对象组成的元组，会抛出一个`TypeError`异常。

**3、`hasattr(object, name)`**

测试对象`objec`t 是否有指定的属性`name`，`name`为字符串格式。

**4、`getattr(object, name[, default])`**

返回对象`object`中指定的属性`name`的值，`default`是当属性`name`不存在时返回的参数。

**5、`setattr(object, name, value)`**

设置对象`object`中指定的属性`name`的值为`value`，如果属性`name`不存在，会新建一个属性并给它赋值。

**6、`delattr(object, name)`**

删除对象`object`中指定的属性`name`，如果属性`name`不存在，则抛出`AttributeError`异常。

**7、`property(fget=None, fset=None, fdel=None, doc=None)`**

通过属性设置属性。

eg：

```
>>> class C:
	def __init__(self, size=10):
		self.size = size
	def getSize(self):
		return self.size
	def setSize(self, value):
		self.size = value
	def delSize(self):
		del self.size
	x = property(getSize, setSize, delSize)

	
>>> c = C()
>>> c.x				# 调用 property第一个参数getSize方法
>>> c.x = 20			# 调用 property第二个参数setSize方法
>>> c.x
>>> del c.x			# 调用 property第三个参数delSize方法
>>> c.x
Traceback (most recent call last):
  File "<pyshell#18>", line 1, in <module>
    c.x
  File "<pyshell#11>", line 5, in getSize
    return self.size
AttributeError: 'C' object has no attribute 'size'
```


# 魔法方法

## 一、Python 魔法方法详解

[https://fishc.com.cn/forum.php?mod=viewthread&tid=48793&extra=page%3D1%26filter%3Dtypeid%26typeid%3D403](https://fishc.com.cn/forum.php?mod=viewthread&tid=48793&extra=page=1&filter=typeid&typeid=403)

## 二、构造和析构

*   魔法方法总是被双下划线包围，例如：`__init__` 方法
*   魔法方法是面向对象的 Python 的一切，如果你不知道魔法方法，说明你还没能意识到面向对象的 Python 的强大
*   魔法方法的 "魔力" 体现在它们总能够在适当的时候被自动调用

**（1）`__init__(self[, ...])`**  
在需要对对象进行初始化操作时，才会用到。  
必须 return None  
不能另加 return，会报错！

**（2）`__new__(cls[, ...])`**  
实例化对象时，第一个被调用的方法。  
默认执行，一般不需要重写。  
需要重写的情况：当继承一个不可变类型，又需要修改的时候，那么它的特性就显得尤为重要。

```
eg：
>>> class CapStr(str):
	def __new__(cls, string):
		string = string.upper()
		return str.__new__(cls, string)

	
>>> a = CapStr('Love')
>>> a
'LOVE'
```

这里的 `CapStr` 是要继承 `str`，但是 `CapStr` 又要把输入的字符串变成大写，`str` 没有这个性质，它是不能改变的，类 `CapStr` 就成了继承 `str` 且能把输入变大写的类

**（3）`__del__(self)`**  
析构器。  
当对象将要被销毁的时候，这个方法就会被调用。  
并非 `del x` 就相当于自动调用 `x.__del__()`，`__del__` 方法是当垃圾回收机制回收这个对象的时候调用的。  
eg：

```
>>> class C:
	def __init__(self):
		print('我是__init__方法，我被调用了！')
	def __del__(self):
		print('我是__del__方法，我被调用了！')

		
>>> c1 = C()
我是__init__方法，我被调用了！
>>> c2 = c1
>>> c3 = c2
>>> del c3
>>> del c2
>>> del c1
我是__del__方法，我被调用了！
```

要删除所有的实例化对象时，才会被调用 `__del__` 方法。

## 三、算术运算

算数运算符  
[https://fishc.com.cn/forum.php?mod=viewthread&tid=48793&extra=page%3D1%26filter%3Dtypeid%26typeid%3D403](https://fishc.com.cn/forum.php?mod=viewthread&tid=48793&extra=page=1&filter=typeid&typeid=403)

反运算  
[https://fishc.com.cn/forum.php?mod=viewthread&tid=48793&extra=page%3D1%26filter%3Dtypeid%26typeid%3D403](https://fishc.com.cn/forum.php?mod=viewthread&tid=48793&extra=page=1&filter=typeid&typeid=403)

eg：

```
>>> class Nint(int):
	def __rsub__(self, other):
		return int.__sub__(self, other)

	
>>> a = Nint(5)
>>> 2 - a
```

当执行反运算时，`a` 是 `self`，`2` 是 `other`。所以 `2 - a` 其实是 5-2，结果为 3。

## 四、属性访问

*   **`__getattr__(self, name)`**

定义当用户试图获取一个不存在的属性时的行为

*   **`__getattribute__(self, name)`**

定义当该类的属性被访问时的行为

*   **`__setattr__(self, name, value)`**

定义当一个属性被设置时的行为

*   **`__delattr__(self, name)`**

定义当一个属性被删除时的行为

eg：  
写一个矩形类，默认有宽和高两个属性；如果为一个叫 square 的属性赋值，那么说明这是一个正方形，值就是正方形的边长，此时宽和高都应该等于边长。

```
class Rectangle:
    def __init__(self, width=0, height=0):
        self.width = width
        self.height = height

    def __setattr__(self, name, value):
        if name == 'square':
            self.width = value
            self.height = value
        else:
            super().__setattr__(name, value)

    def getArea(self):
        return self.width * self.height
```

运行：

```
>>> r = Rectangle(4, 5)
>>> r.getArea()
>>> r.square = 7
>>> r.getArea()
```

## 五、描述符

描述符就是将某种特殊类型的类的实例指派给另一个类的属性。

**特殊类型**：至少要实现以下三个方法的其中一个。

*   **`__get__(self, instance, owner)`**

用于访问属性，返回属性的值

*   **`__set__(self, instance, value)`**

将在属性分配操作中调用，不返回任何内容

*   **`__delete__(self, instance)`**

控制删除操作，不返回任何内容

eg：

```
>>> class MyDecriptor:

	def __get__(self, instance, owner):
		print('getting...', self, instance, owner)

	def __set__(self, instance, value):
		print('setting...', self, instance, value)

	def __delete__(self, instance):
		print('deleting...', self, instance)

		
>>> class Test:
	x = MyDecriptor()

	
>>> t = Test()
>>> t.x
getting... <__main__.MyDecriptor object at 0x03CE2760> <__main__.Test object at 0x03FF6040> <class '__main__.Test'>
>>> t.x = '美少女'
setting... <__main__.MyDecriptor object at 0x03CE2760> <__main__.Test object at 0x03FF6040> 美少女
>>> del t.x
deleting... <__main__.MyDecriptor object at 0x03CE2760> <__main__.Test object at 0x03FF6040>
```

**Property 的原理：**

重写 MyProperty 类（作用与 Property 相同）：

```
>>> class MyProperty:
	def __init__(self, fget=None, fset=None, fdel=None):
		self.fget = fget
		self.fset = fset
		self.fdel = fdel
		
	def __get__(self, instance, owner):
		return self.fget(instance)
	
	def __set__(self, instance, value):
		self.fset(instance, value)
		
	def __delete__(self, instance):
		self.fdel(instance)

		
>>> class C:
	def __init__(self):
		self.s = None
		
	def getS(self):
		return self.s
	
	def setS(self, value):
		self.s = value
		
	def delS(self):
		del self.S
		
	x = MyProperty(getS, setS, delS)
```

运行：

```
>>> c = C()
>>> c.s = '美少女'
>>> c.s
'美少女'
>>> del c.s
>>> c.s
Traceback (most recent call last):
  File "<pyshell#52>", line 1, in <module>
    c.s
AttributeError: 'C' object has no attribute 's'
```

结果与 Property 相同

## 六、定制容器

**协议（Protocols）**

与其他编程语言中的接口很相似，它规定你哪些方法必须要定义。然而，在 Python 中的协议就显得不那么正式。事实上，在 Python 中，协议更像是一种指南。

**容器类型的协议**

*   如果说你希望定制的容器是不可变的话，你只需要定义 `__len__()` 和 `__getitem__()` 方法。
    
*   如果你希望定制的容器是可变的话，除了 `__len__()` 和 `__getitem__()` 方法，你还需要定义 `__setitem__()` 和 `__delitem__()` 两个方法。
    
    **容器类型**
    

![](1680774447290.png)

eg：  

![](1680774447393.png)

  
代码：

```
class CountList:
    def __init__(self, *args):
        self.values = [x for x in args]
        self.count = {}.fromkeys(range(len(self.values)), 0)
    
    def __len__(self):
        return len(self.values)

    def __getitem__(self, key):
        self.count[key] += 1
        return self.values[key]
```

运行：

```
>>> c1 = CountList(1, 3, 5, 7, 9)
>>> c2 = CountList(2, 4, 6, 8, 10)
>>> c1[4]
>>> c2[0]
>>> c1[4] + c2[3]
>>> c1.count
{0: 0, 1: 0, 2: 0, 3: 0, 4: 2}
>>> c2.count
{0: 1, 1: 0, 2: 0, 3: 1, 4: 0}
```

## 七、[迭代器](https://so.csdn.net/so/search?q=%E8%BF%AD%E4%BB%A3%E5%99%A8&spm=1001.2101.3001.7020)

**`iter()`**  
对于一个容器对象调用，得到迭代器  
**`next()`**  
迭代器返回下一个值（如果迭代器没有值可以返回了，那么就会抛出一个 `StopIteration` 的异常）

eg：

```
>>> string = 'FishC'
>>> it = iter(string)
>>> next(it)
'F'
>>> next(it)
'i'
>>> next(it)
's'
>>> next(it)
'h'
>>> next(it)
'C'
>>> next(it)
Traceback (most recent call last):
  File "<pyshell#7>", line 1, in <module>
    next(it)
StopIteration
```

**for 循环的原理：**

```
>>> string = 'FishC'
>>> it = iter(string)
>>> while True:
	try:
		each = next(it)
	except StopIteration:
		break
	print(each)

	
F
i
s
h
C
```

**迭代器的魔法方法：**

**（1）`__iter__()`  
（2）`__next__()`**

**eg：斐波那契数列**

```
>>> class Fibs:
	def __init__(self, n=10):
		self.a = 0
		self.b = 1
		self.n = n
	def __iter__(self):
		return self
	def __next__(self):
		self.a, self.b = self.b, self.a + self.b
		if self.a > self.n:
			raise StopIteration			# 用raise语句来引发一个异常
		return self.a

	
>>> fibs = Fibs()
>>> for each in fibs:
	print(each)

	

>>> fibs = Fibs(50)
>>> for each in fibs:
	print(each)
```

## 八、生成器

迭代器的一种实现

**生成器**：在普通的函数中加入 `yield` 语句。

**协同程序**：  
可以运行的独立函数调用，函数可以暂停或者挂起，并在需要的时候从程序离开的地方继续或者重新开始。

eg：

```
>>> def myGen():
	print("生成器被执行！")
	yield 1
	yield 2

	
>>> g = myGen()
>>> next(g)
生成器被执行！
>>> next(g)
>>> next(g)
Traceback (most recent call last):
  File "<pyshell#60>", line 1, in <module>
    next(g)
StopIteration
>>> for i in myGen():
	print(i)

	
生成器被执行！
```

eg：斐波那契数列

```
>>> def fibs():
	a = 0
	b = 1
	while True:
		a, b = b, a + b
		yield a

		
>>> for each in fibs():
	if each > 20:
		break
	print(each, end = ' ')

	
1 1 2 3 5 8 13
```

*   **列表推导式**：

```
>>> a = [i for i in range(20) if not(i % 2) and i % 3]
>>> a
[2, 4, 8, 10, 14, 16]
```

*   **字典推导式**：

```
>>> b = {i : i % 2 == 0 for i in range(10)}
>>> b
{0: True, 1: False, 2: True, 3: False, 4: True, 5: False, 6: True, 7: False, 8: True, 9: False}
```

*   **集合推导式**：

```
>>> c = {i for i in [1, 2, 2, 3, 4, 5, 5, 6, 7, 8, 4, 3, 1]}
>>> c
{1, 2, 3, 4, 5, 6, 7, 8}
```

*   **生成器推导式**：

```
>>> d = (i for i in range(10) if i % 2 == 0)
>>> d
<generator object <genexpr> at 0x03C06290>
>>> next(d)
>>> next(d)
>>> for each in d:
	print(each)
```

eg：

```
>>> sum((i for i in range(10) if i % 2 == 0))
>>> sum(i for i in range(10) if i % 2 == 0)
```

一对括号、两对括号，都可以！一对括号更加简洁！

# 模块

## 一、模块就是程序

*   容器 ---- > 数据的封装
*   函数 ---- > 语句的封装
*   类 ---- > 方法和属性的封装
*   模块 ---- > 模块就是程序

**导入模块：**  
（1）`import 模块名`  
（2）`from 模块名 import 函数名`  
（3）`import 模块名 as 新名字`

**模块的作用：**  
（1）封装组织 Python 的代码  
（2）实现代码的重用

## 二、`__name__ == '__main__'`

eg：  
在主程序中使用`__name__`变量：

```
>>> __name__
'__main__'
```

在模块中使用`__name__`变量：得到模块名

```
>>> import random as r
>>> r.__name__
'random'
```

## 三、搜索路径

搜索路径其实是一个列表，系统有默认的搜索路径列表。  
可以选择创建一个文件夹来保存你写的模块，但需要在搜索路径列表中添加这个文件夹的所在位置。  
添加可以采用`append()`方法。

## 四、包（package）

创建一个包：  
（1）创建一个文件夹，用于存放相关的模块，文件夹的名字即包的名字；  
（2）在文件夹中创建一个`__init__.py`的模块文件，内容可以为空；  
（3）将相关的模块放入文件夹中。

导入时：`import 包名.模块名`

## 五、Python 标准库

Python 标准库中包含一般任务所需要的模块

快速了解一个模块：

（1）`print(模块名.__doc__)`

```
>>> import timeit
>>> print(timeit.__doc__)
			# 得到balabala一大堆...（这里省略）
>>> dir(timeit)
['Timer', '__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', '_globals', 'default_number', 'default_repeat', 'default_timer', 'dummy_src_name', 'gc', 'itertools', 'main', 'reindent', 'repeat', 'sys', 'template', 'time', 'timeit']
>>> timeit.__all__
['Timer', 'timeit', 'repeat', 'default_timer']			# 可以被外部调用的
```

*   当使用`from timeit import *`这种方法导入：导入的参数只有`timeit.__all__`中的参数，其他参数不导入。

```
>>> from timeit import *
>>> Timer
<class 'timeit.Timer'>
>>> gc
Traceback (most recent call last):
  File "<pyshell#8>", line 1, in <module>
    gc
NameError: name 'gc' is not defined
```

*   `__file__`：指明该模块源代码所在位置

```
>>> import timeit
>>> timeit.__file__
'C:\\Users\\zhuya\\AppData\\Local\\Programs\\Python\\Python38-32\\lib\\timeit.py'
```

（2）`help(模块名)`

```
>>> help(timeit)
			# 得到balabala一大堆...（这里省略）
```