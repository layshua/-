
大器晚成，大音希声，大象无形。
![[Pasted image 20230115222649.png]]
-   **继承**（空心箭头）
-   **聚合**（实心箭头），一个对象拥有另一个对象。Actor 拥有 Actor Component
蓝色都是 Actor，橘色是 Actor Component
# 常见基类

![[5e01f6a77b6e69f39b08335af45f4650_MD5.jpg|500]]

- UObject
- Actor
- Pawn
- Controller
- Character
### UObject 类

> [!question] 什么时候该继承自 UObject 类? 什么时候应该声明一个纯 C++类?
> 
> 当需要以下功能时继承 UObject 类。

UObject是 UE4 大部分类的基类。它提供了如下几种功能：

![[1973fd181d34b367eaa73e5a4fd549b7_MD5.jpg]]
1.  Garbage collection **垃圾收集**
    - C++的内存管理由程序员完成，何时释放内存很棘手。UE 提供了两个解决方案：
    - （1）继承自 UObject 类, 同时指向 UObject 类实例对象的指针成员变量，使用 `UPROPERTY` 宏进行标记。虚幻引擎的 UObject 架构会自动地**被 `UPROPERTY` 标记的变量**考虑到垃圾回收系统中，在没有其他地方引用时候，定期清理，释放内存。自动地进行对象的生命周期管理。
    - （2）采用**智能指针**。请注意, **只有非 UObject 类型，才能够使用智能指针进行自动内存释放**。
2. Reference updating **引用自动更新**
3. Reflection **反射**
    - 运行时能获取一个类，动态创建类的对象，并且能动态获取到类有哪些函数和成员变量等，UE4 的蓝图中大量使用了反射技术。
4. Serialization **序列化**
5. Automatic updating of default property changes **自动检测默认变量的更改**
6. Automatic property initialization **自动变量初始化**
7. Automatic editor integration **和虚幻引擎编辑器的自动交互**
8. Type information available at runtime **运行时类型识别**
    - 请注意，虚幻引擎打开了/GR-编译器参数。意味着你无法使用 C++标准的 RTTI 机制: `dynamic_cast`。UE 实现了一套自己的、更高效的运行时类型识别的方案。**如果你希望使用，请继承自 UObject 类，然后使用 `Cast<>` 函数来完成。**
9. Network replication **网络复制**
    - 当你在进行网络游戏开发 （c/s 架构）时, 你一定希望能够自动地处理变量的同步。而继承自 UObject 类，其被宏标记的变量能够自动地完成网络复制的功能。从服务器端复制对应的变量到客户端。

综上所述，当你需要这些功能的时候，你的这个类应该继承自 UObject 类。
请注意: UObject 类会在引擎加载阶段，创建一个 Default Object 默认对象。这意味着:
- 构造函数并不是在游戏运行的时候调用，同时即便你只有一个 UObject 对象存在于场景中, 构造函数依然会被调用两次。
- 构造函数被调用的时候，UWorld 不一定存在。`GetWorld()`返回值有可能为空!


### Actor 类

所有可以放入关卡的对象都是 **Actor**，比如摄像机、静态网格体、玩家起始位置。Actor 支持三维变换，例如平移、旋转和缩放。你可以通过游戏逻辑代码（C++或蓝图）创建（生成）或销毁 Actor。

在 C++中，`AActor` 是所有 Actor 的基类。

注意：Actor 不直接保存变换（位置、旋转和缩放）数据；如 Actor 的根组件存在，则使用它的变换数据。

> [!question] 什么时候该继承自 Actor 类
> 需要挂载组件的时候

Actor 的字面意思是演员。

在 UE4 中 Actor 拥有这样的能力：**它能够被挂载组件**。

UE 的 Component 和和 Unity 中的 Component 不同！
- Unity 中，一个对象可以挂载多个脚本组件，每个脚本组件是一个单独的类。
- UE 中一个场景实体对应一个类，**组件不是类，组件只是组件！** 类似 Unity 脚本组件的功能在 UE 中用继承自 Actor 类的子类来实现。

![[1040341fdeaf2123fdf8add79225f020_MD5.jpg]]

如上，如果需要它被渲染，可以挂一个静态网格组件，或者骨架网格体组件
如果需要它移动，可以直接在 Actor 类中写代码或者挂一个 Movement 组件。
#### Actor 组件

组件被创建时与其包含的 Actor 相关联。

组件的主要类型有：

-    `UActorComponent`：最适用于抽象行为，例如移动、物品栏或属性管理，以及其他非物理概念。Actor 组件没有变换，即它们在场景中不存在任何物理位置或旋转。**不存在于场景中的任意特定位置。它们通常用于概念上的功能，如 AI 或解译玩家输入。**

-    `USceneComponent`：SceneComponents 是拥有变换的 ActorComponents。变换是场景中的位置，由位置、旋转和缩放定义。SceneComponents 能以层级的方式相互附加。Actor 的位置、旋转和缩放取自位于层级根部的SceneComponent。支持基于位置的行为，这类行为不需要几何表示。这包括弹簧臂、摄像机、物理力和约束（但不包括物理对象），甚至音频。
    
-  `UPrimitiveComponent`：PrimitiveComponent 是拥有一类图像表达（如网格体或粒子系统）的 SceneComponent。诸多有趣的物理和碰撞设置均在此处。

Actor 支持拥有一个 SceneComponent 的层级。每个 Actor 也拥有一个 `RootComponent` 属性，将指定作为 Actor 根的组件。Actor 自身不含变换，因此不带位置、旋转，或缩放。它们依赖于其组件的变换，具体来说是其根组件的变换。**如果此组件是一个 SceneComponent，其将提供 Actor 的变换信息。否则 Actor 将不带变换。其他附加的组件拥有相对于其附加到的组件的变换。**

![[Pasted image 20230826161240.png]]


### Pawn 类

在国际象棋中，Pawn（翻译：兵/卒） 代表的是：兵/卒

![[eee81f393376a8786c638b6eabe292ed_MD5.jpg|198]]

Pawn 类提供了被 “操作” 的特性。他能被 Controller 控制。
就像一个棋手，控制这个棋子。一旦脱离棋手就无法自主行动

### Character 类
![[Pasted image 20230115225829.png]]
Character 类代表一个角色，它继承自 Pawn，提供了一个特殊组件：**Character Movement**。这个组件提供了一个基础的，**基于胶囊体（CapsuleComponent）** 的角色移动功能。包括移动和跳跃，还能扩展出蹲伏和爬行等。
![[b822fae4a1d16b63aeccd92312078af9_MD5.jpg|450]]

> [!question] 什么时候该继承自 Pawn，什么时候该继承自 Character
> 看是否需要**Character Movement**组件
> - 所以如果你的游戏角色是人类或这两足怪物的话，特别适合使用 Character 类。
> - 如果你的 Pawn 类十分简单，或者不需要这样的移动逻辑（比如飞机），那么可以不继承这个类

### Controller 类

Controller 是一种可以控制 `Pawn` 或 Pawn 的派生类（如 `Character`），从而控制其动作的非实体 Actor。可以把它看作是下棋的棋手，或者提线木偶的操作者。

![[48a96ad32e3217302ffcf634ee29a044_MD5.jpg]]

它既可以是玩家，比如 `Player Controller` 类，通过键盘或者手柄输入来操作游戏角色（可以在 Player Controller 类中绑定输入）。
也可以是电脑 AI，比如 `AI Controller` 类来操作游戏中的 NPC 和怪物等角色 （可以 AI Controller 类中使用行为树/EQS 环境查询系统）。

为何虚幻引擎采用这样的设计？Epic 给出的理由非常简单:“不同的怪物也许会共享同样的 Controller，从而获得类似的行为”。即棋手可以通过 `Possess/UnPossess` 操纵多种棋子。

![[2335a0d74602ec1194ba6a229a8946f8_MD5.jpg]]
**Pawn/Character 拥有的只是简单的前进、转向、跳跃、开火等函数。而 Controller 则是能调用这些函数。**

> [!NOTE]
> 当您设置 PlayerController 时，您需要考虑的一个事情就是您想在 PlayerController 中包含哪些功能及内容。
> 
> 您可以在 **Pawn** 中处理所有输入，尤其是不太复杂的情况下。但是，**如果您的需求非常复杂，比如在一个游戏客户端上的多玩家、或实时地动态修改角色的功能，那么最好 `PlayerController` 中处理输入。** **在这种情况中，PlayerController 决定要干什么，然后将命令（比如"开始蹲伏"、"跳跃"）发布给 Pawn。**
> 
> 同时，**某些情况下，则必须把输入处理或其他功能放到 PlayerController 中**。PlayerController 在整个游戏在过程中都是一直存在的，但是 Pawn 可能是临时存在的。比如，在死亡竞技模式的游戏中，您可能死了又重生，所以您将获得一个新的 Pawn，但是您的 PlayerController 都是一样的。在这个示例中，如果您将分数保存到您的 Pawn 上，那么分数将会重置，但是如果您将分数保存到 PlayerController 上，它将不会重置。

# 创建自己的 C++ 类

![[a2de28b8beaedfb1041bc82904442d90_MD5.jpg]]


### 创建 C++ 类
**标准的虚幻引擎模块文件结构：**
![[Pasted image 20230828173115.png]]
1.  虚幻引擎中每个游戏性类都由一个类头文件 `.h` 和一个类源文件`.cpp `构成。`.h ` 文件放在 `public` 文件夹内，`.cpp ` 文件放置在 `private` 文件夹内。 
2. 在`.h` 中声明你的类：如果你的类继承自 `UObject`，你的类名上方需要加入 **`UCLASS()`** 宏。同时，你需要在类体的第一行添加 `GENERATED_UCLASS_BODY()` 宏，或者 **`GENERATED_BODY() `** 宏，主要是为了实现类的反射用。
    - 前者需要手动实现一个带有 `const FObject Initializer&` 参数的构造函数。
    - 后者需要手动实现一个无参数构造函数。注意笔者说的是“实现”而非声明。
3.  在你的 .cpp 文件中，包含当前模块的 PCH 文件。一般是 `模块名+private PCH.h`。如果是游戏模块，有可能包含的是 **`游戏工程名.h`**
4. 每个类头文件需要包含生成的头文件（自动创建）**`ClassName.generated.h`**
5.  编译。

![[e46e76278309fd6e265ec8581e6c917c_MD5.jpg]]

### UE类名规则

虚幻引擎中的类拥有一个标准化的命名方案，通过首字母或前缀即可立即明了其为哪种类。类的前缀有：
- `F`　纯 C++类
- `U`　继承自 UObject，但不继承自 Actor，无法被实例到世界场景中，必须从属于 Actor
- `A`　继承自 Actor
- `S`　Slate 控件相关类 
- `H`　HitResult 相关类

**虚幻引擎头文件工具 Unreal Header Tool（简称UHT）** 会在编译前检查你的类命名。如果类的命名出现错误，那么它会提出警告并终止编译。
![[40e49e2d717588aca8dcb325381445da_MD5.jpg|500]]


## 对象

### 类对象的产生

在标准 C++ 中，一个类产生一个对象，被称为 “实例化”。标准 C++ 一般是通过 `new` 的关键字来实例化一个对象。

![[a3cbfeec00cefa0a68934c677da014be_MD5.jpg]]

在虚幻引擎中，实例化一个类的对象需要判断类的父类，使用不同的实例化方法：

![[cee78b9f9e15f8137e3c1c58781a884b_MD5.jpg]]

### 类对象的获取

我们可以通过某种方式获取到这个对象的指针或引用，然后对它进行操作。

比如我们可以通过 Actor 迭代器：TActorItertor，来获取当前 World 的所有 Actor，如下代码：

```
for (TActorItertor<AActor> Iter(GetWorld()); Iter; ++Iter)
{
   // 调用这个Actor的某个你需要成员函数等
   Iter->YourFunction();
}
```

### 类对象的销毁

一个类的对象需要销毁，一有如下几种方式：

![[df3425f9c326b0ac042aebaf06d01b5e_MD5.jpg]]

**纯 C++ 对象有三种方式：**

一，是局部变量自动销毁，如下代码：

```
void func1() {
   FMyClass myObj = FMyClass();
   // do something 
   // 函数结束时，局部变量自动销毁
}
```

二，是使用 delete 来手动删除：

```
void func1() {
  FMyClass *myObj = new FMyClass();
  // do something
  delete myObj;
}
```

三，是使用 TSharedPtr 的智能指针来自动管理。底层使用了引用计数的原理。

**UObject 对象**

对于 UObject 的对象，一般其他对象用 UPROPERTY 的成员引用了它，只要不引用了，就会自动垃圾回收销毁了，也可以手动 AddToRoot，让它不被回收。后续需要删除时再移除出 Root 即可。

**AActor 对象**

AActor 对象比较简单，需要销毁时调用 Destroy () 函数请求销毁即可，后续引擎会自动调用垃圾回收真正删除它。

## 从 C++ 到蓝图

我们可以通过 UPROPERTY 宏把成员变量注册到蓝图，通过 UFUNCTION 宏把函数注册到蓝图。比如我们创建了一个 MyActor 类，并注册了 MyPlayerName 的成员变量和 HelloUE5 () 的函数，如下图：

![[5149b4d1dd07600fb70f0c46255a8f2e_MD5.jpg]]

### UPROPERTY 宏

我们使用 UPROPERTY 宏来注册成员变量到蓝图，比如 UPROPERTY (EditAnywhere, BlueprintReadWrite, Category = "MyActor") 其中 EditAnywhere 表示可以在蓝图任意地方编辑，BlueprintReadWrite 表示蓝图可以读写这个成员变量，Category = "MyActor" 表示它放在属性编辑器的 “MyActor” 子栏。

### UFUNCTION 宏

我们使用 UFUNCTION 宏来注册成员函数到蓝图，比如 UFUNCTION (BlueprintCallable, Category = "MyActor")，其中 BlueprintCallable 表示蓝图可以调用，Category = "MyActor" 表示函数的子分类为 "MyActor" 可以在蓝图选择调用函数时快速定位到它。

## 引擎系统相关类简介

引擎中常用的一些工具实用类如下：

![[c0259438bc46dc2e622ae3d441992757_MD5.jpg]]

### 正则表达式

需要包含头文件 #include "Regex. h"，通过 FRegexPattern 来创建一个待查找或匹配的模式，然后通过 FRegexMatcher 来查找与匹配字符串中符合模式的部分，如下代码：

```
#include "Regex.h"
FString TextStr("ABCDEFGHIJKLMN");
FRegexPattern TestPattern(TEXT("C.+H"));
FRegexMatcher TestMacher(TestPattern, TestStr);

if (TestMacher.FindNext())
{
  UE_LOG(MyLog, Warning, TEXT("找到匹配内容 %d ~ %d"), 
                TestMacher.GetMatchBeginning(),
                TestMacher.GetMatchEnding());
}
```

### FPaths 路径管理器

在 Core 模块中，虚幻引擎提供了一个用于路径相关处理的类：FPaths。主要提供了 3 类 “工具” 性质 API：

1，**具体路径类**： FPaths:: GameDir () 获取游戏根目录

2，**工具类**：FPaths:: FileExists () 判断一个文件是否存在。

3，**路径转换类**：FPaths:: ConvertRelativePathToFull () 将相对路径转换为绝对路径。

### 配置文件解析

这里涉及到 XML，JSON 与 INI 等三种文件：

**XML**：可以使用 FastXML 与 FXmlFile 进行解析与处理。

**Json**：可以使用 FJsonSerializer 与 FJsonValue 等来进行解析与处理。

**ini**：使用 GConfig 类进行读写与解析。

### 文件读写与访问

使用 FPlatformFileManager:: Get ()->GetPlatformFile () 进行文件的读写相关。常用函数如下：

CopyDirctorTree 拷贝目录树

CopyFile 拷贝当前文件

CreateDirectory 创建目录

DeleteDirectory 删除目录

DeleteFile 删除指定文件

FileExists 检查文件是否存在

OpenRead 打开一个文件进行读取

OpenWrite 打开一个文件进行写入

等等。

### LOG

Log 作为开发中常用到的功能，可以在任何需要情况下记录程序运行情况。

**查看 Log**

在 Game 模式下可以加入 - Log 命令行参数来查看 Log。在编辑器模式，直接打开 Log 窗口就行（Window->DeveloperTools->OutputLog）。

**写 Log**

可以通过 UE_LOG (LogMy, Warning, TEXT ("Hello world")); 来输出 log，第一个参数为 Log 的分类，需要预设。第二个参数为类型，有 Log，Warning，Error 三种类型，其中 Log 为灰色，Warning 为黄色，Error 为红色。具体的输出为 TEXT，内容可以自己构造。

**自定义 Log 的 Category**

我们自己定义 Category 的宏，如下代码：

```
DEFINE_LOG_CATEGORY_STATIC(LogMy, Warning, All);
```

### 字符串

在虚幻引擎中字符串有三种类型：FName，FText，FString。

**FName**：无法修改，大小写不敏感，其实 FName 内部只是一个整数索引，实际的字符串内容是在一个公用的字符串表中保存，非常省内存。

**FText**：无法修改，用来显示，支持本地化和多国语言。

**FString**：允许修改，区分大小写。最为灵活，不过比其他两种字符串，略为耗一些内存。

引擎相关类的总体内容如下：

![[62b82bc981eb26ffd7fc3a1d371ed7c2_MD5.jpg]]

至此，本节的内容就讲的差不多了！我们学会了创建自己的类，对象，C++ 与蓝图，以及一些引擎相关实用类等！下节我们会分享虚幻引擎的模块机制相关，敬请期待！！