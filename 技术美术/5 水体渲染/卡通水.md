## 前言

今天给大家带来的案例是：用 UnityShader 写一个卡通水

先看看它长什么样：

![](https://pic4.zhimg.com/v2-d3a4b973d92e7a541d1b4acc08b8c54b_b.gif)

老规矩，先贴上教程的 Reference：

[https://roystan.net/articles/toon-water.html](https://roystan.net/articles/toon-water.html)

接下来，我会从几个方面概括实现过程：

1.  基于水深度的水着色
2.  基于 uv 的水波纹动画
3.  采样屏幕空间法线，和观察空间顶点法线点积。实现**垂直与水平**水面的物体泡沫量的单独调整
4.  自定义混合模式，实现可改变的泡沫颜色
5.  用 SmoothStep 代替阈值 cutoff，实现抗锯齿

## 一、基于深度的水颜色

### 1. 相机深度 _CameraDepthTexture

**a. 获取深度纹理**

*   “_CameraDepthTexture” 这个变量对所有 Shader 全局可用，但默认是不可用的
*   这个 Demo 中，我们给主相机挂了一个脚本，用来开启这个变量

```cs
using UnityEngine;

public class CameraDepthTextureMode : MonoBehaviour 
{
    [SerializeField]
    DepthTextureMode depthTextureMode;

    private void OnValidate()
    {
        SetCameraDepthTextureMode();
    }

    private void Awake()
    {
        SetCameraDepthTextureMode();
    }

    private void SetCameraDepthTextureMode()
    {
        GetComponent<Camera>().depthTextureMode = depthTextureMode;
    }
}
```

*   之后将检查器字段设置为 Depth

![](https://pic3.zhimg.com/v2-cdfd934437ee366d68a16d01683fb8ca_b.jpg)

*   在 Shader 中，我们通过变量声明处的 “sampler2D _CameraDepthTexture” 访问相机的深度纹理

**b. 采样深度纹理**

*   深度纹理是一个全屏（full-screen）纹理，它的尺寸和我们的屏幕相同
*   所以我们使用**屏幕空间位置（ScreenPositin）**来采样这张深度纹理
*   在输出结构中声明屏幕空间位置

```
float4 screenPosition : TEXCOORD2;
```

*   在顶点着色器中计算屏幕空间位置

```
o.screenPosition = ComputeScreenPos(o.vertex);
```

*   在片元着色器中采样深度纹理

*   第一步采样深度纹理后的值是非线性的（0,1）的值，这样会造成一个问题：

*   相机近处的 1 米的深度值会比离相机远的 1 米的深度值大

*   所以，第二步我们将它非线性深度值转化为线性，以相机的世界单位计算

```
float existingDepth01 = tex2Dproj(_CameraDepthTexture, UNITY_PROJ_COORD(i.screenPosition)).r;
float existingDepthLinear = LinearEyeDepth(existingDepth01);
```

### 2. 水面深度

*   我们想要的是：刚才得到的这个屏幕空间的深度值相比水面深度有多深，所以我们还需要知道水面深度
*   水面深度就是屏幕空间位置的 w 分量，两者相减，就得到了差值

```
float waterDepth = i.screenPosition.w;    //水面深度
 float depthDifference = existingDepthLinear - waterDepth;   //两者差值
```

*   **// 阶段展示**

return depthDifference，我们看一下效果：

![](https://pic4.zhimg.com/v2-10ae60daca7a7ec250efe3c8242df6ef_r.jpg)

### 3、基于深度水着色

**a. 水颜色的原理**

*   当看向水时

*   水和地面距离近时颜色表现为浅色（绿色部分）
*   水和地面距离较远时表现为深色（红色部分）

![](https://pic1.zhimg.com/v2-82a0079c3f1c93ca61bc86b1f5126804_r.jpg)

**b. 计算水颜色**

*   我们用 Lerp 函数对 【地面附近水的颜色】 和 【水深处的颜色】 进行插值

*   用世界单位的深度除以最大深度，计算权重
*   并用 saturate 函数将他们钳制在（0,1）
*   最后用 Lerp 对两者插值

```
float waterDepthDifference01 = saturate(depthDifference / _DepthMaxDistance);
float4 waterColor = lerp(_DepthGradientShallow, _DepthGradientDeep, waterDepthDifference01);
```

*   // 阶段展示  
    此时我们就可以通过调整最大深度值参考，控制近处和远处水颜色

## 二、水波纹

### 1. 使用 Perlin Noise 添加波纹

*   我们使用柏林 noise 在水的表面添加波浪，并且用水深度来控制波浪的可见度（浅水处更明显，产生海岸线效果）

**a. 采样 noise**

```c
//声明个新属性用来读noise图
_SurfaceNoise("Surface Noise", 2D) = "white" {}

// 输入结构增加uv
float4 uv : TEXCOORD0;

// 输出结构增加uv
float2 noiseUV : TEXCOORD0;

// 使用前声明变量
sampler2D _SurfaceNoise;
float4 _SurfaceNoise_ST;//支持Tilling和offset

// 顶点着色器：传递uv，并支持Tilling和Offset
o.noiseUV = TRANSFORM_TEX(v.uv, _SurfaceNoise);

//片元着色器：采样noise
float surfaceNoiseSample = tex2D(_SurfaceNoise, i.noiseUV).r;
```

**b. 风格化波纹**

*   直接采样 noise 的效果是很辣眼睛的，我们需要再进行更卡通的改造
*   // 如果接触过卡渲风格的传统经验关照，一个思路就是将渐变过程截断成 “卡硬” 效果
*   所以这里我们设定一个阈值对上一步采样的 noise 结果进行 cutoff：

*   小于这个阈值的将会被直接舍弃（0）
*   大于这个阈值的将会被设为 1

```c
// Add as a new property.
_SurfaceNoiseCutoff("Surface Noise Cutoff", Range(0, 1)) = 0.777

// Matching property variable.
float _SurfaceNoiseCutoff;

// Add in the fragment shader, just after sampling the noise texture.
float surfaceNoise = surfaceNoiseSample > _SurfaceNoiseCutoff ? 1 : 0;
```

*   **// 阶段展示**  
    此时我们的已经可以通过调整阈值来控制还波纹

![](https://pic2.zhimg.com/v2-4de7b0ac3c48050254888d8ba91ec2dd_b.gif)

### 2. 与水相交的泡沫

*   这一步，我们实现和水面相交地方的泡沫效果
*   思路：

*   基于水深度，调整 noise 的 cutoff 阈值

```c
// Control for what depth the shoreline is visible.
_FoamDistance("Foam Distance", Float) = 0.4

// Matching variable.
float _FoamDistance;

// 片元着色器
float foamDepthDifference01 = saturate(depthDifference / _FoamDistance);
	//泡沫深度
float surfaceNoiseCutoff = foamDepthDifference01 * _SurfaceNoiseCutoff;
	//将泡沫深度乘给cutoff阈值
float surfaceNoise = surfaceNoiseSample > surfaceNoiseCutoff ? 1 : 0;
```

*   **// 阶段展示**  
    可以看到，通过调节 foam DIstance 参数，我们就可以控制和水相交物体的泡沫距离

// 例子资产中地形模型就有下凹，这一步我只是将水材质的 plane 往下移动了一下，相交就是圆形边缘

注：这里有个问题：

*   水和岸的相交点很棒，但和物体的相交处缺不明显
*   后续我们会解决

![](https://pic2.zhimg.com/v2-27ad5f6653453d2c66d94ee0aafee1b1_b.gif)

### 3. 水流动、扰动动画

接下来我们为水添加动画效果

**a. 水流动（uv 流动）**

*   思路：

*   通过_Time 参数对采样 noise 的 uv 进行偏移，实现动画效果

```c
// Property to control scroll speed, in UVs per second.
_SurfaceNoiseScroll("Surface Noise Scroll Amount", Vector) = (0.03, 0.03, 0, 0)

float2 _SurfaceNoiseScroll;

// 片元着色器
float2 noiseUV = float2(i.noiseUV.x + _Time.y * _SurfaceNoiseScroll.x, i.noiseUV.y + _Time.y * _SurfaceNoiseScroll.y);
	//偏移采样noise的uv，来产生动画效果
float surfaceNoiseSample = tex2D(_SurfaceNoise, noiseUV).r;
```

*   效果如下图

可以通过更改_SurfaceNoiseScroll 参数来控制流动方向和速度

![](https://pic4.zhimg.com/v2-5d8345e3c4011f5b196b3921106aec8f_b.gif)

**b. 水扰动**
FlowMap 来处理噪声贴图, 让噪声贴图流动起来
## 三、解决和漂浮物相交泡沫不明显问题

在这一 Part，我们来解决之前提到的：和物体相交部分不明显的问题

*   **原因**：

*   岸边和水面之间的深度相当小，而水面和水下物体之间的深度（从相机的角度）相对较大。

*   **解决方法**：

*   **方案 1：**

*   将_FoamDistance 参数增加到 0.4 左右即
*   这样一来岸边的部分就太大了

![](https://pic2.zhimg.com/v2-2a6a142d557bac3c8cce3cd6e55c79b9_r.jpg)

*   **方案 2：**

*   根据**水面以下的角度**来改变**泡沫的深度（foam depth）**
*   这样一来，垂直的物体表面（和漂浮物相交部分）可以比平坦的物体表面（岸边）得到更多的泡沫（白色）

接下来就开始施行方案 2，需要用的法线纹理

### 2. 比较渲染的法线与 view space 的法线

**a. 计算水面的 view space 法线**

*   我们需要计算**水的 view space 下的法线**，来和渲染好的法线做比较

> [!NOTE] 理解观察空间法线
> 随着摄像机位移不断变化，Unity 摄像机在观察空间看向-z，所以朝向摄像机的法线都为 z 轴方向，越朝向相机值越接近（0，0，1）
> 
![[202308012045.gif]]


水面的法线纹理寸的法线，都是指向正 y 轴，值为（0，1，0）。
当相机平视水面时，观察空间法线的值也是接近（0，1，0），夹角小点积结果大。
当相机垂直观察水面时，观察空间法线越来越接近（0，0，1），夹角变大，点积结果变小。

* 在输入输出结构增加相应的法线数据，并且在顶点着色器中传递给片元着色器

```c
// Add to appdata.
float3 normal : NORMAL;

// Add to v2f.
float3 viewNormal : NORMAL;

// Add to the vertex shader.
o.viewNormal = COMPUTE_VIEW_NORMAL;
```

**b. 采样渲染的法线**

*   我们将之前脚本得到的法线纹理采样来读取法线

```c
sampler2D _CameraNormalsTexture;

// Add to the fragment shader, just above the existing foamDepthDifference01 line.
float3 existingNormal = tex2Dproj(_CameraNormalsTexture, UNITY_PROJ_COORD(i.screenPosition));
```

**c. 作比较**

*   我们用点乘的方法对两者作比较

*   简单来说就是：0°~90° 内：当两个者夹角越小时，点乘结果就越趋近于 1；相反，就越趋近于 0

```
float3 normalDot = saturate(dot(existingNormal, i.viewNormal));
```

*   这里有一个随着两者角度，点积结果的变化图，非常有助于理解

![](https://pic3.zhimg.com/v2-f806a3321646d4f6ecc3df0e5e09a69e_b.gif)

**d. 控制泡沫量**

*   用上一步的点积结果控制与水相交时的泡沫量：

*   当点积大（接近 1）时，我们将使用比小（接近 0）时更低的泡沫阈值。

```c
//用下边这两个参数代替之前声明的泡沫产生距离参数
_FoamMaxDistance("Foam Maximum Distance", Float) = 0.4
_FoamMinDistance("Foam Minimum Distance", Float) = 0.04
//声明变量
float _FoamMaxDistance;
float _FoamMinDistance;

//用Lerp插值泡沫距离，并且将它应用到之前的操作中
float foamDistance = lerp(_FoamMaxDistance, _FoamMinDistance, normalDot);
float foamDepthDifference01 = saturate(depthDifference / foamDistance);
```

**// 改善效果**

*   **注意**：**用 C# 脚本渲染的法线纹理要运行时才会生成**，所以观察是否生效 / 改善时，需要在运行状态下调整
*   可以看到，**在运行状态下**，我们可以单独调节岸边和漂浮物的泡沫量
*   // 想必大家也看到了调参数时其实是挺反人类的，这里可以做一个优化：

*   调节的参数改为 range 类型，让参数在一个范围内调节

![](https://pic1.zhimg.com/v2-73ffedd12553bd37f8edf20a040dfa04_b.gif)

## 四、透明度

*   我们将渲染队列改为 Transparent
*   混合模式改为：Blend SrcAlpha OneMinusSrcAlpha
*   关闭深度写入


## 五、让泡沫的颜色可控制

### 1. 增加泡沫颜色参数

*   我们声明一个 color 类型的属性，乘给最终的 surfacenoise

![](https://pic3.zhimg.com/v2-167ce84136ba4bdd3762b639ca71f7fa_r.jpg)

### 2. 理解混合模式

*   上一步的结果是：

*   可以改变颜色，但改变的结果不对

*   错误的原因出在混合模式，additive 的混合模式实际上多用于发光的特效，在这个 Demo 中是不适用的
*   **我们来看一下混合模式是如何工作的：**

*   当提供两个参数时，Blend 的工作方式是将着色器的输出乘以第一个值（SrcAlpha，或着色器输出的 alpha），将屏幕上的颜色乘以第二个值（OneMinusSrcAlpha 或 1 - 输出的 alpha），然后将两者相加得到最终颜色。



### 3. 自定义混合模式

*   自定义混合方式（函数）
*   混合 Alpha 通道

```
###alphaBlend函数###
float4 alphaBlend(float4 top, float4 bottom)
{
	float3 color = (top.rgb * top.a) + (bottom.rgb * (1 - top.a));
	float alpha = top.a + bottom.a * (1 - top.a);

	return float4(color, alpha);
}

###片元着色器###
float4 surfaceNoiseColor = _FoamColor;
surfaceNoiseColor.a *= surfaceNoise;	//只乘给a通道

return alphaBlend(surfaceNoiseColor, waterColor);
```

**// 效果：**

![](https://pic3.zhimg.com/v2-acaa0fffa0117f20c9e2155cd5a46b76_b.gif)

## 六、抗锯齿

*   仔细观察一下，我们能法线泡沫的边缘实际上锯齿是比较严重的。
*   锯齿严重的原因是我们 cutoff noise 的方式：**不是 0 就是 1**

![](https://pic3.zhimg.com/v2-7ce4a2334b417519d51616390237f6a6_r.jpg)

**解决方法**
*   使用 SmoothStep 函数将 Alpha 从 0 到 1 平滑过渡

*   实现：
*   注释掉之前的 cutoff 方法，改用 smoothstep 计算
*   **我们定义`_FoamEdgeFade` 值必须很小，让 smoothStep 的下限和上限非常接近，0~1 的变化斜率非常大。`_FoamEdgeFade`太大会过于软，没有卡通效果**
*   它们之间的距离刚好可以给边缘增加一些平滑度。

```
//卡通硬边会有锯齿
//float FoamNoise = NoiseFlowTex > FoamNoiseCutoff ? 1 : 0;
//抗锯齿：平滑过渡
float FoamNoise = smoothstep(FoamNoiseCutoff-_FoamEdgeFade,FoamNoiseCutoff+_FoamEdgeFade,NoiseFlowTex);
```