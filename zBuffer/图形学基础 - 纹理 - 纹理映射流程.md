
纹理映射 (Texture Mapping) 是一种将物体空间坐标点转化为纹理坐标，进而从纹理上获取对应点的值，以增强着色细节的方法。

如下图所示，一个光秃秃的人脸模型，贴了一张纹理后变得栩栩如生：

![](<images/1684548373475.png>)

本文主要介绍纹理映射的总体流程，为下文[《纹理映射盘点》](https://zhuanlan.zhihu.com/p/370927083)介绍各种纹理映射的应用做铺垫。

纹理映射有以下四个步骤，但并不是每个都要使用，只是体现纹理映射可以被灵活操控，以获得我们想要的效果。

![](<images/1684548373534.png>)

一、投影映射 (Projector And Mapping)

之所以叫投影映射，是因为主要有两种方法可以将三维的空间坐标点转化为二维的纹理坐标点：Projector 和 UV Mapping

**1） Projector**

对于一些简单的几何体，通常用投影的方式：

![](<images/1684548373574.png>)

这种将矩形地图纹理均匀贴到球表面的投影函数称之为：Spherical 形式

此外还有 Plane, Cubic 和 Cylindrical，下图总结了四者差异（一张红绿相间的纹理贴到不同简单几何体的方式）：

![](<images/1684548373611.png>)

**2） UV Mapping**

Projector 只适用于简单情况，对于更复杂的几何体贴图，往往需要用到 UV Mapping：用于将 3 维模型中的每个顶点与 2 维纹理坐标一一对应。 UV map 则需要建模师精心制作：

![](<images/1684548373674.png>)

在实时渲染中，通常是将 uv 坐标保存在顶点信息中，在三角形内使用时，通过插值的方式得到每个片元具体的 uv 坐标，再从纹理中采样获得对应的值。但也有例外，比如在进行环境贴图 (Environment Mapping) 时，需要在渲染时根据投影方程再去确定每个点的纹理坐标以及纹理值

## 二、变换函数 (Corresponder Function)

在上一步投影映射中，我们将 3 维空间坐标映射为了 2 维参数空间坐标 uv，在此阶段可以做三件事：**坐标范围处理、坐标自由变换、转到纹理空间**

**1） 坐标范围处理**

此时得到的有可能是 [0.25,0.3] 这种在 [0,1] 范围内的值，但也有可能超出了 [0,1] 范围，那么需要对范围外的值进行处理，一般有以下几种方法：**Repeat、Mirror、Clamp** 和 **Border**，用一张图进行总结：

![](<images/1684548373728.png>)

**2） 坐标自由变换**

除了对这些超出范围的 uv 值处理，还可以对其施加 “变换”，比如旋转，平移，缩放，比如想让纹理随着时间运动起来，那么就可以逐帧变换 uv 值

但要注意的是：**对 uv 坐标施加的变换矩阵，往往是实际想要变换的逆矩阵**

如：若想让纹理向右偏移 0.5 单位，那么则应该是 u – 0.5 而不是 u + 0.5。就好比是一个窗口去看这张纹理，uv 就是窗口，窗口向左移动，看起来就是纹理向右移动

**3） 转到纹理空间**

在对 uv 进行合理变换之后，其范围都落到了 [0,1]，再分别乘以纹理实际的宽高，可得到纹理坐标。比如 uv 坐标为 [0.25,0.3]，纹理的宽高为 [256,256]，那么相乘可得到 [64,76.8]，出现了小数

如何根据纹理坐标得到对应的纹理值？这就涉及到下面的纹理采样

## 三、纹理采样 (Texture Sampling)

我们知道，可以将屏幕或者画布上的一个单元称之为像素 pixel，为了与纹理上的一个单元进行区别，特将后者称之为 texel

设想一种特殊情况，我们要渲染的物体正面对着我们，刚好画布尺寸与纹理尺寸一致，比如都是 512*512，那么在获取每个 pixel 对应 texel 值时，刚好就能得到整数的纹理坐标，只需要每个 texel 逐个读取即可，不用考虑什么采样与重建。

但这毕竟只是一种特殊情况，实际中，我们会面临纹理过大或者过小两种情况。分两种情况来讨论：

1.  纹理分辨率过小，需要放大 (Magnification)

2. 纹理分辨率过大，需要缩小 (Minification)

![](<images/1684548373808.png>)

**1. 放大 (Magnification)**

假设我们只有 40*40 的纹理，却要贴到 256*256 大小的画布上去，好比是一个上采样的过程，关于此理论可见专栏的另一篇文章[《采样理论》](https://zhuanlan.zhihu.com/p/361383661)

![](<images/1684548373888.png>)

上采样涉及到重建和采样，重建时需要选择滤波器 (filter)，此前我们讲了三种滤波器：

![](<images/1684548373939.png>)

类似的，在纹理采样中也有三种技术：

1) 最邻近采样 (nearest neighbor)：类似 box 滤波器

2) 双线性采样 (bilinear)：类似 tent 滤波器

3) 三次卷积采样 (cubic convolution)：类似 sinc 滤波器的截断近似，因为 sinc 本身是最理想的滤波器，但是宽度是无限，无法实际使用

![](<images/1684548373975.png>)

用三种方法实施纹理采样的效果图如下：

![](<images/1684548374017.png>)

可以看到，三次卷积采样的效果最好。

下面介绍如何利用 GPU 的双线性插值特性，实现不同的上采样纹理插值：

比如我们得到了 p 点的纹理坐标 (pu,pv) = (5.9,4.2)，需要用周围四个点进行加权混合，得到 p 点的纹理值。有以下几个步骤：

1) 计算目标点 p 相对于周围四个点的位置，方法是加上 0.5 后保留小数，用范围为 [0,1] 的 (u',v') 表示

2) 选取插值函数 f，有多种函数可选择，计算横向和纵向插值的权重 (wu,wv)

3) 先后进行横纵两个方向的插值，所以称为双线性插值，得到最终纹理值 c_uv

![](<images/1684548374054.png>)

其中在计算权重 (wu,wv) 时，可以选择不同的函数 f：

1) box 函数对应于最邻近采样

2) linear 线性函数对应于双线性采样

3) smoothstep 和 quintic 则是对 sinc 函数的近似。注意前面所述的三次卷积采样也是对 sinc 函数的近似，但其计算量很大，所以不常被使用。

总结纹理放大的情况：将低分辨率的小纹理贴到高分辨率的画布上去时，对周围四个点的值进行混合，其混合权重由该点的纹理坐标以及权重函数决定，可以得到不错的效果。

**2. 缩小 (Minification)**

缩小：将高分辨率的纹理贴到低分辨率的画布，即一个 pixel 覆盖了多个 texel

从采样理论来看：我们把放大看作是上采样，那么缩小就看作是下采样。

根据奈奎斯特定理：**当采样频率大于信号最大频率 2 倍的时候，就可以不失真采样。**

一张纹理的最大频率可以是如下情况：一黑一白两个像素紧挨着，不断重复，此时的周期为 2，频率为 1/2，那么采样频率必须至少为 1 才能做到不走样，即 pixel 的个数至少要多于 texel 个数。这与缩小的情况相违背，所以缩小有可能走样。

从之前放大的解决思想来看：

是取最靠近 pixel 中心处单个 texel 的值（最近邻）？

还是取 pixel 中心处邻近四个 texel 的混合值呢（双线性）？

实际上，这两种方法都容易产生锯齿。因为在放大的情况进行混合时，只考虑了周围四个 texel 的值进行混合，而在缩小的情况中，一个 pixel 覆盖的 texel，个数往往不只 4 个。

既然走样产生了锯齿，那么就需要相应的抗锯齿技术。对于**纹理采样抗锯齿，其基本思路都是：对纹理进行预处理，建立一种数据结构，在采样时尽可能对 pixel 覆盖的 texel 区域的平均值进行估计**

此处介绍三种方法：**Mipmapping、Summed-Area Table、Anisotropic Filtering**

**1. Mipmapping**

这种方法很流行，其思想为：建立一系列不同尺寸的多级纹理，在纹理采样时，计算对应的细节级别，再用三线性插值 (Trilinear interpolation) 进行混合。

Mipmapping 分为两个阶段：建立和使用

**1） Mipmap 的建立**

Mipmap 中的多级纹理尺寸逐个减半，其建立取决于两个因素：

一是**滤波方式**，即从高分辨率纹理生成低分辨率纹理时，用哪种滤波函数，效果最差的是 box 滤波，好一点的则是如：Gaussian、Lanczos 等。

二是**伽马校正**，因为很多纹理是存储在 sRGB 非线性空间的，直接进行缩放会产生错误，所以在建立 Mipmap 时，需要先将纹理转到线性空间，进行缩放后，再转回 sRGB 空间。

如图建立了一系列 Mipmap，其中 d 代表细节级别，从下往上依次 d = 0,1,2 ... ：

![](<images/1684548374106.png>)

**2） Mipmap 的使用**

要使用 Mipmap，就要先确定用里面哪个级别的纹理去采样，也就是求出 d 值。

考虑以下情况，左图的一个 pixel 覆盖了多个 texel，在右图纹理空间展开为一个不规则四边形：

![](<images/1684548374148.png>)

一种确定 d 的方法是：求出右图中四边形最长边的长度，然后取 2 的对数，可以得到 d 的值，一般是个小数。也有求取 d 的其他方法，如：求纹理坐标对横纵两个方向差分的最大值，以替代最长边的长度。

然后再从 Mipmap 中选取刚好大于和小于 d 的相邻两级纹理，对两张纹理都进行双线性插值采样（前面放大情况中讲过），得到两个纹理值，然后根据 d 值，再进行一次线性插值，所以统称为三线性插值。

Mipmapping 的优缺点：

1） 优点：Mipmap 建立好后，占用内存固定，且使用时计算量固定

2） 缺点：各向同性，当同一个 pixel 在横纵方向覆盖的 texel 的个数不同时，却对横纵两个方向计算了相同的纹理细节等级。比如横向长度大于纵向，且由此确定了细节等级 d，那么纵向就会过度模糊。下面要讲的 SAT 技术解决了这个问题

**2. Summed-Area Table**

简称为 SAT ，是一种各项异性技术，其思想为：确定该 pixel 在纹理空间上覆盖 texel 区域四边形的轴向最小 包围盒 (Axis-Aligned Bound Box, AABB)，然后求取该包围盒的纹理值的平均值，作为该 pixel 的采样纹理值 c

如下图所示：

![](<images/1684548374183.png>)

此技术需要事先计算好和 texture 尺寸相同，但深度更深的一个数组，其中每个元素保存了当前位置与左下角形成的矩阵区域内所有纹理值的总和，所以此数组称为：Summed-Area Table，在使用时，不经过遍历累加，就可以算出纹理中任意 AABB 的纹理值总和。

SAT 技术用 AABB 去近似 pixel 覆盖的 texel 区域，可以预想，当该区域很狭长且沿对角线朝向时，误差会很大，会引起过度模糊：

![](<images/1684548374220.png>)

总结 SAT 技术的优缺点：

1） 优点：解决了横向和纵向过度模糊与抗锯齿的平衡问题

2） 缺点：SAT 纹理内存占用高；不能解决对角线方向的过度模糊问题

**3. 各向异性过滤 (Anisotropic Filtering)**

对比各项同性与各向异性：

**各向同性：对不同方向都采用相同的参数。**比如 Mipmap 中统一用长边来确定纹理等级，没有兼顾不同方向的 pixel 对 texel 的覆盖情况，就会导致某一个方向会过度模糊

**各项异性：对不同方向采用了不同的参数。**虽然 SAT 技术对于对角线方向处理不好，但是对于横向和纵向都求取了不同的 AABB，所以可以同时兼顾横纵两个方向

而各向异性过滤可以很好地解决各个方向上的过度模糊问题，由于大部分硬件都支持了 Mipmap 的特性，所以很多各向异性过滤技术也是依赖 Mipmap 算法进行改进的。

其中一种算法 Texram 是：沿着主方向增加采样点，再平均混合

![](<images/1684548374259.png>)

上左图的 pixel 覆盖的 texel 四边形如上右图所示：**四边形的短边用于确定 Mipmap 中的纹理等级，以避免过于模糊；四边形的长边确定主方向，长边与短边的比值确定沿主方向添加几个采样点**

比如：长边与短边的比值在 1~2 之间，就用两个采样点，采取和普通 Mipmap 相同的三线性插值后得到两个纹理值，再对两个纹理值平均混合可得到最终此 pixel 的纹理采样值。

游戏中的各向异性过滤常见的选项有 x4、x8 和 x16，此选项决定了在主方向最大采样点个数。比如当设置为 x4，但长边与短边的比值为 5 ，那么此时采样点也只能是 4 个。所以这个设置越大效果越好，但越耗性能。关于 Texram 算法具体实现可见 [[1]](https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=491183)

此外还有对多个采样点进行加权混合的方法，比如用 Gaussian 核进行处理，如 Feline 系统 [[2]](http://ronaldperry.org/FelineSig1999.pdf)

以及还有将四边形区域近似为椭圆形，然后设置椭圆形的核函数进行加权混合的方法，称之为 Elliptical Weighted Average(EWA)，可见 [[3]](https://d1wqtxts1xzle7.cloudfront.net/41190745/High_quality_elliptical_texture_filterin20160115-6094-yhylou.pdf?1452857365=&response-content-disposition=inline%3B+filename%3DHigh_quality_elliptical_texture_filterin.pdf&Expires=1620230025&Signature=YgWpsv2lE3Dh1WccDoREqxe62F-00eX4p3Zmo9B~ZbPgszDgPuOyNkEWN3vdm0ntUaRqLay60xWkN339nTbSwsLTThjA-G9HVaGCoR6aL5-UwsNuXgEZKx0imW~~ZCzWYQRg6L2Cx5IzmPGTjGmWlwcjSyHygyWWoDvrYBKPxIJJx20S9-xtaMJVXzX~S4~wfhtkMGCUy2CoA2~nJFDqWbkFdNzna888WAFXw8EHhqRMQC0P02-PsbEutF7X5~quJplbflu4JgdRMQH4-QcvyEau-SPdOSsl2pdzd9RyruUQaIJmxKoA~yTudzWqJhK79Qbsc4HSq32C1oDbm56BCQ__&Key-Pair-Id=APKAJLOHF5GGSLRBV4ZA)

对于纹理缩小的情况，下图对比了几种不同采样方式的效果：

![](<images/1684548374294.png>)

## 四、纹理转换

在通过纹理采样获取纹理值后，并不一定直接将纹理值作为颜色使用，还有其他用途，如在 Normal Mapping 中当作法向量使用，在 Bump Mapping 中当作高度偏移使用，所以还需要对纹理值进行相应的转换，具体的转换方式在后文给出纹理映射具体应用时再细讲。

总结一下纹理映射的流程：

![](<images/1684548374328.png>)

1） 投影映射：将三维物体坐标转化为二维参数空间 uv 坐标，实时渲染中，uv 坐标通常是保存在顶点信息中

2） 变换函数：将 uv 坐标经过处理变换后，根据实际的纹理尺寸，转化为纹理空间坐标，此时也可能有小数

3） 纹理采样：依据纹理空间坐标，对纹理进行采样，要处理放大和缩小两个情况，其中缩小的情况更为复杂，牵涉到各向异性过滤的算法

4） 纹理转换：通过采样得到纹理值后，往往不能直接使用，还需要进行相应转换才能使用

本文对纹理映射的大致流程进行了梳理，可以看到纹理映射的主要难点有两个：

一是投影映射的过程，很难有好的方法将三维空间坐标与二维 uv 坐标对应起来，往往需要建模师手动调节；

二是纹理采样的过程，特别是在纹理缩小的时候，容易产生锯齿，需要良好的纹理采样抗锯齿算法。

下文[《纹理映射盘点》](https://zhuanlan.zhihu.com/p/370927083)将介绍一些经典的纹理映射的应用，如法线贴图、凹凸贴图、材质贴图、置换贴图等技术。希望能和大家共同学习进步！

## References :

[1] [Texram: A Smart Memory for Texturing](https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=491183)

[2] [Feline: Fast Elliptical Lines for Anisotropic Texture Mapping](http://ronaldperry.org/FelineSig1999.pdf)

[3] [High Quality Elliptical Texture Filtering on GPU](https://d1wqtxts1xzle7.cloudfront.net/41190745/High_quality_elliptical_texture_filterin20160115-6094-yhylou.pdf?1452857365=&response-content-disposition=inline%3B+filename%3DHigh_quality_elliptical_texture_filterin.pdf&Expires=1620230025&Signature=YgWpsv2lE3Dh1WccDoREqxe62F-00eX4p3Zmo9B~ZbPgszDgPuOyNkEWN3vdm0ntUaRqLay60xWkN339nTbSwsLTThjA-G9HVaGCoR6aL5-UwsNuXgEZKx0imW~~ZCzWYQRg6L2Cx5IzmPGTjGmWlwcjSyHygyWWoDvrYBKPxIJJx20S9-xtaMJVXzX~S4~wfhtkMGCUy2CoA2~nJFDqWbkFdNzna888WAFXw8EHhqRMQC0P02-PsbEutF7X5~quJplbflu4JgdRMQH4-QcvyEau-SPdOSsl2pdzd9RyruUQaIJmxKoA~yTudzWqJhK79Qbsc4HSq32C1oDbm56BCQ__&Key-Pair-Id=APKAJLOHF5GGSLRBV4ZA)