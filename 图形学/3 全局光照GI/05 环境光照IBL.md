
---
title: 05 环境光照IBL
aliases: []
tags: []
create_time: 2023-07-14 14:58
uid: 202307141458
banner: "![[Pasted image 20230714145946.png]]"
---
# 环境光照原理
环境光照就是在场景中任意一点往四周看去可看到的光照（距离视为无限远）, 将其记录在一张图上存储。也叫做 **IBL (image-based lighing)**。
通常我们用 Spherical Map 和 Cube Map 来存储环境光照。

如果已知环境光照, 此时放置一个物体在场景中间, 在**不考虑阴影**时我们该如何去得到任何一物体上着色点的 shading 值呢?
- @ **首先要先来看渲染方程**
$$L_o(p,\omega_o) = \int\limits_{\Omega} f_r(p,\omega_i,\omega_o) L_i(p,\omega_i) n \cdot \omega_i d\omega_i$$
通用的解法是使用**蒙特卡洛积分**去解, 但是蒙特卡洛需要大量的样本才能让得出的结果足够接近, 如果我们对每个 shading point 都做一遍蒙特卡洛积分，那样的话太慢了。

- @ **如何避免采样?**
**通过预滤波和预计算，完全避免采样！**

**brdf 分为两种情况:**
1.  brdf 为 glossy 时, lobe 覆盖在球面上的范围很小
2.  brdf 为 diffuse 时, lobe 会覆盖整个半球的区域，在积分域内变化不大
![[Pasted image 20230714130125.png]]

此时应该想到了我们之前讲的渲染方程近似公式:
[[02 PBR理论#渲染方程不等式近似]]
$$
\int_\Omega f(x)g(x)\mathrm{~d}x\approx\frac{\int_\Omega f(x)\mathrm{~d}x}{\int_\Omega\mathrm{~d}x}\cdot\int_\Omega g(x)\mathrm{~d}x
$$
![[02 PBR理论#^ptjnu8]]

由于  $f_r$  项作为 $g(x)$ 正好满足这个条件, 即 small support 或 Smooth integrand, 从而我们将渲染方程的 $L_i$ 项作为 $f(x)$ ，方程可拆分为两部分，这种方法称为 `Split Intergral` ： ^x7aaaa
$$
L_o(p,\omega_o)\approx\boxed{\frac{\int_{\Omega_{f_{r}}}L_i(p,\omega_i)\mathrm{~d}\omega_i}{\int_{\Omega_{f_r}}\mathrm{~d}\omega_i}}\cdot\int_{\Omega^+}f_r(p,\omega_i,\omega_o)\cos\theta_i\mathrm{~d}\omega_i
$$

> [!NOTE] 实时渲染：Split Sum
> 
> 在实时渲染中，为了追求速度通常不会求积分，而是转换成求和，上述拆分方法用**求和式**描述如下：
> $$
> \boxed{\frac1N\sum_{k=1}^N\frac{L_i(\mathbf{l}_k)f(\mathbf{l}_k,\mathbf{v})\cos\theta_{\mathbf{l}_k}}{p(\mathbf{l}_k,\mathbf{v})}\approx\left(\frac1N\sum_{k=1}^NL_i(\mathbf{l}_k)\right)\left(\frac1N\sum_{k=1}^N\frac{f(\mathbf{l}_k,\mathbf{v})\cos\theta_{\mathbf{l}_k}}{p(\mathbf{l}_k,\mathbf{v})}\right)}
> $$
> 这种方法称为 `Split Sum`，且结果和直接采用差异不大：
![[Pasted image 20230714143656.png]]
>

**下文为了讲述了 `Split Intergral` 方法的原理与推导，`Split Sum` 方法的原理与之类似**

## 第一部分：预滤波

**把 $L_i$ 项拆分出来, 然后将 brdf 范围内的 $L_i$ 积分起来并进行 normalize, 其实就是将 IBL 这张图给模糊了（即使用卷积核模糊图像）**

模糊就是在任何一点上取周围一片范围求出范围内的平均值并将平均值写回这个点上, 滤波核取多大取决于 BRDF 占多大, BRDF 的区域越大, 最后取得的图也就越模糊.

**环境光照的预滤波：**
- 预生成一组滤波核不同的环境光照滤波器（类似 mipmap），当我们需要使用时直接查询即可
- 其他滤波核尺寸的图可以通过 [[04 纹理#^s6etys|三线性插值]] 来近似。
![[Pasted image 20230714135052.png]]

- ? 拆分就是为了做一个 Pre-filtering, 那么做 pre-filtering 是为了干什么?
![[Pasted image 20230714135944.png]]
左图为 brdf 求 shading point 值时, 我们要以一定立体角的范围内进行多次采样再加权平均从而求出 shading point 的值.

反过来思考，如右图，对环境光照做 pre-filtering。这样图上任何一点都是周围范围内的加权平均值，**只需要查询一次 IBL图** 就能得到和多次采样加权平均相同的结果，不需要多次采样！

## 第二部分：预计算

到此我们解决了拆分后的前半部分积分采样的问题, 那么接下来我们处理 BRDF 项采样的问题：
$$
L_o(p,\omega_o)\approx\frac{\int_{\Omega_{fr}}L_i(p,\omega_i)\mathrm{d}\omega_i}{\int_{\Omega_{fr}}\mathrm{d}\omega_i}\cdot\boxed{\int_{\Omega^+}f_r(p,\omega_i,\omega_o)\cos\theta_i\mathrm{d}\omega_i}
$$
**如何避免采样？**
- % 接下来讲的方法并不是最优方法, 主要是为了学习方法背后的思想.

**仍然可以用预计算来解决后半部分积分采样的问题**, 但是预计算的话我们需要将参数的所有可能性均考虑进去, 但是比较多，包括 roughness、color 等。考虑所有参数的话我们需要打印出一张五维或者更高的表格, 这样会拥有爆炸的存储量, 因此**我们需要想办法降低维度, 也就是减少参数量从而实现预计算。**

---

在 BRDF 中，考虑的是 DFG 项，由于此时暂时不考虑阴影，此处需要关注的是 F 项和 D 项。
![[Pasted image 20230714142406.png]] 


- F 项可以近似成一个和基础反射率 $R_0$ 、观察角度 $\theta$ 相关的**指数函数**
- 法线发布函数（NDF）是一个一维的分布，其中有两个变量：
    1. 粗糙度 $\alpha$，定义材质是 diffuse 还是 gloosy
    2.  half vector 和法线中间的夹角，可以**近似成和观察角度 $\theta$ 相关的数**

---

至此我们有了三个变量: 基础反射率 $R_0$, 粗糙度 $\alpha$ 和观察角度 $\theta$ , 三维的预计算仍然是一个存储量爆炸的结果, 因此我们还要想办法减少参数量.

所以我们通过将 Schlick 近似带入后半部分的积分中：

$$
\begin{aligned}
\begin{aligned}\int_{\Omega^+}f_r(p,\omega_i,\omega_o)\cos\theta_i\mathrm{d}\omega_i\end{aligned}& \begin{aligned}\approx&R_0\int_{\Omega^+}\frac{f_r}{F}\left(1-(1-\cos\theta_i)^5\right)\cos\theta_i\mathrm{d}\omega_i+\end{aligned}  \\
&\int_{\Omega^+}\frac{f_r}F(1-\cos\theta_i)^5\cos\theta_i\mathrm{d}\omega_i
\end{aligned}
$$

**基础反射率 $R_0$ 被拆出积分式，需要预计算的两个量就只有粗糙度粗糙度 $\alpha$ 和角度 $\theta$，可以将预计算结果绘制成一张 2D 纹理（横轴为 $\cos\theta_v$，纵轴为粗糙度），在使用时进行查询即可。不需要采样！**
![[Pasted image 20230714143534.png|400]]

# 环境光照阴影
主要内容：**在环境光照下利用 sh 计算出 diffuse 物体的 shading 和 shadow**

我们在上节课讲述了如何不采样去计算不考虑 shadow 时的 shading 值, 那么如果考虑阴影，如何去得到物体在环境光照射下生成的阴影呢?

环境光照阴影对实时渲染来说是很困难的, 可以从两个角度考虑:
1. **Many Light 问题**：我们把环境光理解为很多个小的光源, 这种情况下去生成阴影的话, 需要在每个小光源下生成 shadow map, 因此会生成线性于光源数量的 shadow map, 这是十分高昂的代价。
2. **Sampling 问题**：在任何一个 shading point 上已知来自正半球方向的光照去解渲染方程, 最简单的方法是采样空间中各方向上的不同光照, 可以做重要性采样, 虽然做了重要性采样但仍需要大量的样本, 因为最困难的是可见性测试项 $V_i (p,\omega _i)$ 。由于 Shading point 不同方向上的遮挡是不相同的, 我们可以对环境光照进行重要性采样, 但一个 Shading point 周围的遮挡情况是未知的，因此我们只能盲目的去采样 (我个人对盲目采样的理解是, 为了确保准确性需要对 sp 各个方向的遮挡进行采样, 因此仍然会生成大量的样本)。我们也无法提取出  $V_i (p,\omega _i)$  项, 因为如果是 glossy brdf, 他是一个高频的, 且 $L_i$ 项的积分域是整个半球, 因此并不满足 smooth 或 small support, 因此无法提取出   $V_i (p,\omega _i)$  项.

**在工业界中, 我们通常以环境光中最亮的那个作为主要光源, 也就是太阳, 只生成太阳为光源的 shadow。**

下面是几篇关于生成阴影的文章: ![[Pasted image 20230714151259.png]]
1. 做的是全局光照部分产生的 shadow.
2. 解决的是离线渲染中的 many lights 的问题, 核心思想是把反射物当成小光源, 把所有的小光源做一下归类并近似出照射的结果.
3. Real Time Ray Tracing, 可能是最终解决方案.
4. **PRT 可以十分准确的得到来自环境光中的阴影.**

但是我们知道世上没有十全十美的事情,

**那么.... 古尔丹, 代价是什么呢?**

## 信号知识

回顾一下， [[02 光栅化#信号基础]]
这里我们要理解一个思想：
**两个函数相乘再做积分**（product integral）可以看作是一个滤波操作（卷积操作）：
$$
\int_{\Omega}f(x)g(x)\operatorname{d}x
$$

- 可以理解为空间域上的两个信号 $f (x)$ 和 $g (x)$ 进行一个卷积, 等于在频域上让两个信号相乘，如果两个信号有一个信号是低频的, 那么频域上相乘后得到的结果也是低频的, 最终相乘在积分的结果也是低频的, 可以总结为：**积分之后的频率取决于积分前最低的频率。**
- 低频意味着函数更加地 smooth 或者有着 slow 的变化。

## Basis Functions
基函数（Basis Functions）：通常可以用来表示其他函数的一组函数
$$
f(x)=\sum_ic_i\cdot B_i(x)
$$
- 傅里叶级数是一组基函数
- 多项式级数也可以是一组基函数

## Spherical Harmonics (球谐函数)
### 定义

回归正题, 我们要讨论的是如何在环境光照下生成阴影, 先从最简单的开始, 如果给了你环境光和一个 diffuse 的物体, 在不考虑 Shadow 的情况下如何去计算 shading 值?

为了计算 shading 值, 我们引入数学工具 ----->Spherical Harmonics (球谐函数)

**在游戏渲染中, SH 有很多应用. 比如 SH 可以用来表示低频部分的环境光照, 也可以用来提供 light probe 的烘培光照等等...**

- @ **SH 是一系列定义在球面上的 2D 基函数 $B_{i}(\omega)$** ，表示球面不同方向上的属性。
1. 它是一系列的基函数，类似于一维的傅里叶函数, 与里面不同频率的 cos 和 sin 函数类似, 只是全都是二维函数。**这些 2D 函数有不同的频率。不同频率的函数个数也不同, 频率越高所含有的基函数越多。**
2. 因为它是定义在球面上的，球面上会有不同的值, **由于在球面上两个角度 $\theta$ 和 $\varphi$ 就可以确定一个方向了, 因此可以理解为是对方向的函数**, 通过两个角度变量从而知道这一方向**对应在球面上的值**。
>三维空间的方向可以表示为一个二维函数，因为由两个角度 $\theta$ 和 $\varphi$ 就可以确定一个方向。


![[Pasted image 20230714160043.png]]
>SH 的可视化
> $l$ ：阶数，通常第 $l$ 阶有 $2l+1$ 个基函数，前 $n$ 阶有 $n^2$ 个基函数。每一阶中的函数频率相同
> $m$ ：在某一个频率下基函数的序号，分别从从 $-l$ 一直到 $l$。


> [!question] 为什么不直接使用 $\theta$ 和 $\varphi$ 的 2D 函数做傅里叶变换来分析属性？而是使用球谐函数？
> 经过傅里叶变换可能在球面上有不连续的现象，而球谐函数本身就定义在球面上，生成的结果是连续的。
> 

每个基函数都有一个比较复杂的数学表示，对应一个 $legendre$ 多项式，我们不用去了解 $legendre$ 多项式, 我们只需要知道基函数是 $B_i(\omega)$, 可以被某些数学公式来定义不同方向的值是多少就可以了.
- 图中的颜色表示的是值的大小, l=0 中, 越偏白的蓝色地方值越大, 越黑的地方值越小. 而黄色中则表示偏白的地方表示其绝对值大, 偏黑的地方表示绝对值小。也就是蓝色表示正, 黄色表示负.
- 频率表示的就是值的变化, 因此可以很清晰的从形状看出.

### 投影：得到每个 SH 基函数的系数
**投影**：由于一个函数 $f(w)$ 可以由一系列基函数和系数的线性组合表示，那么怎么确定基函数前面的系数，这就需要通过投影操作：

![[9b5ab4dc8a9a6e5932b54184ad5cdf2b_MD5.png]]
$$
c_i=\int_{\Omega}f(\omega)B_i(\omega)\mathrm{~d}\omega 
$$
我们知道函数 F (X), 通过对应的基函数 B (i) 进行投影操作, 从而求出各基函数对应的系数 Ci, 与以下操作是同一个道理, 在空间中想描述一个向量，可以 xyz 三个坐标来表达，把 xyz 轴当做三个基函数，把向量投影到 xyz 轴上，得到三个系数就是三个坐标。

**重建**：知道基函数对应的系数，就能用系数和基函数恢复原来的函数。

由于基函数的阶可以是无限个的，越高的阶可恢复的细节就越好, 但一方面是因为更多的系数会带来更大的存储压力、计算压力，而一般描述变化比较平滑的环境漫反射部分，用 3 阶 SH 就足够了；另一方面则是因为 SH 的物理含义不是特别好理解，高阶 SH 容易出现各种花式 Artifact，美术同学一般都会认为这种表现属于 bug。

![[b15f86554f983e68bab406f7fbafc308_MD5.png]]

f (w) 可以是任何一个函数, 我们说过基函数可以重建任何一个球面函数, 那么我们这里的 f (w) 就是环境光照, 由于环境光是来自于四面八方且都有值, 所以环境光照就是一个球面函数,, 我们可以把它投影到任何一个 SH basis 上, 可以投影很多阶, 但是只需要取前三阶的 SH 去恢复环境光就可以恢复出最低频的细节了, 这个在下文 RAVI 教授的结论有提到.

这里补充一些球谐函数的性质：

**正交性: 能够较简单地投影 / 重建、simple rotation。**

![[59c7f34ea00747d2bff2cc9810869a27_MD5.jpg]]

旋转是一个很重要的性质：**旋转一个基函数之后，得到的函数就不再是一个基函数 (因为基函数有严格的朝向等限制)，但是旋转球谐函数等价于同阶基函数的线性组合。**

Ravi 教授等人在 01 年左右做过一些实验发现，diffuse BRDF 类似于一个低通滤波器，使用一些低频信息就可以恢复出原始内容。回忆一下，在本文之前的内容中曾说过：“**积分之后的频率取决于积分前最低的频率**”，当 diffuse BRDF 使用低频信息即可恢复内容时，也就意味着无论光照项是多么复杂，其本应该用多高频的基函数去表示，但我们希望得到的是其与 BRDF 之积的积分，所以可以使用比较低频的基函数去描述灯光。下面的实验结果意味着，遇到 diffuse 的物体时使用前 3 阶的球谐基函数就可以基本重建出正确率 99% 的结果，

![[24033880a0d3128f91fb6265fe26eeb7_MD5.jpg]]

## 到目前为止，这里只解决了如何根据环境光照进行 shading，主要说明球谐函数的作用，仍没考虑 shadow 问题，接下来我们要解决两个问题:

1. 将 shadow 考虑进去

2. 我们仍然用基函数思路去考虑任何的 brdf.

解决的思路就是 prt, 接下来我们进入 prt 学习:

## **_PRT_**

在实施渲染中, 我们把 rendering equation 写成由三部分组成的积分:

![[7ee830d85fcd905a0126e542ef05fe3f_MD5.jpg]]

光照项, visibility 项和 brdf 项, 这三项都可以描绘成球面函数, 这里用的是 cube map 描述法, 那么最简单的解这个方程的方法就是每个像素挨个去乘, 假设环境光是 $6*64*64$ 的 map，对于每个 shading point 来说，计算 shading 需要计算 $6*64*64$ 次。这个开销是十分大的.

因此我们利用基函数的基本原理把一些东西先预计算出来, 从而节省开销.

![[d642b5d298cbf75505c8a82556d29123_MD5.jpg]]

PRT 的基本思想:

我们把 rendering equation 分为两部分, lighting 和 light transport.

假设在渲染时场景中只有 lighting 项会发生变化 (旋转, 更换光照等), 由于 lighting 是一个球面函数, 因此可以用基函数来表示, 在预计算阶段计算出 lighting.

而 light transport (visibility 和 brdf) 是不变的, 因此相当于对任一 shading point 来说, light transport 项固定的, 可以认为是 shading point 自己的性质, light transport 总体来说还是一个球面函数, 因此也可以写成基函数形式, 是可以预计算出的.

我们分为两种情况, diffuse 和 glossy:

Diffuse:

![[02c9e45220740f040102b09f0c30f364_MD5.jpg]]

由于在 diffuse 情况下, brdf 几乎是一个常数, 因此我们把 brdf 提到外面.

![[e90920cad0aad1fe5dc6f14bd3769ab7_MD5.jpg]]

由于 lighting 项可以写成基函数的形式, 因此我们求和式把其代入积分中, 对于任何一个积分来说, 在 Bi 的限制下, li 此对积分来说是常数, 可以提出来.

![[72b3d9a0b6421ba178dc0dc620ddc3ad_MD5.jpg]]

对于积分中的部分来说, Bi 是基函数, v 和 cos 项在一起不就是 light transport 吗, 那不就是 light transport 乘与一个基函数，这就成了 lighting transport 投影到一个基函数的系数，接下来代入不就能进行预计算了吗，这样就只要算一个点乘就好了。

之所以说是点乘, 结果是个求和, 我们要计算 $l_{1}T_{1}$ + $l_{2}T_{2}$ +......, 不正好相当于两个向量点乘吗.

所以对于任何一个 shading point 我们去算他的 shading 和 shadow, 只需要计算一个点乘就可以了, 十分方便,

## **_但是, 没有东西是十全十美的, 那么, 古尔丹, 这次的代价又是什么呢?_**

**1. light transport 做了预计算, 因此 visibility 当了常量, 因此场景不能动, 因此只能对静止物体进行计算.**

**2. 对于预计算的光源我们把它投影到 sh 上, 如果光源发生了旋转, 那不就相当于换了个光源吗?**

**但是第二个问题由于 sh 函数的旋转不变性可以完美的解决.**

**旋转光照 = 旋转 SH 的基函数**

**但任何一个 SH 基函数旋转后都可以被同阶的 SH 基函数线性组合表示出来**

**因此, 我们根据这个性质, 还是可以立刻得出旋转后的 sh 基函数新的线性组合.**

![[986aa8a613afeb994058511f44609393_MD5.jpg]]

![[fefa799691c3c55319cb2d9de96efb06_MD5.jpg]]

用的阶数越多越接近与原始函数, 第四张图是前 26 阶函数去重建原始函数, 可以看到效果还不错. 但我们在使用时用不到那么多阶.

![[feac22b70bc7dc4a5e5de68a45eae604_MD5.jpg]]

我们将 lighting 这个球面函数, 通过 SH 的基函数用一堆系数来表示, 这些系数排成一行也就是组成了向量, 因此光照变成了一个向量.

如果要重建原函数则只需要把这些系数乘以对应的基函数再加在一起即可.

![[1b95c21b053249c9221814cb0190b315_MD5.jpg]]

我们可以把 Bi 理解为 lighting, 也就是说每个 basis 所描述的环境光去照亮这个物体从而得到照亮之后的结果, 我个人理解预计算就是把每个 basis 照亮得到的结果生成.

![[c97c488484872a02fea1e3365b32d170_MD5.jpg]]

最后我们在计算 shading 和 shadow 时只需要进行向量 li 和 ti 的点乘即可得到结果.

到此我们知道了如何再已知环境光的情况下, 通过使用 PRT 来计算出 diffuse 物体的 shading 和 Shadow 了.

下节课我们讲关于 glossy 和全局光照.