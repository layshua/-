# 链接 ComputeShader 和后处理框架
创建**RayTracingShader.cs**
```cs
// Each #kernel tells which function to compile; you can have many kernels  
#pragma kernel CSMain  
  
// Create a RenderTexture with enableRandomWrite flag and set it  
// with cs.SetTexture  
RWTexture2D<float4> Result;  
  
[numthreads(8,8,1)]  
void CSMain (uint3 id : SV_DispatchThreadID)  
{  
// TODO: insert actual code here!  
  
Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);  
}
```

创建，**RayTracingPass.cs**。
没有找到如何在 volume 面板上公开 Computeshader 类型的变量，所以直接传给脚本即可：
![[Pasted image 20230711170341.png]]

```cs
using System;
using UnityEngine;
using UnityEngine.Experimental.Rendering;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;
using UnityEngine.Serialization;

[Serializable, VolumeComponentMenuForRenderPipeline("Custom Post-processing/Ray Tracing", typeof(UniversalRenderPipeline))]
public class RayTracingPass : CustomPostProcessingManager
{
    //ComputeShader相关
    //public ComputeShader rayTracingShader;
    public ComputeShader rayTracingShader;
    // private Material m_ScreenMaterial;
    // private const string ScreenShaderName = "Unlit/Texture";
    private RenderTexture m_Target;
    private int m_KernelIndex;
    
    //Pass插入点
    public override PassInjectionPoint passInjectionPoint => PassInjectionPoint.BeforeRenderingPostProcessing;
    
    //在Pass内的排序
    public override int orderInPass => 2;
    
    //激活状态
    public override bool IsActive() => rayTracingShader != null;
    
    //配置
    public override void Setup()
    {
        //创建一张和屏幕大小一样的RT
        if (m_Target == null||m_Target.width!=Screen.width||m_Target.height!=Screen.height)
        {
            if (m_Target != null)
                m_Target.Release();
            
            m_Target = new RenderTexture(Screen.width,Screen.height,0,RenderTextureFormat.ARGBFloat,RenderTextureReadWrite.Linear);
            //RWTexture为UAV类型，支持无序(随机）访问读写操作
            m_Target.enableRandomWrite = true; 
            m_Target.Create();
        }
        
    }
    
    //渲染
    public override void Render(CommandBuffer cmd, ref RenderingData renderingData, RTHandle source, RTHandle destination)
    {
        if (m_Target == null)
            return;
        
        //核函数索引
        m_KernelIndex = rayTracingShader.FindKernel("CSMain");
        
        //RT设置到核函数的RWTexture2D中
        rayTracingShader.SetTexture(m_KernelIndex,"Result",m_Target);

        int threadGrouphsX = Mathf.CeilToInt(Screen.width / 8.0f);
        int threadGrouphsY = Mathf.CeilToInt(Screen.height / 8.0f);
        
        //调度线程组，执行核函数
        rayTracingShader.Dispatch(m_KernelIndex, threadGrouphsX, threadGrouphsY, 1);
        
        //进行屏幕绘制
        cmd.Blit(m_Target,destination);
    }
    
    //释放资源
    public override void Dispose(bool disposing)
    {
        base.Dispose(disposing);
        CoreUtils.Destroy(m_Target);
    }
}
```

绘制下图：
![[Pasted image 20230711170202.png]]

# 射线