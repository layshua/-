# 5.1 PBR
[[技术美术/PBR/PBR白皮书/content/1 .PBR总览/README]]
![[TA101_PBR_6.jpg]]
![[TA101_PBR_7.jpg]]
![[TA101_PBR_9.jpg]]
![[TA101_PBR_10.jpg]]
![[TA101_PBR_11.jpg]]


![[Pasted image 20221029160325.png]]
![[Pasted image 20221029160335.png]]
![[Pasted image 20221029160340.png]]

![[Pasted image 20221029160350.png]]

BRDF就是为了解决上述问题
![[Pasted image 20221029160441.png]]
### 5.1.1 经验模型
![[Pasted image 20221029160631.png]]
![[Pasted image 20221029160641.png]]

## 5.1.1 基于物理的材质（BRDF计算）
**ks+kd = 1**
![[Pasted image 20221101211702.png]]
![[Pasted image 20221101211713.png]]
![[Pasted image 20221102144938.png]]
### 直接光（主光）
#### BRDF
![[Pasted image 20221101211851.png]]
![[Pasted image 20221029161107.png]]
![[Pasted image 20221101211935.png]]
**注意：
直接光数量有限，计算直接光将光照结果相加
间接光数量无限，计算间接光要用积分算所有的**
![[Pasted image 20221102172101.png]]
```c
/*  直接光（主光） */
// Cook-Torrance BRDF  
// 漫反射部分  
float3 Ks = F_FrenelSchlick(VH, F0); //菲涅尔描述了光被反射的比例  
float3 Kd = (1-Ks) * (1 - Metallic);  
//float3 Diffuse = Kd * BaseColor / PI;  
float3 Diffuse = Kd * BaseColor; //没有除以 PI, 颜色亮一些  
  
// 高光反射部分  
float D = D_DistributionGGX(N, H, Roughness);  
float3 F = Ks;   
float G = G_Smith(N, V, L, Roughness);  
float3 Specular = D * F * G / max(0.0001, 4 * NV * NL);
```
#### D法线分布函数
法线分布函数描述的是微表面的法线方向与半角向量对齐的概率，如果对齐那么认为该反射光可以被看到，否则没有。

GGX：
![[Pasted image 20221029161311.png]]

```c
float D_DistributionGGX(float3 N, float3 H, float Roughness)
{
		float a = Roughness * Roughness;
		float a2 = a * a;  //为什么取a的四次方，这里是参考的ue4，也可以使用a的二次方进行计算
		float NH = max(0, dot(N,H));
		float NH2 = NH * NH;
		float nominator = a2; //分子
		float denominator = (NH2*(a2-1.0)+1.0);  //分母
		denominator = PI * denominator * denominator;  
		
		return nominator / max(0.00001, denominator);  //防止分母为0
}
```

![[Pasted image 20221101212846.png]]

#### G几何（遮蔽）函数
![[Pasted image 20221029161443.png]]
![[Pasted image 20221101214734.png]]
![[Pasted image 20221101214916.png]]

```c
//G_SchlickGGX  
float G_SchlickGGX(float NV, float Roughness)  
{  
    float a = Roughness + 1.0;  
    float k = a * a / 8.0;  //直接光  
    float nominator = NV;  
    float denominator = NV * (1.0 - k) + k;  
    
    return nominator / max(0.00001, denominator); //防止分母为0    
 }  
 
//G_Smith  
float G_Smith(float3 N, float3 V, float3 L, float Roughness)  
{  
    float NV = max(0, dot(N,V));  
    float NL = max(0, dot(N,L));  
    
    float GGX1 = G_SchlickGGX(NV, Roughness);  
    float GGX2 = G_SchlickGGX(NL,Roughness);  
  
    return GGX1 * GGX2;  
}
```

![[Pasted image 20221101215517.png]]
#### F菲涅尔方程
我不是科学家，没必要公式都会推，会用就可以！
![[Pasted image 20221101213118.png]]
![[Pasted image 20221029161549.png]]
![[Pasted image 20221101213507.png]]
n代表介质的折射率，1为空气的折射率
**v·h或v·n都可以，有两种形式，这里我才用毛星云白皮书里提到的v·h的方法。**
**非金属的FO数值较小，金属FO的数值较大，出于简化计算的原因，通过金属度在一个预设的FO和自身颜色之间经行插值。**

```c
//F
float3 F0 = lerp(0.04, BaseColor, Metallic);

float3 F_FresnelSchlick(float VH, float3 F0)
{
		return F0 + (1 - F0) * pow(1 - VH, 5);
		 
}
```

![[Pasted image 20221101214427.png]]

**真实材质F0数值表参考：**![[PBR-Material-F0-Quick-Reference-Chart.png]]
#### 代码
![[TA101_PBR_36.jpg]]
### 间接光（环境光）
#### 漫反射
前面提到：
直接光数量有限，计算直接光将光照结果相加
间接光数量无限，计算间接光要用积分算所有的

由于实时渲染中机器算力不足，我们通常需要对间接光进行预处理，这里使用到了**IBL**，近似出间接光。
![[Pasted image 20221101220611.png]]
![[Pasted image 20221101220920.png]]
![[Pasted image 20221101221123.png]]
![[Pasted image 20221101221141.png]]
##### 辐照度贴图 irradiance

![[Pasted image 20221101221323.png]]
1. 为什么选择法线所在半球？
因为法线只朝上，不会对下面区域造成影响。
2. 自定义采样数量，并不是采样所有点，开销太大。
![[Pasted image 20221101221538.png]]
##### 球谐函数 Spherical Harmonics

辐照度贴图是固定的，如果游戏中有多个场景，比如室内室外那么肯定是不能为每一个场景都单独弄一个辐照度贴图的，会消耗大量内存。**游戏引擎中使用LightProbe放置在场景中，去近似采样并存储以该LightProbe为中心的“辐照度贴图"，但不是单独存一张贴图，而是用球协函数存储相应的信息，最终存储的是球协函数的参数,通常是9个float**,这比单独存一张贴图节省多了。
在Unity中放置LightProbe，并且烘培后，使用`ShadeSH9`函数即可获取当前的点的"辐照度"。
[Unity中Light Probe详解 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/38550884)
![[Pasted image 20221101223730.png]]

![[Pasted image 20221101222402.png]]
![[Pasted image 20221101222827.png]]
**HDR图下载**：[HDRIs • Poly Haven](https://polyhaven.com/hdris)

#### 镜面反射
![[Pasted image 20221101223143.png]]
##### PartOne
对于高光部分而言，如果材质表面越光滑，则该点出射光大部分贡献来源于入射光的镜面反射，很小一部分来源于各个方向的漫反射。所以，这次**我们在计算积分的时候，需要把<font color="#ff0000">粗糙度</font>也考虑进去**。
**如果粗糙度越低，那么积分的贡献范围就越集中，相当于卷积核的面积越小，大权重集中在核中心，卷积结果尺寸越大，产生越清晰的反射效果。反之亦然。**
![[Pasted image 20221101223443.png]]
可以根据材质的粗糙度，映射到某个粗糙度区间，然后把计算结果保存到不同的LOD等级中(Unity默认6级)。这张具有不同LOD等级的立方体贴图也称为**pre-filtered environment map**。
![[Pasted image 20221101223523.png]]

![[Pasted image 20221101224230.png]]
###### 反射探针 ReflectionProbe
![[Pasted image 20221101224526.png]]
各轴互相垂直，为什么垂直：4 x 90 = 360
![[Pasted image 20221101224717.png]]
##### PartTwo
![[Pasted image 20221101225517.png]]
同样受硬件限制，我们需要进行预处，有两种方法。
- **BRDF LUT**，将原公式结果离线生成出来。
- **数值拟合**
###### BRDF LUT

LUT：Look Up Table  查找表
假设每个方向的入射光都是白色的【L(p,x)= 1.0】，就可以在给定粗糙度，光线wi法线n夹角n·wi的情况，预计算BRDF的响应结果。以x轴的法线与入射光的夹角（NL01），以Y轴为粗糙度，将计算的结果存储在一张2D贴图上（lut），该帖图称为为**BRDF积分贴图**。积分的结果分别储存在贴图的**RG通道**中。使用的时候直接采样该帖图即可。
![[Pasted image 20221101234002.png|300]]


![[Pasted image 20221101233948.png]]
>参考： https://www.gamedevs.org/uploads/real-shading-in-unreal-engine-4.pdf
###### F的计算 与 引入粗糙度的菲涅尔
- **间接光代码中的菲涅尔系数计算和直接光的有两点不同**:
- 第一点是这里没有用于计算微片元朝向的D函数，计算菲涅尔系数使用的是真正的**NV**而不是HV
- 第二点是**考虑了粗糙度**。使用NV是由于环境光来自半球内围绕法线N的所有方向，因此无法和直接光照中的法线分布函数D一样使用单个半角向量来确定微平面分布，所以在此我们只能使用法线和视线的夹角（即NV)来计算菲涅尔效果。
![[Pasted image 20221101234203.png]]

```c
// 直接光部分 NV或VH均可  
float3 F_FrenelSchlick(float VH,float3 F0)  
{  
    return F0 +(1.0 - F0)*pow(1.0-VH,5);  
}  
//间接光部分 只能使用NV并引入粗糙度  
float3 FresnelSchlickRoughness(float NV,float3 F0,float Roughness)  
{  
    float smoothness = 1.0 - Roughness;  
    return F0 + (max(smoothness.xxx, F0) - F0) * pow(1.0 - NV, 5.0);  
}
```

![[Pasted image 20221101234222.png]]
###### 数值拟合
**使命召唤黑色行动2的函数拟合**
如果输出该float2值，会发现和Lut贴图很相似。

```c
float2 BRDF_Ami = AmiBRDFApprox(i.uv.y, i.uv.x);  
return pow(float4(BRDF_Ami,0,0),2.2);
```

![[Pasted image 20221102201016.png|300]]
![[Pasted image 20221102143359.png]]
参考：https://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf

![[Pasted image 20221102143419.png]]
![[Pasted image 20221102143439.png]]
### HDR与LDR 色调映射
在PBR中做光照运算时，最终输出的颜色值时常超过1，而超过1的部分在显示器中显示就会“泛白过爆"，为了解决这个问题，将HDR(High Dynamic Range)的颜色值转换到LDR(Low Dynamic Range)的算法叫做
ToneMapping(色调映射)。在各种ToneMapping算法中**ACESTonemapping效果与性能兼优**。
ToneMapping: HDR->LDR

可以使用unity自带的后处理，也可以手写

ToneMapping.cs **挂载到相机**
```C#
using System.Collections;  
using System.Collections.Generic;  
using UnityEngine;  
  
// [ExecuteInEditorMode]  
[ExecuteInEditMode]  
public class ToneMapping : MonoBehaviour  
{  
    Material material;  
    // Start is called before the first frame update  
    void Start()  
    {  
        var shader = Shader.Find("Ulit/ToneMapping");  
        material = new Material(shader);  
    }  
  
    // Update is called once per frame  
    void Update()  
    {            }  
  
    private void OnRenderImage(RenderTexture src, RenderTexture dest)   
    {  
        Graphics.Blit(src,dest,material);  
    }  
  
}
```

ToneMapping.shader
```c
Shader "Ulit/ToneMapping"  
{  
    Properties  
    {  
        _MainTex ("Texture", 2D) = "white" {}  
    }  
    SubShader  
    {  
        // No culling or depth  
        Cull Off ZWrite Off ZTest Always  
  
        Pass        {  
            CGPROGRAM  
            #pragma vertex vert  
            #pragma fragment frag  
  
            #include "UnityCG.cginc"  
  
            struct appdata  
            {  
                float4 vertex : POSITION;  
                float2 uv : TEXCOORD0;  
            };  
  
            struct v2f  
            {  
                float2 uv : TEXCOORD0;  
                float4 vertex : SV_POSITION;  
            };  
  
            float3 ACESToneMapping(float3 x)  
            {  
                float a = 2.51f;  
                float b = 0.03f;  
                float c = 2.43f;  
                float d = 0.59f;  
                float e = 0.14f;  
                return saturate((x*(a*x+b))/(x*(c*x+d)+e));  
            }  
  
            v2f vert (appdata v)  
            {  
                v2f o;  
                o.vertex = UnityObjectToClipPos(v.vertex);  
                o.uv = v.uv;  
                return o;  
            }  
  
            sampler2D_float _MainTex;  
              
            float4 frag (v2f i) : SV_Target  
            {  
                float4 col = tex2D(_MainTex, i.uv);  
                  
                col.rgb = ACESToneMapping(col.rgb);  
  
                return col;  
            }  
            ENDCG  
        }  
    }  
}
```
![[第二章 光照基础#2. ACES曲线#]]
```c
float3 ACESToneMapping(float3 x)
{
		float a = 2.51f;
		float b = 0.03f;
		float c = 2.43f;
		float d = 0.59f;
		float e = 0.14f;
		return saturate((x * (a * x + b))/(x * (c * x + d) + e));
}
```
### Gamma与Linear
[[第二章 光照基础#2.6 伽马矫正]]
人眼对低亮度的颜色变化感知强，对高亮度的颜色变化感知弱
为了提高图片的显示辨识度，将自然界线性的颜色储存在非线性的空间(Gamma)
在渲染中先将图片转化为线性空间(Linear)，再进行颜色加减乘除操作才是正确的，最后再转为非线性(Gamma)的颜色输出
在Unity中如果设置颜色空间为Gamma，那么在进行PBR计算之前需要用代码手动转到Linear,并且最终输出到显示器的颜色时候需用代码手动转到Gamma空间
在Unity中如果设置颜色空间为Linear，那么Unity会帮我们把图片自动转到Linear空间，并且最终输出到显示器的颜色时候自动转到Gamma空间

### FinalColor
![[Pasted image 20221102143626.png]]
![[Pasted image 20221102143845.png]]
unity没有的basecolor没有乘NL
### 总结
![[Pasted image 20221029161818.png]]
### 拓展
![[Pasted image 20221029163621.png]]
![[Pasted image 20221029163736.png]]
### 案例：PBR头盔
![[Pasted image 20221102205521.png]]
```less
Shader "Unlit/MyHelmet"
{
    Properties
    {
        _BRDFLUTTex ("BRDFLUT", 2D) = "white" {}
        _BaseColorTex ("BaseColor", 2D) = "white" {}
        _MetallicTex ("Metallic", 2D) = "white" {}
        _RoughnessTex ("Roughness", 2D) = "white" {}
        _EmissionTex ("Emission", 2D) = "white" {}
        [HDR]_EmissionColor("Emission Color",Color)=(1,1,1,1)
        _NormalTex ("Normal", 2D) = "black" {}
        _AOTex ("AO", 2D) = "white" {}
    }
    SubShader
    {
        //LightMode 设置为ForwardBase，否则ShadeSH9()会出错。
        Tags { "RenderType"="Opaque" "LightMode"="ForwardBase"}

        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag

            #include "UnityCG.cginc"
            #include "UnityGlobalIllumination.cginc" //ShadeSH9()头文件
            
            struct appdata
            {
                float4 vertex : POSITION;
                float2 uv : TEXCOORD0;
                float3 normal : NORMAL;
                float4 tangent : TANGENT;
                
            };

            struct v2f
            {
                float4 pos : SV_POSITION;
                float2 uv : TEXCOORD0;
                float3 normal : TEXCOORD1;
                float3 tangent : TEXCOORD2;
                float3 bitangent : TEXCOORD3;
                float3 worldPos : TEXCOORD4;
            };

            sampler2D _MainTex;
            float4 _MainTex_ST;

            float  _Value, _RangeValue;
            float4 _Color, _BaseColor;

            float _Metallic, _Roughness;
            sampler2D _BRDFLUTTex;
            // samplerCUBE _EnvCubeMap;

            sampler2D _BaseColorTex, _MetallicTex, _RoughnessTex;
            sampler2D _EmissionTex, _AOTex, _NormalTex;
            float4 _EmissionColor;
            
            #define PI 3.14159265358979323846

            /* D法线分布函数：GGX */
            float D_DistributionGGX(float3 N, float3 H, float Roughness)
            {
                float a = Roughness * Roughness;
                float a2 = a * a;  //为什么取a的四次方，这里是参考的ue4，也可以使用a的二次方进行计算
                float NH =  max(0, dot(N,H));
                float NH2 = NH * NH;
                float nominator = a2; //分子
                float denominator = (NH2*(a2-1.0)+1.0);  //分母
                denominator = PI * denominator * denominator;  
                return nominator / max(0.00001, denominator);  //防止分母为0
            }
            
            /* G几何（遮蔽）函数 ：Schlick-GGX + Smith */
            // G_SchlickGGX  
            float G_SchlickGGX(float NV, float Roughness)  
            {  
                float a = Roughness + 1.0;  
                float k = a * a / 8.0;  //直接光  
                float nominator = NV;  
                float denominator = NV * (1.0 - k) + k;  
                
                return nominator / max(0.00001, denominator); 
             }
            
            // G_Smith  
            float G_Smith(float3 N, float3 V, float3 L, float Roughness)  
            {  
                float NV = max(0, dot(N,V));  
                float NL = max(0, dot(N,L)); 
                
                float GGX1 = G_SchlickGGX(NV, Roughness);  
                float GGX2 = G_SchlickGGX(NL,Roughness);  
              
                return GGX1 * GGX2;  
            }
            
            /* F菲涅尔方程：Schlick近似  */
            // 直接光部分 NV或VH均可
            float3 F_Schlick(float VH,float3 F0)
            {
                return F0 +(1.0 - F0)*pow(1.0-VH,5);
            }
            
            //间接光部分 只能使用NV并引入粗糙度
            float3 F_SchlickRoughness(float NV,float3 F0,float Roughness)
            {
                float smoothness = 1.0 - Roughness;
                return F0 + (max(smoothness.xxx, F0) - F0) * pow(1.0 - NV, 5.0);
            }

            /* 数值拟合 */
            // 使命召唤黑色行动2 的函数拟合
            // float2 AmiBRDFApprox(float Roughness, float NV)
            // {
            //     float g = 1 -Roughness;
            //     float4 t = float4(1/0.96, 0.475, (0.0275 - 0.25*0.04)/0.96, 0.25);
            //     t *= float4(g, g, g, g);
            //     t += float4(0, 0, (0.015 - 0.75*0.04)/0.96, 0.75);
            //     float A = t.x * min(t.y, exp2(-9.28 * NV)) + t.z;
            //     float B = t.w;
            //     return float2 ( t.w-A,A);
            // }
            
            // UE4 在黑色行动2 上的修改版本
            float2 AmiBRDFApprox(float Roughness, float NoV )
            {
                // [ Lazarov 2013, "Getting More Physical in Call of Duty: Black Ops II" ]
                // Adaptation to fit our G term.
                const float4 c0 = { -1, -0.0275, -0.572, 0.022 };
                const float4 c1 = { 1, 0.0425, 1.04, -0.04 };
                float4 r = Roughness * c0 + c1;//mad:multiply add
                float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;//mad
                float2 AB = float2( -1.04, 1.04 ) * a004 + r.zw;//mad
                return AB;
            }

            /* 色调映射 ToneMapping */
            float3 ACESToneMapping(float3 x)
            {
                float a = 2.51f;
                float b = 0.03f;
                float c = 2.43f;
                float d = 0.59f;
                float e = 0.14f;
                return saturate((x*(a*x+b))/(x*(c*x+d)+e));
            }
            
            float4 ACESToneMapping(float4 x)
            {
                float a = 2.51f;
                float b = 0.03f;
                float c = 2.43f;
                float d = 0.59f;
                float e = 0.14f;
                return saturate((x*(a*x+b))/(x*(c*x+d)+e));
            }
            
            v2f vert (appdata v)
            {
                v2f o;
                o.pos = UnityObjectToClipPos(v.vertex);
                o.uv = v.uv;
                o.normal = UnityObjectToWorldNormal(v.normal);
                o.tangent = UnityObjectToWorldDir(v.tangent);
                o.bitangent = normalize(cross(o.normal, o.tangent) * v.tangent.w);
                o.worldPos = mul(unity_ObjectToWorld, v.vertex);
                
                return o;
            }

            
            fixed4 frag (v2f i) : SV_Target
            {
                // 纹理采样
                float3 BaseColor = tex2D(_BaseColorTex, i.uv);
                float3 NormalMap = UnpackNormal(tex2D(_NormalTex,i.uv));
                float Roughness = tex2D(_RoughnessTex, i.uv).r;
                float Metallic = tex2D(_MetallicTex, i.uv).r;
                float3 Emission = tex2D(_EmissionTex, i.uv);
                float3 AO = tex2D(_AOTex, i.uv);
                
                // 变量准备
                float3 L = normalize(UnityWorldSpaceLightDir(i.worldPos));
                float3 V = normalize(UnityWorldSpaceViewDir(i.worldPos));
                float3 H = normalize(L + V);
                float3x3 TBN = float3x3(i.tangent, i.bitangent, i.normal);
                float3 N = normalize(mul(NormalMap, TBN));
                
                float VH = max(0, dot(V, H));
                float NV = max(0, dot(N, V));
                float NL = max(0,dot(N,L));
                
                float3 F0 = lerp(0.04, BaseColor, Metallic); //Fresnel F0：插值区分非金属和金属不同的F0值，非金属的FO数值较小，金属FO的数值较大
                
                /*  直接光（主光） */
                // Cook-Torrance BRDF
                // 漫反射部分
                float3 Ks = F_Schlick(VH, F0); //菲涅尔描述了光被反射的比例
                float3 Kd = (1-Ks) * (1 - Metallic);
                float3 Diffuse = Kd * BaseColor / PI; 
                //float3 Diffuse = Kd * BaseColor; //unity内置的PBR没有除以 PI, 颜色亮一些
                
                // 高光反射部分
                float D = D_DistributionGGX(N, H, Roughness);
                float3 F = Ks; 
                float G = G_Smith(N, V, L, Roughness);
                float3 Specular = D * F * G / max(0.0001, 4 * NV * NL);

                float3 DirectLightColor = (Diffuse + Specular) * NL * _LightColor0.rgb; //NL在这里起到了阴影贴图的作用，背光处变暗
                
                /*  间接光（环境光ambient） */
                // 漫反射部分
                float3 Ks_Ami = F_SchlickRoughness(NV, F0, Roughness);
                float3 Kd_Ami = (1 - Ks_Ami) * (1 - Metallic);
                float3 irradiance =  ShadeSH9(float4(N, 1));  // 球谐函数
                float3 Diffuse_Ami = irradiance * BaseColor * Kd_Ami / PI;
                //float3 Diffuse_Ami = irradiance * BaseColor * Kd_Ami; //没有除以 PI
                
                // 高光反射部分
                float3 F_Ami = Ks_Ami;
                // PartOne
                float3 R = reflect(-V, N);
                //UNITY_SPECCUBE_LOD_STEPS在"UnityStandardConfig.cginc"中// #define UNITY_SPECCUBE_LOD_STEPS (6)
                //根据材质的粗糙度，映射到某个粗糙度区间，然后把计算结果保存到不同的LOD等级中(Unity默认6级)
                float mip = Roughness * (1.7 - 0.7 * Roughness) * UNITY_SPECCUBE_LOD_STEPS;
                // 得到预过滤环境贴图 pre-filtered environment map
                float4 rgb_mip = UNITY_SAMPLE_TEXCUBE_LOD(unity_SpecCube0, R, mip);
                // 采样：光滑的地方采样清晰，粗造的地方采样模糊
                float3 preFilteredEnvironmentMap = DecodeHDR(rgb_mip,unity_SpecCube0_HDR);

                // PartTwo
                //LUT采样
                //float2 env_brdf = tex2D(_BRDFLUTTex, float2(NV, Roughness)).rg; //0.356
                //float2 env_brdf = tex2D(_BRDFLUTTex, float2(lerp(0, 0.99, NV), lerp(0, 0.99, Roughness))).rg;
                
                // 数值拟合
                float2 BRDF_Ami = AmiBRDFApprox(Roughness, NV);
                // float2 BRDF_Ami = AmiBRDFApprox(i.uv.y,i.uv.x);
                //  return pow(float4(BRDF_Ami,0,0),2.2);
                
                float3 Specular_Ami = preFilteredEnvironmentMap  * (F_Ami * BRDF_Ami.r + BRDF_Ami.g);

                float3 AmbientLightColor = (Diffuse_Ami + Specular_Ami) * AO;

                /*  颜色混合 */
                float3 FinalColor = DirectLightColor + AmbientLightColor + (Emission * _EmissionColor);
                
                return float4(FinalColor,1);
            }
            ENDCG
        }
    }
}
```
## 5.1.2 基于物理的相机（鸽）

## 5.1.3 基于物理的灯光（鸽）

## 5.1.4 IBL基于图像照明（鸽）
基于图像照明（Image-Based Lighting, IBL）
[深入理解 PBR/基于图像照明 (IBL) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/66518450)

# 5.2 光线追踪、路径追踪、光线投射、光线步进
games101

# 5.3 体渲染


# 5.5 水体渲染
