
---
title: 05 透明和剔除
aliases: []
tags: []
create_time: 2023-06-20 10:20
uid: 202306201020
banner: "![[Pasted image 20230620102455.png]]"
---

**Unity 中的渲染顺序**：不透明物体（从前到后）-> 天空盒 -> 透明物体（从后往前）

# 1 概述
Unity 中，我们通常使用两种方法来实现透明效果：
1. 透明度测试 (Alpha Test), 这种方法其实无法得到真正的半透明效果；
2. 透明度混合 (Alpha Blending)。

**透明度测试和透明度混合的基本原理如下**：

• 透明度测试：它采用一种“霸道极端”的机制，只要一个片元的透明度不满足条件（通常是小千某个阙值），那么它对应的片元就会被舍弃。被舍弃的片元将不会再进行任何处理，也不会对颜色缓冲产生任何影响；否则，就会按照普通的不透明物体的处理方式来处理它，即进行深度测试、深度写入等。也就是说，**透明度测试是不需要关闭深度写入的**，它和其他不透明物体最大的不同就是它会根据透明度来舍弃些片元。虽然简单，但是它产生的效果也很极端，要么完全透明，即看不到，要么完全不透明，就像不透明物体那样。

• 透明度混合： 这种方法可以得到真正的半透明效果。它会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。但是，**透明度混合需要关闭深度写入**，这使得我们要非常小心物体的渲染顺序。需要注意的是，透明度混合只关闭了深度写入，但没有关闭深度测试。

**渲染引擎采用的方案**：
(1) 先渲染所有不透明物体，并开启它们的深度测试和深度写入。
(2) 把半透明物体按它们距离摄像机的远近进行排序，然后按照从后往前的顺序渲染这些半透明物体，并开启它们的深度测试，但关闭深度写入。

Unity 为了解决渲染顺序的问题提供了 **渲染队列 (render queue)** 这一解决方案。我们可以使用 **`SubShader Queue`** 标签来决定我们的模型将归于哪个渲染队列。 **Unity 在内部使用一系列整数索引来表示每个渲染队列，且索引号越小表示越早被渲染**。![[Pasted image 20221003232825.png]]


# 透明效果

实现透明效果的两种方法：透明度测试和透明度混合

### 透明度测试

![image-20220704153603251](image-20220704153603251.png)

透明度测试的显示效果比较极端：要么完全透明（看不到），要么完全不透明。而且，透明效果的边缘有锯齿。
![image-20220704153317101](image-20220704153317101.png) ![image-20220704153515750](image-20220704153515750.png)

```c
Shader "Unlit/MyAlphaTest"
{
    Properties
    {
        _Color ("Main Tint", Color) = (1, 1, 1, 1)
        _MainTex ("Main Tex", 2D) = "white" {}
        _Cutoff ("Alpha Cutoff", Range(0, 1))= 0.5   
        //为了控制透明度测试时使用的阈值。_Cutoff参数用于决定我们调用clip进行透明度测试时使用的判断条件，范围是[0,1]，这是因为纹理像素的透明度就在此范围内

    }
    SubShader
    {
        Tags 
        { 
            "Queue"="AlphaTest"                //透明度测试使用AlphaTest渲染队列
            "IgnoreProjector"="True"           //该Shader不会受到投影器的影响
            "RenderType"="TransparentCutout"    //把该Shader归入到提前定义的组中（TransparentCutout组），以指明该Shader时一个使用了透明度测试的Shader，该标签通常被用于着色器替换功能
        }

        Pass
        {
            Tags{"LightMode"="ForwardBase"}

            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include "Lighting.cginc"

            fixed4 _Color;
            sampler2D _MainTex;
            float4 _MainTex_ST;
            fixed _Cutoff;

            struct a2v
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 texcoord : TEXCOORD0; 
            };

            struct v2f
            {
                float4 pos : SV_POSITION;
                float3 worldNormal : TEXCOORD0;
                float3 worldPos : TEXCOORD1;
                float2 uv : TEXCOORD2;
            };
            
            v2f vert(a2v v)
            {
                v2f o;
                o.pos = UnityObjectToClipPos(v.vertex);
                o.worldNormal = UnityObjectToWorldNormal(v.normal);
                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);

                return o;
            }

            fixed4 frag(v2f i) : SV_TARGET
            {
                fixed3 worldNormal = normalize(i.worldNormal);
                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));

                fixed4 texColor = tex2D(_MainTex, i.uv);

                //透明度测试
                clip(texColor.a - _Cutoff);

                fixed3 albedo = texColor.rgb * _Color.rgb;
                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;
                fixed3 diffuse = _LightColor0.rgb * albedo * saturate(dot(worldNormal,worldLightDir));

                return fixed4(ambient + diffuse, 1.0);
            }
            
            ENDCG
        }
    }
    Fallback "Transparent/Cutout/VertexLit"
}

```



### 透明度混合

#### 1. 一般方法

![image-20220704153712478](image-20220704153712478.png)

![image-20220704153735600](image-20220704153735600.png)

**透明度混合可以得到更加柔和的透明效果，但是这种方法仍有弊端：关闭深度写入后，造成错误排序，无法对模型进行像素级别的深度排序。**

![image-20220704154122183](image-20220704154122183.png)



**实现效果：**

![image-20220704153821708](image-20220704153821708.png)

![image-20220704154027806](image-20220704154027806.png)

```c
Shader "Unlit/MyAlphaBlendMat"
{
    Properties
    {
        _Color ("Main Tint", Color) = (1, 1, 1, 1)
        _MainTex ("Main Tex", 2D) = "white" {}
        _AlphaScale ("Alpha Scale", Range(0, 1))= 0.5   
    }
    SubShader
    {
        Tags 
        { 
            "Queue"="Transparent"                //透明度混合使用Transparent渲染队列
            "IgnoreProjector"="True"           //该Shader不会受到投影器的影响
            "RenderType"="Transparent"    //把该Shader归入到提前定义的组中（Transparent组），以指明该Shader时一个使用了透明度混合的Shader，该标签通常被用于着色器替换功能
        }

        Pass
        {
            Tags{"LightMode"="ForwardBase"}
            ZWrite Off //关闭深度写入
            Blend SrcAlpha OneMinusSrcAlpha  //Blend设置混合模式

            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include "Lighting.cginc"

            fixed4 _Color;
            sampler2D _MainTex;
            float4 _MainTex_ST;
            fixed _AlphaScale;  //用于在透明纹理的基础上控制整体的透明度

            struct a2v
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 texcoord : TEXCOORD0; 
            };

            struct v2f
            {
                float4 pos : SV_POSITION;
                float3 worldNormal : TEXCOORD0;
                float3 worldPos : TEXCOORD1;
                float2 uv : TEXCOORD2;
            };
            
            v2f vert(a2v v)
            {
                v2f o;
                o.pos = UnityObjectToClipPos(v.vertex);
                o.worldNormal = UnityObjectToWorldNormal(v.normal);
                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);

                return o;
            }

            fixed4 frag(v2f i) : SV_TARGET
            {
                fixed3 worldNormal = normalize(i.worldNormal);
                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));


                fixed4 texColor = tex2D(_MainTex, i.uv);

                fixed3 albedo = texColor.rgb * _Color.rgb;
                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;
                fixed3 diffuse = _LightColor0.rgb * albedo * saturate(dot(worldNormal,worldLightDir));

                return fixed4(ambient + diffuse, texColor.a * _AlphaScale);  //设置了该片元着色器返回值中的透明通道，它是纹理像素的透明通道和材质参数_AlphaScale的乘积
            }
            
            ENDCG
        }
    }
    Fallback "Transparent/VertexLit"
}
```

#### 2. 开启深度写入的半透明效果

使用两个 Pass 来渲染模型，使用这种方法我们仍可以实现模型与他后面的背景混合的效果，同时模型内部之间不会有任何的半透明效果。

![image-20220704154337978](image-20220704154337978.png)



```c
Shader "Unlit/MyAlphaBlendZwriteMat"
{
    Properties
    {
        _Color ("Main Tint", Color) = (1, 1, 1, 1)
        _MainTex ("Main Tex", 2D) = "white" {}
        _AlphaScale ("Alpha Scale", Range (0, 1))= 0.5   
    }
    SubShader
    {
        Tags 
        { 
            "Queue"="Transparent"                //透明度混合使用Transparent渲染队列
            "IgnoreProjector"="True"           //该Shader不会受到投影器的影响
            "RenderType"="Transparent"    //把该Shader归入到提前定义的组中（Transparent组），以指明该Shader时一个使用了透明度混合的Shader，该标签通常被用于着色器替换功能
        }
        
        //使用两个Pass来渲染模型

        //第一个Pass开启深度写入，但不输出颜色，目的仅仅是为了把该模型的深度值写入深度缓冲中
        pass
        {
            Zwrite On
            ColorMask 0
            //ColorMask用于设置颜色通道的写掩码（write mask）,设为0，意味着该Pass不写入任何颜色通道
        }

        //第二个Pass进行正常的透明度混合，由于上一个Pass已经得到了逐像素的正确深度信息，该Pass就可以按照像素级别的深度排序结果进行透明渲染
        Pass
        {
            Tags{"LightMode"="ForwardBase"}
            ZWrite Off //关闭深度写入
            Blend SrcAlpha OneMinusSrcAlpha  //Blend设置混合模式

            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include "Lighting.cginc"

            fixed4 _Color;
            sampler2D _MainTex;
            float4 _MainTex_ST;
            fixed _AlphaScale;  //用于在透明纹理的基础上控制整体的透明度

            struct a2v
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 texcoord : TEXCOORD0; 
            };

            struct v2f
            {
                float4 pos : SV_POSITION;
                float3 worldNormal : TEXCOORD0;
                float3 worldPos : TEXCOORD1;
                float2 uv : TEXCOORD2;
            };
            
            v2f vert(a2v v)
            {
                v2f o;
                o.pos = UnityObjectToClipPos(v.vertex);
                o.worldNormal = UnityObjectToWorldNormal(v.normal);
                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);

                return o;
            }

            fixed4 frag(v2f i) : SV_TARGET
            {
                fixed3 worldNormal = normalize(i.worldNormal);
                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));


                fixed4 texColor = tex2D (_MainTex, i.uv);

                fixed3 albedo = texColor.rgb * _Color.rgb;
                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;
                fixed3 diffuse = _LightColor0.rgb * albedo * saturate(dot(worldNormal,worldLightDir));

                return fixed4(ambient + diffuse, texColor.a * _AlphaScale);  //设置了该片元着色器返回值中的透明通道，它是纹理像素的透明通道和材质参数_AlphaScale的乘积
            }
            
            ENDCG
        }
    }
    Fallback "Transparent/VertexLit"
}
```

### 双面渲染

**通过双面渲染可以看到物体内部和背部的结构。**

![image-20220704154930176](image-20220704154930176.png)





![image-20220704155211450](image-20220704155211450.png)

#### 1. 透明度测试的双面渲染

![image-20220704155008714](image-20220704155008714.png)

#### 2. 透明度混合的双面渲染

![image-20220704155236569](image-20220704155236569.png)

![image-20220704155047959](image-20220704155047959.png)

# 第 13 课透明
[[冯乐乐入门精要#透明效果]]
**这一节还是结合冯乐乐入门精要比较好，这里只需要熟悉一下术语**
![[AP01_L13_4.jpg]]
![[AP01_L13_21.jpg]]

## AC：AlphaTest（AlphaCutout）
**透明度测试**
![[AP01_L13_8.jpg]]
![[AP01_L13_9.jpg]]
```less
Shader "Unlit/AC"  
{  
    Properties  
    {  
        _MainTex ("RGB：颜色 A：透贴", 2D) = "white" {}  
        _Cutoff("透切阈值",Range(0.0,1.0)) = 0.5  //固定写法
    }  
    SubShader  
    {  
        Tags   
{   
            "RenderType"="TransparentCutout"    //对应改为Cutout  
            "ForceNoShadowCasting" = "True"     //关闭阴影投射  
            "IgnoreProjector" = "True"          //不响应投射器  
        }  
  
        Pass  
        {  
            ......
            
            sampler2D _MainTex;  
            //特效一般会开启tilling和offset功能，注意采样时候使用TRANSFORM_TEX(v.uv, _MainTex)  
            float4 _MainTex_ST;  
            float _Cutoff;  
              
            v2f vert (appdata v)  
            {  
                v2f o;  
                o.pos = UnityObjectToClipPos(v.vertex);  
                o.uv = TRANSFORM_TEX(v.uv, _MainTex);  
                return o;  
            }  
  
            fixed4 frag (v2f i) : SV_Target  
            {  
                fixed4 Color = tex2D(_MainTex, i.uv);  
                clip(Color.a - _Cutoff);    //透明剪切  
                return Color;  
            }  
            ENDCG  
        }  
    }  
}
```
## AB：AplhaBlend
透明度混合
![[AP01_L13_11.jpg]]
![[AP01_L13_12.jpg]]
```less
Shader "Unlit/AB"  
{  
    Properties  
    {  
        _MainTex ("RGB：颜色 A：透贴", 2D) = "white" {}  
    }  
    SubShader  
    {  
        Tags   
{   "Queue" = "Transparent"             //调整渲染顺序  
            "RenderType"="Transparent"    //对应改为Cutout  
            "ForceNoShadowCasting" = "True"     //关闭阴影投射  
            "IgnoreProjector" = "True"          //不响应投射器  
        }  
  
        Pass  
        {  
            Name "FORWARD"  
            Tags  
            { "LightMode" = "ForwardBase" }  
            Blend One OneMinusSrcAlpha // 开启混合，设置混合因子  
			    ......
            
            fixed4 frag (v2f i) : SV_Target  
            {  
                fixed4 Color = tex2D(_MainTex, i.uv);  
                return Color;  
            }  
            ENDCG  
        }  
    }  
}
```
## AD：Addtive
透明度叠加: 在 AB 代码基础上改用 Blend One One，视觉上就是提亮
建议用 bloom 替代
![[AP01_L13_14.jpg]] ![[AP01_L13_15.jpg]]
## 混合参数
![[AP01_L13_18.jpg]]
## 面板编辑
![[AP01_L13_19.jpg]]
**封装需要 C#，这里先采用不封装的方法**
![[AP01_L13_20.jpg]]
**效果如下：**
![[Pasted image 20221020200242.png]]
```less
Properties  
{  
    ......
    [Enum(UnityEngine.Rendering.BlendMode)]  
    _BlendSrc("混合源乘子",int) = 0  
    [Enum(UnityEngine.Rendering.BlendMode)]  
    _BlendOst("混合目标乘子",int) = 0  
    [Enum(UnityEngine.Rendering.BlendOp)]  
    _BlendOp("混合算符",int) = 0  
}
Pass  
{
......
BlendOp [_BlendOp]        //可自定义混合运算符  
Blend [_BlendSrc] [_BlendOst]   //可自定义混合模式
}
```

## Alpha 通道预乘问题
![[AP01_L15_5.jpg]]
## AB、AD 改进
使得代码内容统一
![[AP01_L15_6.jpg]]
