世界那么大，我想去看看

## 引言

通过对前九篇的介绍，至此我们已经了解了 UE 里的游戏世界组织方式和游戏业务逻辑的控制。行百里者半九十，前述的篇章里我们的目光往往专注在于特定一个类或者对象，一方面固然可以让内容更有针对性，但另一方面也有了身在山中不见山的困惑。本文作为 GamePlay 章节的最终章，就是要回顾我们之前探讨过的内容，以一个更高层总览的眼光，把之前的所有内容有机组织起来，思考整体的结构和数据及逻辑的流向。

## 游戏世界

如果我们在最初篇所问的，如果让你来制作一款 3D 游戏引擎，你会怎么设计其结构？已经知道，在 UE 的眼里，游戏世界的万物皆 Actor，Actor 再通过 Component 组装功能。Actor 又通过 UChildActorComponent 实现 Actor 之间的父子嵌套。([GamePlay 架构（一）Actor 和 Component](https://zhuanlan.zhihu.com/p/22833151))

![[6ed5ef4dbe67c9b5a2db08151d8bc1a0_MD5.jpg]]

众多的各种 Actor 子类又组装成了 Level([GamePlay 架构（二）Level 和 World](https://zhuanlan.zhihu.com/p/22924838)):

![[083ab4270ff6f7bd035e59204ab8ebbf_MD5.png]]

如此每一个 Level 就拥有了一座 Actor 的森林，你可以根据自己的需要定制化 Level，比如有些 Level 是临时 Loading 场景，有些只是保存光照，有些只是一块静态场景。UE 用 Level 这种细一些粒度的对象为你的想象力提供了极大的自由度，同时也能方便团队内的平行协作。

一个个的 Level，又进一步组装成了 World:

![[9897c66a4c07ad9e4b4ec2f2d6cb7406_MD5.png]]

就像地球上的大陆板块一样，World 允许多个 Level 静态的通过位置摆放在游戏世界中，也允许运行时动态的加载关卡。

而 World 之间的切换，UE 用了一个 WorldContext 来保存切换的过程信息。玩家在切换 PersistentLevel 的时候，实际上就相当于切换了一个 World。而再往上，就是整个游戏唯一的 GameInstance，由 Engine 对象管理着。([GamePlay 架构（三）WorldContext，GameInstance，Engine](https://zhuanlan.zhihu.com/p/23167068))  

![[794292b1c7ae24baa5e24d70256fedea_MD5.png]]

到了 World 这一层，整个游戏的渲染对象就齐全了。但是游戏引擎并不只是渲染，因此为了让玩家也各种方式接入 World 中开始游戏。GameInstance 下不光保存着 World，同时也存储着 Player，有着 LocalPlayer 用于表示本地的玩家，也有 NetConnection 当作远端的连接。（[GamePlay 架构（八）Player](https://zhuanlan.zhihu.com/p/23826859)）：  

![[ea3becbbc94b76fbde904a173793f6fc_MD5.png]]

玩家利用 Player 对象接入 World 之后，就可以开始控制 Pawn 和 PlayerController 的生成，有了附身的对象和摄像的眼睛。最后在 Engine 的 Tick 心跳脉搏驱动下开始一帧帧的逻辑更新和渲染。

## 数据和逻辑

说完了游戏世界的表现组成，那么对于一个 GamePlay 框架而言自然需要与其配套的业务逻辑架构。GamePlay 架构的后半部分就自底向上的逐一分析了各个层次的逻辑载体，按照 MVC 的思想，我们可以把整个游戏的 GamePlay 分为三大部分：表现（View）、逻辑（Controller）、数据（Model）。一图胜千言：  

![[411cebb2b416dac68b7240c94768a758_MD5.jpg]]

(请点击看大图)  
最左侧的是我们已经讨论过的游戏世界表现部分，从最最根源的 UObject 和 Actor，一直到 UGameEngine，不断的组合起来，形成丰富的游戏世界的各种对象。

1.  从 UObject 派生下来的 AActor，拥有了 UObject 的反射序列化网络同步等功能，同时又通过各种 Component 来组装不同组件。UE 在 AActor 身上同时利用了继承和组合的各自优点，同时也规避了彼此的一些缺点，我不得不说，UE 在这一方面度把握得非常的平衡优雅，既不像 cocos2dx 那样继承爆炸，也不像 Unity 那样走极端全部组件组合。
2.  AActor 中一些需要逻辑控制的成员分化出了 APawn。Pawn 就像是棋盘上的棋子，或者是战场中的兵卒。有 3 个基本的功能：可被 Controller 控制、PhysicsCollision 表示和 MovementInput 的基本响应接口。代表了基本的逻辑控制物理表示和行走功能。根据这 3 个功能的定制化不同，可以派生出不同功能的的 DefaultPawn、SpectatorPawn 和 Character。([GamePlay 架构（四）Pawn](https://zhuanlan.zhihu.com/p/23321666))
3.  AController 是用来控制 APawn 的一个特殊的 AActor。同属于 AActor 的设计，可以让 Controller 享受到 AActor 的基本福利，而和 APawn 分离又可以通过组合来提供更大的灵活性，把表示和逻辑分开，独立变化。([GamePlay 架构（五）Controller](https://zhuanlan.zhihu.com/p/23480071))。而 AController 又根据用法和适用对象的不同，分化出了 APlayerController 来充当本地玩家的控制器，而 AAIController 就充当了 NPC 们的 AI 智能。([GamePlay 架构（六）PlayerController 和 AIController](https://zhuanlan.zhihu.com/p/23649987))。而数据配套的就是 APlayerState，可以充当 AController 的可网络复制的状态。
4.  到了 Level 这一层，UE 为我们提供了 ALevelScriptActor（关卡蓝图）当作关卡静态性的逻辑载体。而对于一场游戏或世界的规则，UE 提供的 AGameMode 就只是一个虚拟的逻辑载体，可以通过 PersistentLevel 上的 AWorldSettings 上的配置创建出我们具体的 AGameMode 子类。AGameMode 同时也是负责在具体的 Level 中创建出其他的 Pawn 和 PlayerController 的负责人，在 Level 的切换的时候 AGameMode 也负责协调 Actor 的迁移。配套的数据对象是 AGameState。([GamePlay 架构（七）GameMode 和 GameState](https://zhuanlan.zhihu.com/p/23707588))
5.  World 构建好了，该派玩家进来了。但游戏的方式多样，玩家的接入方式也多样。UE 为了支持各种不同的玩家模式，抽象出了 UPlayer 实体来实际上控制游戏中的玩家 PlayerController 的生成数量和方式。([GamePlay 架构（八）Player](https://zhuanlan.zhihu.com/p/23826859))
6.  所有的表示和逻辑汇集到一起，形成了全局唯一的 UGameInstance 对象，代表着整个游戏的开始和结束。同时为了方便开发者进行玩家存档，提供了 USaveGame 进行全局的数据配套。([GamePlay 架构（九）GameInstance](https://zhuanlan.zhihu.com/p/24005952))

UE 为我们提供了这些 GamePlay 的对象，说多其实也不多，而且其实也是这么优雅有机的结合在一起。但是仍然会把一些朋友给迷惑住了，常常就会问哪些逻辑该写在哪里，哪些数据该放在哪里，这么多个对象，好像哪个都可以。比如 Pawn，有些人就会说我就是直接在 Pawn 里写逻辑和数据，游戏也运行的好好的，也没什么不对。

如果你是一个已经对设计架构了然于心，也预见到了游戏未来发展变化，那么这么直接干也确实比较快速方便。但是这么做其实隐含了两个前提，一是这个 Pawn 的逻辑足够简单，把 MVC 的三者混合在一起依然不超过你的心智负担；二是已经断绝了逻辑和数据的分离，如果以后本地想复用一些逻辑创建另一个 Pawn 就会很麻烦，而且未来联机多玩家的状态复制也不支持。但说回来，人类的一个最常见的问题就是自大，对自己能力的过度自信，对未来变化的虚假掌控感。程序员在自己的编程世界里，呼风唤雨操作内存设备惯了，这种强大的掌控感非常容易地就外延到其他方面去了。你现在写的代码，过几个月后再回头看，是不是经常觉得非常糟糕？那奇怪了，当初写的时候怎么就感觉信心满满呢？所以踩坑多了的人就会自然的保守一些。另一方面，作为团队里的技术高手或老人，我个人觉得也有支持同行和提携后辈的责任，对自己而言只是多花一点点力气，却为别人树立一个清晰的程序结构典范，也传播了设计思想。程序员何苦为难程序员。

但还有一些人喜欢那么硬怼着干的原因要嘛是对未来的可预见性不足（经验不足），要嘛是对程序设计的基本原则不够了解（程序能力不够），比如最简单的 “单一职责”。在新手期，面对着 UE 的程序世界，虽然在已经懂的人眼里就那么几个对象，但是在新手眼里，往往就感觉复杂无比，面对未知，我们本能的反应是逃避，往往就倾向于哪些看起来这么用能工作，就像玩游戏一样，形成了你的 “专属套路”。跟穷人忙于工作而没力气提高自己是一个道理。相信我，所有的高手都是从小白过来的，我敢保证，他出生的时候脑袋也肯定是一片空白！区别是有些人后来不怕麻烦的勤能补拙，他努力的去理解这种设计模式的优劣，不局限于自己已经掌握的一片舒适区内，努力去设想未来的各种变化和应对之法，最终形成自己的独立思考。高手只是比新手懂得更多想得更多一些而已。

闲话说完。在分析 UE 这么一个 GamePlay 系统的时候，就像 UML 有各种图一样，我们也应该从各个切面去分析它的构成。这里有两大基本原则：单一职责和变化隔离，但也可以说只有一个。所有的程序设计模式都只是在抽象变化，把变化都抽离开了，剩下的不就是单一职责了嘛。所以 UE 里对 MVC 的实践其实也只是在不断抽离出各个对象的变化部分，把 Pawn 的逻辑抽出来是 Controller，把数据抽出来是 PlayerState。把 World 的 Level 静态逻辑抽出来是关卡蓝图，把动态的游戏玩法抽离出来是 GameMode，把游戏数据抽离出来是 GameState。具体的每个层次的数据和逻辑的关系前文已经一一详细说过了，此处就不再赘述了。但也再次着重探讨一些分析方法：

*   从竖直的角度来看，左侧是表示，中间是逻辑，右侧是数据。  
    

*   当我们谈到表示的时候，脑袋里想的应该是一个单纯的展示对象，就像一个基本的网络物体，它可以带一些基本的动画，再多一些功能，也顶多只能像一个木偶，有着一些非常机械原始的行为。我们让他前进，他可以知道左腿右腿交替着迈，但他是无知觉的。所以左侧的那一串对象，你应该尽量得让他们保持简单。
*   实现中间的逻辑的时候，你应该专注于逻辑本身，尽量的忘记两旁的表示和数据。去思考哪些逻辑是表示固有的还是比较智能判断的。哪些 Controller 或 Mode 我们应该尽量的让它们通用，哪些就让它们特定的负责某一块，有些也不能强求，自己把握好度。
*   右侧的数据，同样的保持简单。我们把它们分离出来的目的就是为了独立变化和在网络间同步，注意一下别走回头路了就好。我们应该只在此放置纯数据。

*   从水平的切面上看，依次自底向上，记住一个原则，哪个层次的应该尽量只负责哪个层次的东西，不要对上层或下层的细节知道得太多，也尽量不要逾矩越权去指手画脚别的对象里的内务事。大家通力协作，注重隐私，保持安全距离，不就社会和谐了嘛。  
    

*   最底层的 Component，应该只是实现一些与游戏逻辑无关的功能。理解这个 “无关” 是关键。换个游戏，你这些 Component 依然可以用，就是所谓的游戏无关。
*   Actor 层，通过 Pawn、Controller 和 PlayerState 的合作，根据需要旗下再派生出特定的 Character，或 PlayerController，AIController，但它们的合作模式，三大家族的长老们已经定下了，后辈们应该尽量遵守。这一层，关键的地方在于分清楚哪些是操作 Actor 的，别向下把 Actor 内部的功能给抽了出来，也别大包大揽把整个游戏的玩法也管了过来。脑袋保持清醒，这一层所做的事，就是为了让 Actor 们显得更加的智能。换句话说，这些智能的 Actor 组合，理论上是可以在随便哪个 Level 里用的。
*   Level 和 World 层，分清楚静态的关卡蓝图和动态可组合 GameMode。静态的意思是这个场景本身的运作机制，动态的指的是可以像切换比赛方式一样切换一场游戏的目的。在这一层上，你得有总览游戏大局的自觉了，咱们都是干大事的人，眼光就不要局限在那些一兵一卒那些小事了。制定好游戏规则，赋予这一场游戏以意义，是 GameMode 最重要的职责。注意两点，一是脑袋里有跟弦，一旦开始联机环境了，GameMode 就升职到 Server 里去了，Client 就没有了，所以千万要小心别在 GameMode 做些客户端的小事；二是 GameState 是表示一场游戏的数据的，而 PlayerState 是表示 Controller 的数据，对象和范围都不同，不能混了。
*   GameInstance 层，一般来说 Player 不需要你做太多事情，UE 已经帮你处理好了。虽说力量越大，责任就越大，但领导日理万机累坏了也不行是吧。所以 GameInstance 作为全局的唯一逻辑对象，我们如果能不打扰他就尽量少把事推给他，否则你很快就会看着 GameInstance 里堆着一山东西。GameInstance 身在高层，应该只尽量做一些 Level 之间的协调工作。而 SaveGame 也应该尽量只保存游戏持久的数据。

自始至终，回顾一下每个类的本身的职责，该是他的就是他的，别人的不要抢。读者朋友们，如果到此觉得似乎懂了一些，但还是觉得不够深刻理解的话，也没关系，凡事不能一蹴而就，在开发过程中多想多琢磨自然而然就会慢慢领悟了。

## 整体类图

从类的继承层次上，咱们再加深一下理解。下图只列出了 GamePlay 架构里一些相关的重要的类：  

![[a6116bb849954485b938b8394f46b861_MD5.jpg]]

(请点击看大图)  
由此也可以看出来，UE 基于 UObject 的机制出发，构建出了纷繁复杂的游戏世界，几乎所有的重要的类都直接或间接的继承于 UObject，都能充分利用到 UObject 的反射等功能，大大加强了整体框架的灵活度和表达能力。比如 GamePlay 中最常用到根据某个 Class 配置在运行时创建出特定的对象的行为就是利用了反射功能；而网络里的属性同步也是利用了 UObject 的网络同步 RPC 调用；一个 Level 想保存成 uasset 文件，或者 USaveGame 想存档，也都是利用了 UObject 的序列化；而利用了 UObject 的 CDO（Class Default Object），在保存时候也大大节省了内存；这么多 Actor 对象能在编辑器里方便的编辑，也得益于 UObject 的属性编辑器集成；对象互相引用的从属关系有了 UObject 的垃圾回收之后我们就不用担心会释放问题了。想象一下如果一开始没有设计出 UObject，那么这个 GamePlay 框架肯定是另一番模样了。

## 总结

对于 GamePlay 我们从构建游戏世界开始，再到一层层的逻辑控制，本篇也从各个切面上总结归纳了整体架构。希望读者们好好领会 UE 的 GamePlay 架构思想，别贪快，整体上慢慢琢磨以上的架构图，细节上可以回顾过往的单篇来了解。

对于这一套 UE 提供的 GamePlay 框架，我们既然选择了用 UE 引擎，那么自然就应该想着怎么充分利用好它。框架就是你如果在它的规则下办事，那它就是事半功倍的助力器，你会常常发现 UE 怎么连这个也帮你做完了；而如果你在不了解的情况下想逆着它行事，就常常感受到怎么哪里都受到束缚。我们对于框架的理念应该就像是对待一辆汽车一般，我们关心的是怎么驾驶它到达想要的目的地，而不是折腾着怪它四个轮子不能按照你的心意朝不同方向乱转。对比隔壁的 Cocos2dx、或 Unity、或 CryEngine，UE 能够提供这么一个完善的 GamePlay 框架，对我们开发者而言，是一件幸福的事，不是吗？

## 结束语

完结撒花！GamePlay 大章节也终于结束了，最开始是本着怎么尽早尽大的能帮助到读者朋友们，所以选择了 GamePlay 作为起始章节。相信 GamePlay 也是开发者们日常开发过程中接触最多，也是有可能混淆最多，概念不清，很容易用错的一块主题。在介绍 GamePlay 的时候，更多的重点是在于介绍各对象的职责和关联，所以更多是用类图来描述结构，反而对源码进行剖析的机会不多，但读者们可以自己去阅读验证。希望 GamePlay 架构的一系列十篇文章能切实地帮助到你们。

而下个专题，根据 QQ 群友们的投票反馈，决定了是 UObject！有相当部分开发人员，可能不知道也不太关心 UObject 的内部机制。清楚了 UObject，确实对于开发游戏并没有多少直接的提升，但《InsideUE4》系列教程的初衷就是为了深入到引擎内部提高开发者人员的内功。对于有志于想掌握好 UE 的开发者而言，分析一个游戏引擎，如果只是一直停留在高层的交互，而对于最底层的对象系统不了解的话，那就像云端行走一般，自身感觉飘飘然，但是总免不了内心里有些不安，学习和使用的脚步也会显得虚浮。因此在下个专题，我们将插入 UObject 的最最深处，把 UObject 扒得一毛不挂，慢慢领会她的美妙！我们终于有机会得偿心愿，细细把玩一句句源码，了解关于 UObject 的 RTTI、反射、GC、序列化等等的内容。如果你也曾经好奇 NewObject 里发生了些什么、困惑 CreateDefaultSubObject 为何只能在构造函数里调用、不解 GC 是如何把对象给释放掉了、uasset 文件里是些什么……

敬请期待下个专题：UObject！

_UE4.14_

---------------------------------------------------------------------------------------------------------------------------

知乎专栏：[InsideUE4](https://zhuanlan.zhihu.com/insideue4)

UE4 深入学习 QQ 群：**456247757**(非新手入门群，请先学习完官方文档和视频教程)

微信公众号：**aboutue**，关于 UE 的一切新闻资讯、技巧问答、文章发布，欢迎关注。  

**个人原创，未经授权，谢绝转载！**