# 溶解方案总结
## **溶解的思路**

就是在 Frag 阶段，**判断是否丢弃像素**。

**丢弃像素的方法**

*   **（常用）**通过 clip 函数
*   通过 discard
*   通过设置 alpha 变量为 0

### 通过 clip 函数

*   clip (x)，x 小于 0 就会丢弃该像素。
*   在片段着色器中，根据当前 uv，采样噪声图，就可以获得一个遮罩值。
*   clip (遮罩值 - 阈值)，就可以看到一个动态溶解效果。

```
half dissove = tex2D(_DissTex, i.uv).r;

clip(dissolve - _Clip);
```

## 定向溶解和中心点溶解

[Unity 小工具：溶解效果（Dissolve） - zd304 的文章 - 知乎](https://zhuanlan.zhihu.com/p/138942181)

![[8ff1e9d34f5883941904931fa45a0672_MD5.gif]]

### 定向溶解

在 Vert 阶段，得到一个方向因子（worldFactor），然后 clip = clip + worldFactor，即可得到效果。

**方向因子**

*   世界变换矩阵的 w 行向量即为世界位置。

```
float4 worldPos = mul(unity_ObjectToWorld, v.vertex);
float3 rootPos = float3(unity_ObjectToWorld[0].w, unity_ObjectToWorld[1].w, unity_ObjectToWorld[2].w);
float3 dir = worldPos.xyz - rootPos;
float posOffset = dot(normalize(_DissolveDir), dir);
o.worldFactor = posOffset;
```

**Frag - Clip**

```
fixed dissove = tex2D(_DissTex, i.uv).r;
dissove = (dissove - _Clip) + i.worldFactor * _WorldSpaceScale;
clip(dissove);
```

### 中心点溶解

根据像素离中心点距离，即 distance 函数。

```
fixed dissove = tex2D(_DissTex, i.uv).r;
float dist = distance(_DissolveCenterUV, i.uv);
dissove = dissove + dist * _WorldSpaceScale;
```

# 溶解

### ASE 实现
![[Pasted image 20221004114121.png]]

### Shader 实现
实现裁剪效果时采用局部坐标，不采用世界坐标。原因在于当物体移动时，世界坐标发生改变无法控制裁剪效果，控制局部坐标就容易一些。
```c
Shader "Unlit/myshader"  {  
    Properties  
    {  
        _MainTex("Main Texture", 2D) = "white"{}     //贴图参数  
        _NoiseTex("Noise Texure", 2D) = "white"{}    //噪声贴图  
        _BurningValue("_BurningValue", Float) = 1  //控制噪声大小  
        _BurningWidth("_BurningWidth", Float) = 0.01  //控制溶解效果边缘宽度  
        _BurningOffset("_BurningOffset", Float) = 0.55 //   
[HDR]_Color("_Color", Color) =  (1,1,1,0)    //颜色参数,注意标注[HDR]，才能开启bloom效果  
    }  
    SubShader{  
        Tags {"RenderType" = "Opaque"}  
          
        Pass  
        {  
            CGPROGRAM  
  
            #pragma vertex vert;  
            #pragma fragment frag;  
  
            #include "UnityCG.cginc"    //头文件  
  
            //数据变量  
            sampler2D _MainTex;  
            float4 _MainTex_ST;  
            sampler2D _NoiseTex;  
            float _BurningValue;  
            float _BurningWidth;  
            float _BurningOffset;  
            float4 _Color;  
              
            struct a2v  
            {  
                float4 vertex : POSITION;   //顶点局部坐标  
                float2 uv     : TEXCOORD0;          //顶点的uv1  
                float4 normal : NORMAL;             //顶点的法线  
                float4 color  : COLOR;              //顶点的颜色  
            };  
  
            struct v2f  
            {  
                float4 vertex       : SV_POSITION;  //顶点的裁剪坐标系下的坐标  
                float2 uv           : TEXCOORD0;    //顶点的uv  
                float4 worldNormal  : TEXCOORD1;    //顶点世界法线  
                float3 worldPosition  : TEXCOORD2;  //顶点世界坐标  
                float3 localPosition  : TEXCOORD3;  //顶点局部坐标  
            };  
  
            v2f vert(a2v v)  
            {  
                v2f o;  
                o.vertex = UnityObjectToClipPos(v.vertex);  
                o.worldNormal = mul(v.normal, unity_WorldToObject);  
                o.uv = v.uv;  
  
                o.localPosition = v.vertex.xyz; //局部坐标  
                o.worldPosition = mul(unity_ObjectToWorld, v.vertex);  
                  
                return o;  
            }  
  
            float4 frag(v2f i) : SV_Target  
            {  
                float height = i.localPosition.y + _BurningOffset; //若不加0.55，当_BurningValue为0时，会出现水平的分界线在模型原点(这个值可以随便调)  
                //采样贴图  
                float4 final = tex2D(_MainTex, i.uv);  
                float noise = tex2D(_NoiseTex, i.uv).r;    
                //noise +=0.1; //控制 noise 最小值为 0.1, 避免噪声的接近 0 的部分需要乘以很大的_BurningValue（用于黑色部分很多的噪声贴图）  
                float burn = noise * _BurningValue; //控制噪声大小  
                float s1 = step (height, burn);  
                float s2 = step(height, burn + _BurningWidth);  
                float colorRange = s2 - s1;     //得出溶解边缘  
                clip(height - burn);  
                return lerp(final,  _Color, colorRange);  
            }  
            ENDCG  
        }  
          
    }  
}
```

菲尼尔边缘光效果
```c
Shader "Unlit/robotshader"  {  
    Properties  
    {  
        _MainTex("Main Texture", 2D) = "white"{}     //贴图参数  
        _NoiseTex("Noise Texure", 2D) = "white"{}    //噪声贴图  
        _BurningValue("_BurningValue", Float) = -6  //控制噪声大小  
        _BurningWidth("_BurningWidth", Float) = 0.1  //控制溶解效果边缘宽度  
        _BurningOffset("_BurningOffset", Float) = 0.55   
[HDR]_Color("_Color", Color) =  (1,1,1,0)    //颜色参数,注意标注[HDR]，才能开启bloom效果  
        //菲涅尔  
        _FresnelScale("FresnelScale", Range(0,0.05)) = 0  
        [HDR]EdgeColor("FresnelColor", COLOR) = (1,1,1,1)  
          
          
    }  
    SubShader{  
        Tags {"RenderType" = "Opaque"}  
          
        Pass  
        {  
            CGPROGRAM  
  
            #pragma vertex vert;  
            #pragma fragment frag;  
  
            #include "UnityCG.cginc"    //头文件  
  
            //数据变量  
            sampler2D _MainTex;  
            float4 _MainTex_ST;  
            sampler2D _NoiseTex;  
            float _BurningValue;  
            float _BurningWidth;  
            float _BurningOffset;  
            float4 _Color;  
            float _FresnelScale;  
            fixed4 EdgeColor;  
              
            struct a2v  
            {  
                float4 vertex : POSITION;   //顶点局部坐标  
                float2 uv     : TEXCOORD0;          //顶点的uv1  
                float4 normal : NORMAL;             //顶点的法线  
                float4 color  : COLOR;              //顶点的颜色  
            };  
  
            struct v2f  
            {  
                float4 vertex       : SV_POSITION;  //顶点的裁剪坐标系下的坐标  
                float2 uv           : TEXCOORD0;    //顶点的uv  
                float4 worldNormal  : TEXCOORD1;    //顶点世界法线  
                float3 worldPosition  : TEXCOORD2;  //顶点世界坐标  
                float3 localPosition  : TEXCOORD3;  //奠定局部坐标  
            };  
  
            v2f vert(a2v v)  
            {  
                v2f o;  
                o.vertex = UnityObjectToClipPos(v.vertex);  
                o.worldNormal = mul (v.normal, unity_WorldToObject);  
                o.uv = v.uv;  
  
                o.localPosition = v.vertex. xyz;   
                o.worldPosition = mul(unity_ObjectToWorld, v.vertex);  
                  
                return o;  
            }  
  
            float4 frag(v2f i) : SV_Target  
            {  
                float3 viewDir = UnityWorldSpaceViewDir(i.worldPosition);  
                float3 worldNormal = normalize(i.worldNormal);  
  
                //Schlick菲涅尔近似式  
                float Fresnel =  _FresnelScale+ (1 -_FresnelScale) * pow(1 - saturate(dot(worldNormal,viewDir)), 5);  
                  
                float4 FresnelColor = EdgeColor * Fresnel;  
                  
                float height = i.localPosition.y + _BurningOffset;   
                float4 final = tex2D(_MainTex, i.uv) + FresnelColor;  
                float noise = tex2D(_NoiseTex, i.uv).r;    
                  
                      
                float burn = noise * _BurningValue * _CosTime.z * 5;; //控制噪声大小  
                float s1 = step(height, burn);  
                float s2 = step(height, burn + _BurningWidth);  
                float colorRange = s2 - s1;     //得出溶解边缘  
                clip(height - burn);  
                  
                return lerp(final, _Color, colorRange);  
            }  
            ENDCG  
        }  
    }  
}
```
