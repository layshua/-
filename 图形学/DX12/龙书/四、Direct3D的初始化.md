---
banner: "![[Pasted image 20230101204819.png]]"
banner_y: 0.33
---
# 1 预备知识
DX12较之上个版本主要改变：性能优化方面大大减少了 CPU 开销，改进了对多线程的支持。性能提升！
## 基础概念
通过 Direct3D 这种底层**图形应用程序编程接口（Application Programming Interface, API)**, 即可在在应用程序中对**图形处理器 (Graphics Processing Unit, GPU)** 进行控制和编程。我们能够借此以硬件加速的方式渲染出虚拟的 3D 场景。

**渲染目标（render target）** 是为了渲染场景而将像素绘制到的特定缓冲区 (buffer)。通常是占用部分显存的后台缓冲区，以及纹理（详见后文）。

**像素（pixl）**  是构成图像的基本元素。从图形角度来讲，可认为像素是一种图像的采样单位（将图像以像素为基础进行划分，再于像素中进行采样)。因此，两张同样大小的图片，分辨率高者，意味着像素数量越多，细节越丰富，画面就越清晰。由于实际显示上的原因（后面注释会提到)，也赋予了像素“大小”的概念。**在 Direct3D 中，像素被抽象为具有一定长宽的色块。**

**纹素 (texel)** ：构成纹理的基本元素又称纹素，**通常我们将纹素视为像素**。尽管后台缓冲区是一个纹理, 但我们仍常将其组成元素称为像素，因为就后台缓冲区这种情况而言，它所存储的内容是颜色信息。即便纹理中存储的不是颜色信息，大家有时也称纹理的元素为像素（如“法线图中的像素”)。**至于二者是否需要区分，具体还要看应用场景。** 比如谈到像素与纹素的映射关系时，必须将这两个概念予以区分。文中谈到的基本上是约定俗成的叫法。
## 组件对象模型
**组件对象模型 (Component Object Model, COM)** 是一种令 DirectX 不受编程语言束缚，并且使之向后兼容的技术。
我们通常将 COM 对象视为一种接口，但考虑当前编程的目的，遂将它当作一个 C++类来使用。用 C++语言编写 DirectX 程序时，COM 帮我们隐藏了大量底层细节。

**不使用 C++的 new 和 delete**：
要获取指向某 COM 接口的指针，需借助特定函数或另一 COM 接口的方法一而不是用 C+语言中的关键字 new 去创建一个 COM 接口。
COM 对象会统计其引用次数；因此，在使用完某接口时，我们便应调用它的 Release 方法 (COM 接口的所有功能都是从 IUnknown 这个 COM 接口继承而来的，包括 Release 方法在内)，而不是用 delete 来别删除——当 COM 对象的引用计数为 0 时，它将自行释放自己所占用的内存。

为了**辅助用户管理 COM 对象的生命周期**，Windows 运行时库 (Windows Runtime Library, WRL)专门为此提供了 `Microsoft::WRL: ComPtr` 类 ( `#include <wrl.h>`), 我们可以把它当作是 **COM 对象的智能指针**。当一个 `ComPtr` 实例超出作用域范围时，它便会自动调用相应 COM 对象的 Release方法，继而省掉了我们手动调用的麻烦。本书中常用的 3 个 `ComPtr` 方法如下。
1. `Get`：返回一个指向此底层 COM 接口的指针。此方法常用于把原始的 COM 接口指针作为参数传递给函数。例如：
```c++ nums
ComPtr<ID3D12Rootsignature> mRootsignature;
......
//SetGraphicsRootsignature 需要获取 ID3D12 RootSignature*类型的参数
mCommandList->SetGraphicsRootsignature (mRootsignature.Get());
```

2. `GetAddressof`: 返回指向此底层 COM 接口指针的地址。凭此方法即可利用函数参数返回 COM接口的指针。例如：
```c++ nums
ComPtr<ID3D12CommandAllocator> mDirectCmdListAlloc;
ThrowIfFailed(md3dDevice->CreateCommandAllocator (
		D3D12 COMMAND LIST TYPE DIRECT,
		mDirectCmdListAlloc. GetAddressof ())
	);
```
3. `Reset` : 将此 ComPtr 实例设置为 nullptr 释放与之相关的所有引用（同时减少其底层 COM 接口的引用计数)。此方法的功能与将 ComPtr 目标实例赋值为 nullptr 的效果相同。

> [!NOTE] 
> COM 接口都以大写字母“I”作为开头。例如，表示命令列表的 COM 接口为  
> `ID3D12GraphicsCommandList`
> 
## 纹理格式
**2D 纹理（2D texture)** 是一种由数据元素构成的矩阵（可将此“矩阵”看作 2D 数组)。它的用途之一是存储 2D 图像数据，在这种情况下，纹理中每个元素存储的都是一个像素的颜色。
然而，纹理的用处并非仅此而已。例如，有种称作法线贴图 (normal mapping)的高级技术，其纹理内的每个元素存储的就是一个 3D 向量而不是颜色信息。因此，尽管纹理给人的第一印象通常是用来存储图像数据，但其实际用途却十分广泛。简单来讲，1D、2D、3D 纹理就相当于特定数据元素所构成 1D、2D、3D 数组。但随着后续章节中对纹理讨论的逐渐深入，我们便会知道，**纹理其实还不只是像“数据数组”那样简单。它们可能还具有多种 mipmap 层级，而 GPU 则会据此对它们进行特殊的处理**，例如运用过滤器（filter)和进行多重采样（multisample)。**另外，并不是任意类型的数据元素都能用于组成纹理，它只能存储 `DXGI FORMAT` 枚举类型中描述的特定格式的数据元素。** 下面是一些相关的格式示例：
1. `DXGI FORMAT R32G32B32 FLOAT`: 每个元素由 3 个 32 位浮点数分量构成。
2. `DXGI FORMAT R16G16B16A16 UNORM`: 每个元素由 4 个 16 位分量构成，每个分量都被映射到$[0,1]$区间。
3. `DXGI FORMAT R32G32UINT`: 每个元素由 2 个 32 位无符号整数分量构成。
4. `DXGI FORMAT R8G8B8A8 UNORM`: 每个元素由 4 个 8 位无符号分量构成，每个分量都被映射到$[0,1]$区间。
5. `DXGI FORMAT R8G8B8A8 SNORM`: 每个元素由 4 个 8 位有符号分量构成，每个分量都被映射到$[-1,1]$ 小区间。
6. `DXGI FORMAT R8G8B8A8SINT`: 每个元素由 4 个 8 位有符号整数分量构成，每个分量都被
映射到 $[-128,127]$ 区间。
7. `DXGI FORMAT R8G8B8A8UINT`: 每个元素由 4 个 8 位无符号整数分量构成，每个分量都被
映射到 $[0,255]$ 区间。

颜色都是由红、绿、蓝“**三基色**” (注意美术中的“三原色”是指红黄蓝！)组合而成（例如，红色和绿色混合成黄色)。alpha 通道（或称为 alpha 分量)则通常用于控制透明度。
然而，正如前文所述，尽管格式名称在字面上指示的是颜色和 lpha 值，但**纹理存储的却不一定是颜色信息**。例如，格式 `DXGI FORMAT R32G32B32 FLOAT` 中含有 3 个浮点数分量，因此可以利用坐标格式为浮点数的方式存储任意 3D 向量。除此之外，亦有**无类型 (typeless)格式的纹理，我们仅用它来预留内存**，待纹理被绑定到渲染流水线 (rendering pipeline, 详见第 5 章)之后，再具体解释它的数据类型（有点像 C++语言里的强制转换 2）。例如，下面的无类型格式保留的是由 4 个 16 位分量组成的元素，但并没有指出数据的具体类型（例如，是整数、浮点数还是无符号整数？）：`DXGI FORMAT R16G16B16A16 TYPELESS`
我们将在第 6 章中看到 `DXGI FORMAT` 枚举类型也可用于描述顶点以及索引的数据格式。

## 交换链和页面翻转
**为了避免动画中出现画面闪烁的现象，最好将动画帧完整地绘制在一种称为<mark style="background: #FF5582A6;"><mark style="background: #FF5582A6;">后台缓冲区</mark></mark>的<mark style="background: #FF5582A6;">离屏</mark>(off-screen, 即不可直接呈现在显示设备上之意)<mark style="background: #FF5582A6;">纹理</mark>内。** 只要将指定动画帧的整个场景绘到后台缓冲区中，它就会以一个完整的帧画面展现在屏幕上；依照此法，观者便不会察觉出帧的绘制过程一而只会观赏到完整的动画帧。为此，需要利用由硬件管理的两种纹理缓冲区：即所谓的**前台缓冲区 (front buffer)** 和**后台缓冲区 (back buffer)** 。
**前台缓冲区存储的是当前显示在屏幕上的图像数据，而动画的下一帧则被绘制在后台缓冲区里。**
当后台缓冲区中的动画帧绘制完成之后，两种缓冲区的角色互换：后台缓冲区变为前台缓冲区呈现新一帧的画面，而前台缓冲区则为了展示动画的下一帧转为后台缓冲区，等待填充数据。前后台缓冲的这种互换操作称为**呈现 (presenting, 亦有译作提交、显示等)**。呈现是一种高效的操作，只需交换指向当前前台缓冲区和后台缓冲区的两个指针即可实现。
![[Pasted image 20230406150703.png]]
>图 4.1 对于第 n 帧来讲，当前显示的是缓冲区 A 中的内容，我们将把下一帧的数据渲染到此时的后台缓冲区 B 内。一旦后台缓冲区绘制完毕，两个缓冲区的指针将互换，即缓冲区 B 将变成前台缓冲区，而缓冲区 A 则成为新的后台缓冲区。接下来，我们会把下一帧的内容渲染到缓冲区 A 中。待后台缓冲区（即此时的缓冲区 A)完成绘制，两个缓冲区的指针再次互换，即在第+2 帧中，缓冲区 A 重新成为前台缓冲区，缓冲区 B 则再次客串后台缓冲区

**前台缓冲区和后台缓冲区构成了<mark style="background: #FF5582A6;">交换链（swap chain)</mark>**, 在 Direct3D 中用 `IDXGISwapChain` 接口来表示。这个接口不仅存储了前台缓冲区和后台缓冲区两种纹理，而且还提供了修改缓冲区大小(`IDXGISwapChain::ResizeBuffers`)和呈现缓冲区内容 (`IDXGISwapChain::Present`)的方法。**使用两个缓冲区（前台和后台)的情况称为<mark style="background: #FF5582A6;">双缓冲</mark> (double buffering, 亦有译作双重缓冲、双倍缓冲等)。** 当然，也可以运用更多的缓冲区。例如，使用 3 个缓冲区就叫作三重缓冲（triple buffering, 亦有译作三倍缓冲等)。对于一般的应用来说，使用两个缓冲区就足够了。

> [!NOTE] 
> 尽管后台缓冲区是一个纹理（因而构成纹理的基本元素又称纹素，texel), 但我们仍常将其组成元素称为像素，因为就后台缓冲区这种情况而言，它所存储的内容是颜色信息。即便纹理中存储的不是颜色信息，大家有时也称纹理的元素为像素（如“法线图中的像素”)。
> 至于二者是否需要区分，具体还要看应用场景。比如谈到像素与纹素的映射关系时，必须将这两个概念予以区分。文中谈到的基本上是约定俗成的叫法。


## 深度缓冲
**<mark style="background: #FF5582A6;">深度缓冲区（depth buffer)</mark>这种<mark style="background: #FF5582A6;">纹理</mark>资源存储的并非图像数据，而是特定像素的深度信息。**
深度值的范围为 0.0~1.0。0.0 代表观察者在视锥体（view frustum）中能看到离自己最近的物体，1.0 则代表观察者在视锥体中能看到离自己最远的物体。
**深度缓冲区中的元素与后台缓冲区内的像素呈一一对应关系（即后台缓冲区中第 i 行第 j 列的元素对应于深度缓冲区内第 i 行第 j 列的元素)。** 所以，如果后台缓冲区的分辨率为 1280×1024，那么深度缓冲区中就应当有 1280×1024 个深度元素。
为了确定不同物体间的像素前后顺序，Direct3D 采用了一种叫作深度缓冲 (depthbuffering)或 z 缓冲 (z-buffering, 其中的 z 指 z 坐标)的技术。**这里要着重强调一个细节：若使用了深度缓冲，则物体的绘制顺序也就变得无关紧要了。**

总而言之，深度缓冲技术的原理是计算每个像素的深度值，并执行深度测试 (depth test)。而深度测试则用于对竞争写入后台缓冲区中同一像素的多个像素深度值进行比较。具有最小深度值的像素（说明该像素离观察者最近)会获得最终的胜利，它将被写入后台缓冲区中。这样做也是合乎情理的，因为离观察者较近的像素无疑会遮挡其后面的像素。
**深度缓冲区也是一种纹理，所以一定要用明确的数据格式来创建它。深度缓冲可用的格式包括以下几种：**
1. `DXGI_FORMAT_D32_FLOAT_S8X24_UINT`: 该格式共占用 64 位，取其中的 32 位指定一个浮点型深度缓冲区，另有 8 位（无符号整数)分配给模板缓冲区（stencil buffer), 并将该元素映射到$[0,255]$区间，剩下的 24 位仅用于填充对齐（padding)不作他用。
2. `DXGI_FORMAT_D32_FLOAT`: 指定一个 32 位浮点型深度缓冲区。
3. `DXGI FORMAT D24 UNORM S8UINT`: 指定一个无符号 24 位深度缓冲区，并将该元素映射
到 $[0,1]$ 区间。另有 8 位（无符号整型)分配给模板缓冲区，将此元素映射到$[0,255]$区间。
4. `DXGI FORMAT D16 UNORM`: 指定一个无符号 16 位深度缓冲区，把该元素映射到 $[0, 1]$ 区间。