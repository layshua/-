---
title: " C++原理 "
create_time: " 2023-09-28 20:43 "
uid: "202309282043"
reference: []
---

# 概念
## 三个级别的语言
1. **机器语言**。又称二进制代码，是计算机唯一可以直接识别和执行的语言。
2. **汇编语言**。汇编语言用英文单词和其缩写（助记符）代替二进制的指令代码。使用汇编语言编辑的程序，必须经过一个称为**汇编程序**的系统软件的编译，将其转换为机器语言，才能在计算机的硬件系统上执行。
3. **高级语言**。C++等，需要经过**编译程序**编译成汇编语言程序，经过**汇编**操作得到机器语言程序，或直接由高级语言程序翻译成机器语言程序。

## 翻译程序
- **编译程序（由编译器生成）**：将高级语言编写的源程序全部语句一次全部编译成机器语言程序，而后再执行机器语言程序（只需要编译一次，如 C/C++）
- **汇编程序（由汇编器生成）**：汇编语言转换为机器语言
- **解释程序（由解释器生成）**：将源程序的一条语句翻译成对应于机器语言的语句并立即执行。紧接着翻译下一句（每次执行都要编译，如 python，js）
- **翻译程序**：编译、汇编、解释程序统称翻译程序


## 从源程序到可执行文件
![[Pasted image 20230928215219.png]]

```c++ file:hello.c
#include <stdio.h>

int main(){
    printf("Hellow World.\n");
    return 0;
}

```
对于一个 C++源文件，从文本到可执行文件一般需要四个过程：
### 1 预处理阶段
**预处理器（cpp）** 对源程序 `hello. c` 中以字符 `#` 字节开头的命令进行处理，例如将 `#include` 命令后面的 `.h` 文件内容插入程序文件。输出修改后的源程序 `hello. i` 

- 删除所有的 `#define` ，展开所有的宏定义。
- 处理所有的条件预编译指令，如 `#if` 、`#endif` 、 `#ifdef` 、`#elif` 和 `#else` 。
- 处理 `#include` 预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。
- 删除所有的注释，`“//”`和`“/**/”`。
- 保留所有的 `#pragma` 编译器指令，编译器需要用到他们，如： `#pragma once`  是为了防止有文件被重复引用。
- 添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是能够显示行号。
```c++ file:hello.i
# 1 "hello.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 31 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 32 "<command-line>" 2
# 1 "hello.c"
# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 424 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 427 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 428 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 429 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 425 "/usr/include/features.h" 2 3 4
# 448 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 449 "/usr/include/features.h" 2 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 2 3 4
# 28 "/usr/include/stdio.h" 2 3 4

```
### 2 编译阶段
**编译器（ccl）** 对预处理后的源程序进行编译，生成汇编语言程序 ` hello.s`

编译过程一般分为6步：扫描、语法分析、语义分析、源代码优化、代码生成和目标代码优化。
![[2037768-20ef368560491608.webp]]
```c++ file:hello.s
	.file	"hello.c"
	.text
	.section	.rodata
.LC0:
	.string	"Hellow World."
	.text
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	leaq	.LC0(%rip), %rdi
	call	puts@PLT
	movl	$0, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.ident	"GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0"
	.section	.note.GNU-stack,"",@progbits
```
### 3 汇编阶段
汇编器（as）将 `hello.s` 翻译成机器语言指令，把这些指令打包成一种叫做**可重定位目标程序**的格式，并保存在 `hello.o` 文件中，这是一个二进制文件，用文本编辑器打开会显示为乱码。

汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器 as 完成。经汇编之后，产生目标文件 (与可执行文件格式几乎一样) xxx.o (Windows 下)、xxx.obj (Linux 下)。

### 4 链接阶段
**链接器（ld）** 将多个可重定位目标文件和标准库函数链接为一个可执行目标文件（简称可执行文件）。
`hello` 程序调用了 `printf` 函数，它是 C 标准库函数，具体存在于一个已经预编译好的 `printf.o` 文件，链接器（ld）负责将这个文件与我们的 hello 文件合并起来。

将多个目标文件及所需要的库连接成最终的可执行目标文件。链接分为静态链接和动态链接：
**静态链接：**
函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。
空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；
更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。
运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。
**动态链接**
动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。
共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；
更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。
性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。

# 一、运行原理
## 内存分区模型
C++程序在执行时，将内存大方向划分为**4 个区域**

-   **程序代码区**：存放**函数体（类的成员函数、全局函数）的二进制代码**，由操作系统进行管理的
-   **全局/静态区**：存放**全局变量和静态变量**
-   **文字常量区**：存放**常量字符串**。
-   **栈区**：由编译器自动分配释放, 存放**函数的参数值, 局部变量**等
-   **堆区**：由程序员分配和释放 (malloc/new), 若程序员不释放, 程序结束时由操作系统回收（不是数据结构中的堆）

### 程序运行前
在程序编译后，生成了 exe 可执行程序，**未执行该程序前**分为两个区域

**代码区：**
**存放 CPU 执行的机器指令**
代码区是**共享**的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可
代码区是**只读**的，使其只读的原因是防止程序意外地修改了它的指令

**全局区：**
全局变量和静态变量存放在此.
全局区还包含了常量区, 字符串常量和其他常量也存放在此.
该区域的数据在程序结束后由操作系统释放.

总结：
-   C++中在程序运行前分为全局区和代码区
-   代码区特点是共享和只读
-   全局区中存放全局变量、静态变量、常量
-   常量区中存放 const 修饰的全局常量和字符串常量
### 程序运行后
**栈区：**
由编译器自动分配释放, 存放函数的参数值, 局部变量等
注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放

**堆区：**
由程序员分配释放, 若程序员不释放, 程序结束时由操作系统回收
在 C++中主要利用 new 在堆区开辟内存

## 编译器是如何工作的

编译器实际上需要做的唯一一件事，就是将我们的文本文件拿来转换他们，转换成一种称为目标文件格式的中间格式。这些 obj 文件可以传递到链接器，这个链接器可以做它所有的要链接的事情。

编译器在生成这些 obj 时实际上做了几件事：  
首先，预处理我们的代码，这意味着所有的预处理语句都会先处理。一旦我们的代码被预处理，接下来我们将或多或少地进行记号化和解析，基本上整理成编译器能够真正理解和推理的格式。这基本上导致了所谓的抽象语法树被创建。它基本上是我们代码的一种表示，但是是抽象的语法树。一旦编译器创建了抽象语法树，它可以开始实际生成代码。这段代码就是实际的机器，我们的 CPU，将执行的代码。  
我们还得到了其他各种数据，比如一个存储所有常量、变量的地方，这基本上就是编译器所做的一切。
Aaaa
每一个 CPP 文件将产生一个目标文件，这些 CPP 文件被称为翻译单元。本质上必须意识到 C++ 不关心文件，文件不是存在于 C++ 中的东西。在 C++ 中，文件只是提供给编译器源代码的一种方式，你负责告诉编译器你输入的是什么类型的文件，以及编译器应该如何处理它。比如说把 a.cpp 改为 b.hbh，只要告诉编译器这是个 c++ 文件亦可，所以文件是没有意义的。

预处理到文件：（生成. i，但是就不生成. obj 了）  

![](1671805718710.png)

  
OBJ 为二进制文件，不易读，我们可以在 VS 中选择生成汇编：  

![](1671805718846.png)

  
默认的 Debug 优化：  

![](1671805718977.png)

  
运行时检查：  

![](1671805719168.png)

  
如果开氧气优化则会报错：

```
Error	D8016	'/O2' and '/RTC1' command-line options are incompatible	Project2
```

要把运行时检查修改为 default：  

![](1671805719276.png)

  
它基本上不会执行运行时检查。

## 链接器是如何工作的

现在链接的主要焦点是找到每个符号和函数在哪里，并把他们连接起来。应用程序需要知道入口点（entry point，一般为 main）在哪里，当你实际运行你的应用程序的时候，C++ 运行时库（run time library）会说：这是 main 函数，我要跳到这里，然后开始执行代码。

在 VS 中按下 ctrl + F7，只有编译会发生，链接将永远不会发生。但是如果是 build 或者是 F5 运行，它会编译然后链接。

语法错误（syntax error）以 C 打头（compile），告诉我们错误在编译阶段。LNK 则代表链接 link，告诉我们错误在链接阶段。

自定义 entry point（一个 exe 一定有 entry point）：  

![](1671805719404.png)

  
链接错误：  
未解决的外部符号 unresolved external symbol——当链接器找不到它需要的东西时发生。（如果从来没调用某个函数，则根本无需链接）  

![](1671805719540.png)

  
如上图，在一段程序中，如果我们在函数中调用 Log，但是 main 中并没有调用 multiply，如果 log 没有被链接器找到，则仍然会报错——因为 multiply 函数是有可能被别的翻译单元调用的！因此仍然需要进行链接。  
那么只要我们让 multiply 函数变为 static 的，即 static int Multiply (int a, int b)，那么这就表明这个函数只被声明在这个翻译单元中。因此即使 Log 函数在其他翻译单元是没有定义的，由于其只存在于 Multiply 中，而 Multiply 是 static 的且当前翻译单元未被调用，就表明 Multiply 从来没有被调用过！因此无需链接，也就不会得到任何链接错误。

当然，重复定义，会让链接器不知道链接到哪一个函数，因此也会出错。比如在一个头文件中定义了一个函数：  

![](1671805719690.png)

  
而在 Log. cpp 和 Math. cpp 中都调用了 Log 函数并且包含了 Log. h 头文件（注意，头文件 include 仅仅是把头文件内容复制粘贴过来而已），那么由于各自为翻译单元，有两个 Log 函数的定义存在，链接器仍然将不知道去调用哪个函数，会出现错误：

```
。。。。。 already defined in Log.obj
```

告诉我们 Log 函数已经在 log. obj 被定义了。

修复措施：

1.  static  
    表明头文件代码贴进来的时候，这个函数只是文件的内部函数，所以 Log. cpp 和 Math. cpp 都有他们各自的 Log 函数且对其他的 obj 文件不可见。  
    
    ![](1671805719815.png)
    
2.  inline  
    inline 的意思是获取我们实际的函数体并将函数调用替换为函数体（直接贴进去）。
3.  放到其他的翻译单元中，头文件只声明

链接器需要带走我们所有的目标文件，并将它们链接在一起。它也将拉进我们可能用到的其他任何其他库，例如 C run time library、C++ 标准库、平台的 api 等等，从许多不同的地方 linking 是很常见的。

还有其他不同的链接：静态链接和动态链接（第 49 节课和第 50 节课，动态库 dll 静态库 lib）


## 在 Visual Studio 中调试代码

断点和读取内存——这是调试的两大部分。当然会同时使用，换句话说你要设置断点就是为了读取内存。

断点 break point 是程序中调试器将中断的点。这里 break 的意思是暂停。当我们的程序执行到断点处时它将暂停。在我们这个例子的整个项目中它会挂起执行线程，让我们来看看这个程序的 state。说到 state，cherno 指的是内存，我们可以暂停程序看看它的内存中发生了什么。

一个运行中的程序所需的内存是相当大的，包括你设置的每个变量、要调用的函数等等。当你将程序中断后，内存数据实际上还在，能查看内存对诊断你的程序出问题的原因非常有用。通过查看内存可以看到每一个变量的值。

确保在将会被执行的代码行打上断点（空行的断点不起作用）。

visual studio：

*   step into——F11  
    进入到这行代码上的函数里面（如果这一行有一个函数的话）。
*   step over——F10  
    从当前函数跳到下一行代码。
*   step out——shift + F11  
    跳出当前函数，回到调用这个函数的位置。



![](1671805720035.png)

  
如上图这样的代码，黄色箭头表示将要执行这行代码，调试器显示的是，a 将要被设置的内存位置的数字被显示出来了。因为我们没有把这个变量设置成任何东西，它只是未初始化的内存，这意味着这个值只是给我们展示了内存中实际包含的内容。

内存视图（VS 中，alt + 6，或是 debug-Windows-memory-memory1）：  

![](1671805720148.png)
  

![](1671805720269.png)

  
最左边是内存地址以十六进制格式表示的实际值。在中间为实际的数据，右边为 ASCII 码对这些数字的解释。  
变量名取地址，即可在内存视图中找到对应位置：  

![](1671805720456.png)

  

![](1671805720675.png)
这里内存是大量的 CC，意味着它是未初始化的栈内存。


# LIB、DLL
共有两种库：  
一种是 LIB 包含了函数所在的 DLL 文件和文件中函数位置的信息（入口），代码由运行时加载在进程空间中的 DLL 提供，称为**动态链接库 dynamic link library**。  
一种是 LIB 包含函数代码本身，在编译时直接将代码加入程序当中，称为**静态链接库 static link library**。  

共有两种链接方式：  
**动态链接**使用动态链接库，允许可执行模块（. dll 文件或. exe 文件）仅包含在运行时定位 DLL 函数的可执行代码所需的信息。  
**静态链接**使用静态链接库，链接器从静态链接库 LIB 获取所有被引用函数，并将库同代码一起放到可执行文件中。

**关于 lib 和 dll 的区别如下：**  
（1）lib 是编译时用到的，dll 是运行时用到的。如果要完成源代码的编译，只需要 lib；如果要使动态链接的程序运行起来，只需要 dll。  
（2）如果有 dll 文件，那么 lib 一般是一些索引信息，记录了 dll 中函数的入口和位置，dll 中是函数的具体内容；**如果只有 lib 文件，那么这个 lib 文件是静态编译出来的，索引和实现都在其中。使用静态编译的 lib 文件，在运行程序时不需要再挂动态库，缺点是导致应用程序比较大，而且失去了动态库的灵活性，发布新版本时要发布新的应用程序才行。**  
（3）动态链接的情况下，有两个文件：一个是 LIB 文件，一个是 DLL 文件。LIB 包含被 DLL 导出的函数名称和位置，DLL 包含实际的函数和数据，应用程序使用 LIB 文件链接到 DLL 文件。在应用程序的可执行文件中，存放的不是被调用的函数代码，而是 DLL 中相应函数代码的地址，从而节省了内存资源。DLL 和 LIB 文件必须随应用程序一起发行，否则应用程序会产生错误。如果不想用 lib 文件或者没有 lib 文件，可以用 WIN32 API 函数 LoadLibrary、GetProcAddress 装载。

**使用 lib 需注意两个文件：**  
（1）. h 头文件，包含 lib 中说明输出的类或符号原型或数据结构。应用程序调用 lib 时，需要将该文件包含入应用程序的源文件中。  
（2）. LIB 文件，略。

**使用 dll 需注意三个文件：**  
（1）. h 头文件，包含 dll 中说明输出的类或符号原型或数据结构的. h 文件。应用程序调用 dll 时，需要将该文件包含入应用程序的源文件中。  
（2）. LIB 文件，是 dll 在编译、链接成功之后生成的文件，作用是当其他应用程序调用 dll 时，需要将该文件引入应用程序，否则产生错误。如果不想用 lib 文件或者没有 lib 文件，可以用 WIN32 API 函数 LoadLibrary、GetProcAddress 装载。  
（3）. dll 文件，真正的可执行文件，开发成功后的应用程序在发布时，只需要有. exe 文件和. dll 文件，并不需要. lib 文件和. h 头文件。

**使用 lib 的方法：**  
静态 lib 中，一个 lib 文件实际上是任意个 obj 文件的集合，obj 文件是 cpp 文件编译生成的。在编译这种静态库工程时，根本不会遇到链接错误；即使有错，也只会在使用这个 lib 的 EXT 文件或者 DLL 工程里暴露出来。  
在 VC 中新建一个 static library 类型的工程 Lib，加入 test. cpp 文件和 test. h 文件（头文件内包括函数声明），然后编译，就生成了 Lib. lib 文件。  
别的工程要使用这个 lib 有两种方式：  
（1）在 project->link->Object/Library Module 中加入 Lib. lib 文件（先查询工程目录，再查询系统 Lib 目录）；或者在源代码中加入指令 
```c++ nums
#pragma comment (lib, “Lib. lib”)
```
（2）将 Lib. lib 拷入工程所在目录，或者执行文件生成的目录，或者系统 Lib 目录中。  
（3）加入相应的头文件 test. h。

使用 DLL 的方法：  
使用动态链接中的 lib，不是 obj 文件的集合，即里面不会有实际的实现，它只是提供动态链接到 DLL 所需要的信息，这种 lib 可以在编译一个 DLL 工程时由编译器生成。  
创建 DLL 工程的方法（略）。  
**（1）隐式链接**  
第一种方法是：通过 project->link->Object/Library Module 中加入. lib 文件（或者在源代码中加入指令 #pragma comment (lib, “Lib. lib”)），并将. dll 文件置入工程所在目录，然后添加对应的. h 头文件。
```c++ nums
#include "stdafx.h"  
#include "DLLSample.h"  
#pragma comment(lib, "DLLSample.lib") // 你也可以在项目属性中设置库的链接  
int main()  
{
	 TestDLL(123); //dll 中的函数，在 DllSample.h 中声明  
	 return(1);  
}  

```

**（2）显式链接**  
需要函数指针和 WIN32 API 函数 LoadLibrary、GetProcAddress 装载，使用这种载入方法，不需要. lib 文件和. h 头文件，只需要. dll 文件即可（将. dll 文件置入工程目录中）。
```c++ nums
#include <iostream>  
#include <windows.h> // 使用函数和某些特殊变量  
typedef void (*DLLFunc)(int);  
int main() 
{
		DLLFunc dllFunc; 
		HINSTANCE hInstLibrary = LoadLibrary("DLLSample.dll");  
		
		if (hInstLibrary == NULL)  
		{  
			 FreeLibrary(hInstLibrary);  
		}
		
		dllFunc = (DLLFunc)GetProcAddress(hInstLibrary, "TestDLL");
		  
		if (dllFunc == NULL)  
		{  
			FreeLibrary(hInstLibrary);  
		}  

		dllFunc(123);  
		std::cin.get();  
		FreeLibrary(hInstLibrary);  
		return(1);  
}  
```
LoadLibrary 函数利用一个名称作为参数，获得 DLL 的实例（HINSTANCE 类型是实例的句柄），通常调用该函数后需要查看一下函数返回是否成功，如果不成功则返回 NULL（句柄无效），此时调用函数 FreeLibrary 释放 DLL 获得的内存。  
GetProcAddress 函数利用 DLL 的句柄和函数的名称作为参数，返回相应的函数指针，同时必须使用强转；判断函数指针是否为 NULL，如果是则调用函数 FreeLibrary 释放 DLL 获得的内存。此后，可以使用函数指针来调用实际的函数。  
最后要记得使用 FreeLibrary 函数释放内存。

注意：应用程序如何找到 DLL 文件？  
使用 LoadLibrary 显式链接，那么在函数的参数中可以指定 DLL 文件的完整路径；如果不指定路径，或者进行隐式链接，Windows 将遵循下面的搜索顺序来定位 DLL：  
（1）包含 EXE 文件的目录  
（2）工程目录  
（3）Windows 系统目录  
（4）Windows 目录  
（5）列在 Path 环境变量中的一系列目录


.h 头文件是编译时必须的，lib 是链接时需要的，dll 是运行时需要的。

附加依赖项的是. lib 不是. dll，若生成了 DLL, 则肯定也生成 LIB 文件。如果要完成源代码的编译和链接，有头文件和 lib 就够了。如果也使动态连接的程序运行起来，有 dll 就够了。在开发和调试阶段，当然最好都有。

.h .lib .dll 三者的关系是：

H 文件作用是: 声明函数接口 

DLL 文件作用是: 函数可执行代码 

当我们在自己的程序中引用了一个 H 文件里的函数, 编链器怎么知道该调用哪个 DLL 文件呢? 这就是 LIB 文件的作用: 告诉链接器调用的函数在哪个 DLL 中，函数执行代码在 DLL 中的什么位置，这也就是为什么需要附加依赖项 .LIB 文件，它起到桥梁的作用。如果生成静态库文件，则没有 DLL ，只有 lib，这时函数可执行代码部分也在 lib 文件中

目前以 lib 后缀的库有两种，一种为静态链接库 (Static Libary，以下简称“静态库”)，另一种为动态连接库 (DLL，以下简称“动态库”) 的导入库 (Import Libary，以下简称“导入库”）。静态库是一个或者多个 obj 文件的打包，所以有人干脆把从 obj 文件生成 lib 的过程称为 Archive，即合并到一起。比如你链接一个静态库，如果其中有错，它会准确的找到是哪个 obj 有错，即静态 lib 只是壳子。动态库一般会有对应的导入库，方便程序静态载入动态链接库，否则你可能就需要自己 LoadLibary 调入 DLL 文件，然后再手工 GetProcAddress 获得对应函数了。有了导入库，你只需要链接导入库后按照头文件函数接口的声明调用函数就可以了。导入库和静态库的区别很大，他们实质是不一样的东西。静态库本身就包含了实际执行代码、符号表等等，而对于导入库而言，其实际的执行代码位于动态库中，导入库只包含了地址符号表等，确保程序找到对应函数的一些基本地址信息。

一般的动态库程序有 lib 文件和 dll 文件。lib 文件是必须在编译期就连接到应用程序中的，而 dll 文件是运行期才会被调用的。如果有 dll 文件，那么对应的 lib 文件一般是一些索引信息，具体的实现在 dll 文件中。如果只有 lib 文件，那么这个 lib 文件是静态编译出来的，索引和实现都在其中。静态编译的 lib 文件有好处：给用户安装时就不需要再挂动态库了。但也有缺点，就是导致应用程序比较大，而且失去了动态库的灵活性，在版本升级时，同时要发布新的应用程序才行。在动态库的情况下，有两个文件，而一个是引入库（. LIB）文件，一个是 DLL 文件，引入库文件包含被 DLL 导出的函数的名称和位置，DLL 包含实际的函数和数据，应用程序使用 LIB 文件链接到所需要使用的 DLL 文件，库中的函数和数据并不复制到可执行文件中，因此在应用程序的可执行文件中，存放的不是被调用的函数代码，而是 DLL 中所要调用的函数的内存地址，这样当一个或多个应用程序运行是再把程序代码和被调用的函数代码链接起来，从而节省了内存资源。从上面的说明可以看出，DLL 和. LIB 文件必须随应用程序一起发行，否则应用程序将会产生错误。

静态库和共享库都是一个 obj 文件的集合，但静态链接后，执行程序中存在自己所需 obj 的一份拷贝，而动态链接后，执行程序仅仅是包含对共享库的一个引用。共享库相当于一个由多个 obj 文件组合而成的 obj 文件，在链接后其所有代码被加载，不管需要的还是不需要的。  
似乎可以得出一个结论：  
 静态链接后的程序比动态链接的所用存储空间大，因为执行程序中包含了库中代码拷贝；  
 而动态链接的程序比静态链接的所用的运行空间大，因为它将不需要的代码也加载到运行空间。

  
针对上面的知识 2 个问题：1） DLL 和. LIB 文件必须随应用程序一起发行，否则应用程序将会产生错误。我的答案：lib 应该不需要吧。2）如果是某个程序中调用了一个动态库（通过 header 文件，lib+dll 来调用），则对动态库的某个函数的内容修改了，但接口不改，则调用此动态库的程序需重新编译连接吗？如果是通过 loadlibary 动态加载，需要重新编译连接吗？  

我的答案：通过 header+lib+dll 调用的话需要重新编译连接，但是通过 loadlibrary 来使用的话，不需要重新编译连接。

第 2 个答案错了应该是不需要重新编译接口不变的话 .lib 都不用更新  
From: 

[ http://www.cppblog.com/mzty/archive/2010/11/28/134901.html

 1） 节省内存。同一个软件模块，若是以源代码的形式重用，则会被编译到不同的可执行程序中，同时运行这些 exe 时这些模块的二进制码会被重复加载到内存中。如果使用 dll, 则只在内存中加载一次，所有使用该 dll 的进程会共享此块内存（当然，像 dll 中的全局变量这种东西是会被每个进程复制一份的）。  
   
 2） 不需编译的软件系统升级，若一个软件系统使用了 dll, 则该 dll 被改变（函数名不变）时，系统升级只需要更换此 dll 即可，不需要重新编译整个系统。事实上，很多软件都是以这种方式升级的。例如我们经常玩的星际、魔兽等游戏也是这样进行版本升级的。  
   
 3） Dll 库可以供多种编程语言使用，例如用 c 编写的 dll 可以在 vb 中调用。这一点上 DLL 还做得很不够，因此在 dll 的基础上发明了 COM 技术，更好的解决了一系列问题。

]( http://www.cppblog.com/mzty/archive/2010/11/28/134901.html )