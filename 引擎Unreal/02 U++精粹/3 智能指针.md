---
title: 3 智能指针
create_time: 2023-09-28 15:25
uid: "202309281525"
reference: []
banner: "[[Pasted image 20230928152538.png]]"
banner_header: 
banner_lock: true
---
# 八、智能指针
## 概述
UE 智能指针不能用于与 `UObject` 及其派生类不兼容。**常用于 `Uobject` 系统外的数据对象（比如自己创建的类）** 
引擎具有 `UObject` 管理的单独内存管理系统（[对象处理](https://docs.unrealengine.com/5.2/zh-CN/unreal-object-handling-in-unreal-engine)文档），两个系统未互相重叠。

### 智能指针类型

智能指针可影响其包含或引用对象的寿命。不同智能指针对对象有不同的限制和影响。下表可用于协助决定各类型智能指针的适用情况：

共享指针：最常用的指针, 用来存储。

共享引用
- 共享引用永远不会为 null，且总是可以进行解引用。
- 共享指针的性能消耗最小。所有操作所占时间都是固定的。

弱指针
1. 弱指针允许您安全地检查一个对象是否已经被销毁。
2. 使用弱引用来断开引用循环。
缺点: 最慢

### 智能指针优点
**为什么原则使用 UE 智能指针：**
1. C++原生智能指针不是在所有平台上都可用。UE 智能指针可以跨平台。
2. 可以和其他虚客器及类型无缝地协作。
3. 更好地控制平台特性、包括线程处理和优化。
4. 我们想提供线程安全的功能以获得好的性能。
5. 我们想在性能方面有更多的控制权 (内联函数、内存、虚函数的应用等)。
6. 在不需要的时候倾向于不引入新的第三方依赖。


|优点|描述|
|---|---|
|**防止内存泄漏**|共享引用不存在时，智能指针（弱指针除外）会自动删除对象。|
|**弱引用**|弱指针会中断引用循环并阻止悬挂指针。|
|**可选择的线程安全**）|虚幻智能指针库包括线程安全代码，可跨线程管理引用计数。如无需线程安全，可用其换取更好性能。|
|**运行时安全**|共享引用从不为空，可固定随时取消引用。|
|**授予意图**|可轻松区分对象所有者和观察者。|
|**内存**|智能指针在 64 位下仅为 C++指针大小的两倍（加上共享的 16 字节引用控制器）。唯一指针除外，其与 C++指针大小相同。|

**在性能上的优势**
1. 所有运算均为常量时间。
2. 共享指针解引用的速度和 C+指针一样快。
3. 复制共享指针永远不会分配内存。
4. 线程安全的版本是无锁的。
5. 和 STL 相比，其实现更快。

**劣势**
1. 创建和复制智能指针比创建和复制原始 C++指针需要更多开销
2. 保持引用计数增加基本运算的周期
3. 共享指针使用的内存比 C++指针多
4. 引用控制器有两个堆分配。使用 `MakeShared` 代替 `MakeShareable` 可避免二次分配，并可提高性能。
5. 由多个共享指针引用的每个独立对象都有性能消耗。
6.  弱指针访问速度比共享指针访问速度略慢。

**内存使用情况（在 32 位操作系统）**
1. 所有的共享指针 (TSharedPtr，TSharedRef，TWeakPtr)都占 8 个字节当针对 32 一位系统编译时)
2.  C 指针 (无符号 32 位整型)
3. 引用控制器指针无符号 32 位整型)
4. TSharedFromThis 也占 8 个字节, 因为它内嵌了弱指针/

**引用控制器（当针对 32-位系统编译时）**
1. 引用控制器对象占 12 个字节
2.  C+指针无符号 32 位整型)
3. 共享引用计数 (无符号 32 位整型)
4. 弱引]用计数 (无符号 32 位整型)
注意: 无论有多少个共享指针/弱指针引用一个对象，都仅为每个对象创建一个引用控制器。.



##  TSharedPtr

> [!NOTE] 共享指针（强指针）
> **共享指针（Shared Pointers）** 是指既健壮、又能为空指针的智能指针。**共享指针沿袭了普通智能指针的所有优点**，它能避免出现内存泄漏、悬挂指针，还能避免指针指向未初始化的内存。
> 
> **还有一些其他特点**：
> - **共享所有权（Shared Ownership）：** 引用计数支持多个共享指针，以确保它们引用的数据对象永远不被删除，前提是它们中的任意一个仍指向数据对象。
> - **自动失效（Automatic Invalidation）：** 你可安全引用易变对象，无需担心出现悬挂指针。
> - **弱引用：** 弱指针可中断引用循环。
> - **意向指示（Indication of Intent）：** 区分拥有者（参见[共享引用](https://docs.unrealengine.com/5.2/zh-CN/shared-references-in-unreal-engine)）和观察者，并提供不可为空的引用。
>     
> **共享指针有一些值得注意的基本特性，包括：**
> - 语法非常健壮
> - 非侵入性（但能反射）
> - 线程安全（视情况而定）
> - 性能佳，占用内存少
> 
> > [!NOTE] 非侵入性
> **共享指针是非侵入性的，即对象不知道其是否为智能指针拥有**。
> 


**共享指针类似于共享引用，<font color="#ff0000">主要区别在于共享指针可以指向空对象，共享引用不可为空</font>。**
除非需要空对象或可为空的对象，否则建议你**优先选择共享引用**。

### 1 声明和初始化

**共享指针可为空**，所以无论有无数据对象，都可以对它们进行初始化。

- **`MakeShared<T>() / MakeShareable() ` ：创建共享指针
- MakeShared：在单个内存块中分配新的对象实例和引用控制器，但要求对象提供公共构造函数。
- MakeShareable：效率较低，但即使对象的构造函数是私有的也可以工作，使您能够获得不是您创建的对象的所有权，并在删除对象时支持自定义行为。
- 注意**只能用于动态分配内存！`new`**
```c++
// 创建空白的共享指针
TSharedPtr<FMyObjectType> EmptyPointer;

// 为新对象创建共享指针
TSharedPtr<FMyObjectType> NewPointer(new FMyObjectType()); 
TSharedPtr<FMyObjectType> NewPointer = MakeShareable(new FMyObjectType());

// 从共享引用创建共享指针
TSharedRef<FMyObjectType> NewReference(new FMyObjectType());
TSharedPtr<FMyObjectType> PointerFromReference = NewReference;

// 创建线程安全的共享指针
TSharedPtr<FMyObjectType, ESPMode::ThreadSafe> NewThreadsafePointer = MakeShared<FMyObjectType, ESPMode::ThreadSafe>(MyArgs);
```

### 2 复制/转移

**复制共享指针时，系统将向它引用的对象添加一个引用。**

```c++
// 增加对象ExistingSharedPointer引用的引用数。
TSharedPtr<FMyObjectType> AnotherPointer = ExistingSharedPointer;
```


- **使用 `MoveTemp`（或 `MoveTempIfPossible`）函数将一个共享指针的内容转移到另一个共享指针，将原始的共享指针保留为空：**（对应 C++的 std::move）

```c++
// 将PointerOne的内容移至PointerTwo。在此之后，PointerOne将引用nullptr。
PointerTwo = MoveTemp(PointerOne);
// 将PointerTwo的内容移至PointerOne。在此之后，PointerTwo将引用nullptr。
PointerOne = MoveTempIfPossible(PointerTwo);
```

`MoveTemp` 和 `MoveTempIfPossible` 的唯一不同之处在于 `MoveTemp` 包含静态断言，强制其只能在非常量左值（lvalue）上执行。

### 3 重置
**使用 `Reset` 函数、或分配一个空指针来重置共享指针

```c++
PointerOne.Reset();
PointerTwo = nullptr;
// PointerOne和PointerTwo现在都引用nullptr。
```

### 5 比较 / 有效性

`==` `!=`：共享指针是否相等
相等被定义为两个共享指针引用同一对象。

```c++
TSharedPtr<FTreeNode> NodeA, NodeB;
if (NodeA == NodeB)
{
    // ...
}
```

- **`IsValid` 函数（是否为有效的）和 `bool` 运算符有助于判断共享指针是否引用了有效对象。
-  **`Get`**：**返回对象的原生 C++指针，若为空返回 null**

```c++
if (Node.IsValid())
{
    // ...
}
if (Node)
{
    // ...
}
if (Node.Get() != nullptr)
{
    // ...
}

//更严格的检查
if (Node.IsValid() && Node.Get())
{
    //...
}
```

### 6 解引用和访问

你可以像使用普通 C++指针那样解引用，调用方法和访问成员。你也可以像使用其他 C++指针那样，通过调用 **`IsValid`** 函数或使用重载的 `bool` 运算符，在取消引用之前执行空检查。

```c++
// 在解引用前，检查节点是否引用了一个有效对象。
if (Node)
{
    // 以下三行代码中的任意一行都能解引用节点，并且对它的对象调用ListChildren：
    Node->ListChildren();
    Node.Get()->ListChildren();  //推荐
    (*Node).ListChildren();
}
```

## TSharedRef
共享引用（强引用）

- **不可为空**，初始化必须有数据对象
- 无法重置 `Reset` 共享引用、向其指定空对象，或创建空白引用。因此**固定包含有效对象**，甚至**没有 `IsValid` 方法**。
- **与标准的 C++引用不同，可在创建后将共享引用重新指定到另一对象。

**在共享引用和共享指针之间进行选择时，除非需要空对象或可为空的对象，否则建议你优先选择共享引用。**

避免将数据作为 `TSharedRef` 或 `TSharedPtr` 参数传到函数，此操作将因取消引用和引用计数而产生开销。相反，**建议将引用对象作为 `const &` 进行传递。**
### 声明和初始化

- **`MakeShared<T>() / MakeShareable() ` ：创建共享引用

```c++
//创建共享引用
TSharedRef<FMyObjectType> NewReference(new FMyObjectType());
TSharedRef<FMyObjectType> NewReference = MakeShared<FMyObjectType>();
```

在无有效对象的情况下尝试创建的共享引用将不会编译，并尝试将共享引用初始化为空指针变量：

```c++
//以下两者均不会编译：
TSharedRef<FMyObjectType> UnassignedReference; 
TSharedRef<FMyObjectType> NullAssignedReference = nullptr;
//以下会编译，但如NullObject实际为空则断言。
TSharedRef<FMyObjectType> NullAssignedReference = NullObject;
```

### 比较
`==` `!=`：共享引用是否相等
相等表示引用相同对象。
```c++
    TSharedRef<FMyObjectType> ReferenceA, ReferenceB;
    if (ReferenceA == ReferenceB)
    {
        // ...
    }
```

## TWeakPtr


- **弱指针**存储对象的弱引用，不参与引用计数。
- **在访问弱指针引用的对象前，应使用 `Pin` 函数生成共享指针。此操作确保使用该对象时其将继续存在。**
- 如只需要确定弱指针是否引用对象，可将其与 `nullptr` 比较，或在之上调用 `IsValid`。

### 声明、初始化

**可创建空白弱指针，或通过共享指针和共享引用创建

```c++
//创建共享引用。
TSharedRef<FMyObjectType> ObjectOwner = MakeShared<FMyObjectType>();
//创建指向对象的弱指针。
TWeakPtr<FMyObjectType> ObjectObserver(ObjectOwner);
```

### 复制
与共享指针相同，弱指针是否引用有效对象，均可进行安全复制：

```c++
TWeakPtr<FMyObjectType> AnotherObjectObserver = ObjectObserver;
```

### 重置
`Reset ()` 或 `nullptr` 
```c++
//可通过将弱指针设为nullptr进行重置。
ObjectObserver = nullptr;
//也可使用重置函数。
AnotherObjectObserver.Reset();
```

### 有效性

- **`IsValid` 函数（是否为有效的）和 `bool` 运算符有助于判断共享指针是否引用了有效对象。
-  **`Get`**：返回对象指针，若为空返回 null
  
### 转换为共享指针

**`Pin` 函数将创建指向弱指针对象的共享指针。** 

共享指针（包括由 `Pin` 函数返回的指针）可在条件句中作为 `bool` 类型进行求值，其中 `true` 表示有效对象。

以下代码检查弱指针是否引用有效对象。如是，至少在共享指针（由 `Pin` 函数创建）超出范围或被显式清除前，将保证其持续有效。

```c++
    //获取弱指针中的共享指针，并检查其是否引用有效对象。
    if (TSharedPtr<FMyObjectType> LockedObserver = ObjectObserver.Pin())
    {
        //共享指针仅在此范围内有效。
        //该对象已被验证为存在，而共享指针阻止其被删除。
        LockedObserver->SomeFunction();
    }
```

### 访问对象

1. 首先使用 **`Pin`** 函数，将其转换为共享指针。
2. 然后通过共享指针或弱指针上的 **`Get`** 函数进行访问。此方法可确保使用该对象时，其将持续有效。

### 打破引用循环

两个或多个对象使用智能指针保持彼此间的强引用时，将出现引用循环。在此类情况下，对象间会相互保护以免被删除。各对象固定被另一对象引用，因此对象无法在另一对象存在时被删除。如外部对象未对引用循环中对象进行引用，其实际上将出现内存泄漏。

**弱指针不会保留自身引用的对象，因此其可中断此类引用循环。要在未拥有对象时对其进行引用，并延长其寿命时，可使用弱指针。**
### 使用警告
在以下情况中请谨慎使用弱指针：

- **在 Set 或 Map 中用作键。弱指针可能会在未通知容器的情况下随时无效，因此共享指针或共享引用更适用于充当键。可安全地将弱指针用作数值。
- 虽然弱指针提供 `IsValid` 函数，但是检查 `IsValid` 无法保证对象在任何时间长度内均可持续有效。线程安全共享指针可能会因另一线程上的活动而随时无效，因此使用线程安全共享指针应尤其注意。`Pin` 返回的共享指针将使对象在代码将其清除或其超出范围前保持活跃状态，**因此 `Pin` 函数是用于检查的首选方法，此类检查会导致取消引用或访问存储对象。**

## TUniquePtr

- 唯一指针仅会显式拥有其引用的对象。
- 唯一指针可转移所有权，但无法共享。复制唯一指针的任何尝试都将导致编译错误。
- 唯一指针超出范围时，其将自动删除其所引用的对象。
- 不要为共享指针或共享引用引用的对象创建唯一指针

### 创建 / 初始化 / 判断 / 解引用 / 重置

*   `MakeUnique ()` 创建唯一指针
*   `IsValid ()`
*   `->` 运算符
*   `Get()` 函数
*   **`Release()`** **释放并移交所有权**
*   `Reset()` 或 `nullptr` 重置
    
```c++
// 创建唯一指针
TUniquePtr<SimpleObject> ObjUniquePtr = MakeUnique<SimpleObject>();

// 判断有效性
if (ObjUniquePtr.IsValid()) 
{
    ObjUniquePtr->ExeFun(); // 解引用
}

// 释放指针，移交
TUniquePtr<SimpleObject> ObjUniquePtr2(ObjUniquePtr.Release());

// 重置
ObjUniquePtr.Reset();		
ObjUniquePtr2 = nullptr;
```
    
## 智能指针类型转换

### 引用转指针
**共享引用隐式转换为共享指针**
```c++
    TSharedPtr<FMyObjectType> MySharedPointer = MySharedReference;
```

### 指针转引用
**`ToSharedRef`**：**从共享指针创建共享引用**
- 要求共享指针引用了一个非空对象
- 从空共享指针创建共享引用将触发断言。

```c++
// 在解引用之前，请确保共享指针有效，以避免可能出现的断言。
if (MySharedPointer.IsValid())
{
    MySharedReference = MySharedPointer.ToSharedRef();
}
```

### 弱指针转强指针
**`Pin` 函数将创建指向弱指针对象的共享指针。** 

```c++
//ObjectObserver为弱指针
TSharedPtr<FMyObjectType> LockedObserver = ObjectObserver.Pin()
```


### 子类转父类
隐式转换
```c++
//SimpleObject是ComplexObject的父类
TSharedPtr<SimpleObject> simpleObj;
TSharedPtr<ComplexObject> complexObj = MakeShared<ComplexObject>();

// 派生类转基类
simpleObj = complexObj;
```

### 父类转子类
`StaticCastSharedRef` 和 `StaticCastSharedPtr` 
```c++
//SimpleObject是ComplexObject的父类
// 基类转派生类
TSharedPtr<ComplexObject> complexObj2 = StaticCastSharedPtr<ComplexObject>(simpleObj);
```

### `const` 转 `mutable`
[[《C++ Primer》#mutable关键字]]：简单理解就是把 const 转换成非 const

`ConstCastSharedRef` 和 `ConstCastSharedPtr` ：将 `const` 智能引用或智能指针分别转换为 `mutable` 智能引用或智能指针。

```c++
//创建常量指针
const TSharedPtr<SimpleObject> simpleObj_const(new SimpleObject());
//常量指针转非常量指针
TSharedPtr<SimpleObject> simpleObj_mutable = ConstCastSharedPtr<SimpleObject>(simpleObj_const);
```

## TSharedFromThis 
共享指针是非侵入性的，意味对象不知道其是否为智能指针拥有。
有些函数的参数为共享引用或共享指针，我们就需要传进去一个对象，但**如何让对象知道自己就是智能指针？**
将一个类继承自 `TSharedFromThis` 后，那么这个类的对象就会知道自己是属于哪一个共享指针。

>对标的是原生 C++的 `std::enable_shared_from_this`。用法也非常相似?? 存疑

**`TSharedFromThis` 意思就使用 `this` 指针来构造一个共享指针，通过这个共享指针可以安全的使用 this 指针。** 
其内部有一个弱指针，若要获取类实例的 this 指针，它提供两类接口 **AsShared ()** 和 **SharedThis ()**，它们会**通过 `TWeakPtr` 返回一个共享引用；

*   自定义类继承 `TSharedFromThis` 模板类
*   `AsShared()` 将 C++原生指针转换为共享引用，如果需要，我们可以再隐式转为共享指针
*   `SharedThis(this)` 会返回具备 "this" 类型的共享引用

```c++
class BaseClass : public TSharedFromThis<BaseClass>
{
    public:
        void printf(){};
}

void Func()
{
    //创建共享指针访问成员函数
    TSharedPtr<BaseClass> sharePtr = MakeShareable(new BaseClass());
    sharePtr->printf();

    //通过.Get()将共享指针解引用, 我们将可以通过智能指针获得原生C++指针
    //原生C++指针ptr指向sharePtr所指的对象
    BaseClass* ptr = sharePtr.Get(); 

    //对于普通的类，我们如果想把ptr在转换为共享指针，需要再次调用MakeShareable创建新的共享指针
    //⭐对于继承了TSharedFromThis的类，类对象知道自己是共享指针
    //因此我们可以直接使用AsShared()将指向BaseClass的C++原生指针ptr转换为共享引用
    //然后隐式转换为共享指针
    if(ptr)
    {
         TSharedPtr<BaseClass> sharePtr2 = ptr->AsShared();    
    }
```

**需要注意的是：**
① **调用 AsShared () 的对象必须是一个智能指针**，否则仍然不能保证使用 this 裸指针或对内存重复释放，在 UE4 中会触发断言；
② 在**类外部调用静态方法 `SharedThis()` 时，当前操作模块的类也必须公有继承其自身的 `TSharedFromThis`**；
③ `AsShared()` 和 `SharedThis()` **不能在构造函数内部使用**，共享引用此时并未初始化，将导致崩溃或断言。

```c++
class MyClass : public TSharedFromThis<MyClass>
{
public:
    TSharedRef<MyClass> SharedMyself()
    {
        return SharedThis(this);
    }
};

// 普通指针或对象，使用TSharedFromThis内的方法会触发断言 
TSharedPtr<MyClass> ptr = MakeShared<MyClass>();

// 通过接口获取类实例的智能引用，维护的是同一块内存，同一个计数器 
TSharedRef<MyClass> pRef1 = ptr->AsShared();
TSharedRef<MyClass> pRef2 = ptr->SharedMyself();

// 在类外部使用该接口，那么操作模块的类也必须继承其自身的TSharedFromThis 
TSharedRef<MyClass> pRef3 = SharedThis(ptr.Get());
```

## 自定义删除器

**共享指针和共享引用支持对它们引用的对象使用自定义删除器**。如需运行自定义删除代码，请**提供 lambda 函数**，作为创建智能指针时使用的参数，就像这样：

```c++
void DestroyMyObjectType(FMyObjectType* ObjectAboutToBeDeleted)
{
    // 此处添加删除代码。
}
// 这些函数使用自定义删除器创建指南指针。
TSharedRef<FMyObjectType> NewReference(new FMyObjectType(), [](FMyObjectType* Obj){ DestroyMyObjectType(Obj); });

TSharedPtr<FMyObjectType> NewPointer(new FMyObjectType(), [](FMyObjectType* Obj){ DestroyMyObjectType(Obj); });
```

## 线程安全

**通常仅在单线程上访问智能指针的操作才是安全的。**

**如需访问多线程，请使用智能指针类的线程安全版本：**

- `TSharedPtr<T, ESPMode::ThreadSafe>`
- `TSharedRef<T, ESPMode::ThreadSafe>`
- `TWeakPtr<T, ESPMode::ThreadSafe>`
- `TSharedFromThis<T, ESPMode::ThreadSafe>`

**由于原子引用计数，此类线程安全版本比默认版本稍慢，但其行为与常规 C++指针一致：**
- 读取和复制固定为线程安全。
- 写入和重置须同步后才安全。

如了解多线程永不访问指针，可通过避免使用线程安全版本获得更好性能。
