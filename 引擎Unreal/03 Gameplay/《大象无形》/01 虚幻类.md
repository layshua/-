
大器晚成，大音希声，大象无形。
![[Pasted image 20230115222649.png]]
-   **继承**（空心箭头）
-   **聚合**（实心箭头），一个对象拥有另一个对象。Actor 拥有 Actor Component
蓝色都是 Actor，橘色是 Actor Component
# 常见基类

![[5e01f6a77b6e69f39b08335af45f4650_MD5.jpg|500]]

- UObject
- Actor
- Pawn
- Controller
- Character
### UObject 类

> [!question] 什么时候该继承自 UObject 类? 什么时候应该声明一个纯 C++类?
> 
> 当需要以下功能时继承 UObject 类。

UObject是 UE4 大部分类的基类。它提供了如下几种功能：

![[1973fd181d34b367eaa73e5a4fd549b7_MD5.jpg]]
1.  Garbage collection **垃圾收集**
    - C++的内存管理由程序员完成，何时释放内存很棘手。UE 提供了两个解决方案：
    - （1）继承自 UObject 类, 同时指向 UObject 类实例对象的指针成员变量，使用 `UPROPERTY` 宏进行标记。虚幻引擎的 UObject 架构会自动地**被 `UPROPERTY` 标记的变量**考虑到垃圾回收系统中，在没有其他地方引用时候，定期清理，释放内存。自动地进行对象的生命周期管理。
    - （2）采用**智能指针**。请注意, **只有非 UObject 类型，才能够使用智能指针进行自动内存释放**。
2. Reference updating **引用自动更新**
3. Reflection **反射**
    - 运行时能获取一个类，动态创建类的对象，并且能动态获取到类有哪些函数和成员变量等，UE4 的蓝图中大量使用了反射技术。
4. Serialization **序列化**
5. Automatic updating of default property changes **自动检测默认变量的更改**
6. Automatic property initialization **自动变量初始化**
7. Automatic editor integration **和虚幻引擎编辑器的自动交互**
8. Type information available at runtime **运行时类型识别**
    - 请注意，虚幻引擎打开了/GR-编译器参数。意味着你无法使用 C++标准的 RTTI 机制: `dynamic_cast`。UE 实现了一套自己的、更高效的运行时类型识别的方案。**如果你希望使用，请继承自 UObject 类，然后使用 `Cast<>` 函数来完成。**
9. Network replication **网络复制**
    - 当你在进行网络游戏开发 （c/s 架构）时, 你一定希望能够自动地处理变量的同步。而继承自 UObject 类，其被宏标记的变量能够自动地完成网络复制的功能。从服务器端复制对应的变量到客户端。

综上所述，当你需要这些功能的时候，你的这个类应该继承自 UObject 类。
请注意: UObject 类会在引擎加载阶段，创建一个 Default Object 默认对象。这意味着:
- 构造函数并不是在游戏运行的时候调用，同时即便你只有一个 UObject 对象存在于场景中, 构造函数依然会被调用两次。
- 构造函数被调用的时候，UWorld 不一定存在。`GetWorld()`返回值有可能为空!


### Actor 类

所有可以放入关卡的对象都是 **Actor**，比如摄像机、静态网格体、玩家起始位置。Actor 支持三维变换，例如平移、旋转和缩放。你可以通过游戏逻辑代码（C++或蓝图）创建（生成）或销毁 Actor。

在 C++中，`AActor` 是所有 Actor 的基类。

注意：Actor 不直接保存变换（位置、旋转和缩放）数据；如 Actor 的根组件存在，则使用它的变换数据。

> [!question] 什么时候该继承自 Actor 类
> 需要挂载组件的时候

Actor 的字面意思是演员。

在 UE4 中 Actor 拥有这样的能力：**它能够被挂载组件**。

UE 的 Component 和和 Unity 中的 Component 不同！
- Unity 中，一个对象可以挂载多个脚本组件，每个脚本组件是一个单独的类。
- UE 中一个场景实体对应一个类，**组件不是类，组件只是组件！** 类似 Unity 脚本组件的功能在 UE 中用继承自 Actor 类的子类来实现。

![[1040341fdeaf2123fdf8add79225f020_MD5.jpg]]

如上，如果需要它被渲染，可以挂一个静态网格组件，或者骨架网格体组件
如果需要它移动，可以直接在 Actor 类中写代码或者挂一个 Movement 组件。
#### Actor 组件

组件被创建时与其包含的 Actor 相关联。

组件的主要类型有：

-    `UActorComponent`：最适用于抽象行为，例如移动、物品栏或属性管理，以及其他非物理概念。Actor 组件没有变换，即它们在场景中不存在任何物理位置或旋转。**不存在于场景中的任意特定位置。它们通常用于概念上的功能，如 AI 或解译玩家输入。**

-    `USceneComponent`：SceneComponents 是拥有变换的 ActorComponents。变换是场景中的位置，由位置、旋转和缩放定义。SceneComponents 能以层级的方式相互附加。Actor 的位置、旋转和缩放取自位于层级根部的SceneComponent。支持基于位置的行为，这类行为不需要几何表示。这包括弹簧臂、摄像机、物理力和约束（但不包括物理对象），甚至音频。
    
-  `UPrimitiveComponent`：PrimitiveComponent 是拥有一类图像表达（如网格体或粒子系统）的 SceneComponent。诸多有趣的物理和碰撞设置均在此处。

Actor 支持拥有一个 SceneComponent 的层级。每个 Actor 也拥有一个 `RootComponent` 属性，将指定作为 Actor 根的组件。Actor 自身不含变换，因此不带位置、旋转，或缩放。它们依赖于其组件的变换，具体来说是其根组件的变换。**如果此组件是一个 SceneComponent，其将提供 Actor 的变换信息。否则 Actor 将不带变换。其他附加的组件拥有相对于其附加到的组件的变换。**

![[Pasted image 20230826161240.png]]


### Pawn 类

在国际象棋中，Pawn（翻译：兵/卒） 代表的是：兵/卒

![[eee81f393376a8786c638b6eabe292ed_MD5.jpg|198]]

Pawn 类提供了被 “操作” 的特性。他能被 Controller 控制。
就像一个棋手，控制这个棋子。一旦脱离棋手就无法自主行动

### Character 类
![[Pasted image 20230115225829.png]]
Character 类代表一个角色，它继承自 Pawn，提供了一个特殊组件：**Character Movement**。这个组件提供了一个基础的，**基于胶囊体（CapsuleComponent）** 的角色移动功能。包括移动和跳跃，还能扩展出蹲伏和爬行等。
![[b822fae4a1d16b63aeccd92312078af9_MD5.jpg|450]]

> [!question] 什么时候该继承自 Pawn，什么时候该继承自 Character
> 看是否需要**Character Movement**组件
> - 所以如果你的游戏角色是人类或这两足怪物的话，特别适合使用 Character 类。
> - 如果你的 Pawn 类十分简单，或者不需要这样的移动逻辑（比如飞机），那么可以不继承这个类

### Controller 类

Controller 是一种可以控制 `Pawn` 或 Pawn 的派生类（如 `Character`），从而控制其动作的非实体 Actor。可以把它看作是下棋的棋手，或者提线木偶的操作者。

![[48a96ad32e3217302ffcf634ee29a044_MD5.jpg]]

它既可以是玩家，比如 `Player Controller` 类，通过键盘或者手柄输入来操作游戏角色（可以在 Player Controller 类中绑定输入）。
也可以是电脑 AI，比如 `AI Controller` 类来操作游戏中的 NPC 和怪物等角色 （可以 AI Controller 类中使用行为树/EQS 环境查询系统）。

为何虚幻引擎采用这样的设计？Epic 给出的理由非常简单:“不同的怪物也许会共享同样的 Controller，从而获得类似的行为”。即棋手可以通过 `Possess/UnPossess` 操纵多种棋子。

![[2335a0d74602ec1194ba6a229a8946f8_MD5.jpg]]
**Pawn/Character 拥有的只是简单的前进、转向、跳跃、开火等函数。而 Controller 则是能调用这些函数。**

> [!NOTE]
> 当您设置 PlayerController 时，您需要考虑的一个事情就是您想在 PlayerController 中包含哪些功能及内容。
> 
> 您可以在 **Pawn** 中处理所有输入，尤其是不太复杂的情况下。但是，**如果您的需求非常复杂，比如在一个游戏客户端上的多玩家、或实时地动态修改角色的功能，那么最好 `PlayerController` 中处理输入。** **在这种情况中，PlayerController 决定要干什么，然后将命令（比如"开始蹲伏"、"跳跃"）发布给 Pawn。**
> 
> 同时，**某些情况下，则必须把输入处理或其他功能放到 PlayerController 中**。PlayerController 在整个游戏在过程中都是一直存在的，但是 Pawn 可能是临时存在的。比如，在死亡竞技模式的游戏中，您可能死了又重生，所以您将获得一个新的 Pawn，但是您的 PlayerController 都是一样的。在这个示例中，如果您将分数保存到您的 Pawn 上，那么分数将会重置，但是如果您将分数保存到 PlayerController 上，它将不会重置。

# 创建自己的 C++ 类

![[a2de28b8beaedfb1041bc82904442d90_MD5.jpg]]


### 创建 C++ 类
**标准的虚幻引擎模块文件结构：**
![[Pasted image 20230828173115.png]]
1.  虚幻引擎中每个游戏性类都由一个类头文件 `.h` 和一个类源文件`.cpp `构成。`.h ` 文件放在 `public` 文件夹内，`.cpp ` 文件放置在 `private` 文件夹内。 
2. 在`.h` 中声明你的类：如果你的类继承自 `UObject`，你的类名上方需要加入 **`UCLASS()`** 宏。同时，你需要在类体的第一行添加 `GENERATED_UCLASS_BODY()` 宏，或者 **`GENERATED_BODY() `** 宏，主要是为了实现类的反射用。
    - 前者需要手动实现一个带有 `const FObject Initializer&` 参数的构造函数。
    - 后者需要手动实现一个无参数构造函数。注意笔者说的是“实现”而非声明。
3.  在你的 .cpp 文件中，包含当前模块的 PCH 文件。一般是 `模块名+private PCH.h`。如果是游戏模块，有可能包含的是 **`游戏工程名.h`**
4. 每个类头文件需要包含生成的头文件（自动创建）**`ClassName.generated.h`**
5.  编译。

![[e46e76278309fd6e265ec8581e6c917c_MD5.jpg]]

### UE类名规则

虚幻引擎中的类拥有一个标准化的命名方案，通过首字母或前缀即可立即明了其为哪种类。类的前缀有：
- `F`　纯 C++类
- `U`　继承自 UObject，但不继承自 Actor，无法被实例到世界场景中，必须从属于 Actor
- `A`　继承自 Actor
- `S`　Slate 控件相关类 
- `H`　HitResult 相关类

**虚幻引擎头文件工具 Unreal Header Tool（简称UHT）** 会在编译前检查你的类命名。如果类的命名出现错误，那么它会提出警告并终止编译。
![[40e49e2d717588aca8dcb325381445da_MD5.jpg|500]]


## 对象

### 类对象的产生

在标准 C++ 中，一个类产生一个对象，被称为 “实例化”。标准 C++ 一般是通过 `new` 的关键字来实例化一个对象。

![[a3cbfeec00cefa0a68934c677da014be_MD5.jpg]]

在虚幻引擎中，实例化一个类的对象需要判断类的父类，使用不同的实例化方法：
1.  如果你的类是一个纯 C++类型（F 开头），你可以通过 `new` 来产生对 
象。
2.  如果你的类继承自 UObject 但不继承自 Actor，你需要通过 
`NewObject` 函数来产生出对象。
3.  如果你的类继承自 AActor，你需要通过 `SpawnActor` 函数来产生出对 
象。

![[cee78b9f9e15f8137e3c1c58781a884b_MD5.jpg]]
### 类对象的获取

获取一个类对象的唯一方法，就是通过某种方式传递到这个对象的 指针或引用。

我们可以通过 Actor 迭代器：`TActorItertor`，来获取当前场景的某种 Actor 的所有实例，如下代码：

```c++
for (TActorItertor<AActor> Iter(GetWorld()); Iter; ++Iter)
{
   // 调用这个Actor的某个你需要成员函数等
   Iter->YourFunction();
   
   //等价
   *(Iter).YourFunction(); 
}
```
其中 TActorIterator 的泛型参数不一定是 Actor，可以是你需要查找的其他类型。
### 类对象的销毁

一个类的对象需要销毁，一有如下几种方式：

![[df3425f9c326b0ac042aebaf06d01b5e_MD5.jpg]]

#### 纯 C++类
1. 纯 C++ 类在函数体中创建，而且不是通过 new 来分配内存，自动销毁。
```c++
void func1() 
{
   FMyClass myObj = FMyClass();
   // do something 
   // 函数结束时，局部变量自动销毁
}
```

2. （要谨慎使用）纯 C++ 类使用 new 来分配内存，而且直接传递类的指针。需要 delete 来手动删除。否则内存泄漏

```c++
void func1() 
{
  FMyClass *myObj = new FMyClass();
  // do something
  delete myObj;
}
```

3. 纯 C++ 类使用 new 来分配内存，同时使用智能指针 `TSharedPtr/TSharedRef` 来管理。根据引用计数自动释放。

#### UObject 类

UObject 采用自动垃圾回收机制。当一个类的成员变量包含指向 UObject 的对象，同时又带有 `UPROPERTY` 宏定义，那么这个成员变量将会触发引用计数机制。
垃圾回收器会定期从根节点 Root 开始检查，当一个 UObject 没有被别的任何 UObject 引用，就会被垃圾回收。你可以通过 `AddToRoot` 函数来让一个 UObject 一直不被回收。


#### Actor 类

Actor 类对象可以通过调用 `Destory` 函数来请求销毁，这样的销毁意味着将当前 Actor 从所属的世界中“摧毁”。但是对象对应内存的回收依然是由系统决定。

## 从 C++ 到蓝图

> [!question] Title
> 虚幻引擎的蓝图真是太好用了，我该如何让蓝图能够调用我的 
C++类中的函数呢？

### UPROPERTY 宏

当你需要将一个 UObject 类的子类的成员变量注册到蓝图中时，你只需要借助 `UPROPERTY` 宏即可完成。
>关于能够在 UPROPERTY 中使用的参数，请阅读官方文档
```c++
UPROPERTY(BlueprintReadWrite,VisibleAnywhere,Category="Object")
```


### UFUNCTION 宏

我们使用 `UFUNCTION` 宏来注册成员函数到蓝图

```c++
UFUNCTION(BlueprintCallable,Category="Test")
```

`BlueprintCallable` 表示这个函数可以被蓝 图调用，可选的还有：`BlueprintImplementEventBlueprintNativeEvent`。 
前者表示，这个成员函数由其蓝图的子类实现，你不应该尝试在 C++中给出函数的实现，这会导致链接错误。
后者表示，这个成员函数提供一个“C++的默认实现”，同时也可以被蓝图重载。你需要提供一个`函数名_Implement`为名字的函数实现，放置于.cpp 中。

比如我们创建了一个 MyActor 类，并注册了 MyPlayerName 的成员变量和 HelloUE5 () 的函数，如下图：

![[5149b4d1dd07600fb70f0c46255a8f2e_MD5.jpg]]
## 游戏性框架概述
行为树和网络架构（鸽）
# 引擎系统相关类简介

引擎中常用的一些工具实用类如下：

![[c0259438bc46dc2e622ae3d441992757_MD5.jpg]]

### 正则表达式
正则表达式，又称正规表示法、常规表示法。
正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的 一些特定字符，以及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。

在虚幻引擎 4 使用正则表达式，首先，我们要添加头文件。
```c++
#include "Regex.h"
//需要注意的是，此头文件是放在Core模块里的。一般我们不需要额外在Build.cs里添加了。
```

通过 `FRegexPattern` 来创建一个正则表达式，然后通过 `FRegexMatcher` 驱动正则表达式的运行。

`FRegexMatcher` 提供多个函数，如返回查找字符的起始位置、结束 位置、设置查找区间等。
但是我们最常用的还是 `FindNext()`这个函数。它会返回一个 bool 值，表示是否查找到匹配表示式的内容。

```c++
#include "Regex.h"
FString TextStr("ABCDEFGHIJKLMN");
FRegexPattern TestPattern(TEXT("C.+H")); //TEXT里的内容就是正则表达式的具体内容
FRegexMatcher TestMacher(TestPattern, TestStr);

if (TestMacher.FindNext())
{
  UE_LOG(MyLog, Warning, TEXT("找到匹配内容 %d ~ %d"), 
  TestMacher.GetMatchBeginning(),
  TestMacher.GetMatchEnding()); //输出 找到匹配内容 2-8
}
```

### FPaths  路径管理器

在 Core 模块中，虚幻引擎提供了一个用于路径相关处理的类：FPaths。主要提供了 3 类 “工具” 性质 API：

1. **具体路径类**： `FPaths::GameDir()` 获取游戏根目录
2. **工具类**：`FPaths::FileExists()` 判断一个文件是否存在。
3. **路径转换类**：`FPaths::ConvertRelativePathToFull()` 将相对路径转换为绝对路径。

由于 FPaths 类中的函数众多，这里不一一列举。

### XML 与 Json

**XML**：可以使用 FastXML 与 FXmlFile 进行解析与处理。
**Json**：可以使用 FJsonSerializer 与 FJsonValue 等来进行解析与处理。


### 文件读写与访问
虚幻引擎提供了**与平台无关的文件读写与访问接口**，即 `FPlatformFileManager`。

该类定义于头文件 `PlatformFilemanager.h ` 中，所属模块为 Core，一般虚幻引擎会默认包含本模块，如果没有，请手动在当前模块的. build. cs 中包含。

通过以下调用：
```c++
FPlatformFileManager::Get ()->GetPlatformFile ()
//获得一个IPlatformFile类型的引用。这个接口即提供了通用的文件访问接口
```

**常用函数如下：**
略，见《大象无形》7.4 节

### GConfi 类
使用 GConfi 类读写配置文件
7.5 节

### UE_LOG

Log 作为开发中常用到的功能，可以在任何需要情况下记录程序运行情况。

#### 查看 Log

**Game 模式**
在 Game（打包）模式下，记录 Log 需要在启动参数后加`-Log`。 
**编辑器模式**
在编辑器下，需要打开 Log 窗口（Window->DeveloperTools->OutputLog）。

#### 使用Log
```c++
UE_LOG(LogMy, Warning, TEXT("Hell World"));
UE_LOG(LogMy, Warning, TEXT("Show a String %s"),*FString("Hello")) 
UE_LOG(LogMy, Warning, TEXT("Show a Int %d"),100);
```
可以通过 UE_LOG (LogMy, Warning, TEXT ("Hello world")); 来输出 log，第一个参数为 Log 的分类，需要预设。第二个参数为类型，有 Log，Warning，Error 三种类型，其中 Log 为灰色，Warning 为黄色，Error 为红色。具体的输出为 TEXT，内容可以自己构造。

#### 自定义 Log 的 Category

我们自己定义 Category 的宏，如下代码：

```
DEFINE_LOG_CATEGORY_STATIC(LogMy, Warning, All);
```

### 字符串

在虚幻引擎中字符串有三种类型：FName，FText，FString。

**FName**：无法修改，大小写不敏感，其实 FName 内部只是一个整数索引，实际的字符串内容是在一个公用的字符串表中保存，非常省内存。

**FText**：无法修改，用来显示，支持本地化和多国语言。

**FString**：允许修改，区分大小写。最为灵活，不过比其他两种字符串，略为耗一些内存。

引擎相关类的总体内容如下：

![[62b82bc981eb26ffd7fc3a1d371ed7c2_MD5.jpg]]

至此，本节的内容就讲的差不多了！我们学会了创建自己的类，对象，C++ 与蓝图，以及一些引擎相关实用类等！下节我们会分享虚幻引擎的模块机制相关，敬请期待！！