设计计虚幻引擎的 Gameplay 技能系统时，有三大注意事项。
1. **追踪技能的所有者**（和网络复制中的 ownership 不是一个概念）：技能及其效果必须维持所有权的概念。当一种效果运行计算时，它需要知道其所有者是谁，以便使用其属性，当一种技能的作用会让玩家得分时，它需要知道哪个玩家拥有它，以便正确给分。
2. **追踪技能的状态**：
    - 技能激活时。
    - 技能目前正在执行中时。
    - 技能完全完成并且不再处于活动状态时。
3. **协调技能的执行**：技能必须能够在执行期间使用特定时序与多个不同的系统交互。这些交互可以包括：
# Gameplay 技能系统的组件

Gameplay 技能系统指在处理所有这些用例，方法是**将技能建模为负责自身执行的完全独立的实体**。

该系统由多个组件构成：
- 带有 **技能系统组件（`Ability System Component`）** 的所属Actor，维持该Actor拥有的所有技能的列表，并处理激活。
- **Gameplay技能蓝图（`Gameplay Ability Blueprints`）** ，表示各个技能，并协调其游戏内执行。
    - 由 **Gameplay技能任务（`Gameplay Ability Tasks`）** 以及其他函数构成。
- **属性集（`Attribute Set`）** ，附加到 Ability System Component。
    - 包含 **Gameplay属性（`Gameplay Attributes`）** ，用于驱动计算或表示资源。
- **Gameplay效果（`Gameplay Effects`）** ，处理Actor因使用技能而发生的更改。
    - **Gameplay效果计算（`Gameplay Effect Calculations`）** ，提供模块化、可复用的方法来计算效果。
    - **Gameplay提示（`Gameplay Cues`）** ，与Gameplay效果关联，并提供数据驱动的方法来处理视觉效果。

## 追踪所有权

你需要将 `Ability System Component` 附加到 Actor，该 Actor 才能使用 Gameplay 技能。
- 此组件负责为 Actor 添加和去除技能，追踪 Actor 拥有的技能，以及激活技能。
- 它还是技能系统上下文中所属 Actor 的主要表示，提供一个系统来追踪属性、持续进行的效果、**Gameplay 标签（Gameplay Tags）** 和 **Gameplay 事件（Gameplay Events）** 以及直接访问所属 Actor 的接口。  

在多人游戏中，技能系统组件还负责将信息复制到客户端，将玩家动作传达到服务器，并验证客户端是否有权更改技能系统组件的状态。技能系统组件的父Actor必须属于本地控制的玩家才能远程激活。

## Gameplay Ability
### 处理技能及其执行

`Gameplay Ability`是一个蓝图对象，**负责执行技能的所有事件**，包括播放动画，触发效果，从所有者获取属性，以及显示视觉效果。

#### 控制激活 Activate

你主要有四种方法 **激活（Activate）** `Gameplay Ability`：

1. **使用 Gameplay 技能句柄（`Gameplay Ability Handle`）** 通过蓝图或 C++代码显式激活技能。这在授予技能时由 `Ability System Component` 提供。
2. **使用 Gameplay 事件**。这会使用匹配的技能触发器触发所有技能。如果你需要抽象输入和决策机制，此方法非常适合，因为它提供了最大的灵活度。
3. **通过匹配的 Tags 使用 Gameplay 效果**。这会使用匹配的技能触发器触发所有技能。这是<mark style="background: #FF5582A6;">触发技能的 Gameplay 效果的首选方法</mark>。典型用例是休眠减益，它触发的技能会播放禁用动画，并禁止其他游戏动作。
4. 使用 **输入代码（Input Codes）** 。这些会添加到 `Ability System Component`，在调用时会触发匹配的所有技能。其运作方式类似于 Gameplay 事件。

> [!tip]
> `Gameplay Ability` 可以表示一组范围广泛的游戏内动作，不限于玩家显式使用的能力或咒语。击中反应或以上例子的休眠动画，都是很好的例子。

当你 **激活** Gameplay 技能时，系统会将该技能识别为进行中。接着，它会触发 Attach 到激活事件的代码，遍历每个函数和 Gameplay Tasks，直到你调用 `Finish` 函数来表示技能已完成执行。如果你需要执行额外的清理，你可以将更多代码附加到 `On Finished` 事件。你还可以 `Cancel` 技能，使其在执行中途停止。

Gameplay技能使用Gameplay标签来限制执行。所有技能都有在激活时会添加到其所属Actor的标签列表，以及阻止激活或自动取消该技能的标签列表。虽然你可以使用自己的代码手动取消、阻止或允许技能的执行，但这里提供了在整个系统内一致的方法。

#### 控制执行 Execution

`Gameplay Ability` 支持各种常见用例，例如技能冷却和分配资源成本，并且有一个预制的 `Gameplay Ability Tasks` 库，用于处理动画和其他常见的引擎系统。

虽然标准蓝图函数节点会立即完成执行，但 `Gameplay Ability Tasks` 会追踪它们是处于不活动状态、进行中还是已完成，并且可以编程为在执行期间触发其他事件。它们还可以追踪其父 `Gameplay Ability` 是否已取消并相应清理。
游戏通过扩展 `Gameplay Ability Tasks` 来实现自定义 Gameplay 逻辑是很常见的做法。

`Gameplay Ability` 还可以响应 Gameplay 事件，它们是通用事件监听器，等待从所属 Actor 接收 Gameplay 标签和 **事件数据（Event Data）** 结构体。

### 属性集和属性

Gameplay 技能系统主要通过 **属性集（Attribute Sets）** 与 Actor 交互，其中包含 **Gameplay 属性（Gameplay Attributes）** 。这些是可在计算中使用或由 Gameplay 技能修改的数字浮点值。它们可用于你需要的任意目的，但**常见用例包括追踪角色的生命值或击中点**，以及角色的核心统计数据值（例如力量和智能）。

虽然你可以使用基本变量来表示这些值，但 `Gameplay Attributes` 可带来多项**优势**：
- 属性集提供了一组一致、可复用的属性，可用于构建系统。
- Gameplay Ability 可以通过反射访问 Gameplay Attributes，以便可以直接在蓝图编辑器中创建简单的计算和效果。
- Gameplay Attributes 会单独追踪默认值、当前值和最大值，这样就更容易创建临时修改（增益和减益）以及持久效果。
- Gameplay Attributes 还会将其值复制到所有客户端，适合直观地显示敌方血条等本地 UI。

> [!quote] 使用方法
> 要使 Actor 能够使用 `Gameplay Attributes`，你必须将其添加到其 `Ability System Component`。在此之后，`Ability System Component` 可以自动访问你分配给 `Attribute Sets` 的属性。  

### 处理Gameplay效果

GAS 会使用 `Gameplay Effects` 将**更改**应用于 Gameplay Ability 的目标 Actor。这些可以是一次性的效果，例如应用伤害，也可以是持久效果，例如持续的毒素伤害、增益和减益。
就持久效果而言，`Gameplay Effects` 会将自身附加到目标 Actor，直到去除为止，并且它们可以预设为拥有有限的生命周期，此后将到期并自行清理，撤销对目标 Actor 的 `Gameplay Attributes` 的所有更改。

`Gameplay Effects` 使用 `Gameplay Effect Calculations` 来基于 `Gameplay Attributes` 处理计算。
虽然你可以直接在蓝图编辑器中创建简单的计算，但你还可以编写逻辑更复杂并且一次可影响多个属性的自定义效果计算。这些能够处理来自 Gameplay 技能的所属 Actor 和目标 Actor 的信息，以便你可以将常用计算集中放到一个可复用的代码片段中。 

### 处理美化（Cosmetic）效果

`Gameplay Cues` 是负责运行视觉和声音效果的 Actor 和 UObject，是在多人游戏中复制美化反馈的首选方法。
创建 `Gameplay Cues` 时，你会运行要在事件图表中播放的效果的逻辑。`Gameplay Cues` 可以与一系列 Gameplay 标签关联，并且匹配这些标签的 `Gameplay Effects` 将自动应用它们。

例如，**如果你将标签 Ability.Magic.Fire.Weak 添加到 Gameplay 提 `Gameplay Cues`，拥有 Ability.Magic.Fire.Weak 的 `Gameplay Effects` 将自动生成该 `Gameplay Cues` 并运行它**。这样就可以快速轻松创建视觉效果的通用库，而不必手动从代码触发它们。
 
或者，你也可以触发没有 Gameplay Effects 关联的 Cue 。有关此实现的例子，你可以查看 Lyra 示例游戏的武器发射反馈。

`Gameplay Cues` 不使用可靠的复制，因此有可能一些客户端没有接收到提示或显示其反馈。如果你将 Gameplay 代码绑定到这些 Cue，这可能造成不同步。因此，`Gameplay Cues` 应该仅用于美化反馈。对于需要复制到所有客户端的 Gameplay 相关反馈，你应该转而依赖 Ability Tasks 来处理复制。**播放蒙太奇（Play Montage）** 技能任务就是很好的例子。 

# 支持网络多玩家 (鸽)

Gameplay技能提供了一些内置功能来支持联网多人游戏，但存在一些局限性和指南，你应该加以注意。其中许多指南反映了一般网络多人游戏最佳实践。

### 技能系统组件和复制

为节省带宽和防止作弊，技能系统组件不将其完整状态复制到所有客户端。具体而言，它们不将技能和Gameplay效果复制到所有客户端，只复制它们影响的Gameplay属性和标签。

### 复制技能和使用预测

网络游戏中的大部分技能都应该在服务器上运行并复制到客户端，因此技能激活时通常有延迟。这在大部分快节奏的多人游戏中是不能接受的。要掩盖这种延迟，你可以在本地激活技能，然后向服务器表明你已将其激活，以便服务器可以跟上。

有可能服务器会拒绝技能激活，这意味着它必须撤销技能在本地做出的更改。你可以使用 **本地预测的** 技能处理这些情况。为提供帮助，当授予效果的技能被服务器拒绝时，一些Gameplay效果支持回滚。这包括大部分非瞬时Gameplay效果，但要注意，伤害以及其他瞬时属性/标签更改等不包括在内。

### 使用技能与服务器拥有的对象交互

Gameplay技能可以处理与机器人、NPC以及其他由服务器拥有的Actor和对象之间的交互。你必须通过本地拥有的Actor（通常是玩家的Pawn）以及复制的技能或调用服务器函数的另一个非GAS机制来执行此操作。这会将交互复制到服务器，后者接着有权执行对NPC的更改。