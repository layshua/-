---
banner: "![[Pasted image 20230101204819.png]]"
banner_y: 0.33
---
# 1 概念
DX12较之上个版本主要改变：性能优化方面大大减少了 CPU 开销，改进了对多线程的支持。性能提升！

通过 Direct3D 这种底层**图形应用程序编程接口（Application Programming Interface, API)**, 即可在在应用程序中对**图形处理器 (Graphics Processing Unit, GPU)** 进行控制和编程。我们能够借此以硬件加速的方式渲染出虚拟的 3D 场景。

**渲染目标（render target）** 是为了渲染场景而将像素绘制到的特定缓冲区 (buffer)。通常是占用部分显存的后台缓冲区，以及纹理（详见后文）。

**像素（pixl）**  是构成图像的基本元素。从图形角度来讲，可认为像素是一种图像的采样单位（将图像以像素为基础进行划分，再于像素中进行采样)。因此，两张同样大小的图片，分辨率高者，意味着像素数量越多，细节越丰富，画面就越清晰。由于实际显示上的原因（后面注释会提到)，也赋予了像素“大小”的概念。**在 Direct3D 中，像素被抽象为具有一定长宽的色块。**

**纹素 (texel)** ：构成纹理的基本元素又称纹素，**通常我们将纹素视为像素**。尽管后台缓冲区是一个纹理, 但我们仍常将其组成元素称为像素，因为就后台缓冲区这种情况而言，它所存储的内容是颜色信息。即便纹理中存储的不是颜色信息，大家有时也称纹理的元素为像素（如“法线图中的像素”)。**至于二者是否需要区分，具体还要看应用场景。** 比如谈到像素与纹素的映射关系时，必须将这两个概念予以区分。文中谈到的基本上是约定俗成的叫法。

**采样 ( sampling )**：又称取样，本是信号处理方面的术语。在本书中, 可认为该操作是以特定的模式，从连续的图像数据中采集出离散的关键颜色信息。

**显存（GPU memory）**：也有直译作 GPU 内存等。显卡通常是一块带有 PCIe 总线接口的物理电路（这里仅谈独立显卡)。
GPU 较之于显卡的地位大致相当于 CPU 较之于主板。相应的，GPU 控制的显存基本相当于 CPU 控制的内存，而后者在本书中也常被称为系统内存 ( system memory)。CPU 内部有多级缓存与寄存器，分别用于缓存指令与控制 CPU; GPU 内部亦有缓存与寄存器，分别用于缓存纹理、缓存着色器指令等以及控制 GPU。有的文献在划分 GPU 的组成结构时，会把 GPU 的寄存器及其控制的内存统称为 GPU memory ( GPU 存储器)。
## 组件对象模型
**组件对象模型 (Component Object Model, COM)** 是一种令 DirectX 不受编程语言束缚，并且使之向后兼容的技术。
我们通常将 COM 对象视为一种接口，但考虑当前编程的目的，遂将它当作一个 C++类来使用。用 C++语言编写 DirectX 程序时，COM 帮我们隐藏了大量底层细节。

**不使用 C++的 new 和 delete**：
要获取指向某 COM 接口的指针，需借助特定函数或另一 COM 接口的方法一而不是用 C+语言中的关键字 new 去创建一个 COM 接口。
COM 对象会统计其引用次数；因此，在使用完某接口时，我们便应调用它的 Release 方法 (COM 接口的所有功能都是从 IUnknown 这个 COM 接口继承而来的，包括 Release 方法在内)，而不是用 delete 来别删除——当 COM 对象的引用计数为 0 时，它将自行释放自己所占用的内存。

为了**辅助用户管理 COM 对象的生命周期**，Windows 运行时库 (Windows Runtime Library, WRL)专门为此提供了 `Microsoft::WRL: ComPtr` 类 ( `#include <wrl.h>`), 我们可以把它当作是 **COM 对象的智能指针**。当一个 `ComPtr` 实例超出作用域范围时，它便会自动调用相应 COM 对象的 Release方法，继而省掉了我们手动调用的麻烦。本书中常用的 3 个 `ComPtr` 方法如下。
1. `Get`：返回一个指向此底层 COM 接口的指针。此方法常用于把原始的 COM 接口指针作为参数传递给函数。例如：
```c++ nums
ComPtr<ID3D12Rootsignature> mRootsignature;
......
//SetGraphicsRootsignature 需要获取 ID3D12 RootSignature*类型的参数
mCommandList->SetGraphicsRootsignature (mRootsignature.Get());
```

2. `GetAddressof`: 返回指向此底层 COM 接口指针的地址。凭此方法即可利用函数参数返回 COM接口的指针。例如：
```c++ nums
ComPtr<ID3D12CommandAllocator> mDirectCmdListAlloc;
ThrowIfFailed(md3dDevice->CreateCommandAllocator (
		D3D12 COMMAND LIST TYPE DIRECT,
		mDirectCmdListAlloc. GetAddressof ())
	);
```
3. `Reset` : 将此 ComPtr 实例设置为 nullptr 释放与之相关的所有引用（同时减少其底层 COM 接口的引用计数)。此方法的功能与将 ComPtr 目标实例赋值为 nullptr 的效果相同。

> [!NOTE] 
> COM 接口都以大写字母“I”作为开头。例如，表示命令列表的 COM 接口为  
> `ID3D12GraphicsCommandList`
> 
## 纹理格式
**2D 纹理（2D texture)** 是一种由数据元素构成的矩阵（可将此“矩阵”看作 2D 数组)。它的用途之一是存储 2D 图像数据，在这种情况下，纹理中每个元素存储的都是一个像素的颜色。
然而，纹理的用处并非仅此而已。例如，有种称作法线贴图 (normal mapping)的高级技术，其纹理内的每个元素存储的就是一个 3D 向量而不是颜色信息。因此，尽管纹理给人的第一印象通常是用来存储图像数据，但其实际用途却十分广泛。简单来讲，1D、2D、3D 纹理就相当于特定数据元素所构成 1D、2D、3D 数组。但随着后续章节中对纹理讨论的逐渐深入，我们便会知道，**纹理其实还不只是像“数据数组”那样简单。它们可能还具有多种 mipmap 层级，而 GPU 则会据此对它们进行特殊的处理**，例如运用过滤器（filter)和进行多重采样（multisample)。**另外，并不是任意类型的数据元素都能用于组成纹理，它只能存储 `DXGI FORMAT` 枚举类型中描述的特定格式的数据元素。** 下面是一些相关的格式示例：
1. `DXGI FORMAT R32G32B32 FLOAT`: 每个元素由 3 个 32 位浮点数分量构成。
2. `DXGI FORMAT R16G16B16A16 UNORM`: 每个元素由 4 个 16 位分量构成，每个分量都被映射到$[0,1]$区间。
3. `DXGI FORMAT R32G32UINT`: 每个元素由 2 个 32 位无符号整数分量构成。
4. `DXGI FORMAT R8G8B8A8 UNORM`: 每个元素由 4 个 8 位无符号分量构成，每个分量都被映射到$[0,1]$区间。
5. `DXGI FORMAT R8G8B8A8 SNORM`: 每个元素由 4 个 8 位有符号分量构成，每个分量都被映射到$[-1,1]$ 小区间。
6. `DXGI FORMAT R8G8B8A8SINT`: 每个元素由 4 个 8 位有符号整数分量构成，每个分量都被
映射到 $[-128,127]$ 区间。
7. `DXGI FORMAT R8G8B8A8UINT`: 每个元素由 4 个 8 位无符号整数分量构成，每个分量都被
映射到 $[0,255]$ 区间。

颜色都是由红、绿、蓝“**三基色**” (注意美术中的“三原色”是指红黄蓝！)组合而成（例如，红色和绿色混合成黄色)。alpha 通道（或称为 alpha 分量)则通常用于控制透明度。
然而，正如前文所述，尽管格式名称在字面上指示的是颜色和 lpha 值，但**纹理存储的却不一定是颜色信息**。例如，格式 `DXGI FORMAT R32G32B32 FLOAT` 中含有 3 个浮点数分量，因此可以利用坐标格式为浮点数的方式存储任意 3D 向量。除此之外，亦有**无类型 (typeless)格式的纹理，我们仅用它来预留内存**，待纹理被绑定到渲染流水线 (rendering pipeline, 详见第 5 章)之后，再具体解释它的数据类型（有点像 C++语言里的强制转换 2）。例如，下面的无类型格式保留的是由 4 个 16 位分量组成的元素，但并没有指出数据的具体类型（例如，是整数、浮点数还是无符号整数？）：`DXGI FORMAT R16G16B16A16 TYPELESS`
我们将在第 6 章中看到 `DXGI FORMAT` 枚举类型也可用于描述顶点以及索引的数据格式。

## 交换链和页面翻转
**为了避免动画中出现画面闪烁的现象，最好将动画帧完整地绘制在一种称为<mark style="background: #FF5582A6;"><mark style="background: #FF5582A6;">后台缓冲区</mark></mark>的<mark style="background: #FF5582A6;">离屏</mark>(off-screen, 即不可直接呈现在显示设备上之意)<mark style="background: #FF5582A6;">纹理</mark>内。** 只要将指定动画帧的整个场景绘到后台缓冲区中，它就会以一个完整的帧画面展现在屏幕上；依照此法，观者便不会察觉出帧的绘制过程一而只会观赏到完整的动画帧。为此，需要利用由硬件管理的两种纹理缓冲区：即所谓的**前台缓冲区 (front buffer)** 和**后台缓冲区 (back buffer)** 。
**前台缓冲区存储的是当前显示在屏幕上的图像数据，而动画的下一帧则被绘制在后台缓冲区里。**
当后台缓冲区中的动画帧绘制完成之后，两种缓冲区的角色互换：后台缓冲区变为前台缓冲区呈现新一帧的画面，而前台缓冲区则为了展示动画的下一帧转为后台缓冲区，等待填充数据。前后台缓冲的这种互换操作称为**呈现 (presenting, 亦有译作提交、显示等)**。呈现是一种高效的操作，只需交换指向当前前台缓冲区和后台缓冲区的两个指针即可实现。
![[Pasted image 20230406150703.png]]
>图 4.1 对于第 n 帧来讲，当前显示的是缓冲区 A 中的内容，我们将把下一帧的数据渲染到此时的后台缓冲区 B 内。一旦后台缓冲区绘制完毕，两个缓冲区的指针将互换，即缓冲区 B 将变成前台缓冲区，而缓冲区 A 则成为新的后台缓冲区。接下来，我们会把下一帧的内容渲染到缓冲区 A 中。待后台缓冲区（即此时的缓冲区 A)完成绘制，两个缓冲区的指针再次互换，即在第+2 帧中，缓冲区 A 重新成为前台缓冲区，缓冲区 B 则再次客串后台缓冲区

**前台缓冲区和后台缓冲区构成了<mark style="background: #FF5582A6;">交换链（swap chain)</mark>**, 在 Direct3D 中用 `IDXGISwapChain` 接口来表示。这个接口不仅存储了前台缓冲区和后台缓冲区两种纹理，而且还提供了修改缓冲区大小(`IDXGISwapChain::ResizeBuffers`)和呈现缓冲区内容 (`IDXGISwapChain::Present`)的方法。**使用两个缓冲区（前台和后台)的情况称为<mark style="background: #FF5582A6;">双缓冲</mark> (double buffering, 亦有译作双重缓冲、双倍缓冲等)。** 当然，也可以运用更多的缓冲区。例如，使用 3 个缓冲区就叫作三重缓冲（triple buffering, 亦有译作三倍缓冲等)。对于一般的应用来说，使用两个缓冲区就足够了。

> [!NOTE] 
> 尽管后台缓冲区是一个纹理（因而构成纹理的基本元素又称纹素，texel), 但我们仍常将其组成元素称为像素，因为就后台缓冲区这种情况而言，它所存储的内容是颜色信息。即便纹理中存储的不是颜色信息，大家有时也称纹理的元素为像素（如“法线图中的像素”)。
> 至于二者是否需要区分，具体还要看应用场景。比如谈到像素与纹素的映射关系时，必须将这两个概念予以区分。文中谈到的基本上是约定俗成的叫法。


## 深度缓冲
**<mark style="background: #FF5582A6;">深度缓冲区（depth buffer)</mark>这种<mark style="background: #FF5582A6;">纹理</mark>资源存储的并非图像数据，而是特定像素的深度信息。**
深度值的范围为 0.0~1.0。0.0 代表观察者在视锥体（view frustum）中能看到离自己最近的物体，1.0 则代表观察者在视锥体中能看到离自己最远的物体。
**深度缓冲区中的元素与后台缓冲区内的像素呈一一对应关系（即后台缓冲区中第 i 行第 j 列的元素对应于深度缓冲区内第 i 行第 j 列的元素)。** 所以，如果后台缓冲区的分辨率为 1280×1024，那么深度缓冲区中就应当有 1280×1024 个深度元素。
为了确定不同物体间的像素前后顺序，Direct3D 采用了一种叫作深度缓冲 (depthbuffering)或 z 缓冲 (z-buffering, 其中的 z 指 z 坐标)的技术。**这里要着重强调一个细节：若使用了深度缓冲，则物体的绘制顺序也就变得无关紧要了。**

总而言之，深度缓冲技术的原理是计算每个像素的深度值，并执行深度测试 (depth test)。而深度测试则用于对竞争写入后台缓冲区中同一像素的多个像素深度值进行比较。具有最小深度值的像素（说明该像素离观察者最近)会获得最终的胜利，它将被写入后台缓冲区中。这样做也是合乎情理的，因为离观察者较近的像素无疑会遮挡其后面的像素。
**深度缓冲区也是一种纹理，所以一定要用明确的数据格式来创建它。深度缓冲可用的格式包括以下几种：**
1. `DXGI_FORMAT_D32_FLOAT_S8X24_UINT`: 该格式共占用 64 位，取其中的 32 位指定一个浮点型深度缓冲区，另有 8 位（无符号整数)分配给模板缓冲区（stencil buffer), 并将该元素映射到$[0,255]$区间，剩下的 24 位仅用于填充对齐（padding)不作他用。
2. `DXGI_FORMAT_D32_FLOAT`: 指定一个 32 位浮点型深度缓冲区。
3. `DXGI_FORMAT_D24_UNORM_S8_UINT`: 指定一个无符号 24 位深度缓冲区，并将该元素映射
到 $[0,1]$ 区间。另有 8 位（无符号整型)分配给模板缓冲区，将此元素映射到$[0,255]$区间。
4. `DXGI_FORMAT_D16_UNORM`: 指定一个无符号 16 位深度缓冲区，把该元素映射到 $[0, 1]$ 区间。

> [!NOTE] 
> **一个应用程序不一定要用到模板缓冲区。但一经使用，则深度缓冲区将总是与模板缓冲区如影随形，共同进退**。例如，32 位格式 `DXGI_FORMAT_D24_UNORM_S8_UINT` 使用 24 位作为深度缓冲区，其他 8 位作为模板缓冲区。**出于这个原因，深度缓冲区叫作深度/模板缓冲区更为得体。** 

## 资源与描述符
在渲染处理的过程中，GPU 可能会对资源进行读和写两种操作。**在发出绘制命令之前，我们需要将与本次<mark style="background: #FF5582A6;">绘制调用 (draw call) </mark>相关的资源<mark style="background: #FF5582A6;">绑定 (bind 或称链接，link)</mark> 到渲染流水线上。**
部分资源可能在每次绘制调用时都会有所变化，所以我们也就要每次按需更新绑定。但是，GPU 资源并非直接与渲染流水线相绑定，而是要通过一种名为**描述符（descriptor)** 的对象来对它间接引用，我们可以**把描述符视为一种对送往 GPU 的资源进行描述的轻量级结构。** 
从本质上来讲，它实际上即为一个中间层; 若指定了资源描述符，GPU 将既能获得实际的资源数据，也能了解到资源的必要信息。因此，**我们将把绘制调用需要引用的资源，通过指定描述符的方式绑定到渲染流水线。**
**为什么我们要额外使用描述符这个中间层呢?** 究其原因，GPU 资源实质都是一些普通的内存块。由于资源的这种通用性，它们便能被设置到渲染流水线的不同阶段供其使用。一个常见的例子是先把纹理用作渲染目标 (即 Direct3D 的绘制到纹理技术)，随后再将该纹理作为一个着色器资源（即此纹理会经采样而用作着色器的输入数据)。不管是充当渲染目标、深度/模板缓冲区还是着色器资源等角色，仅靠资源本身是无法体现出来的。而且，我们有时也许只希望将资源中的部分数据绑定至渲染流水线，但如何从整个资源中将它们选取出来呢? 再者，创建一个资源可能用的是无类型格式，这样的话，GPU 甚至不会知道这个资源的具体格式。
解决上述问题就是引入描述符的原因。除了指定资源数据, 描述符还会为 GPU 解释资源: 它们会告知 Direct3D 某个资源将如何使用 (即此资源将被绑定在流水线的哪个阶段上)，而且我们可借助描述符来指定欲绑定资源中的局部数据。这就是说，如果某个资源在创建的时候采用了无类型格式，那么我们就必须在为它创建描述符时指明其具体类型。

> [!NOTE] 视图（view)与描述符（descriptor)是同义词
> **“视图”虽是 Direct3D 先前版本里的常用术语，但它仍然沿用在 Direct3D 12 的部分 API 中。**在本书里，两者交替使用**，例如，“常量缓冲区视图 ( constant buffer view)”与“常量缓冲区描述符 ( constant buffer descriptor )"表达的是同一事物。

**每个描述符都有一种具体类型，此类型指明了资源的具体作用。** 本书常用的描述符如下：
1. CBV/SRV/UAV 描述符分别表示的是常量缓冲区视图（ constant buffer view)、着色器资源视图( shader resource view)和无序访问视图 ( unordered access view )这 3 种资源。
2. 采样器（ sampler，亦有译为取样器）描述符表示的是采样器资源（用于纹理贴图)。
3. RTV 描述符表示的是渲染目标视图资源 ( render target view )。
4. DSV 描述符表示的是深度/模板视图资源 ( depth/stencil view )。

**描述符堆 ( descriptor heap )** 中存有一系列描述符（可将其看作是描述符数组)，本质上是存放用户程序中某种特定类型描述符的一块内存。**我们需要为每一种类型的描述符都创建出单独的描述符堆。另外，也可以为同一种描述符类型创建出多个描述符堆**。
**我们能用多个描述符来引用同一个资源**。例如，可以通过多个描述符来引用同一个资源中不同的局部数据。而且，前文曾提到过，一种资源可以绑定到渲染流水线的不同阶段。因此，**对于每个阶段都需要设置独立的描述符**。例如，当一个纹理需要被用作渲染目标与着色器资源时，我们就要为它分别创建两个描述符: 一个 RTV 描述符和一个 SRV 描述符。类似地，如果以无类型格式创建了一个资源，又希望该纹理中的元素可以根据需求当作浮点值或整数值来使用，那么就需要为它分别创建两个描述符: 一个指定为浮点格式，另一个指定为整数格式。
**创建描述符的最佳时机为初始化期间**。由于在此过程中需要执行一些类型的检测和验证工作，所以**最好不要在运行时 ( runtime)才创建描述符**。

> [!NOTE] 
> 2009 年 8 月的 SDK 文档写到:“所谓创建一个完整类型的资源，即在资源创建的伊始就确定了它的具体格式。这将使运行时的访问操作得到优化。”因此，当确实需要用到无类型资源所带来的灵活性时 (即根据不同的视图对同一种数据进行多种不同解释的能力)，再以这种方式来创建资源，否则应创建完整类型的资源。

## 多重采样技术原理
由于屏幕中显示的像素不可能是无穷小的"，所以并不是任意一条直线都能在显示器上“平滑”而完美地呈现出来。图 4.4 所示的，即为以像素矩阵 ( matrix of pixels，可以理解为“像素 2D 数组”)逼近直线的方法所产生的“阶梯”**( aliasing，锯齿状走样）** 效果。类似地，显示器中呈现的三角形之边也存在着不同程度的锯齿效应。
![[Pasted image 20230406155546.png|350]]
通过提高显示器的分辨率就能够缩小像素的大小, 继而使上述问题得到显著地改善, 使阶梯效应在很大程度上不易被用户所察觉。
在不能提升显示器分辨率, 或在显示器分辨率受限的情况下，我们就可以运用各种**反走样 ( antialiasing, 也有译作抗锯齿、反锯齿、反失真等)** 技术。有一种名为**超级采样（ supersampling，可简记作 SSAA，即 Super Sample Anti-Aliasing）** 的反走样技术，它使用 4 倍于屏幕分辨率大小的后台缓冲区和深度缓冲区。3D 场景将以这种更大的分辨率渲染到后台缓冲区中。当数据要从后台缓冲区调往屏幕显示的时候, 会将后台缓冲区按 4 个像素一组进行**解析 ( resolve，或称降采样，downsample )**。把放大的采样点数降低回原采样点数每组用求平均值的方法得到一种相对平滑的像素颜色。因此，超级采样实际上是通过软件的方式提升了画面的分辨率。
**超级采样是一种开销高昂的操作**，因为它将像素的处理数量和占用的内存大小都增加到之前的 4 倍。对此，**Direct3D 还支持一种在性能与效果等方面都较为折中的反走样技术**，叫作**多重采样 (multisampling, 可简记作 MSAA，即 MultiSample Anti-Aliasing )**。这种技术通过跨子像素共享一些计算信息，从而使它比超级采样的开销更低。现假设采用 4X 多重采样（即每个像素中都有 4 个子像素)，并同样使用 4 倍于屏幕分辨率的后台缓冲区和深度缓冲区。值得注意的是，这种技术并不需要对每一个子像素都进行计算，而是仅计算一次像素中心处的颜色，再基于可视性 (每个子像素经深度/模板测试的结果)和覆盖性 (子像素的中心在多边形的里面还是外面?)将得到的颜色信息分享给其子像素 。图 4.5 展示了一个多重采样的相关实例。
![[Pasted image 20230406155909.png]]

> [!NOTE] 超级采样和多重采样的关键区别
> 对于超级采样来说，图像颜色要根据每一个子像素来计算，因此每个子像素都可能各具不同的颜色。
> 而以多重采样的方式来求取图像颜色时，每个像素只需计算一次，最后，再将得到的颜色数据复制到多边形覆盖的所有可见子像素之中。由于计算图像颜色是图形流水线中开销最大的步骤之一，所以用多重采样来代替超级采样对节省资源而言意义非凡。但是话说回来，超级采样的精准度确实更高一筹。

图 4.5 所示的是一种将每个像素都以均匀栅格划分为 4 个子像素的反锯齿采样模式。实际上，每家硬件厂商所采用的模式 (即选定的子像素位置，可以说决定了采样的位置)可能会各不相同，而 Direct3D 也并没有定义子像素的具体布局。在各种特定的情况下，不同的布局模式各有千秋。

**利用 Direct3D 进行多重采样:P87**
## 功能级别
从 Direct3D 11 开始便引进了**功能级别 ( feature level )** 的概念（在代码里用枚举类型 D3D_ FEATURE_LEVEL 表示)，以下参数大致对应于 Direct3D 9 到 Direct3D 11 之间的各种版本":
```c++ nums
enum D3D_FEATURE_LEVEL
{
	D3D_ FEATURE_ LEVEL_9_1 = 0x9100,
	D3D FEATURE_ LEVEL_9_2  = 0x9200,
	D3D FEATURELEVEL93 = 0x9300,
	D3D FEATURE LEVEL_10_o = 0xa000,
	D3D FEATURE LEVEL101 = 0xal00,
	D3D FEATURE_LEVEL_11_0 = 0xb000,
	D3D_ FEATURE_ LEVEL_11_1 = Oxb100
}D3D_FEATURE_LEVEL;
```
“功能级别”为不同级别所支持的功能进行了严格的界定（每个功能级别所支持的特定功能可参见 SDK 文档)。例如，一款支持功能级别 11 的 GPU，除了个别特例之外 (像类似于多重采样数量这样的信
息仍然需要查询，因为 Direct3D 规范允许这些 Direct3D 11硬件在此方面有各自不同的实现)，必须支持完整的 Direct3D 11 功能集。功能集使程序员的开发工作更加便捷——只要了解所支持的功能集, 就能知道有哪些 Direct3D 功能可供使用。
如果用户的硬件不支持某特定功能级别，应用程序理当回退至版本更低的功能级别。例如，为了照顾更多用户，一款应用程序可能会支持 Direct3D 11、10 乃至 9.3 级别的硬件。应用程序当按照从最新到最旧的级别支持顺序展开检测: 首先检测 Direct3D 11 是否被支持，其次检测 Direct3D 10，最后检测 Direct3D 9.3。**在本书中，我们总是假设需要支持的功能级别为 D3D_FEATURE_LEVEL_11_0**。但是在现实的应用程序中，我们往往需要考虑支持稍旧的硬件，以获得更多的用户。
## DirectX 图形基础结构
**DirectX 图形基础结构 (DirectX Graphics Infrastructure，DXGI，也有译作 DirectX 图形基础设施）**，是一种与 Direct3D 配合使用的 API。设计 DXGI 的基本理念是使多种图形 API 中所共有的底层任务能借助一组通用 API 来进行处理。例如，为了保证动画的流畅性，2D 渲染与 3D 渲染两组 API 都要用到交换链和页面翻转功能，这里所用的交换链接口 `IDXGISwapChain` (详见 4.1.4 节）实际上就属于 DXGI API。
DXGI 还用于处理一些其他常用的图形功能，如切换全屏模式 ( full-screen mode。另一种是窗口模式，windowed mode )，枚举显示适配器、显示设备及其支持的显示模式 (分辨率、刷新率等）等这类图形系统信息。除此之外，它还定义了 Direct3D 支持的各种表面格式信息( `DXGI_FORMAT` )。
我们刚刚简单地叙述了 DXGI 的概念，下面来介绍一些在 Direct3D 初始化时会用到的相关接口。`IDXGIFactory` 是 DXGI 中的关键接口之一, 主要用于创建 `IDXGISwapChain` 接口以及枚举显示适配器。而显示适配器则真正实现了图形处理能力。通常来说，**显示适配器（ display adapter )** 是一种硬件设备 (例如独立显卡), 然而系统也可以用软件显示适配器来模拟硬件的图形处理功能。一个系统中可能会存在数个适配器（比如装有数块显卡)。适配器用接口 `IDXGIAdapter` 来表示。
另外，一个系统也可能装有数个显示设备。**我们称每一台显示设备都是一个<mark style="background: #FF5582A6;">显示输出 ( display output</mark> 有的文档也作 adapter output，适配器输出)实例**，用 IDXGIOutput 接口来表示。每个适配器都与一组显示输出相关联。

**设置代码见 P89**

## 功能支持的检测
P92
```c++ nums
HRESULT ID3D12Device::CheckFeatureSupport (
D3D12_FEATURE Feature, //用于指定我们]希望检测的功能支持类型。

void *pFeaturesupportData, //检测图形适配器中 GPU的硬件体系架构特性。

UINT FeaturesupportDatasize); //检测对给定纹理格式的支持情况
```

## 资源驻留
复杂的游戏会运用大量纹理和 3D mesh 等资源，但是其中的大多数并不需要总是置于显存中供 GPU 使用。例如，让我们来构想这样一个游戏场景: 在野外的森林中，有一个巨大的洞穴。在玩家进入洞穴之前，绘制画面并不会用到与洞穴相关的资源; 当玩家进入洞穴之后，又不再需要森林数据资源。
**在 Direct3D 12 中, 应用程序通过控制资源在显存中的去留，主动管理资源的驻留情况 (即 residency 。无论资源是否本已位于显存中，都可对其进行管理。在 Direct3D 11 中则由系统自动管理)。** 该技术的基

