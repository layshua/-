
---
title: 1持久化对象
aliases: []
tags: []
create_time: 2023-06-15 21:26
uid: 202306152126
banner: "![[1686835479404.png]]"
---

创建保存和加载：
- 根据按键产生随机立方体。
- 使用泛型类型和虚方法。
- 将数据写入文件并读回。
- 保存游戏状态，以便稍后加载。

## 按需创建对象

### 游戏逻辑

因为我们的游戏非常简单，所以我们将使用一个 `Game` 组件脚本来控制它。它会产生立方体，为此我们将使用预制件。因此，它应该包含一个公共字段来连接预制实例。

```
using UnityEngine;

public class Game : MonoBehaviour {

	public Transform prefab;
}
```

将一个游戏对象添加到场景中，并将此组件附加到场景中。然后创建一个默认立方体，将其变成预制体，并为游戏对象提供一个引用。

![](<images/1686835479985.png>)

![](<images/1686835480539.png>)


```
void Update () {
		if (Input.GetKeyDown(createKey)) {
			Instantiate(prefab);
		}
	}
```

###  随机化立方体

让我们随机化我们创建的每个立方体的位置。

使用静态 [Random](http://docs.unity3d.com/Documentation/ScriptReference/Random.html).insideUnitSphere属性获取一个随机点，将其放大到五个单位的半径，并将其用作最终位置。因为这不仅仅是一个微不足道的实例化，所以将代码放在一个单独的 `CreateObject` 方法中，并在按键时调用它。

```
void Update () {
		if (Input.GetKeyDown(createKey)) {

			CreateObject();
		}
	}

	void CreateObject () {
		Transform t = Instantiate(prefab);
		t.localPosition = Random.insideUnitSphere * 5f;
	}
```

![](<images/1686835481678.png>)

Randomly placed cubes. 随机放置的立方体。

让我们给每个立方体一个随机旋转，我们可以使用静态 [Random](http://docs.unity3d.com/Documentation/ScriptReference/Random.html).rotation 属性。

```
void CreateObject () {
		Transform t = Instantiate(prefab);
		t.localPosition = Random.insideUnitSphere * 5f;
		t.localRotation = Random.rotation;
	}
```

![](<images/1686835482240.png>)

Randomized rotations. 随机旋转。

最后，我们还可以改变立方体的大小。我们将使用均匀缩放的立方体，所以它们总是完美的立方体，只是大小不同。静态 [Random](http://docs.unity3d.com/Documentation/ScriptReference/Random.html). [Range](http://docs.unity3d.com/Documentation/ScriptReference/RangeAttribute.html) 方法可用于获取某个范围内的随机 float 值 。让我们从0.1号的小立方体到1号的常规立方体。要将该值用于刻度的所有三个维度，只需将 [Vector3](http://docs.unity3d.com/Documentation/ScriptReference/Vector3.html).one 与之相乘，然后将结果指定给局部刻度。

```
void CreateObject () {
		Transform t = Instantiate(prefab);
		t.localPosition = Random.insideUnitSphere * 5f;
		t.localRotation = Random.rotation;
		t.localScale = Vector3.one * Random.Range(0.1f, 1f);
	}
```

![](<images/1686835482807.png>)


### 开始新游戏

如果我们想开始一个新的游戏，我们必须退出游戏模式，然后再次进入。但这只有在Unity Editor中才有可能。玩家需要退出我们的应用程序并重新启动它才能玩新游戏。**如果我们能在保持游戏模式的同时开始一个新的游戏，那就更好了。**
如果按下了一个键，则调用新的 `BeginNewGame` 方法。我们一次只能处理一个键，所以如果没有按 C 键，只检查 N 键。

```
void Update () {
		if (Input.GetKeyDown(createKey)) {
			CreateObject();
		}
		else if (Input.GetKey(newGameKey)) {
			BeginNewGame();
		}
	}

	void BeginNewGame () {}
```

### 跟踪对象

我们的游戏可以生成任意数量的随机立方体，这些立方体都会添加到场景中。但 `Game` 对它产生的东西没有记忆。为了摧毁立方体，我们首先需要找到它们。为了实现这一点，我们将让 `Game` 跟踪它实例化的对象的引用列表。

```
List<Transform> objects;
```


```
void Awake () {
		objects = new List<Transform>();
	}
```

接下来，通过的 `Add` 方法，每次实例化一个新的列表时，都会向列表添加 Transform引用。

```
void CreateObject () {
		Transform t = Instantiate(prefab);
		t.localPosition = Random.insideUnitSphere * 5f;
		t.localRotation = Random.rotation;
		t.localScale = Vector3.one * Random.Range(0.1f, 1f);
		objects.Add(t);
	}
```

### 清除 List

现在我们可以循环浏览 `BeginNewGame` 中的列表，并销毁所有实例化的游戏对象。这与数组的工作原理相同，只是列表的长度是通过其 `Count` 属性找到的。

```
void BeginNewGame () {
		for (int i = 0; i < objects.Count; i++) {
			Destroy(objects[i].gameObject);
		}
	}
```

这给我们留下了一个被破坏对象的引用列表。我们也必须通过调用 `Clear` 方法清空列表来消除这些问题。

```
void BeginNewGame () {
		for (int i = 0; i < objects.Count; i++) {
			Destroy(objects[i].gameObject);
		}
		objects.Clear();
	}
```

## 抽象存储
**该节略过，可以直接使用我写的 PlayerPrefsDataManager**
### Game Data Writer and Reader  
游戏数据编写器和阅读器

为了隐藏读取和写入数据的细节，我们将创建自己的读取器和编写器类。让我们从编写器开始，将其命名为 `GameDataWriter` 。

```
using System.IO;
using UnityEngine;

public class GameDataWriter {

	BinaryWriter writer;
}
```

A new object instance of our custom writer type can be created via `**new** **GameDataWriter**()`. But this only makes sense if we have a writer to wrap. So create a custom constructor method with a `[BinaryWriter](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=BinaryWriter)` parameter. This is a method with the type name of its class as its own name, which also acts as its return type. It replaces the implicit default constructor method.  
我们的自定义编写器类型的新对象实例可以通过 `new GameDataWriter()` 创建。但这只有在我们有一个作家的情况下才有意义。因此，创建一个带有 BinaryWriter 参数的自定义构造函数方法。这是一个方法，其类的类型名作为自己的名称，也作为其返回类型。它替换了隐式默认构造函数方法。

```
public GameDataWriter (BinaryWriter writer) {
	}
```

Although invoking a constructor method results in a new object instance, such methods don't explicitly return anything. The object gets created before the constructor is invoked, which can then take care of any required initialization. In our case, that's simply assigning the writer parameter to the object's field. As I've used the same name for both, I have to use the `**this**` keyword to explicitly indicate that I'm referring to the object's field instead of the parameter.  
尽管调用构造函数方法会产生一个新的对象实例，但这样的方法不会显式返回任何内容。在调用构造函数之前创建对象，然后构造函数可以处理任何所需的初始化。在我们的例子中，这只是将writer参数分配给对象的字段。由于我对两者使用了相同的名称，所以我必须使用 `**this**` 关键字来明确表示我指的是对象的字段，而不是参数。

```
public GameDataWriter (BinaryWriter writer) {
		this.writer = writer;
	}
```

The most basic functionality is to write a single `**float**` or `**int**` value. Add public `Write` methods for this, simply forwarding the invocation to the actual writer.  
最基本的功能是写入一个 `**float**` 或 `**int**` 值。为此添加公共#2方法，只需将调用转发给实际的编写器即可。

```
public void Write (float value) {
		writer.Write(value);
	}

	public void Write (int value) {
		writer.Write(value);
	}
```

Besides that, also add methods to write a `[Quaternion](http://docs.unity3d.com/Documentation/ScriptReference/Quaternion.html)`—for rotations—and a `[Vector3](http://docs.unity3d.com/Documentation/ScriptReference/Vector3.html)`. These methods have to write all the components of their parameter. In the case of a quaternion, that's four components.  
除此之外，还添加了一些方法来编写 `[Quaternion](http://docs.unity3d.com/Documentation/ScriptReference/Quaternion.html)` -用于旋转和 `[Vector3](http://docs.unity3d.com/Documentation/ScriptReference/Vector3.html)` 。这些方法必须写入其参数的所有组件。在四元数的情况下，这是四个分量。

```
public void Write (Quaternion value) {
		writer.Write(value.x);
		writer.Write(value.y);
		writer.Write(value.z);
		writer.Write(value.w);
	}
	
	public void Write (Vector3 value) {
		writer.Write(value.x);
		writer.Write(value.y);
		writer.Write(value.z);
	}
```

Next, create a new `**GameDataReader**` class, using the same approach as for the writer. In this case, we wrap a `[BinaryReader](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=BinaryReader)`.  
接下来，使用与编写器相同的方法创建一个新的 `**GameDataReader**` 类。在这种情况下，我们包装一个 `[BinaryReader](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=BinaryReader)` 。

```
using System.IO;
using UnityEngine;

public class GameDataReader {

	BinaryReader reader;

	public GameDataReader (BinaryReader reader) {
		this.reader = reader;
	}
}
```

Give it methods that are simply named `ReadFloat` and `ReadInt`, that forward the invocations to `ReadSingle` and `ReadInt32`.  
给它简单命名为 `ReadFloat` 和 `ReadInt` 的方法，将调用转发到 `ReadSingle` 和 `ReadInt32` 。

```
public float ReadFloat () {
		return reader.ReadSingle();
	}

	public int ReadInt () {
		return reader.ReadInt32();
	}
```

Also create `ReadQuaternion` and `ReadVector3` methods. Read their components in the same order that we write them.  
同时创建 `ReadQuaternion` 和 `ReadVector3` 方法。按照我们编写它们的相同顺序读取它们的组件。

```
public Quaternion ReadQuaternion () {
		Quaternion value;
		value.x = reader.ReadSingle();
		value.y = reader.ReadSingle();
		value.z = reader.ReadSingle();
		value.w = reader.ReadSingle();
		return value;
	}

	public Vector3 ReadVector3 () {
		Vector3 value;
		value.x = reader.ReadSingle();
		value.y = reader.ReadSingle();
		value.z = reader.ReadSingle();
		return value;
	}
```

### Persistable Objects 持久性对象

Now it's a lot simpler to write the transform data of cubes in `**Game**`. But we can go one step further. What if `**Game**` could simply invoke `writer.Write(objects[i])`? That would be very convenient, but would require `**GameDataWriter**` to know the details of writing a game object. But it's better to keep the writer simple, limited to primitive values and simple structs.  
现在，在 `**Game**` 中编写Cube的转换数据要简单得多。但我们可以更进一步。如果 `**Game**` 可以简单地调用 `writer.Write(objects[i])` 呢？这将是非常方便的，但需要#3知道编写游戏对象的细节。但最好保持作者的简单，仅限于原始值和简单的结构。

We can turn this reasoning around. `**Game**` doesn't need to know how to save a game object, that's the responsibility of the object itself. All the object needs is a writer to save itself. Then `**Game**` could use `objects[i].Save(writer)`.  
我们可以扭转这种推理 `**Game**` 不需要知道如何保存游戏对象，这是对象本身的责任。对象所需要的只是一个写入程序来保存自己。那么#1可以使用#2。

Our cubes are simple objects, without any custom components attached. So the only thing that's to save is the transform component. Let's create a `**PersistableObject**` component script that knows how to save and load that data. It simply extends `[MonoBehaviour](http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.html)` and has a public `Save` method and `Load` method with a `**GameDataWriter**` or `**GameDataReader**` parameter respectively. Have it save the transform position, rotation, and scale, and load them in the same order.  
我们的Cube是简单的对象，没有附加任何自定义组件。因此，唯一要保存的是变换组件。让我们创建一个 `**PersistableObject**` 组件脚本，它知道如何保存和加载数据。它只是扩展了 `[MonoBehaviour](http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.html)` ，并有一个公共的 `Save` 方法和 `Load` 方法，分别带有 `**GameDataWriter**` 或 `**GameDataReader**` 参数。让它保存变换位置、旋转和缩放，并按相同顺序加载它们。

```
using UnityEngine;

public class PersistableObject : MonoBehaviour {

	public void Save (GameDataWriter writer) {
		writer.Write(transform.localPosition);
		writer.Write(transform.localRotation);
		writer.Write(transform.localScale);
	}

	public void Load (GameDataReader reader) {
		transform.localPosition = reader.ReadVector3();
		transform.localRotation = reader.ReadQuaternion();
		transform.localScale = reader.ReadVector3();
	}
}
```

The idea is that a game object that can be persisted only has one `**PersistableObject**` component attached to it. Having multiple such components makes no sense. We can enforce this by adding the `[DisallowMultipleComponent](http://docs.unity3d.com/Documentation/ScriptReference/DisallowMultipleComponent.html)` attribute to the class.  
这个想法是，一个可以持久化的游戏对象只有一个 `**PersistableObject**` 组件。拥有多个这样的组件是没有意义的。我们可以通过将 `[DisallowMultipleComponent](http://docs.unity3d.com/Documentation/ScriptReference/DisallowMultipleComponent.html)` 属性添加到类中来强制实现这一点。

```
[DisallowMultipleComponent]
public class PersistableObject : MonoBehaviour {

	…
}
```

Add this component to our cube prefab.  
将此组件添加到我们的立方体预制件中。

![](<images/1686835485537.png>)

Persistable prefab. 持久预制。

### Persistent Storage 持久性存储

Now that we have a persistent object type, let's also create a `**PersistentStorage**` class to save such an object. It contains the same saving and loading logic as `**Game**`, except that it only saves and loads a single `**PersistableObject**` instance, provided via a parameter to public `Save` and `Load` methods. Make it a `[MonoBehaviour](http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.html)`, so we can attach it to a game object and it can initialize its save path.  
既然我们有了一个持久对象类型，那么让我们创建一个 `**PersistentStorage**` 类来保存这样的对象。它包含与 `**Game**` 相同的保存和加载逻辑，只是它只保存和加载一个 `**PersistableObject**` 实例，该实例通过参数提供给公共 `Save` 和 `Load` 方法。让它成为 `[MonoBehaviour](http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.html)` ，这样我们就可以将它附加到游戏对象上，它就可以初始化其保存路径。

```
using System.IO;
using UnityEngine;

public class PersistentStorage : MonoBehaviour {

	string savePath;

	void Awake () {
		savePath = Path.Combine(Application.persistentDataPath, "saveFile");
	}

	public void Save (PersistableObject o) {
		using (
			var writer = new BinaryWriter(File.Open(savePath, FileMode.Create))
		) {
			o.Save(new GameDataWriter(writer));
		}
	}

	public void Load (PersistableObject o) {
		using (
			var reader = new BinaryReader(File.Open(savePath, FileMode.Open))
		) {
			o.Load(new GameDataReader(reader));
		}
	}
}
```

Add a new game object to the scene with this component attached. It represents the persistent storage of our game. Theoretically, we could have multiple such storage objects, used to store different things, or to provide access to different storage types. But in this tutorial we use just this single file storage object.  
将一个新的游戏对象添加到附加了该组件的场景中。它代表了我们游戏的持久存储。理论上，我们可以有多个这样的存储对象，用于存储不同的东西，或者提供对不同存储类型的访问。但是在本教程中，我们只使用了这个单独的文件存储对象。

![](<images/1686835486080.png>)

Storage object. 存储对象。

### Persistable Game 持久性游戏

To make use of the new persistable object approach, we have to rewrite `**Game**`. Change the `prefab` and `objects` content type to `**PersistableObject**`. Adjust `CreateObject` so it can deal with this type change. Then remove all the code specific to reading from and writing to files.  
为了使用新的持久化对象方法，我们必须重写 `**Game**` 。将 `prefab` 和 `objects` 内容类型更改为 `**PersistableObject**` 。调整#4，使其能够处理此类型的更改。然后删除所有特定于读取和写入文件的代码。

```
using System.Collections.Generic;

using UnityEngine;

public class Game : MonoBehaviour {

	public PersistableObject prefab;

	…

	List<PersistableObject> objects;



	void Awake () {
		objects = new List<PersistableObject>();

	}

	void Update () {
		…
		else if (Input.GetKeyDown(saveKey)) {

		}
		else if (Input.GetKeyDown(loadKey)) {

		}
	}
	
	…

	void CreateObject () {
		PersistableObject o = Instantiate(prefab);
		Transform t = o.transform;
		…
		objects.Add(o);
	}








}
```

We'll have `**Game**` rely on a `**PersistentStorage**` instance to take care of the details of storing data. Add a public `storage` field of this type, so we can give `**Game**` a reference to our storage object. To again save and load the game state, we have `**Game**` itself extend `**PersistableObject**`. Then it can load and save itself, using the storage.  
我们将让 `**Game**` 依赖 `**PersistentStorage**` 实例来处理存储数据的细节。添加一个这种类型的公共#2字段，这样我们就可以给#3一个对存储对象的引用。为了再次保存和加载游戏状态，我们有#4本身扩展 `**PersistableObject**` 。然后，它可以使用存储来加载和保存自己。

```
public class Game : PersistableObject {

	…

	public PersistentStorage storage;

	…

	void Update () {
		if (Input.GetKeyDown(createKey)) {
			CreateObject();
		}
		else if (Input.GetKeyDown(saveKey)) {
			storage.Save(this);
		}
		else if (Input.GetKeyDown(loadKey)) {
			BeginNewGame();
			storage.Load(this);
		}
	}

	…
}
```

Connect the storage via the inspector. Also reconnect the prefab, as its reference was lost due to the field's type change.  
通过检查员连接存储器。同时重新连接预制件，因为字段的类型更改导致其引用丢失。

![](<images/1686835486646.png>)

Game connected to prefab and storage.  
游戏连接到预制和存储。

### Overriding Methods 覆盖方法

When we save and load the game now, we end up writing and reading the transformation data of our main game object. This is useless. Instead, we have to save and load its list of objects.  
当我们现在保存和加载游戏时，我们最终会写入和读取主游戏对象的转换数据。这没用。相反，我们必须保存并加载它的对象列表。

Instead of relying on the `Save` method defined in `**PersistableObject**`, we have to give `**Game**` its own public version of `Save` with a `**GameDataWriter**` parameter. In it, write the list as we did before, now using the convenient `Save` method of the objects.  
我们不依赖于 `**PersistableObject**` 中定义的 `Save` 方法，而是必须给 `**Game**` 一个 `**GameDataWriter**` 参数来提供其自己的#3的公共版本。在其中，像以前一样编写列表，现在使用对象的便捷 `Save` 方法。

```
public void Save (GameDataWriter writer) {
		writer.Write(objects.Count);
		for (int i = 0; i < objects.Count; i++) {
			objects[i].Save(writer);
		}
	}
```

This is not yet enough to make it work. The compiler complains that `**Game**.Save` hides the inherited member `**PersistableObject**.Save`. While `**Game**` can work with its own `Save` version, `**PersistentStorage**` only knows about `**PersistableObject**.Save`. So it would invoke this method, not the one from `**Game**`. To make sure that the correct `Save` method gets invoked, we have to explicitly declare that we override the method that `**Game**` inherited from `**PersistableObject**`. That's done by adding the `**override**` keyword to the method declaration.  
这还不足以使其发挥作用。编译器抱怨 `**Game**.Save` 隐藏了继承的成员 `**PersistableObject**.Save` 。虽然#2可以使用自己的#3版本，但#4只知道 `**PersistableObject**.Save` 。所以它会调用这个方法，而不是来自 `**Game**` 的方法。为了确保正确的 `Save` 方法被调用，我们必须明确声明我们覆盖了 `**Game**` 从 `**PersistableObject**` 继承的方法。这是通过将 `**override**` 关键字添加到方法声明中来完成的。

```
public override void Save (GameDataWriter writer) {
		…
	}
```

However, we cannot just override any method we like. By default, we're not allowed to do this. We have to explicitly enable it, by adding the `**virtual**` keyword to the `Save` and `Load` method declarations in `**PersistableObject**`.  
然而，我们不能只是覆盖我们喜欢的任何方法。默认情况下，我们不允许这样做。我们必须显式地启用它，方法是将 `**virtual**` 关键字添加到#3中的 `Save` 和 `Load` 方法声明中。

```
public virtual void Save (GameDataWriter writer) {
		writer.Write(transform.localPosition);
		writer.Write(transform.localRotation);
		writer.Write(transform.localScale);
	}

	public virtual void Load (GameDataReader reader) {
		transform.localPosition = reader.ReadVector3();
		transform.localRotation = reader.ReadQuaternion();
		transform.localScale = reader.ReadVector3();
	}
```

`**PersistentStorage**` will now end up invoking our `**Game**.Save` method, even though it's passed to it as a `**PersistableObject**` argument. Also have `**Game**` override the `Load` method.  
`**PersistentStorage**` 现在将最终调用我们的 `**Game**.Save` 方法，即使它是作为 `**PersistableObject**` 参数传递给它的。同时让#3覆盖#4方法。

```
public override void Load (GameDataReader reader) {
		int count = reader.ReadInt();
		for (int i = 0; i < count; i++) {
			PersistableObject o = Instantiate(prefab);
			o.Load(reader);
			objects.Add(o);
		}
	}
```

![](<images/1686835487185.png>)

File containing two transforms.  
包含两个变换的文件。

The next tutorial is [Object Variety](https://catlikecoding.com/unity/tutorials/object-management/object-variety/).  
下一个教程是“对象多样性”。

[repository](https://bitbucket.org/catlikecodingunitytutorials/object-management-01-persisting-objects) [PDF](https://catlikecoding.com/unity/tutorials/object-management/persisting-objects/Persisting-Objects.pdf)