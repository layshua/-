笔者最近在回顾一些图形学基础知识，遂整理在此，此文涉及图形学中的纹理

在前文[《纹理映射流程》](https://zhuanlan.zhihu.com/p/369977849)中，我们梳理了纹理映射的总体流程，知道几乎可以将纹理上的任何信息映射到物体表面

在这里，主要介绍纹理映射的应用：**Material Map、Alpha Map、Bump Map、Normal Map、Relief Map、Displacement Map、Parallax Map、Textured Light、Shadow Map、Environment Map**

我将这些应用分为六个方面：

**控制着色信息、控制片元透明度、改变法线、改变表面结构、阴影贴图、环境贴图**

## 一、控制着色信息

在之前[《基础着色模型》](https://zhuanlan.zhihu.com/p/360222821)中，介绍了简单的 Blinn-Phong 着色模型，如下图所示：

![](<images/1684548488321.png>)

可以看到，里面有许多需要调节的参数，如表面颜色、高光强弱、高光衰减等因子，这还只是简单的着色模型，如果用基于物理的着色（PBS）模型，参数会更加复杂。

虽然可以通过赋予顶点更多信息来改变这些参数，但是要做到亚三角形的细节，就需要用各种各样纹理，来对每个片元的着色参数进行调节，我将这些纹理映射方法统称为**材质映射** (Material Map)

用得最多的是**漫反射映射** (diffuse/albedo/base color map)，比如经常用于模拟墙壁或者岩石：

![](<images/1684548488374.png>)

此外还可以改变镜面反射的系数，如**粗糙度** (决定高光衰减) 和**高光反射系数**：

![](<images/1684548488409.png>)

同时应用漫反射贴图和粗糙度贴图的效果如下：

![](<images/1684548488482.png>)

## 二、控制片元透明度

纹理都是矩形的，但当我们需要实现 **贴画** (decal) 或者 **镂空** (cutout) 效果时，往往不想让纹理贴满整个表面，也就是说，一些地方的透明度要为 0.

如下图中的血迹的贴画和镂空的树：

![](<images/1684548488520.png>)

此类纹理映射称为**透明度映射** (Alpha Map)，这种纹理通常有一个性质：texel 完全透明或者完全不透明 (其实也有半透明需要混合的情况，此处不考虑)

所以不需要把片元当作半透明进行混合，而是进行**透明度测试** (Alpha Test)，将透明度小于阈值的 texel 认为是完全透明，直接抛弃片元，否则为完全不透明

测试完成后，再用 z-buffer 算法 (可见前文[《透明度与混合》](https://zhuanlan.zhihu.com/p/368065919)) 进行对所有完全不透明片元进行混合。

透明度测试的伪代码如下：

![](<images/1684548488587.png>)

但是简单的透明度测试在使用 Mipmap 使会存在问题：如下图，第 0 级纹理连续四个 texel 的透明度为 [0.0, 1.0, 1.0, 0.0]，第 1 级纹理就为 [0.5, 0.5]

假设我们的阈值设为 0.75，根据双线性插值，可知道第 0 级纹理中有 1.5/4 在测试中保留，但是在第 1 级纹理中由于 0.5<0.75，所以像素均被抛弃，如下图所示：

![](<images/1684548488651.png>)

于是，在不同的 Mipmap 纹理等级中，经过透明度测试留下来的像素占比 (Coverage) 也不一样，会随着 d 增大，有效像素越来越少，如下图所示：

![](<images/1684548488685.png>)

在一个镜头逐渐拉远时，可以看到树叶也在变少，到远距离时只能看到树干了：

![](<images/1684548488721.png>)

一般解决的方法有两种：

1） 手动调节每级 Mipmap 的透明度，或者在 shader 里面根据纹理等级 d 对透明度进行缩放

2） 一般严重的 artifact 出现在 d 比较大的时候，所以就限制 d 的最大值

但这两种方法都只能是近似，不能很好解决问题，出现这个 artifact 的关键在于：不同 Mipmap，用同样的透明度阈值会得到不同的 **Coverage**(代表测试留存的像素比例)

Castano 提出了一种：保证 coverage 一致的情况下，自适应确定透明度阈值，并对原透明度缩放调整的方法，详见 [[1]](http://the-witness.net/news/2010/09/computing-alpha-mipmaps/)

其步骤为：

1） 先求出 d=0 纹理等级时，自定义的一个阈值 a_0 对应的 coverage = c_0，

2） 随后在 d=1,2,3… 等各级纹理中 coverage 与 c_0 相近的前提下，用二分查找求出不同等级的透明度阈值 a_d，此时理论上只需要对不同等级的纹理透明度施加不同的透明度阈值即可，但是现有管线的透明度测试中，只能用同一个透明度阈值。所以等效为：

3） 对各级纹理的透明度进行 a_0 / a_d 倍缩放，在透明度测试时，用 d=0 级处的透明度阈值 a_0 阈值即可。

此过程可用下图表示：

![](<images/1684548488777.png>)

使用此算法处理前后的效果如下，可见处理后，中远距离的树叶没有消失：

![](<images/1684548488894.png>)

除此之外，还有其他方法，考虑到本文的主旨是讲纹理映射的应用，所以关于透明度测试的一些问题就后面有机会再讲

另外在对 RGBA 值进行线性插值时，要注意先把 alpha 分量预乘到 RGB 分量上，再进行插值，比如要对很透明的绿色 (0,255,0,2) 和不透明的红色 (255,0,0,255) 进行插值，有两种情况：

![](<images/1684548488931.png>)

可以发现，无预乘插值结果更偏绿，而预乘后插值结果更偏红。

比较实际的情况是：希望插值的结果偏向于不透明那边颜色的色调，所以通常而言，**预乘后插值会比较合理**

## 三、改变法线

用于改变表面法线的贴图统称为**凹凸贴图** (Bump Mapping，虎书上面把 Bump Mapping 特指为后续的 height-field map，我此处沿用了 RTR 的说法，即 Bump Mapping 包含这一类技术，都是改变法向的技术)

为什么使用凹凸贴图呢？我们先来看三种细节层次：

1） 宏观特征 (Macro-Feature)：往往是跨三角形的，主要用几何体来表征。比如一个人的头或者胳膊，都是用三角形构成的几何体

2） 微观特征 (Micro-Feature)：往往是亚像素的，主要是用着色方程来表征。比如衣服的材质和皮肤的材质、粗糙度等不一样

3） 中观特征 (Meso-Feature)：中观特征位于宏观和微观之间，往往是在一个三角形内跨像素的，比如衣服上的褶皱或者脸上的皱纹，这些特征用细小的三角形建模显得过于浪费了，于是就用凹凸贴图的方式表征。

我们知道，一个三角形就有一个法向量，凹凸贴图在于微调三角形内每个像素的法线，但只用于着色方程中计算光照，三角形的几何体并没有改变，仍然是平的。**凹凸贴图的制作通常是从非常细节、非常多小三角形的模型中导出来**

凹凸贴图的保存有几种方式：

1） 用一个分量保存高程图 (height-field)，然后通过差分计算出法向量，称之为 **height-field map**

2） 用两个分量保存法向量在 (u,v) 两个方向的偏移(b_u,b_v)，称之为 **offset map**

3） 用三个分量直接保存新的法向量 (x,y,z)，称之为 **normal map**

三者保存方式如下图所示：

![](<images/1684548489128.png>)

对于第一种高程 (height-field)，其纹理值高的地方对应 “高度” 也高，一般看起来是一张灰度图，如下图所示，用一张高程纹理来形成球面起伏的效果：

![](<images/1684548489196.png>)

对应第二种偏移图 (offset map)，这是 Blinn 在 1978 年提出来的，属于很老的技术，现在很少用，可参考 [[2]](https://www.microsoft.com/en-us/research/wp-content/uploads/1978/01/p286-blinn.pdf)

而第三种法向贴图 (normal map)，应用最广泛。直接将法向量三个分量 (x,y,z) 保存在纹理的 (R,G,B) 三个通道，用 [0,255] 表示 [-1,1]，所以在前面图中转化为减去了 128. 法向贴图及其效果可见下图，由于法向都与三角形面法向相近，所以 z 分量会比较大，贴图看上去往往是蓝色的：

![](<images/1684548489233.png>)

此外，对于法向量所处的坐标空间也有一定选择：

1） 世界空间 (world space)：法向量处于世界空间系，那么模型一旦旋转后就不能用了

2） 物体空间 (object space)：模型旋转后贴图还能用，但是不能将贴图复用于同一模型的多个不同朝向的面

3） 切线空间 (tangent space)：贴图可以复用于不同朝向的表面上，所以最常用

![](<images/1684548489323.png>)

切线空间基一般是三个分量：法向基 **n** (normal)、切线基 **t** (tangent)、双切线基 **b** (bitangent)，但为了节省存储，只在每个顶点保存 **t** 和 **b**，然后叉乘计算 **n**。

要注意的是：**在计算光照时，要保证法向量和光线向量等都在同一个坐标空间。**

若不在同一空间，乘以一个矩阵转换即可，比如将向量从物体空间转到切线空间的矩阵：

![](<images/1684548489367.png>)

另外还有一个问题，**凹凸贴图在多级纹理插值时会很困难**，因为着色方程的表达式与法向量的关系往往不是线性的。

在线性插值时，比如由两个法向量 n1,n2 插值得到新的法向量 n，记此过程为：n = a*n1 + b*n2，但在着色时，比如 Blinn-Phong 里的高光部分记为 c(n)，不是线性运算，合并计算与分别计算的光照并不相等，即：

![](<images/1684548489406.png>)

关于此问题的一个解决思路是：将着色方程的一些参数作为整体进行插值，把这个整体作为变量使得光照计算变为线性，而不仅仅是插值法向量。具体细节的话得在 PBS 里面才涉及到，此处就不深入了。

凹凸贴图的缺点在于：没有真正改变表面的几何凹凸性，所以在观察角度过于倾斜的时候，越会觉得表面像贴了一张纸上去，这是因为没有考虑由于高程带来的视差和遮挡

**Parallax Mapping(视差贴图)** 解决了这个问题

如下左图所示，当我们从相机观察到 p 点时，由于高程的存在，我们应该看到的是 p_ideal 处的着色，但实际上在凹凸贴图中用的是 p 点的着色信息，所以看起来不够真实：

![](<images/1684548489450.png>)

视差映射由 Kaneko 提出 [[3]](https://www.gamedevs.org/uploads/detailed-shape-representation-with-parallax-mapping.pdf)

如上右图所示，所做的事情就是：根据 p 点的高程，以及 v 的方向，对 p 点偏移一段距离到达 p_adj，以接近 p_ideal

当高程变化比较平缓时，这个方法表现较好，但是当高程在 p 点处变化剧烈时或者 v 与表面法向的角度很大时，就有可能导致 p_adj 与 p_ideal 相差很远，如下图所示：

![](<images/1684548489485.png>)

为了解决这个问题，Welsh 对此进行了改进 [[4]](http://page.mi.fu-berlin.de/block/htw-lehre/wise2015_2016/bel_und_rend/skripte/welsh2004.pdf)：

为了防止 p 点偏移得过于厉害，Welsh 将偏移量限制在 h 范围内，此方法对于这种局部高程变化剧烈的砖墙图能够表现得很好，见下图：

![](<images/1684548489529.png>)

即使这种方法解决了高程变化剧烈的情况，但还遗留一种遮挡的情况。

如下图所示，光线有时会被更高的其他点的高程所遮挡，但是上面并没有考虑这一点：

![](<images/1684548489569.png>)

一种类似于 Ray Marching 的思想：从 p 点出发，向前检查有限数量的点，看这些点处的高程是否与光线相交，如果相交则取离交点最近的像素点，如 p_adj，并用此处的光照去替代 p 点的光照信息。

此外还有其他很丰富的方法，这一类技术统称为 **地势贴图** (relief Mapping).

下图对比了凹凸贴图 (法线贴图)、视差贴图、地势贴图三种情况的效果：

![](<images/1684548489601.png>)

Ray Marching 很有趣，是 ShaderToy 里面很常用的技巧，它和 Ray Tracing 很相似，都需要投射光线，区别在于 RM 没有实实在在的几何体，判断光线相交情况是用 Sphere Tracing 结合 Signed Distance Functions(SDF)，之后有机会也会写一篇关于 RM 的文章

## 四、改变表面结构

第三部分中的凹凸贴图 (法线贴图)、视差贴图和地势贴图，都只是在计算光照时对法线或者其他光照方程的输入进行了微调，没有修改表面结构

此处所介绍的**移位贴图** (Displacement Mapping) 则实际性地修改了表面结构，其主要依赖于渲染管线的**曲面细分** (tessellation) 功能，即根据贴图中对三角形进行曲面细分，生成足够多更小的三角形，并对每个三角形的顶点位置都进行移位，实际上得到了更为精细的几何体。

可想而知，这种技术是效果最好的，但也是最复杂的。

Kalos 在 06 年有一篇综述 [[5]](https://www.researchgate.net/profile/Laszlo-Szirmay-Kalos/publication/220506016_Displacement_Mapping_on_the_GPU_-_State_of_the_Art/links/5aec48feaca2727bc003fdf9/Displacement-Mapping-on-the-GPU-State-of-the-Art.pdf)：

对比了各种技术，感觉讲得很不错，下图来源于此：

![](<images/1684548489636.png>)

## 五、改变光源

纹理还可以用于改变光源，称之为 **Textured Light**

最简单的二维光源，类似投影仪的工作原理：把一张纹理放在聚光灯下投射过来，那么光照就带有各种图案：

![](<images/1684548489675.png>)

除了二维纹理，用视锥体的方式进行投射之外，还可以用一维纹理保存光线的衰减系数，甚至用三维体纹理直接保存光在空间中的分布，但极其耗费内存。

## 五、阴影贴图

介绍阴影贴图之前，先回顾一下 z-buffer 算法：将距离相机最近的片元的深度保存起来：

![](<images/1684548489757.png>)

如果我们把相机换成点光源，那么**右边这张深度图，是否可以代表有光照片元的深度？且大于这个深度的片元都没有光照？**

这就是阴影贴图的思想，考虑以下场景：

![](<images/1684548489797.png>)

黄色区域为点光源光照示意范围，绿色区域为视锥体范围，很明显，红线处是阴影部分，实际操作时怎样确定这个红线位置呢？有以下步骤：

1） 第一次 pass，将相机放在光源位置，用 z-buffer 的方式存一张深度缓冲，称之为**阴影贴图** (Shadow Map)，并记录此时的投影变换矩阵 M

2） 第二次 pass，正式开始渲染场景，将相机放到正确的位置，对片元进行着色时，考察每个片元处是否有光照，方法为：用第一次 pass 里面的矩阵 M 将三维点 (Px,Py,Pz) 变换为二维坐标 (px,py) 和深度 pz，将 pz 与第一次 pass 里面存下来的阴影贴图对应点的深度 c(px,py) 进行对比，若 pz> c(px,py)，则认为此片元无光照，否则有光照。

此过程如下图所示：

![](<images/1684548489838.png>)

但此处的阴影贴图局限于只能生成点光源的硬阴影，对于其他光源或者软阴影的生成还需要其他方法，会在后面专门的阴影章节讲解。

## 六、环境贴图 (Environment Mapping)

相信一些人看过《楚门的世界》这部电影，里面的一个世界是被很大的一个几何体围起来的，环境贴图也是类似的做法：你所看到的四周比较远的东西不过是一整张贴图

环境贴图有多种保存形式：最常用的**立方贴图** (Cubic Map)、**经纬度贴图** (Latitude-Longitude Map)、**球面贴图** (Sphere Map)：

![](<images/1684548489874.png>)

环境贴图主要有两个应用：

一是作为场景的背景颜色，比如这个场景有一些模型，但是模型后面不可能总是灰的或者黑的背景色，那么环境贴图就充当背景的颜色

二是作为镜面反射的颜色，比如场景中有一面镜子，你从镜子里看到的，实际是反射的背景的颜色，就好比你看到的镜子的颜色，其实就是镜子里面那个虚拟摄像机朝反射方向看过去的环境贴图的颜色，比如在 Forza 游戏中，赛车上的反射效果：

![](<images/1684548489933.png>)

环境贴图有一个很重要的性质就是：**贴图很远，以至于在获取贴图纹理值的时候，不需要考虑向量的位置，只需要考虑向量的方向** 即可：

![](<images/1684548489970.png>)

如图所示，尽管两个摄像机的位置不一样，但是视线方向是一致的，那么得到的环境贴图的纹理也是一样的。这种性质可以在计算光照时，不用判断向量到底与贴图的哪一点相交，只考虑方向

本文对一些常见的纹理映射的应用进行了大致讲解，每一种应用延伸出去都有很多东西可讲，受限于自身的水平和文章的篇幅，此处没有展开。如有错误，还请多多指教！

## References :

[1] [Computing Alpha Mipmaps](http://the-witness.net/news/2010/09/computing-alpha-mipmaps/)

[2] [SIMULATION OF WRINKLED SURFACES](https://www.microsoft.com/en-us/research/wp-content/uploads/1978/01/p286-blinn.pdf)

[3] [Detailed Shape Representation with Parallax Mapping](https://www.gamedevs.org/uploads/detailed-shape-representation-with-parallax-mapping.pdf)

[4] [Parallax Mapping with Offset Limiting: A Per­Pixel Approximation of Uneven Surfaces](http://page.mi.fu-berlin.de/block/htw-lehre/wise2015_2016/bel_und_rend/skripte/welsh2004.pdf)

[5] [Displacement Mapping on the GPU - State of the Art](https://www.researchgate.net/profile/Laszlo-Szirmay-Kalos/publication/220506016_Displacement_Mapping_on_the_GPU_-_State_of_the_Art/links/5aec48feaca2727bc003fdf9/Displacement-Mapping-on-the-GPU-State-of-the-Art.pdf)