# 【第四章】后处理
![[Pasted image 20221024155317.png]]
## 采样基本操作
1. Texture object 要命名为默认名称_MainTex
2. 通过多次采样，扰动 uv 可以 Append 出不同效果（仅为演示，乱连的~）
3. 可以将_MainTex 储存到 register，方便采样
![[Pasted image 20221024163809.png]]
![[Pasted image 20221024160300.png]]
![[Pasted image 20221024160318.png]]
## HSV 和 RGB 
**RGB**比较常用（负数都显示成黑色）
**HSV** (Hue, Saturation, Value)
色调（H）、饱和度（S）和明度（V）
Hexadecimal：十六进制
![[Pasted image 20221003152912.png|200]]

转自：[Unity Shader - HSV 和 RGB 的相互转换 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/133441623)
对于颜色值，**RGB** 可能是我们接触最多的颜色模型，图像中的任何颜色都是由**红色（R）**、**绿色（G）**、**蓝色（B）** 这三个通道合成的，这三种颜色可以组合成几乎所有的颜色。

然而，它并不直观，比如我随便说一个 rgb 值，你能猜到他是什么颜色吗？几乎不可能，所以，后面引入了**HSV**、**HSL**等颜色模型。 **HSV** 相对于 **RGB** 来说是一种更加直观的颜色模型，**HSV**更加符合我们人类视觉。
### HSL 和 HSV 概念

**HSL** 即色相、饱和度、亮度（英语：Hue, Saturation, Lightness）。

**HSV** 即色相、饱和度、明度（英语：Hue, Saturation, Value），又称 HSB，其中 B 即英语：Brightness。

-   色相（H）是色彩的基本属性，就是平常所说的颜色名称，如红色、黄色等。
-   饱和度（S）是指色彩的纯度，越高色彩越纯，低则逐渐变灰，取 0-100%的数值。
-   明度（V），亮度（L），取 0-100%

### HSL 和 HSV 色彩空间比较

二者在数学上都是圆柱，但

**HSV** 在概念上可以被认为是颜色的倒圆锥体（白色在上底面圆心，黑点在下顶点）；

**HSL** 在概念上表示了一个双圆锥体和圆球体（白色在上顶点，黑色在下顶点，最大横切面的圆心是半程灰色）。
![[Pasted image 20221024161403.jpg|400]]
![[v2-33e2c70d429d9079c9b53e2f570032aa_1440w 2.webp]]
**以下函数由国外大神 [Inigo Quilez](https://link.zhihu.com/?target=http%3A//www.iquilezles.org/www/index.htm) 提供** [https://www.shadertoy.com/view/MsS3](https://link.zhihu.com/?target=https%3A//www.shadertoy.com/view/MsS3Wc)
### HSB/HSV 转 RGB
```c
// Official HSV to RGB conversion 
vec3 hsv2rgb( in vec3 c )
{
    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );

    return c.z * mix( vec3(1.0), rgb, c.y);
}
// Smooth HSV to RGB conversion 
// https://www.shadertoy.com/view/MsS3Wc
vec3 hsv2rgb_smooth( in vec3 c )
{
    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );

    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing 

    return c.z * mix( vec3(1.0), rgb, c.y);
}
```
**ShaderLab 版：**
```c
float3 hsb2rgb( float3 c ){
    float3 rgb = clamp( abs(fmod(c.x*6.0+float3(0.0,4.0,2.0),6)-3.0)-1.0, 0, 1);
    rgb = rgb*rgb*(3.0-2.0*rgb);
    return c.z * lerp( float3(1,1,1), rgb, c.y);
}
```
### RGB 转 HSB/HSV
```c
vec3 rgb2hsb( in vec3 c ){
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz),vec4(c.gb, K.xy),step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r),vec4(c.r, p.yzx),step(p.x, c.r));
    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),d / (q.x + e),q.x);
}
```
**ShaderLab 版:**
```c
float3 RGB2HSV(float3 c)
{
    float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
    float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}
```
### 实践
下面我们在 Unity Shader 中来看看

#### 笛卡尔坐标系下的 SHV
由下图我们可以清晰的看到 **X 轴决定色相，Y 轴决定饱和度**
![[Pasted image 20221024162348.jpg]]
```less
Shader "lcl/shader2D/HSV"
{

    SubShader
    {
        Pass
        {
            CGPROGRAM
            // vert_img 是 UnityCG.cginc 内置的
            #pragma vertex vert_img 
            #pragma fragment frag

            #include "UnityCG.cginc"

            //  该函数由国外大神 Iñigo Quiles 提供
            //  https://www.shadertoy.com/view/MsS3Wc
            float3 hsb2rgb( float3 c ){
                float3 rgb = clamp( abs(fmod(c.x*6.0+float3(0.0,4.0,2.0),6)-3.0)-1.0, 0, 1);
                rgb = rgb*rgb*(3.0-2.0*rgb);
                return c.z * lerp( float3(1,1,1), rgb, c.y);
            }

            // ---------------------------【片元着色器】---------------------------
            fixed4 frag (v2f_img i) : SV_Target
            {
                fixed4 col;
                // hsb 转换为 rgb
                // uv.x  决定 色相, 
                // uv.y  决定 亮度, 
                col.rgb = hsb2rgb(float3(i.uv.x, 1, 1-i.uv.y));
                return col;
            }
            ENDCG
        }
    }
}
```
#### 极坐标系下的 SHV

在极坐标系下，我们可以看到，**角度决定色相，半径决定饱和度，亮度固定**
![[Pasted image 20221024162435.jpg]]

```less
Shader "lcl/shader2D/HSVInPolarCoordinate"
{

    SubShader
    {
        Pass
        {
            CGPROGRAM
            // vert_img 是 UnityCG.cginc 内置的
            #pragma vertex vert_img 
            #pragma fragment frag

            #include "UnityCG.cginc"

            #define TWO_PI 6.28318530718

            //  该函数由国外大神 Iñigo Quiles 提供
            //  https://www.shadertoy.com/view/MsS3Wc
            float3 hsb2rgb( float3 c ){
                float3 rgb = clamp( abs(fmod(c.x*6.0+float3(0.0,4.0,2.0),6)-3.0)-1.0, 0, 1);
                rgb = rgb*rgb*(3.0-2.0*rgb);
                return c.z * lerp( float3(1,1,1), rgb, c.y);
            }

            // ---------------------------【片元着色器】---------------------------
            fixed4 frag (v2f_img i) : SV_Target
            {
                fixed4 col;
                // 笛卡尔坐标系转换到极坐标系
                float2 center = float2(0.5,0.5)-i.uv;
                float angle = atan2(center.y,center.x);
                float radius = length(center)*2.0;

                // 将角度 从(-PI, PI) 映射到 (0,1)范围
                // 角度决定色相, 半径决定饱和度, 亮度固定
                col.rgb = hsb2rgb(float3((angle/TWO_PI)+0.5,radius,1.0));
                return col;
            }
            ENDCG
        }
    }
}
```
## Base 原图
**RGBA：**

![[Pasted image 20221024155948.png]]
![[Pasted image 20221024155317.png]]
**R 通道：**
![[Pasted image 20221024155508.png]]
**反色：
![[Pasted image 20221024160039.png]]
![[Pasted image 20221024155601.png]]
## 改变颜色
![[Pasted image 20221024163907.png]]
实现对 HSV 的修改，可以通过使用_Time 作为值传入 Add，实现动态变化。
以下例子仅对 H 进行改变：
![[modifycolor.gif]]
## 暗/亮视野
![[Pasted image 20221024165351.png]]
![[Pasted image 20221024165416.png]]
![[Pasted image 20221024165437.png]]
## 白噪音
方法一：floor
![[Pasted image 20221024171946.png]]
方法二：frac
![[Pasted image 20221024172429.png]]
## Glitch 故障
[Content/高品质后处理：十种故障艺术（Glitch Art）算法的总结与实现 · 毛星云](https://gitee.com/liuke101/maoxingyun/tree/master/Content/%E9%AB%98%E5%93%81%E8%B4%A8%E5%90%8E%E5%A4%84%E7%90%86%EF%BC%9A%E5%8D%81%E7%A7%8D%E6%95%85%E9%9A%9C%E8%89%BA%E6%9C%AF%EF%BC%88Glitch%20Art%EF%BC%89%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AE%9E%E7%8E%B0)
Cyberpunk~
![[glitch.gif]]
核心思想：
1. 对 UV 做偏移
2. RGB 通道分离
### 理解 UV 偏移
![[Pasted image 20221024223235.png]]
![[Pasted image 20221024223323.png]]
UV 偏移主要发生在这里：
![[Pasted image 20221024223354.png]]
对纹理坐标 add 一个坐标，纹理坐标被改变，进而当采样纹理时，出现偏移现象。图中可以观察到，小圆圈位置的图像与左下角图像一致，说明该区域的 uv 被便宜到此处。
### 公共量
![[Pasted image 20221024221531.png]]
### 动态噪音算法
使用了两种算法，区别仅在于输出值
#### RandomNoise float1
![[Pasted image 20221024220434.png]]
#### RandomNoise vector2
![[Pasted image 20221024220602.png]]
### 噪音
![[Pasted image 20221024221000.png]]
### RGB 通道 UV 偏移
三通道进行相同处理，变量属性不共享，最后将各自通道输入 register
![[Pasted image 20221024222343.png]]
Apend 将 RGB 组装起来即可
![[Pasted image 20221024222458.png]]
## Scan 扫描
![[819AD6B83516F9D27F0ECC74109A155A.jpg]]
## 从深度重建世界坐标位置
ASE 内置节点解析
![[Pasted image 20221024225644.png]]
![[Pasted image 20221024225614.png]]
直接输出如下：
![[Pasted image 20221024230304.png]]
**注意：这里使用的方法是以以相机坐标为中心进行扫描，不适合游戏模式（游戏模式应该以外部传入的位置为中心，可以实时更新）**
![[Pasted image 20221024232033.png]]
![[Pasted image 20221024232011.png]]
通过调整 Float0 即表现出简单的扫描效果。


