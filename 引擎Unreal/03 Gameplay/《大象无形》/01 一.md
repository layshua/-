
大器晚成，大音希声，大象无形。

# 常见基类

我们先来学习一下 UE4 的 5 个常见基类：
- UObject
- Actor
- Pawn
- Controller
- Character

![[5e01f6a77b6e69f39b08335af45f4650_MD5.jpg]]

### UObject 类

> [!question] 什么时候该继承自 UObject 类? 什么时候应该声明一个纯 C++类?
> 
> 当需要以下功能时继承 UObject 类。

UObject是 UE4 大部分类的基类。它提供了如下几种功能：

![[1973fd181d34b367eaa73e5a4fd549b7_MD5.jpg]]
1.  Garbage collection **垃圾收集**
    - C++的内存管理由程序员完成，何时释放内存很棘手。UE 提供了两个解决方案：
    - （1）继承自 UObject 类, 同时指向 UObject 类实例对象的指针成员变量，使用 `UPROPERTY` 宏进行标记。虚幻引擎的 UObject 架构会自动地**被 `UPROPERTY` 标记的变量**考虑到垃圾回收系统中，在没有其他地方引用时候，定期清理，释放内存。自动地进行对象的生命周期管理。
    - （2）采用**智能指针**。请注意, **只有非 UObject 类型，才能够使用智能指针进行自动内存释放**。
2. Reference updating **引用自动更新**
3. Reflection **反射**
    - 运行时能获取一个类，动态创建类的对象，并且能动态获取到类有哪些函数和成员变量等，UE4 的蓝图中大量使用了反射技术。
4. Serialization **序列化**
5. Automatic updating of default property changes **自动检测默认变量的更改**
6. Automatic property initialization **自动变量初始化**
7. Automatic editor integration **和虚幻引擎编辑器的自动交互**
8. Type information available at runtime **运行时类型识别**
    - 请注意，虚幻引擎打开了/GR-编译器参数。意味着你无法使用 C++标准的 RTTI 机制: `dynamic_cast`。UE 实现了一套自己的、更高效的运行时类型识别的方案。**如果你希望使用，请继承自 UObject 类，然后使用 `Cast<>` 函数来完成。**
9. Network replication **网络复制**
    - 当你在进行网络游戏开发 （c/s 架构）时, 你一定希望能够自动地处理变量的同步。而继承自 UObject 类，其被宏标记的变量能够自动地完成网络复制的功能。从服务器端复制对应的变量到客户端。

综上所述，当你需要这些功能的时候，你的这个类应该继承自 UObject 类。
请注意: UObject 类会在引擎加载阶段，创建一个 Default Object 默认对象。这意味着:
- 构造函数并不是在游戏运行的时候调用，同时即便你只有一个 UObject 对象存在于场景中, 构造函数依然会被调用两次。
- 构造函数被调用的时候，UWorld 不一定存在。`GetWorld()`返回值有可能为空!


### Actor 类

> [!question] 什么时候该继承自 Actor 类
> 需要挂载组件的时候

Actor 的字面意思是演员。

在 UE4 中 Actor 拥有这样的能力：**它能够被挂载组件**。

UE 的 Component 和和 Unity 中的 Component 不同！
- Unity 中，一个对象可以挂载多个脚本组件，每个脚本组件是一个单独的类。
- UE 中一个场景实体对应一个类，**组件不是类，组件只是组件！** 类似 Unity 脚本组件的功能在 UE 中用继承自 Actor 类的子类来实现。

![[1040341fdeaf2123fdf8add79225f020_MD5.jpg]]

如上，如果需要它被渲染，可以挂一个静态网格组件，或者骨架网格体组件
如果需要它移动，可以直接在 Actor 类中写代码或者挂一个 Movement 组件。

### Pawn 类

在国际象棋中，Pawn（翻译：兵/卒） 代表的是：兵/卒

![[eee81f393376a8786c638b6eabe292ed_MD5.jpg|198]]

Pawn 类提供了被 “操作” 的特性。他能被 Controller 控制。
就像一个棋手，控制这个棋子。一旦脱离棋手就无法自主行动

### Character 类

Character 类代表一个角色，它继承自 Pawn，提供了一个特殊组件：**Character Movement**。这个组件提供了一个基础的，**基于胶囊体**的角色移动功能。包括移动和跳跃，还能扩展出蹲伏和爬行等。
![[b822fae4a1d16b63aeccd92312078af9_MD5.jpg|450]]

> [!question] 什么时候该继承自 Pawn，什么时候该继承自 Character
> 看是否需要**Character Movement**组件
> - 所以如果你的游戏角色是人类或这两足怪物的话，特别适合使用 Character 类。
> - 如果你的 Pawn 类十分简单，或者不需要这样的移动逻辑（比如飞机），那么可以不继承这个类

### Controller 类

Controller 是用来操控 Pawn/Character 的人。 可以把它看作是下棋的棋手，或者提线木偶的操作者。

![[48a96ad32e3217302ffcf634ee29a044_MD5.jpg]]

它既可以是玩家，比如 `Player Controller` 类，通过键盘或者手柄输入来操作游戏角色（可以在 Player Controller 类中绑定输入）。
也可以是电脑 AI，比如 `AI Controller` 类来操作游戏中的 NPC 和怪物等角色 （可以 AI Controller 类中使用行为树/EQS 环境查询系统）。

为何虚幻引擎采用这样的设计？Epic 给出的理由非常简单:“不同的怪物也许会共享同样的 Controller，从而获得类似的行为”。即棋手可以通过 `Possess/UnPossess` 操纵多种棋子。

![[2335a0d74602ec1194ba6a229a8946f8_MD5.jpg]]
**Pawn/Character 拥有的只是简单的前进、转向、跳跃、开火等函数。而 Controller 则是能调用这些函数。**


# 创建自己的 C++ 类

![[a2de28b8beaedfb1041bc82904442d90_MD5.jpg]]

### 使用 UE 创建 C++ 类

我们在 UE4 里面创建一个 C++ 类，有如下三个步骤：

![[0d02e82359e69dec13a099b8dd95b0da_MD5.jpg]]

点击创建后，虚幻引擎会打开 Visual Studio。产生 *. h 和 *. cpp 文件，然后会自动编译，并且加载到引擎中。

![[29f3c30b9f8950bdd7f022ae04c39513_MD5.jpg]]

### 手工创建 C++ 类

如果是需要手工创建 C++ 类的话，推荐有 public 目录，以及 private 目录，其中 *. h 推荐放到 public 目录，而 *. cpp 推荐放到 private 目录：

![[b1b5de06155f4f5eeb3656c3458a83a0_MD5.jpg]]

如果我们的类是继承自 UObject。类名上方需要加入 UClass () 宏，类体的第一行需要添加 GENERAED_BODY () 宏，主要是为了实现类的反射用，另外头文件记得包含一个 *. generated. h 文件：

![[e46e76278309fd6e265ec8581e6c917c_MD5.jpg]]

### 虚幻引擎类名规则

我们发现，虽然我们在创建 C++ 类的时候，给的类名是 MyObject，但是它的类名实际上是 UMyObject。那么这前面的 U 表示什么意思呢？这是按照虚幻引擎的命名规则，添加的命名前缀，常用的命名前缀如下：

![[40e49e2d717588aca8dcb325381445da_MD5.jpg]]

## 对象

### 类对象的产生

在标准 C++ 中，一个类产生一个对象，被称为 “实例化”。标准 C++ 一般是通过 new 的关键字来实例化一个对象。

![[a3cbfeec00cefa0a68934c677da014be_MD5.jpg]]

在虚幻引擎中，实例化一个类的对象需要判断类的父类，使用不同的实例化方法：

![[cee78b9f9e15f8137e3c1c58781a884b_MD5.jpg]]

### 类对象的获取

我们可以通过某种方式获取到这个对象的指针或引用，然后对它进行操作。

比如我们可以通过 Actor 迭代器：TActorItertor，来获取当前 World 的所有 Actor，如下代码：

```
for (TActorItertor<AActor> Iter(GetWorld()); Iter; ++Iter)
{
   // 调用这个Actor的某个你需要成员函数等
   Iter->YourFunction();
}
```

### 类对象的销毁

一个类的对象需要销毁，一有如下几种方式：

![[df3425f9c326b0ac042aebaf06d01b5e_MD5.jpg]]

**纯 C++ 对象有三种方式：**

一，是局部变量自动销毁，如下代码：

```
void func1() {
   FMyClass myObj = FMyClass();
   // do something 
   // 函数结束时，局部变量自动销毁
}
```

二，是使用 delete 来手动删除：

```
void func1() {
  FMyClass *myObj = new FMyClass();
  // do something
  delete myObj;
}
```

三，是使用 TSharedPtr 的智能指针来自动管理。底层使用了引用计数的原理。

**UObject 对象**

对于 UObject 的对象，一般其他对象用 UPROPERTY 的成员引用了它，只要不引用了，就会自动垃圾回收销毁了，也可以手动 AddToRoot，让它不被回收。后续需要删除时再移除出 Root 即可。

**AActor 对象**

AActor 对象比较简单，需要销毁时调用 Destroy () 函数请求销毁即可，后续引擎会自动调用垃圾回收真正删除它。

## 从 C++ 到蓝图

我们可以通过 UPROPERTY 宏把成员变量注册到蓝图，通过 UFUNCTION 宏把函数注册到蓝图。比如我们创建了一个 MyActor 类，并注册了 MyPlayerName 的成员变量和 HelloUE5 () 的函数，如下图：

![[5149b4d1dd07600fb70f0c46255a8f2e_MD5.jpg]]

### UPROPERTY 宏

我们使用 UPROPERTY 宏来注册成员变量到蓝图，比如 UPROPERTY (EditAnywhere, BlueprintReadWrite, Category = "MyActor") 其中 EditAnywhere 表示可以在蓝图任意地方编辑，BlueprintReadWrite 表示蓝图可以读写这个成员变量，Category = "MyActor" 表示它放在属性编辑器的 “MyActor” 子栏。

### UFUNCTION 宏

我们使用 UFUNCTION 宏来注册成员函数到蓝图，比如 UFUNCTION (BlueprintCallable, Category = "MyActor")，其中 BlueprintCallable 表示蓝图可以调用，Category = "MyActor" 表示函数的子分类为 "MyActor" 可以在蓝图选择调用函数时快速定位到它。

## 引擎系统相关类简介

引擎中常用的一些工具实用类如下：

![[c0259438bc46dc2e622ae3d441992757_MD5.jpg]]

### 正则表达式

需要包含头文件 #include "Regex. h"，通过 FRegexPattern 来创建一个待查找或匹配的模式，然后通过 FRegexMatcher 来查找与匹配字符串中符合模式的部分，如下代码：

```
#include "Regex.h"
FString TextStr("ABCDEFGHIJKLMN");
FRegexPattern TestPattern(TEXT("C.+H"));
FRegexMatcher TestMacher(TestPattern, TestStr);

if (TestMacher.FindNext())
{
  UE_LOG(MyLog, Warning, TEXT("找到匹配内容 %d ~ %d"), 
                TestMacher.GetMatchBeginning(),
                TestMacher.GetMatchEnding());
}
```

### FPaths 路径管理器

在 Core 模块中，虚幻引擎提供了一个用于路径相关处理的类：FPaths。主要提供了 3 类 “工具” 性质 API：

1，**具体路径类**： FPaths:: GameDir () 获取游戏根目录

2，**工具类**：FPaths:: FileExists () 判断一个文件是否存在。

3，**路径转换类**：FPaths:: ConvertRelativePathToFull () 将相对路径转换为绝对路径。

### 配置文件解析

这里涉及到 XML，JSON 与 INI 等三种文件：

**XML**：可以使用 FastXML 与 FXmlFile 进行解析与处理。

**Json**：可以使用 FJsonSerializer 与 FJsonValue 等来进行解析与处理。

**ini**：使用 GConfig 类进行读写与解析。

### 文件读写与访问

使用 FPlatformFileManager:: Get ()->GetPlatformFile () 进行文件的读写相关。常用函数如下：

CopyDirctorTree 拷贝目录树

CopyFile 拷贝当前文件

CreateDirectory 创建目录

DeleteDirectory 删除目录

DeleteFile 删除指定文件

FileExists 检查文件是否存在

OpenRead 打开一个文件进行读取

OpenWrite 打开一个文件进行写入

等等。

### LOG

Log 作为开发中常用到的功能，可以在任何需要情况下记录程序运行情况。

**查看 Log**

在 Game 模式下可以加入 - Log 命令行参数来查看 Log。在编辑器模式，直接打开 Log 窗口就行（Window->DeveloperTools->OutputLog）。

**写 Log**

可以通过 UE_LOG (LogMy, Warning, TEXT ("Hello world")); 来输出 log，第一个参数为 Log 的分类，需要预设。第二个参数为类型，有 Log，Warning，Error 三种类型，其中 Log 为灰色，Warning 为黄色，Error 为红色。具体的输出为 TEXT，内容可以自己构造。

**自定义 Log 的 Category**

我们自己定义 Category 的宏，如下代码：

```
DEFINE_LOG_CATEGORY_STATIC(LogMy, Warning, All);
```

### 字符串

在虚幻引擎中字符串有三种类型：FName，FText，FString。

**FName**：无法修改，大小写不敏感，其实 FName 内部只是一个整数索引，实际的字符串内容是在一个公用的字符串表中保存，非常省内存。

**FText**：无法修改，用来显示，支持本地化和多国语言。

**FString**：允许修改，区分大小写。最为灵活，不过比其他两种字符串，略为耗一些内存。

引擎相关类的总体内容如下：

![[62b82bc981eb26ffd7fc3a1d371ed7c2_MD5.jpg]]

至此，本节的内容就讲的差不多了！我们学会了创建自己的类，对象，C++ 与蓝图，以及一些引擎相关实用类等！下节我们会分享虚幻引擎的模块机制相关，敬请期待！！