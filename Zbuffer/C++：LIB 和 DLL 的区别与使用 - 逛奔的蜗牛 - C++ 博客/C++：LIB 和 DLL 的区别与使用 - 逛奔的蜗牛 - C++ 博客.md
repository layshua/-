共有两种库：  
一种是 LIB 包含了函数所在的 DLL 文件和文件中函数位置的信息（入口），代码由运行时加载在进程空间中的 DLL 提供，称为**动态链接库 dynamic link library**。  
一种是 LIB 包含函数代码本身，在编译时直接将代码加入程序当中，称为**静态链接库 static link library**。  

共有两种链接方式：  
**动态链接**使用动态链接库，允许可执行模块（.dll 文件或. exe 文件）仅包含在运行时定位 DLL 函数的可执行代码所需的信息。  
**静态链接**使用静态链接库，链接器从静态链接库 LIB 获取所有被引用函数，并将库同代码一起放到可执行文件中。

关于 lib 和 dll 的区别如下：  
（1）lib 是编译时用到的，dll 是运行时用到的。如果要完成源代码的编译，只需要 lib；如果要使动态链接的程序运行起来，只需要 dll。  
（2）如果有 dll 文件，那么 lib 一般是一些索引信息，记录了 dll 中函数的入口和位置，dll 中是函数的具体内容；如果只有 lib 文件，那么这个 lib 文件是静态编译出来的，索引和实现都在其中。使用静态编译的 lib 文件，在运行程序时不需要再挂动态库，缺点是导致应用程序比较大，而且失去了动态库的灵活性，发布新版本时要发布新的应用程序才行。  
（3）动态链接的情况下，有两个文件：一个是 LIB 文件，一个是 DLL 文件。LIB 包含被 DLL 导出的函数名称和位置，DLL 包含实际的函数和数据，应用程序使用 LIB 文件链接到 DLL 文件。在应用程序的可执行文件中，存放的不是被调用的函数代码，而是 DLL 中相应函数代码的地址，从而节省了内存资源。DLL 和 LIB 文件必须随应用程序一起发行，否则应用程序会产生错误。如果不想用 lib 文件或者没有 lib 文件，可以用 WIN32 API 函数 LoadLibrary、GetProcAddress 装载。

使用 lib 需注意两个文件：  
（1）.h 头文件，包含 lib 中说明输出的类或符号原型或数据结构。应用程序调用 lib 时，需要将该文件包含入应用程序的源文件中。  
（2）.LIB 文件，略。

使用 dll 需注意三个文件：  
（1）.h 头文件，包含 dll 中说明输出的类或符号原型或数据结构的. h 文件。应用程序调用 dll 时，需要将该文件包含入应用程序的源文件中。  
（2）.LIB 文件，是 dll 在编译、链接成功之后生成的文件，作用是当其他应用程序调用 dll 时，需要将该文件引入应用程序，否则产生错误。如果不想用 lib 文件或者没有 lib 文件，可以用 WIN32 API 函数 LoadLibrary、GetProcAddress 装载。  
（3）.dll 文件，真正的可执行文件，开发成功后的应用程序在发布时，只需要有. exe 文件和. dll 文件，并不需要. lib 文件和. h 头文件。

使用 lib 的方法：  
静态 lib 中，一个 lib 文件实际上是任意个 obj 文件的集合，obj 文件是 cpp 文件编译生成的。在编译这种静态库工程时，根本不会遇到链接错误；即使有错，也只会在使用这个 lib 的 EXT 文件或者 DLL 工程里暴露出来。  
在 VC 中新建一个 static library 类型的工程 Lib，加入 test.cpp 文件和 test.h 文件（头文件内包括函数声明），然后编译，就生成了 Lib.lib 文件。  
别的工程要使用这个 lib 有两种方式：  
（1）在 project->link->Object/Library Module 中加入 Lib.lib 文件（先查询工程目录，再查询系统 Lib 目录）；或者在源代码中加入指令 #pragma comment(lib, “Lib.lib”)。  
（2）将 Lib.lib 拷入工程所在目录，或者执行文件生成的目录，或者系统 Lib 目录中。  
（3）加入相应的头文件 test.h。

使用 DLL 的方法：  
使用动态链接中的 lib，不是 obj 文件的集合，即里面不会有实际的实现，它只是提供动态链接到 DLL 所需要的信息，这种 lib 可以在编译一个 DLL 工程时由编译器生成。  
创建 DLL 工程的方法（略）。  
**（1）隐式链接**  
第一种方法是：通过 project->link->Object/Library Module 中加入. lib 文件（或者在源代码中加入指令 #pragma comment(lib, “Lib.lib”)），并将. dll 文件置入工程所在目录，然后添加对应的. h 头文件。
```c++ nums
#include "stdafx.h"  
#include "DLLSample.h"  
#pragma comment(lib, "DLLSample.lib") // 你也可以在项目属性中设置库的链接  
int main()  
{
	 TestDLL(123); //dll 中的函数，在 DllSample.h 中声明  
	 return(1);  
}  

```
![](<assets/1680873907645.png>)

**（2）显式链接**  
需要函数指针和 WIN32 API 函数 LoadLibrary、GetProcAddress 装载，使用这种载入方法，不需要. lib 文件和. h 头文件，只需要. dll 文件即可（将. dll 文件置入工程目录中）。
```c++ nums
#include <iostream>  
#include <windows.h> // 使用函数和某些特殊变量  
typedef void (*DLLFunc)(int);  
int main() 
{
		DLLFunc dllFunc; 
		HINSTANCE hInstLibrary = LoadLibrary("DLLSample.dll");  
		
		if (hInstLibrary == NULL)  
		{  
			 FreeLibrary(hInstLibrary);  
		}
		
		dllFunc = (DLLFunc)GetProcAddress(hInstLibrary, "TestDLL");
		  
		if (dllFunc == NULL)  
		{  
			FreeLibrary(hInstLibrary);  
		}  

		dllFunc(123);  
		std::cin.get();  
		FreeLibrary(hInstLibrary);  
		return(1);  
}  
```
LoadLibrary 函数利用一个名称作为参数，获得 DLL 的实例（HINSTANCE 类型是实例的句柄），通常调用该函数后需要查看一下函数返回是否成功，如果不成功则返回 NULL（句柄无效），此时调用函数 FreeLibrary 释放 DLL 获得的内存。  
GetProcAddress 函数利用 DLL 的句柄和函数的名称作为参数，返回相应的函数指针，同时必须使用强转；判断函数指针是否为 NULL，如果是则调用函数 FreeLibrary 释放 DLL 获得的内存。此后，可以使用函数指针来调用实际的函数。  
最后要记得使用 FreeLibrary 函数释放内存。

注意：应用程序如何找到 DLL 文件？  
使用 LoadLibrary 显式链接，那么在函数的参数中可以指定 DLL 文件的完整路径；如果不指定路径，或者进行隐式链接，Windows 将遵循下面的搜索顺序来定位 DLL：  
（1）包含 EXE 文件的目录  
（2）工程目录  
（3）Windows 系统目录  
（4）Windows 目录  
（5）列在 Path 环境变量中的一系列目录


.h 头文件是编译时必须的，lib 是链接时需要的，dll 是运行时需要的。

附加依赖项的是. lib 不是. dll，若生成了 DLL, 则肯定也生成 LIB 文件。如果要完成源代码的编译和链接，有头文件和 lib 就够了。如果也使动态连接的程序运行起来，有 dll 就够了。在开发和调试阶段，当然最好都有。

.h .lib .dll 三者的关系是：

H 文件作用是: 声明函数接口 

DLL 文件作用是: 函数可执行代码 

当我们在自己的程序中引用了一个 H 文件里的函数, 编链器怎么知道该调用哪个 DLL 文件呢? 这就是 LIB 文件的作用: 告诉链接器 调用的函数在哪个 DLL 中，函数执行代码在 DLL 中的什么位置 ，这也就是为什么需要附加依赖项 .LIB 文件，它起到桥梁的作用。如果生成静态库文件，则没有 DLL ，只有 lib，这时函数可执行代码部分也在 lib 文件中

目前以 lib 后缀的库有两种，一种为静态链接库 (Static Libary，以下简称“静态库”)，另一种为动态连接库(DLL，以下简称“动态库”) 的导入库(Import Libary，以下简称“导入库”）。静态库是一个或者多个 obj 文件的打包 ，所以有人干脆把从 obj 文件生成 lib 的过程称为 Archive，即合并到一起。比如你链接一个静态库，如果其中有错，它会准确的找到是哪个 obj 有错，即静态 lib 只是壳子。动态库一般会有对应的导入库，方便程序静态载入动态链接库 ，否则你可能就需要自己 LoadLibary 调入 DLL 文件，然后再手工 GetProcAddress 获得对应函数了。有了导入库，你只需要链接导入库后按照头文件函数接口的声明调用函数就可以了。导入库和静态库的区别很大，他们实质是不一样的东西。静态库本身就包含了实际执行代码、符号表等等，而对于导入库而言，其实际的执行代码位于动态库中，导入库只包含了地址符号表等，确保程序找到对应函数的一些基本地址信息。

一般的动态库程序有 lib 文件和 dll 文件。lib 文件是必须在编译期就连接到应用程序中的，而 dll 文件是运行期才会被调用的。 如果有 dll 文件，那么对应的 lib 文件一般是一些索引信息，具体的实现在 dll 文件中。如果只有 lib 文件，那么这个 lib 文件是静态编译出来的，索引和实现都在其中。静态编译的 lib 文件有好处：给用户安装时就不需要再挂动态库了。但也有缺点，就是导致应用程序比较大，而且失去了动态库的灵活性，在版本升级时，同时要发布新的应用程序才行。在动态库的情况下，有两个文件，而一个是引入库（.LIB）文件，一个是 DLL 文件，引入库文件包含被 DLL 导出的函数的名称和位置，DLL 包含实际的函数和数据，应用程序使用 LIB 文件链接到所需要使用的 DLL 文件，库中的函数和数据并不复制到可执行文件中，因此在应用程序的可执行文件中，存放的不是被调用的函数代码，而是 DLL 中所要调用的函数的内存地址，这样当一个或多个应用程序运行是再把程序代码和被调用的函数代码链接起来，从而节省了内存资源。从上面的说明可以看出，DLL 和. LIB 文件必须随应用程序一起发行，否则应用程序将会产生错误。

静态库和共享库都是一个 obj 文件的集合 ，但静态链接后，执行程序中存在自己所需 obj 的一份拷贝，而动态链接后，执行程序仅仅是包含对共享库的一个引用。共享库相当于一个由多个 obj 文件组合而成的 obj 文件，在链接后其所有代码被加载，不管需要的还是不需要的。  
似乎可以得出一个结论：  
 静态链接后的程序比动态链接的所用存储空间大，因为执行程序中包含了库中代码拷贝；  
 而动态链接的程序比静态链接的所用的运行空间大，因为它将不需要的代码也加载到运行空间。

  
针对上面的知识 2 个问题：1） DLL 和. LIB 文件必须随应用程序一起发行，否则应用程序将会产生错误。 我的答案：lib 应该不需要吧。2）如果是某个程序中调用了一个动态库（通过 header 文件，lib+dll 来调用），则对动态库的某个函数的内容修改了，但接口不改，则调用此动态库的程序需重新编译连接吗？如果是通过 loadlibary 动态加载，需要重新编译连接吗？  

我的答案：通过 header+lib+dll 调用的话需要重新编译连接，但是通过 loadlibrary 来使用的话，不需要重新编译连接。

第 2 个答案错了 应该是不需要重新编译 接口不变的话 .lib 都不用更新  
From: 

[http://www.cppblog.com/mzty/archive/2010/11/28/134901.html

 1） 节省内存。同一个软件模块，若是以源代码的形式重用，则会被编译到不同的可执行程序中，同时运行这些 exe 时这些模块的二进制码会被重复加载到内存中。如 果使用 dll, 则只在内存中加载一次，所有使用该 dll 的进程会共享此块内存（当然，像 dll 中的全局变量这种东西是会被每个进程复制一份的）。  
   
 2） 不需编译的软件系统升级，若一个软件系统使用了 dll, 则该 dll 被改变（函数名不变）时，系统升级只需要更换此 dll 即可，不需要重新编译整个系统。事实上，很多软件都是以这种方式升级的。例如我们经常玩的星际、魔兽等游戏也是这样进行版本升级的。  
   
 3） Dll 库可以供多种编程语言使用，例如用 c 编写的 dll 可以在 vb 中调用。这一点上 DLL 还做得很不够，因此在 dll 的基础上发明了 COM 技术，更好的解决了一系列问题。

](http://www.cppblog.com/mzty/archive/2010/11/28/134901.html)