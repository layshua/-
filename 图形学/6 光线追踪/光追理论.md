
---
title: 光追理论
aliases: []
tags: []
create_time: 2023-07-12 12:03
uid: 202307121203
banner: "![[Pasted image 20230712120618.png]]"
---

光线追踪是和光栅化不同的着色方式

**为什么要使用光线追踪？**

光栅化不能很好的控制**全局效果**：
![[Pasted image 20221210160907.png]]
-   软阴影（光栅化虽然可以做，但不如光追简单）
-   Gossy：光滑的非玻璃镜面材质，例如光滑的金属
-   间接光照

**本课关于光线追踪的几个假设**（非物理正确）
- 光沿直线传播
- 光线与光线之间不会发生碰撞
- 光路的可逆性，光线的路径可以从眼睛到物体，也可以从物体到眼睛

# 1 光线投射 RayCasting 
![[Pasted image 20221210161157.png]]
**光线投射的假设：**
- 出射点是一个点
- 光源点光源
- 场景物体中的反射为完美的镜面反射，即入射角等于出射角
- **光线投射的光线只弹射一次**

**光线投射的步骤：**
1. **投射：** 从 eye point 穿过成像平面投射光线（**每个像素投射一条光线**）到场景中 
2. **求交：** 找到与场景物体的最近交点（完美解决了光栅化的深度测试问题）
3. **检查阴影**：将交点和光源连接（shadow ray）, 判断物体对光源来说是不是可见的（即是否在阴影中）。如果中间有阻挡，就说明在阴影里。如果没有阻挡，就说明可见，
4. **着色：**  交点处的法线已知，**对可见交点计算着色，相加后写回之前穿过的像素中

![[v2-33789871a86c5b76463e52b508c692dc_1440w.webp]]


# 2 Whitted-Style 光线追踪
![[Pasted image 20221210161809.png]]

光线投射的光线只弹射一次，实际上光线会弹射很多次，这就引出了光线追踪。

**Whitted-Style 光线追踪**是一种**递归光线追踪（Recursive Ray Tracing）**
- 光线不仅仅只会反射，还会折射、然后再与其他物体进行反射
- 实际上弹射次数不需要太多，弹射 8 次和弹射 16 次区别不大（能量守恒）。

**Whitted-Style 光线追踪的步骤：**
1. **投射：** 从 eye point 穿过成像平面投射光线（**每个像素投射一条光线**）到场景中 
2. **求交：** 找到与场景物体的最近交点（完美解决了光栅化的深度测试问题），然后从该点继续反射或者折射（光线每次弹射都会有能量衰减），继续找最近交点。如此递归，直到递归次数达到设定的最大弹射次数。
3. **检查阴影**：将所有交点和光源连接（shadow ray）, 判断物体对光源来说是不是可见的（即是否在阴影中）。如果中间有阻挡，就说明在阴影里。如果没有阻挡，就说明可见。
4. **着色：** 交点处的法线已知，**对所有可见的交点分别计算着色，相加后写回之前穿过的像素中
![[v2-53d9f085fe850ece368c5d018d85dbbf_1440w.webp]]
>最大弹射次数设置为两次的情况

# 3 射线求交

### 射线方程

对于每一束光线都满足以下方程：$\mathbf{r}(t)=\mathbf{o}+t\mathbf{d}\quad0\leq t<\infty$
其中 $o$ 为开始点，$d$ 为单位方向向量，$t$ 为时间

![[Pasted image 20221210162854.png]]

## 射线与球面求交

![[Pasted image 20230711235159.png]]


**交点 $P$ 必须同时满足射线方程和球方程**，即满足：
$$
(\mathbf{o}+t\mathbf{d}-\mathbf{c})^2-R^2=0
$$
除了 $t$ 以外，其他量已知，解方程即可得 $t$
$$
t=\frac{-b\pm\sqrt{b^2-4ac}}{2a}
$$
其中：
$$
\begin{aligned}
&a=\mathbf{d}\cdot\mathbf{d} \\
&b=2(\mathbf{o}-\mathbf{c})\cdot\mathbf{d} \\
&\begin{aligned}c=(\mathbf{o}-\mathbf{c})\cdot(\mathbf{o}-\mathbf{c})-R^2\end{aligned}
\end{aligned}
$$
当 $b^{2}-4ac\geqslant0且t\geqslant0$ 时，等式成立。
**求出 $t$，代入射线方程就能确定交点位置。**

**三种情况：**
- 等式不成立->不相交
- 等式成立->相交
    - t 有一个解，此时相切，有一个交点
    - t 有两个解，此时相交，有两个交点，我们取最近的交点
![[Pasted image 20230712000356.png]]

## 射线与隐式几何求交

![[v2-194d685244aaf670e9bce1664c70086a_1440w.webp]]


**类似球面求交的原理**，对于任何隐式的集合体，将射线方程 $r(t)$ 以 $p$ 点带入隐式的方程中算出 $f (o+td)=0$ 即可算出 $t$ 求出交点

已知隐式几何方程 $f$ 和射线方程
**交点 $P$ 必须同时满足射线方程和隐式几何方程**，即满足：
$$
f(\mathbf{o}+t\mathbf{d})=0
$$

解方程即可得 $t$
$$
t=\frac{-b\pm\sqrt{b^2-4ac}}{2a}
$$
当 $b^{2}-4ac\geqslant0且t\geqslant0$ 时，等式成立。
**求出 $t$，代入射线方程就能确定交点位置。**


## 射线与显式几何求交
对于 2D 几何，在图形内部随意取一个点，向外发出射线，和图形的交点数量一定为奇数。相反，在外部取一个点，向图形发出射线，交点一定为偶数。
扩展到 3D，对所有三角形面进行上述 2D 方法判断，但是这种方法效率太低。

**几何体性质：**
-   几何体由若干个平面组成
-   平面可以由一个法线和平面上一个点 $p'$ 来表示（点法式）

**已知平面上一点$p'$和法线 $N$，如何判断点 $p$ 是否在平面上：**
当向量 $(p-p')$ 与法线垂直时，说明点 $p$ 在平面上。即满足  $(p-p)'\cdot N = 0$ 
由此可定义任意在平面 $p'$ 上的点，一系列点的集合就是面，所以也可以用来定义一个表面。

**步骤：**
-   可使用 $(p-p')·N=0$ 表示一个平面
-   将光线方程以 $p$ 带入光线方程中
-   求出 $t$ 算出交点
-   判断交点在三角形的内还是外，若在内则是三角形的交点
![[Pasted image 20221210165026.png]]


### Möller Trumbore 算法
推导： https://zhuanlan.zhihu.com/p/451582864

射线三角相交算法是一种快速计算射线与三角形在三个维度上的交点的方法，通过向量与矩阵计算可以**快速得出交点与重心坐标**，而无需对包含三角形的平面方程进行预计算

-   已知光线满足 $r (t)=o+td$
-   $P_0、P_1、P_2$ 为三角形三个顶点
-   可以得到以下等式，右边是重心坐标形式
-   通过以下 $E_1、E_2$ 等的参数定义可以解出等式得到交点
-   **通过重心坐标判断交点是否在三角形内**：$b1＞0；b2＞0；1 - b1 - b2 ＞0$
![[Pasted image 20221210164908.png]]

# 4 加速结构

如果三角形面特别多，以上面的算法对每个三角形进行计算将会特别慢。
我们不妨用"对象"来代替三角形，简单来说只对包围盒计算求交，而不是对内部的复杂模型进行计算。
- 对象在包围盒内
- 先测试射线是否击中包围盒，如果没有击中包围盒，就说明没有击中物体

**现在业界主要使用基于对象划分的层次包围盒（BVH）**

## 轴对齐包围盒 (AABB)
**Axis-Aligned Bounding Box（AABB）**

- 思想：如果光线和包围盒不相交，那么更不可能和物体相交
- box 是**三个对立面**（三对无限大的平板，下图为其中一对）的交集
- 轴对齐：任何一边都沿着 xyz 坐标轴，方便计算
![[Pasted image 20221210165531.png]]
**如何判断光线你什么时候与 box 相交？**
### 2D Box
2D Box 有**两个对立面**

**算法思想：**
- 两个对立面都满足光线进入，才能说光线进入了 box
- 只要离开任意对立面，就说明光线离开了 box

**步骤：**
1. 计算与 $x_0,x_1$ 这对面与光线相交（进和出）的时间 $t_{min}$、$t_{max}$
2. 计算 $y_0,y_1$ 这对面与光线的相交时间 $t_{min}$、$t_{max}$ （注意此时 $t_{min}$ 为负数）
3. 已经知道了光线什么时候进出这两个对立面，取 $t_{min}$ 的最大值，$t_{max}$ 的最小值 （交集）即可得到结果

![[Pasted image 20221210170221.png]]

### 3D Box
3D Box 有**三个对立面**

**算法思想：**
- 三个对立面都满足光线进入了，才能说光线进入了 box
- 只要离开任意对立面，就说明光线离开了 box

**步骤：**
1. 对每一对立面分别计算 $t_{min}$ 和 $t_{max}$
2. $t_{进入}=\max\{t_{\mathrm{min}}\},\quad t_{离开}=\min\{t_{\mathrm{max}}\}$
3. 如果 $t_{进入} ＜ t_{离开}$，说明光线在 box 中留存了一段时间，即相交

应该检查时间 $t$ 是否为负值，以保证物理正确性
**t 为负值的情况：**
-   $t_{离开}<0$ 则说明 box 在光线的背面（无交点）
-   $t_{离开}\geqslant0$  且 $t_{进入}<0$ 则说明光源在 box 内部，这样才能解释 $t_{进入}<0$（有交点）

**总结： AABB 有交点当且仅当 $t_{离开}\geqslant t_{进入}$  且 $t_{离开}\geqslant0$**  

## AABB 均匀网格划分
Uniform grids 均匀网格
**均匀网格适合物体分布均匀的场景**，对于分布不均匀的场景，考虑空间划分进行优化加速。

 
**AABB 均匀划分的步骤：**
-   1. 找到包围盒（最外层的正方体）
-   2. 建立网格（黑色网格）
-   3. 标记物体表面与 box 相交的网格（灰色标记）

![[Pasted image 20221210173123.png]]
-   4. 从光线发射方向逐个遍历网格
-   5. 光线每次经过物体表面在在的网格时，就判断—次是否相交

![[Pasted image 20221210173553.png]]

**网格数量应该取多少比较合适？**$27 * 物体数量$（3D 空间）
 

## AABB 空间划分

### 空间划分的分类
为了适应物体分布不均匀的场景，有多种空间划分方法
思想：物体分布密集的区域用更多网格，分布稀疏的区域用少量网格

![[Pasted image 20221210173202.png]]
#### 八叉树 Oct-Tree
![[Pasted image 20230712112504.png|500]]

-   八叉树是在每个子树下面画十字，划分为八块（在二维下是分为四块，三维是八块）
-   由于是均匀划分，会出现将同一个物体划分为两块的问题。

#### KD-Tree
-   每次划分只划分为两块（类似二叉树）
-   在二维中第一次为水平的划分，第二次为竖直的，然后循环划分
-   在三维中类似，以 xyz 轴顺序进行划分
-   这样可以保证划分比较均匀

**建立 KD 树**
通过一次对 x, y（二维）进行递归划分，得到下面的 KD 树 (例子中没有对蓝色区域进一步划分，实际上是和右边部分进行相同的划分，这里只是为了做对比所以没有划分)
- 内部节点不存储对象
- 叶子节点存储对象列表
![[Pasted image 20221210174330.png]]

**遍历 KD 树**
-   假设有一条光线射出
-   逐个对每个子树进行判断是否有与包围盒相交
-   若相交则对他的子树继续遍历知道将找到所有与光线相交的包围盒
-   将其包围盒下的物体查找交点
![[Pasted image 20221210175324.png]]

**KD 树的问题：**
-   难以判断物体与包围盒边界的相交问题
-   一个物体容易同时穿过多个包围盒被重复计算影响性能

因此 KD 树的应用场景越来越小。

**目前广泛使用的技术名叫层次包围盒（BVH）**

#### BSP-Tree
-   划分和 kd 树类似
-   **由于划分不是横平竖直的不能用于 AABB 的划分**


## 对象划分 &层次包围盒（BVH）
Bounding Volume Hierarchy（BVH）

不是通过空间划分，而是通过对象划分 。


- 将包围盒中的对象划分成两组，每一组重新求包围盒，然后在新的包围盒内再次划分，并求新的包围盒，递归进行，直到叶子节点里有比较少的对象（比如 5 个三角形）。
- 一个对象只可能出现在一个叶子节点
- 每次的划分都选择 XYZ 中最长的轴进行划分，这样保证划分的大小比较平均（也有其他办法）
- 总是选择中间大小的对象进行划分（快速划分算法），这样划分出来树更加接近平衡二叉树
>**一组无序数，找到第 i 大的数，可以使用快速划分算法，时间内复杂度 O (n)。**

![[Pasted image 20221210175639.png]]
**BVH 的存储结构：**
- 中间节点：包围盒，子节点指针
- 孩子节点：包围盒，物体列表
	
BVH 的伪代码：

```c
Intersect(Ray ray, BVH node) 
{
    if (ray misses node.bbox) 
        return;//如果与节点光线都不相交就返回
    if (node is a leaf node)//如果相交且这是一个叶子节点
    {
        test intersection with all objs;//将节点内三角形都做判断
        return closest intersection;//返回最近的那个
    }
    hit1 = Intersect(ray, node.child1);//如果不是叶子节点则递归找到最近的那个
    hit2 = Intersect(ray, node.child2);
    return the closer of hit1, hit2;
}
```

**空间划分和对象划分对比**
![[Pasted image 20230712115734.png|450]]
**空间划分(如 kd -tree)**
- 将空间划分为不重叠的区域
- 一个对象可以包含在多个区域中
![[Pasted image 20230712115739.png|400]]
**对象划分(如 BVH)**
- 将一组对象划分为不相交的子集
- 每个集合的边界框可能在空间上重叠


# 5 渲染方程与全局光照
[[2 PBR理论#渲染方程和反射方程|渲染方程如下：]]

$$L_o(p,\omega_o) = L_{e}(p,\omega_{o})+\int\limits_{\Omega} f_r(p,\omega_i,\omega_o) L_i(p,\omega_i) n \cdot \omega_i d\omega_i$$
## 直接光
**点光源的反射方程：**
点光源只有一个方向有入射光，所以不用积分，多个点光源直接累加即可。
![[Pasted image 20221210200218.png|350]]![[Pasted image 20221210200239.png|350]]

**面光源的反射方程：**
面光源是点光源的集合，因此对面光源所在立体角进行积分可以得出面光源的反射方程
![[Pasted image 20221210200305.png]]


## 间接光
光源不一定都是直接光，还有反射来的间接光。将其他物体反射过来的光当成光源，得到渲染方程
- $w_i$ 本来规定从点 $x$ 指向光源，是为了方便光照计算。这里不使用这个规定。将 $w_i$ 规定为视为从反射点指向点 $x$，我们将这个反射来的光也参与光照计算，那么在计算的时候需要将其**取负号**。
-   只需要计算反射光，其余参数均已知

![[Pasted image 20221210200340.png]]

我们可以将方程简写：
$$
I(u)=e(u)+\int I(v)\boxed{K(u,v)dv}
$$
写成算子形式：
$$
L=E+KL
$$
-   在一个场景内能量守恒
-   $L$ ：反射能量
-   $E$ ：直接光辐射的能量
-  $K$：反射符，可以将光源反射能量 $L$ 再次 反射
-  $KL$：光源反射能量 $L$ 再次反射

解出： $L=E+KL→L=(I-K)^{-1}E$

通过二项式定理得到下面的式子
$$
L=(1+K+K^2+K^3+\ldots)E
$$
$$
L=E+KE+K^2E+K^3E+\ldots 
$$

-   $L=E$ 为直接光辐射的能量
-   $L=E+KE$ 为直接光辐射的能量+第一次反射的能力 （第一次反射为直接光照反射，之后的就是间接光反射）
-   $L=KE+K²E$ 为直接光辐射的能量+一次反射的能量+二次反射的能量 
-   以此类推，**所有弹射加起来就是全局光照**

![[Pasted image 20221210200804.png]]


# 6 概率论基础知识
**$X$：随机变量。** 表示潜在值的分布
**$X\sim p (x)$：概率密度函数。** 描述随机过程选择值的相对概率
![[Pasted image 20221210201659.png]]

**随机变量的期望值：** 从随机分布中反复抽取样本所得到的平均值。
![[Pasted image 20221210201825.png]]
**概率密度函数（PDF）：** 一个随机变量 $X$，它可以取一组连续值中的任意一个，其中某个特定值的相对概率由连续**概率密度函数 $p (X)$** 给出。
![[Pasted image 20221210202132.png]]
![[Pasted image 20221210202240.png]]
**求函数的期望：**
![[Pasted image 20221210202320.png]]
# **蒙特卡洛路径追踪（Path Tracing）**

### 蒙特卡洛积分 Monte Carlo
**有些积分没有解析式，那么怎么求解呢？**
用数值方法计算一个复杂定积分的近似值

蒙特卡洛积分：对函数的积分域多次采样求均值，作为积分的近似值
**每次采样的积分域为宽为 $b-a$，高为 $f (x_i)$ 的长方形。**

定义一个d $f(x)$**，函数图像如下：
![[Pasted image 20221210203444.png]]
![[Pasted image 20221210203737.png]]

**例子：**
![[Pasted image 20221210203754.png]]

将积分均匀采样，使用的概率密度函数是为常数，每个采样的概率都是 1/b-a，得出以下式子。
![[Pasted image 20221210203808.png]]
其中将 b-a 移到后面可以得到最开始蒙特卡洛积分的式子。

**总结：**
-  采样越多，误差越小
-  在 x 上积分必须在 x 上采样
![[Pasted image 20221210204029.png]]
### Witted-Style 时错误的

路径追踪解决了在 Witted-Style 中不正确的部分

-   无法完成 Glossy 的材质，在 Glossy 材质中光线打到材质上不完全沿着 Specular 的方向走
-   漫反射后仍然会多次反射，需要引入全局光照
![[Pasted image 20221210204312.png]]
![[Pasted image 20221210204404.png]]
### 蒙特卡洛积分应用到渲染方程
![[Pasted image 20221210204839.png]]

将某个渲染点 p 的ω<sub>i</sub>方向（作为随机变量）进行多次采样找到反射光源的角度得到蒙特卡洛积分：
![[Pasted image 20221210205204.png]]
![[Pasted image 20221210205240.png]]

通过这样的方法可以算出任意着色点的渲染方程

#### 直接光照的算法

```c
shade(p, wo)
    Randomly choose N directions wi~pdf
    Lo = 0.0
    For each wi
        Trace a ray r(p, wi)
        If ray r hit the light
            Lo += (1 / N) * L_i * f_r * cosine / pdf(wi)
    Return Lo
```

#### 全局光照的算法

```c
shade(p, wo)
    Randomly choose N directions wi~pdf
    Lo = 0.0
    For each wi
        Trace a ray r(p, wi)
        If ray r hit the light
            Lo += (1 / N) * L_i * f_r * cosine / pdf(wi)
        Else If ray r hit an object at q
            Lo += (1 / N) * shade(q, -wi) * f_r * cosine / pdf(wi)
    Return Lo
```

如果采样中反射过来的不是光源而是物体则将物体也当做光源，将物体反射过来的能量来进行计算。

### 上述算法的产生的问题

**反弹次数的上升产生射线数量爆炸**

一根光线打到物体后会反射很多个光线到同一个物体，以此类推产生指数爆炸、
![[Pasted image 20221210210818.png]]

因此**如果蒙特卡洛积分采样次数为 1 则不会出现指数爆炸的现象。**

路径追踪算法：

```c
shade(p, wo)
    Randomly choose ONE direction wi~pdf(w)
    Trace a ray r(p, wi)
    If ray r hit the light
        Return L_i * f_r * cosine / pdf(wi)
    Else If ray r hit an object at q
        Return shade(q, -wi) * f_r * cosine / pdf(wi
```

**只采样一次的光线追踪被称之为路径追踪，上面采样 N 次的被称之为分布式光线追踪（Distributed Ray Tracing）**

生成多个路径进行路径追踪：
![[Pasted image 20221210210846.png]]

对于每个像素发射 N 条光线（采样）做以下的算法

将每个射出去的采样接收到能量的点做蒙特卡洛积分得到平均值

```c
ray_generation(camPos, pixel)
    Uniformly choose N sample positions within the pixel
    pixel_radiance = 0.0
    For each sample in the pixel
        Shoot a ray r(camPos, cam_to_sample)
        If ray r hit the scene at p
            pixel_radiance += 1 / N * shade(p, sample_to_cam)
    Return pixel_radiance
```

### 由于路径追踪递归产生的死循环
使用俄罗斯轮盘赌的方法
![[Pasted image 20221210210633.png]]
-   首先增加一个结束的概率 P_RR
-   每次调用 shade 函数的时候做一个随机数判断
-   若大于随机数则 return0 反之继续执行 shade 函数并返回 L0/P_RR
-   这样算下来数学期望不会变，E (L0)=P∗(L0/P)+(1−P)∗0=Lo
-   且路径追踪总会停下来

```c
shade(p, wo)
    Manually specify a probability P_RR
    Randomly select ksi in a uniform dist. in [0, 1]
    If (ksi > P_RR) return 0.0;
    
    Randomly choose ONE direction wi~pdf(w)
    Trace a ray r(p, wi)
    If ray r hit the light
        Return L_i * f_r * cosine / pdf(wi) / P_RR
    Else If ray r hit an object at q
        Return shade(q, -wi) * f_r * cosine / pdf(wi) / P_RR
```

### **提高效率**

每个像素中的采样点越多，形成的效果越好，比如下图中最右边的例子需要 50000 个采样才能找到光线，大多数的采样被浪费了
![[Pasted image 20221210210906.png]]

因此为了提高效率我们可以通过找到光源与方向的关系，改写渲染方程，将渲染方程写成对光源的积分
![[Pasted image 20221210211248.png]]
改写的渲染方程：

![[1b663c7757ecd37156674f02fe670853_MD5.webp]]

我们最终渲染出来的光纤传播分解为两个部分

-   光源的直接光照
-   光源对其他物体的弹射（需要用到上面的随机算法）

如果光源中有物体挡住则不能渲染光源的直接光照，通过一个 if 来解决

```c
shade(p, wo)
    # 光源的直接光照
    L_dir = 0.0
    Uniformly sample the light at x’ (pdf_light = 1 / A)
    Shoot a ray from p to x’
    If the ray is not blocked in the middle
        L_dir = L_i * f_r * cos θ * cos θ’ / |x’ - p|^2 / pdf_light
    # 光源对其他物体的弹射
    L_indir = 0.0
    Test Russian Roulette with probability P_RR
    Uniformly sample the hemisphere toward wi (pdf_hemi = 1 / 2pi)
    Trace a ray r(p, wi)
    If ray r hit a non-emitting object at q
        L_indir = shade(q, -wi) * f_r * cos θ / pdf_hemi / P_RR
    Return L_dir + L_indir
```

### **其他的知识**

-   点光源不容易处理，因此建议写成一个很小的面光
-   路径追踪可以做到几乎 100%的真实（照片级真实感）
- ![[Pasted image 20221210211823.png]]
-   光线追踪有很多类型
- ![[Pasted image 20221210211933.png]]
-   过去认为的 Ray tracing 就是 whitted-style ray tracing
-   **现在包括：**
	- （单向和双向）路径跟踪
	-   光子映射
	-   Metropolis light transport（MLT）
	-   VCM / UPBP
- 生成照片的两种方法：光栅化\光线追踪

-   课程中光线追踪未涉及的部分
-   函数采样理论
-   选择什么样的 PDF（重要性采样）
-   随机数的生成
-   结合不同的采用结果（如光源和着色点）
-   像素发出多个路径，是否平均其着色效果即可（pixel reconstruction filter）
-   像素的 radiance 和 color 的区别（伽马矫正）

