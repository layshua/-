# 第一章：绪论

## 1.1 数据结构的基本概念

**1. 数据**：数据是信息的载体，是描述客观事物属性的数、字符以及所有能输入到计算机中并被程序识别和处理的符号的集合。

**2. 数据元素**：数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。例如，学生记录就是一个数据元素，它由学号、姓名、性别等数据项组成。

**3. 数据对象**: 数据对象是具有相同性值的数据元素的集合，是数据的一个子集。

**4. 数据类型**: 数据类型是一个值的集合和定义再此集合上的一组操作的总称。

1）原子类型。其值不可再分的数据类型。如 bool 和 int 类型。  
2）结构类型。其值可以再分解为若干成分（分量）的数据类型。  
3）[抽象数据类型](https://so.csdn.net/so/search?q=%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&spm=1001.2101.3001.7020)。抽象数据组织及与之相关的操作。（定义一个 ADT 就是定义了数据的逻辑结构，数据的运算，也就是定义了一个完整的数据结构）

**5. 数据结构**: 数据结构是相互之间存在一种或多种特定关系的数据元素的集合。

## 1.2 数据结构的三要素

### 逻辑结构
[逻辑结构](https://so.csdn.net/so/search?q=%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020)是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。与数据的存储无关，独立于计算机。
![[Pasted image 20230831095914.png]]
逻辑结构包括：
![[Pasted image 20230831100004.png|450]]
1. **线性结构**：结构中的数据元素之间只存在一对一的关系，除了第一个元素，所有元素都有唯一前驱；除了最后一个元素，所有元素都有唯一后继。
2. **集合**：结构中的数据元素之间除 “同属一个集合” 外，别无其它关系。
3. **树形结构**：结构中数据元素之间存在一对多的关系。
4. **图状结构**：数据元素之间是多对多的关系。

### 存储结构（物理结构）
存储结构是指数据结构在计算机中的表示（又称映像），也称物理结构。它包括数据元素的表示和关系的表示。数据的存储结构是用计算机语言实现的逻辑结构，依赖于计算机语言。

**存储结构包括：**
1. **顺序存储**：把**逻辑上相邻的元素存储在物理位置也相邻**的存储单元中，元素之间的关系由存储单元的邻接关系来体现。
    - 优点：实现随机存取，每个元素占用最少的存储空间
    - 缺点：只能使用相邻的一整块存储单元，可能产生较多外部碎片
2. **链式存储**：**逻辑上相邻的元素在物理位置上可以不相邻**，借助指示元素存储地址的指针来表示元素之间的逻辑关系。
    - 优点：不会产生碎片，充分利用所有存储单元
    - 去欸但：每个元素因存储指针占用额外存储空间，且只能顺序读取
3. **索引存储**：在存储元素信息的同时，还建立附加的索引表，索引表中的每项称为索引项，索引项的一般形式是（关键字，地址）
    - 优点：检索速度快
    - 缺点：索引表占用存储空间，增删数据要修改索引表，时间开销大。
4. **散列存储**（**哈希存储**）：根据元素的关键字直接计算出该元素的存储地址，又称哈希（Hash）存储。
    - 优点：检索，增删节点快速
    - 缺点：若哈希函数不好，可能出现存储单元的冲突，解决冲突会增加时间空间的开销

#### 随机存取、顺序存取、随机存储、顺序存储
这四个概念是完全不一样的，切不可将之混淆

**存取：**
1. **随机存取就是直接存取**，**可以通过下标直接访问**的那种数据结构，与存储位置无关，例如数组。
2. **非随机存取就是顺序存取**了，**不能通过下标访问**了，只能按照存储顺序存取，与存储位置有关，例如链表。
3. 顺序存取就是存取第 N 个数据时，必须先访问前（N-1）个数据 （list），随机存取就是存取第 N 个数据时，不需要访问前（N-1）个数据，直接就可以对第 N 个数据操作 （array）。

**存储结构：**
1. **顺序存储结构**：在计算机中用一组地址连续的存储单元依次存储线性表的各个数据元素，称作线性表的顺序存储结构。
    - 顺序存储结构是存储结构类型中的一种，该结构是把逻辑上相邻的节点存储在物理位置上相邻的存储单元中，结点之间的逻辑关系由存储单元的邻接关系来体现。由此得到的储结构为顺序存储结构。**通常用高级程序设计语言中的<font color="#ff0000">数组</font>来表述线性表的顺序存储结构**。（注意，线性表中的元素**位序**从 1 开始，数组元素的**下标**从 0 开始）
2. 随机存储结构：在计算机中用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）。
    - 它不要求逻辑上相邻的元素在物理位置上也相邻。因此它没有顺序存储结构所具有的弱点，但也同时失去了顺序表可随机存取的优点。随机存储最典型的代表为链式存储：

### 3. 数据的运算
施加在数据上的运算包括运算的定义何实现。**运算的定义**是针对逻辑结构的，指出运算的功能；**运算的实现**是针对存储结构的，指出运算的具体操作步骤。

## 1.3 算法的基本概念

**程序 = 数据结构 + 算法**  

算法（algorithm) 是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。  
**算法的特性：**  
1. 有穷性：一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。  
2. 确定性：算法中每条指令必须有确定的含义，对于相同的输入只能得到相同的输出。  
3. 可行性：算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。  
4. 输入：一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。  
5. 输出：一个算法有一个多个输出，这些输出是与输入有着某种特定关系的量。  

# 第二章：线性表
![[Pasted image 20230831100324.png]]
>线性表是逻辑结构，顺序表和链表为存储结构
## 2.1 线性表的定义

线性表是具有**相同数据类型**的 n(n>0) 个数据元素的有限序列。
- 第一个元素称为表头元素，最后一个元素称为表尾元素
- 除第一个元素外，每个元素有且仅有一个直接前驱。
- 除最后一个元素外，每个元素有且仅有一个直接后继。
- 每个数据元素的存储位置都和线性表的起始位置相差一个该数据元素的位序成正比的常数，因此线性表中任一数据元素都可以**随机存取**

## 2.2 顺序存储
### 2.2 顺序表的定义

顺序表的特点：
- 用一组地址连续的存储单元存储数据元素，使得逻辑上相邻的元素在物理位置上也相邻
- 表中元素的**逻辑顺序与其物理顺序相同**
- 可以随机访问，即通过首地址和元素序号就可以在 $O(1)$ 时间内找到指定的元素
- 插入和删除需要移动大量元素

![[Pasted image 20230831100739.png]]


## 2.3 链式存储
- 链式存储线性表时，不要求逻辑上相邻的元素在物理位置上也相邻。
- 插入和删除不需要移动操作，只需要修改指针
- 不能随机存取（查找某个特定节点，需要从头遍历）

#### 单链表
![[Pasted image 20230905094314.png]]

**定义：** 线性表的链式存储又称单链表，它是指通过一组任意的存储单元来存储线性表中的数据元素。
对于每个链表节点，除了存放自身自信外，还要**存放一个指向后继的指针。**

```c++
typedef struct LNode{//定义单链表结点类型
    ElemType data; //数据域
    struct LNode *next;//指针域
}LNode, *LinkList;
```

头指针指向第一个节点，为 NULL 时表示空表

**单链表的两种实现方式：**

1.  不带头结点的单链表

```
```bash
typedef struct LNode{
    ElemType data;
    struct LNode *next;
}LNode, *LinkList;

//初始化一个空的单链表
bool InitList(LinkList &L){  //注意用引用 &
    L = NULL; //空表，暂时还没有任何结点；
    return true;
}

void test(){
    LinkList L;  //声明一个指向单链表的指针: 头指针
    //初始化一个空表
    InitList(L);
    //...
}

//判断单链表是否为空
bool Empty(LinkList L){
    if (L == NULL)
        return true;
    else
        return false;
}
```

头结点：代表链表上头指针指向的第一个结点，不带有任何数据。

2.  带头结点的单链表
![[Pasted image 20230905094517.png]]
```
typedef struct LNode{
    ElemType data;
    struct LNode *next;
}LNode, *LinkList;

//初始化一个单链表（带头结点）
bool InitList(LinkList &L){  
    L = (LNode*) malloc(sizeof(LNode));  //头指针指向的结点——分配一个头结点（不存储数据）
    if (L == NULL)          //内存不足，分配失败
        return false;
    L -> next = NULL;       //头结点之后暂时还没有结点
    return true;
}

void test(){
    LinkList L;  //声明一个指向单链表的指针: 头指针
    //初始化一个空表
    InitList(L);
    //...
}

//判断单链表是否为空（带头结点）
bool Empty(LinkList L){
    if (L->next == NULL)
        return true;
    else
        return false;
}
```

**带头结点和不带头结点的比较：**  
不带头结点：写代码麻烦！对第一个数据节点和后续数据节点的处理需要用不同的代码逻辑，对空表和非空表的处理也需要用不同的代码逻辑; 头指针指向的结点用于存放实际数据;  
带头结点：头指针指向的头结点不存放实际数据, 头结点指向的下一个结点才存放实际数据;

#### 双链表
![[Pasted image 20230905095018.png]]

双链表节点有两个指针，指向其前驱和后继

```c
typedef struct DNode{            //定义双链表结点类型
    ElemType data;               //数据域
    struct DNode *prior, *next;  //前驱和后继指针
}DNode, *DLinklist;
```

#### 循环链表

##### 循环单链表
![[Pasted image 20230905095241.png]]
**最后一个结点的指针不是 NULL, 而是指向头结点**
判空条件不是头结点的指针是否为空，而是他是否等于头指针。

##### 循环双链表
![[Pasted image 20230905095408.png]]
**表头结点的 prior 指向表尾结点，表尾结点的 next 指向头结点**

##### 双向循环链表 
和单链的循环表类似，双向链表也可以有循环表，让头结点的前驱指针指向链表的最后一个结点，让最后一个结点的后继指针指向头结点。  

![](<images/1693447314241.png>)
#### 静态链表
![[Pasted image 20230905095525.png]]

用数组的方式来描述线性表的链式存储结构: **分配一整片连续的内存空间**，各个结点集中安置，包括了——数据元素 and 下一个结点的数组下标 (游标)
*   其中数组下标为 0 的结点充当 "头结点"
*   游标为 - 1 表示已经到达表尾

### 顺序表和链表的比较
1. 存取（读写）方式
顺序表可以顺序存取，也可以随机存取，链表只能从表头顺序存取元素。例如在第 i 个位置上执行存或取的操作，顺序表仅需一次访问，而链表则需从表头开始依次访问 i 次。
2. 逻辑结构与物理结构
采用顺序存储时，逻辑上相邻的元素，对应的物理存储位置也相邻。而采用链式存储时，逻辑上相邻的元素，物理存储位置不一定相邻，对应的逻辑关系是通过指针链接来表示的。
3. 查找、插入和删除操作
对于按值查找，顺序表无序时，两者的时间复杂度均为 O (n); 顺序表有序时，可采用折半查找，此时的时间复杂度为 O (logn)。
对于按序号查找，顺序表支持随机访问，时间复杂度仅为 O (1)，而链表的平均时间复杂度为 O (n)。顺序表的插入、删除操作，平均需要移动半个表长的元素。链表的插入、删除操作，只需修改相关结点的指针域即可。由于链表的每个结点都带有指针域，故而存储密度不够大。
4. 空间分配
顺序存储在静态存储分配情形下，一旦存储空间装满就不能扩充，若再加入新元素，则会出现内存溢出，因此需要预先分配足够大的存储空间。预先分配过大，可能会导致顺序表后部大量闲置; 预先分配过小，又会造成溢出。动态存储分配虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，而且若内存中没有更大块的连续存储空间，则会导致分配失败。
链式存储的结点空间只在需要时申请分配，只要内存有空间就可以分配，操作灵活、高效。


### 顺序、链式、静态、动态四种存储方式的比较

1.  顺序存储的固有特点：  
    逻辑顺序与物理顺序一直，本质上是用数组存储线性表的各个元素（即随机存取）；存储密度大，存储空间利用率高。
2.  链式存储的固有特点：  
    元素之间的关系采用这些元素所在的节点的 “指针” 信息表示（插、删不需要移动节点）。
3.  静态存储的固有特点：  
    在程序运行的过程中不要考虑追加内存的分配问题。
4.  动态存储的固有特点：  
    可动态分配内存；有效的利用内存资源，使程序具有可扩展性。

# 第三章：栈和队列

### 3.1 栈（stack）
![[Pasted image 20230905100318.png]]
**顺序栈**：采用顺序存储的栈，存储单元地址连续，附设一个 top 指针指向当前栈顶元素的位置。
**共享栈**：利用栈底位置相对不变的特性，可以让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸。![[Pasted image 20230905100327.png]]

**栈的链式存储 (链栈)**：便于多个栈共享存储空间和提高效率，不存在栈满的清空。通常采用单链表实现，并规定所有操作都在表头进行。
![[Pasted image 20230905100447.png]]


### 3.2 队列（Queue）
![[Pasted image 20230905100601.png]]
队头（Front）：出队
队尾（Rear）：入队

#### 队列的顺序存储结构
分配一块连续的存储单元存放队列中的元素，并附设两个指针：
*   队头指针front：指向队头元素
*   队尾指针 rear：指向队尾元素的下一个位置
（不同地方定义可能不同）
队空条件：`front==rear==0`

入队：先送值到队尾元素，再将队尾指针+1
出队：先取队头元素，再将队头指针+1
![[Pasted image 20230905100913.png]]

#### 循环队列
定义：将循环队列臆造为一个环状的空间，即把存储队列元素的表从逻辑上视为一个环，称为循环队列。  
基本操作：

当队首指针 front=MaxSize-1 时，再前进一个位置就自动到 0，这可以利用除法取余`%`运算来实现。
```
a%b == a除以b的余数

初始时：Q.front = Q.rear = 0;
队首指针进1：Q.front = (Q.front + 1) % MaxSize
队尾指针进1：Q.rear = (Q.rear + 1) % MaxSize —— 队尾指针后移，当移到最后一个后，下次移动会到第一个位置
队列长度：(Q.rear + MaxSize - Q.front) % MaxSize
```

**区分队空还是队满的情况：**  
**方案一: 牺牲一个单元来区分队空和队满**  
约定队头指针在队尾指针的下一个位置作为队满的标志，即 
```
队满条件:(Q.rear+1) % MaxSize==Q.front
队空条件仍: Q.front==Q.rear
队列中元素的个数:(Q.rear-Q.front+MaxSize)% MaxSize
```
![[Pasted image 20230905101546.png]]

**方案二: 不牺牲存储空间，设置 size**  
定义一个变量 `size`用于记录队列此时记录了几个数据元素，初始化 `size = 0`，进队成功 `size++`，出队成功`size--`，根据 size 的值判断队满与队空

队满条件：`size == MaxSize`
队空条件：`size == 0`

**方案三: 不牺牲存储空间，设置 tag**  
定义一个变量 `tag`，`tag = 0` -- 最近进行的是删除操作；`tag = 1` -- 最近进行的是插入操作；

每次删除操作成功时，都令`tag = 0`；只有删除操作，才可能导致队空；  
每次插入操作成功时，都令`tag = 1`；只有插入操作，才可能导致队满；  
队满条件：`Q.front == Q.rear && tag == 1`
队空条件：`Q.front == Q.rear && tag == 0`

#### 队列的链式存储结构

队列的链式表示称为**链队列**，它实际上是一个同时带有队头指针和队尾指针的单链表。  
![[Pasted image 20230905101640.png]]
![[Pasted image 20230905101716.png]]
#### 双端队列
![[Pasted image 20230905101727.png]]

1. 定义：双端队列是指允许两端都可以进行入队和出队操作的队列

*   双端队列允许从两端插入、两端删除的线性表；
*   如果只使用其中一端的插入、删除操作，则等同于栈；
*   输入受限的双端队列：允许一端插入，两端删除的线性表；
*   输出受限的双端队列：允许两端插入，一端删除的线性表；

### 3.3 栈的应用

#### 3.3.1 栈在括号匹配中的应用

用栈实现括号匹配

*   ((())) 最后出现的左括号最先被匹配 (栈的特性—LIFO);
    
*   遇到左括号就入栈;
    
*   遇到右括号，就 “消耗” 一个左括号 (出栈);  
    匹配失败情况：
    
*   扫描到右括号且栈空，则该右括号单身;
    
*   扫描完所有括号后，栈非空，则该左括号单身;
    
*   左右括号不匹配;
    

代码：

```
#define MaxSize 10 

typedef struct{
    char data[MaxSize];
    int top;
} SqStack;

//初始化栈
InitStack(SqStack &S)

//判断栈是否为空
bool StackEmpty(SqStack &S)

//新元素入栈
bool Push(SqStack &S, char x)

//栈顶元素出栈，用x返回
bool Pop(SqStack &S, char &x)

bool bracketCheck(char str[], int length){
    SqStack S;      //声明
    InitStack(S);   //初始化栈

    for(int i=0; i<length; i++){
        if(str[i] == '(' || str[i] == '[' || str[i] == '{'){
            Push(S, str[i]);       //扫描到左括号，入栈
        }else{
            if(StackEmpty(S))      //扫描到右括号，且当前栈空
                return false;      //匹配失败
            
            char topElem;          //存储栈顶元素
            Pop(S, topElem);       //栈顶元素出栈

            if(str[i] == ')' && topElem != '(' )
                return false;

            if(str[i] == ']' && topElem != '[' )
                return false;

            if(str[i] == '}' && topElem != '{' )
                return false;       
        }
    }

    StackEmpty(S);                //栈空说明匹配成功
}
```

#### 3.3.2 栈在表达式求值中的应用

**1. 中缀表达式 (需要界限符)**  
运算符在两个操作数中间:

```
① a + b
② a + b - c
③ a + b - c*d
④ ((15 ÷ (7-(1+1)))×3)-(2+(1+1))
⑤ A + B × (C - D) - E ÷ F
```

**2. 后缀表达式 (逆波兰表达式)**  
运算符在两个操作数后面:

```
① a b +
② ab+ c - / a bc- +
③ ab+ cd* -
④ 15 7 1 1 + - ÷ 3 × 2 1 1 + + -
⑤ A B C D - × + E F ÷ - (机算结果)
  A B C D - × E F ÷ - + (不选择)
```

中缀表达式转后缀表达式 - 手算  
步骤 1： 确定中缀表达式中各个运算符的运算顺序

步骤 2： 选择下一个运算符，按照 [左操作数 右操作数 运算符] 的方式组合成一个新的操作数

步骤 3： 如果还有运算符没被处理，继续步骤 2

“左优先” 原则: 只要左边的运算符能先计算，就优先算左边的 (保证运算顺序唯一)；

```
中缀：A + B - C * D / E + F
       ①   ④   ②   ③   ⑤     
后缀：A B + C D * E / - F +
```

**重点：中缀表达式转后缀表达式 - 机算**  
初始化一个栈，用于保存暂时还不能确定运算顺序的运算符。从左到右处理各个元素，直到末尾。可能遇到三种情况:

遇到操作数: 直接加入后缀表达式。  
遇到界限符: 遇到 ‘(’ 直接入栈; 遇到 ‘)’ 则依次弹出栈内运算符并加入后缀表达式，直到弹出 ‘(’ 为止。`注意: '(' 不加入后缀表达式。`  
遇到运算符: 依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到 ‘(’ 或栈空则停止。之后再把当前运算符入栈。  
按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。

后缀表达式的计算—手算:  
从左往右扫描，每遇到一个运算符，就让运算符前面最近的两个操作数执行对应的运算，合体为一个操作数；

```
注意： 两个操作数的左右顺序
```

**重点：后缀表达式的计算—机算**  
用栈实现后缀表达式的计算（栈用来存放当前暂时不能确定运算次序的操作数）

步骤 1: 从左往后扫描下一个元素，直到处理完所有元素;

步骤 2: 若扫描到操作数，则压入栈，并回到步骤 1; 否则执行步骤 3;

步骤 3: 若扫描到运算符，则弹出两个栈顶元素，执行相应的运算，运算结果压回栈顶，回到步骤 1;

注意: 先出栈的是 “右操作数”

**3. 前缀表达式 (波兰表达式)**  
运算符在两个操作数前面:

```
① + a b
② - +ab  c
③ - +ab *cd
```

中缀表达式转前缀表达式—手算  
步骤 1： 确定中缀表达式中各个运算符的运算顺序

步骤 2： 选择下一个运算符，按照 [运算符 左操作数 右操作数] 的方式组合成一个新的操作数

步骤 3： 如果还有运算符没被处理，就继续执行步骤 2

“右优先” 原则: 只要右边的运算符能先计算，就优先算右边的;

```
中缀：A + B * (C - D) - E / F
       ⑤   ③    ②    ④   ①
前缀：+ A - * B - C D / E F
```

前缀表达式的计算—机算  
用栈实现前缀表达式的计算

步骤 1: 从右往左扫描下一个元素，直到处理完所有元素；

步骤 2: 若扫描到操作数则压入栈，并回到步骤 1，否则执行步骤 3

步骤 3: 若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到步骤 1；

注意: 先出栈的是 “左操作数”

**4. 中缀表达式的计算 (用栈实现)**  
两个算法的结合： 中缀转后缀 + 后缀表达式的求值

初始化两个栈，操作数栈 和运算符栈

若扫描到操作数，压人操作数栈

若扫描到运算符或界限符，则按照 “中缀转后缀” 相同的逻辑压入运算符栈 (期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈项元素并执行相应运算，运算结果再压回操作数栈)

#### 3.3.3 栈在递归中的应用

函数调用的特点：最后被调用的函数最先执行结束 (LIFO)

函数调用时，需要用一个栈存储：

*   调用返回地址
*   实参
*   局部变量

递归调用时，函数调用栈称为 “递归工作栈”:

*   每进入一层递归，就将递归调用所需信息压入栈顶；
*   每退出一层递归，就从栈顶弹出相应信息；

** 缺点：** 太多层递归可能回导致栈溢出；

适合用 “递归” 算法解决：可以把原始问题转换为属性相同，但规模较小的问题；

# 第四章：字符串
字符串简称串
### 4.1 串的定义和实现

#### 4.1.1 串的定义

串: 零个或多个字符组成的有限序列，如 `S = 'iPhone 11 Pro Max?'；`

串是特殊的线性表，数据元素之间呈线性关系（逻辑结构相似）；  串的数据对象限定为字符集：中文字符、英文字符、数字字符、标点字符…  
串的基本操作，如增删改除通常以子串为操作对象

#### 4.1.3 串的存储结构

定长顺序存储：类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串。
堆分配存储表示：仍以一组空间足够大的、地址连续的存储单元依次存放字符序列，但它们的存储空间实在程序执行过程种动态分配的 (new 或malloc)
串的链式存储（块链）：每一个链表的结点存储多个字符——每个结点称为块——块链结构
![[Pasted image 20230905102630.png]]


### 4.2 串的模式匹配

**模式匹配**：子串的定位操作称为串的模式匹配，它**求的是子串（常称模式串）在主串中的位置。**
#### 4.2.1 朴素模式匹配算法

```
int Index(SString S, SString T){
    int i=1;                //扫描主串S
    int j=1;                //扫描模式串T
    while(i<=S.length && j<=T.length){
        if(S.ch[i] == T.ch[j]){
            ++i;
            ++j;             //继续比较后继字符
        }
        else{
            i = i-j+2;
            j=1;             //指针后退重新开始匹配
        }
    }
    if(j>T.length)
        return i-T.length;
    else
        return 0;
}
```

**时间复杂度分析：**

*   主串长度为 n，模式串长度为 m  
    最多比较`n-m+1`个子串  
    最坏时间复杂度 = `O(nm)`  
    每个子串都要对比 m 个字符 (对比到最后一个字符才匹配不上)，共要对比 n-m+1 个子串，复杂度 = `O((n-m+1)m) = O(nm - m^2 + m) = O(nm)`  
    PS: 大多数时候，n>>m  
    最好时间复杂度 = `O(n)`  
    每个子串的第一个字符就匹配失败，共要对比 n-m+1 个子串，复杂度 = `O(n-m+1) = O(n)`

#### 4.2.2 改进的模式匹配算法——KMP 算法

*   不匹配的字符之前，一定是和模式串一致的；
*   根据模式串 T，求出 next 数组（只与模式串有关，与主串无关），利用 next 数组进行匹配，当匹配失败时，主串的指针 i 不再回溯！  
    next 数组是根据子串求出来的，当前面的字符串已知时如果有重复的，从当前的字符匹配即可。

1.  求 next 数组

*   作用：当模式串的第 j 个字符失配时，从模式串的第 next[j] 继续往后匹配;
*   对于任何模式串，当第 1 个字符不匹配时，只能匹配下一个子串，因此，next[1] = 0——表示模式串应右移一位，主串当前指针后移一位，再和模式串的第一字符进行比较；
*   对于任何模式串，当第 2 个字符不匹配时，应尝试匹配模式串的第一个字符，因此，next[2] = 0;  
    例：对于串 T = `'abaabc'`  
    
    ![](<images/1693447314948.png>)
    

2.  利用`next数组`进行模式匹配

```
int Index_KMP(SString S, SString T, int next[]){
    int i=1;     //主串
    int j=1;     //模式串
    while（i<S.length && j<=T.length){
        if(j==0 || S.ch[i]==T.ch[j]){      //第一个元素匹配失败时
            ++j;
            ++i;         //继续比较后继字符
        }
        else
            j=next[j]   //模式串向右移动
    }
    if(j>T.length)
        return i-T.length; //匹配成功
}
```

3.  时间复杂度分析

*   求 next 数组时间复杂度 = O(m)
*   模式匹配过程最坏时间复杂度 = O(n)
*   KMP 算法的最坏时间复杂度 = O(m+n)

**next 数组的求法：**

我们能确定 next 数组第一二位一定分别为 0，1，后面求解每一位的 next 值时，根据前一位进行比较。  
从第三位开始，将前一位与其 next 值对应的内容进行比较，  
如果相等，则该位的 next 值就是前一位的 next 值加上 1；  
如果不等，向前继续寻找 next 值对应的内容来与前一位进行比较，  
直到找到某个位上内容的 next 值对应的内容与前一位相等为止，  
则这个位对应的值加上 1 即为需求的 next 值；  
如果找到第一位都没有找到与前一位相等的内容，那么求解的位上的 next 值为 1。

注意下标都是从 1 开始的  
传送门：[https://blog.csdn.net/m0_37482190/article/details/86667059](https://blog.csdn.net/m0_37482190/article/details/86667059)

# 第五章：树
![[Pasted image 20230905103027.png]]

### 5.1 树的基本概念

#### 5.1.1 树的定义

树是 `n` 个结点的有限集。
* 空树：`n=0`
- 根节点没有前驱，其他节点有且只有一个前驱
- 所有节点可以有 0 个或多个后继

树的定义是递归的，即树的定义中又用到了其自身。数是一种递归的数据结构
树作为一种逻辑结构，同时也是一种分层结构。
#### 5.1.2 基本术语
![[Pasted image 20230905103227.png]]

祖先：AB 是 K 的祖先，K 是他们的子孙
双亲：E 是 K 的双亲
兄弟：KL拥有相同双亲 E 
堂兄弟：双亲在同一层

结点的度：孩子数量
树的度：树中结点的最大度数
分支节点：度大于 0
叶子节点：度等于 0
结点的层次：从树根开始定义，根节点为第一层，从上到下依次类推。
结点深度：从根结点开始自顶向下
结点高度：从叶子节点开始自底向上
树的高度（深度）：树中结点最大层数

有序树：树中结点各子树从左到右是由次序的，不能互换，称为有序树，否则为无序数。
路径：两节点之间的路径由所经过的结点序列构成
路径长度：经过的边数

森林：m 棵互不相交的树的集合。

#### 5.1.3 树的性质

1.  树中的结点数等于所有结点的度数之和加 1。
2.  度为 $m$ 的树第 $i$ 层上至多有 $m^i-1$ 个结点
3.  度为 $m$ 的数、$m$ 叉数的区别  

    ![](<images/1693447314994.png>)
    

### 5.2 二叉树的概念

#### 5.2.1 二叉树的定义与特性
二叉树是另一种树形结构，其特点是**每个结点至多只有两棵子树**（即二叉树中不存在度大于 2 的结点)，并且**二叉树的子树有左右之分，其次序不能任意颠倒（二叉树是有序树，若将其左、右子树颠倒，则成为另一棵不同的二叉树。即使树中结点只有一棵子树，也要区分它是左子树还是右子树。）。**
![[Pasted image 20230905104508.png]]

与树相似，二叉树也以递归的形式定义。二叉树是 n (n≥0）个结点的有限集合:
1. 或者为空二叉树，即 n=0。
2. 或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一棵二叉树。

**二叉树与度为 2 的有序树的区别:**
1. 度为 2 的树至少有 3 个结点，而二叉树可以为空。
2. 度为 2 的有序树的孩子的左右次序是相对于另一孩子而言的，若某个结点只有一个孩子，则这个孩子就无须区分其左右次序，而二叉树无论其孩子数是否为 2，均需确定其左右次序，即二叉树的结点次序不是相对于另一结点而言，而是确定的。


#### 5.2.2 几种特殊的二叉树
![[Pasted image 20230905104719.png]]
1.  **满二叉树**：一颗深度为 $h$ 且有 $2^h-1$ 个结点的二叉树称为满二叉树。每一层上的结点数都达到最大。叶子全部在最低层。
2.  **完全二叉树**：深度为 $h$ 的具有 $n$ 个结点的二叉树，当且仅当其每一个结点都与深度为 $h$ 的满二叉树中编号为 $1~n$ 的结点一一对应时，称之为完全二叉树。
3.  **二叉排序树**。左子树上所有结点的关键字均小于根结点的关键字; 右子树上的所有结点的关键字均大干根结点的关键字: 左子树和右子树又各是一棵二叉排序树。
4.  **平衡二叉树**: 树上任一结点的左子树和右子树的深度之差不超过 1。


#### 5.2.3 二叉树的存储结构

##### 顺序存储
![[Pasted image 20230905105008.png]]
二叉树的顺序存储是指用一组**地址连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素**，即将完全二叉树上编号为 $i$ 的结点元素存储在一维数组下标为 $i-1$ 的分量中
依据二叉树的性质，**完全二叉树和满二叉树采用顺序存储比较合适**，树中结点的序号可以唯一地反映结点之间的逻辑关系，这样既能最大可能地节省存储空间，又能利用数组元素的下标值确定结点在二叉树中的位置，以及结点之间的关系。

##### 链式存储
![[Pasted image 20230905105022.png]]
由于顺序存储的空间利用率较低，因此**二叉树一般都采用链式存储结构**，用链表结点来存储二叉树中的每个结点。
在二叉树中，结点结构通常包括若干数据域和若干指针域，二叉链表至少包含 3 个域: 数据域 data、左指针域 lchild 和右指针域 rchild.

实际上在不同的应用中，还可以增加某些指针域，如**增加指向父结点的指针**后，变为**三叉链表**的存储结构。

### 5.3 二叉树的遍历和线索二叉树
二叉树的遍历是指按某条搜索路径访问树中每个结点，使得每个结点均被访问一次，而且仅被访问一次。由于二叉树是一种非线性结构，每个结点都可能有两棵子树，因而需要寻找一种规律，以便使二叉树上的结点能排列在一个线性队列上，进而便于遍历。
由二叉树的递归定义可知，遍历一棵二叉树便要决定对根结点 N、左子树 L 和右子树 R 的访问顺序。按照**先遍历左子树再遍历右子树**的原则，常见的遍历次序有**先序 (NLR)、中序（LNR)和后序 (LRN）** 三种遍历算法，**序指的是根结点在何时被访问**。

#### 5.3.1 二叉树的遍历

##### 先序遍历（根左右）

*   若二叉树为空，不用操作
*   若二叉树非空：
    *   访问根节点
    *   先序遍历左子树
    *   先序遍历右子树
- 
```c++
typedef struct BiTnode{
   ElemType data;          
   struct BiTNode *lchild, *rchild; 
}BiTNode, *BiTree;

void PreOrder(BiTree T){
   if(T!=NULL){
      visit(T);                 //访问根结点
      PreOrder(T->lchild);      //递归遍历左子树
      PreOrder(T->rchild);      //递归遍历右子树
   }
}
```

##### 中序遍历（左根右）

*   若二叉树为空，不用操作
*   若二叉树非空：
    *   先序遍历左子树
    *   访问根节点
    *   先序遍历右子树
- 
```c
typedef struct BiTnode{
   ElemType data;          
   struct BiTNode *lchild, *rchild; 
}BiTNode, *BiTree;

void InOrder(BiTree T){
   if(T!=NULL){
      InOrder(T->lchild);       //递归遍历左子树
      visit(T);                 //访问根结点
      InOrder(T->rchild);       //递归遍历右子树
   }
}
```

##### 后序遍历（左右根）

*   若二叉树为空，不用操作
*   若二叉树非空：  
    - 先序遍历左子树  
    - 先序遍历右子树  
    - 访问根节点
- 
```c
typedef struct BiTnode{
   ElemType data;          
   struct BiTNode *lchild, *rchild; 
}BiTNode, *BiTree;

void PostOrder(BiTree T){
   if(T!=NULL){
      PostOrder(T->lchild);       //递归遍历左子树 
      PostOrder(T->rchild);       //递归遍历右子树
      visit(T);                 //访问根结点
   }
}
```

##### 二叉树的层次遍历  
![[Pasted image 20230905105548.png]]

要进行层次遍历，需要借助一个队列。先将二叉树根结点入队，然后出队，访问出队结点，若它有左子树，则将左子树根结点入队; 若它有右子树，则将右子树根结点入队。然后出队，访问出队结点……如此反复，直至队列为空。


```
//二叉树的结点(链式存储)
typedef struct BiTnode{
   ElemType data;          
   struct BiTNode *lchild, *rchild; 
}BiTNode, *BiTree;

//链式队列结点
typedef struct LinkNode{
   BiTNode * data;
   typedef LinkNode *next;
}LinkNode;

typedef struct{
   LinkNode *front, *rear;  
}LinkQueue;

//层序遍历
void LevelOrder(BiTree T){
   LinkQueue Q;
   InitQueue (Q);          //初始化辅助队列
   BiTree p;
   EnQueue(Q,T);           //将根节点入队
   while(!isEmpty(Q)){     //队列不空则循环
      DeQueue(Q,p);        //队头结点出队
      visit(p);            //访问出队结点
      if(p->lchild != NULL)
         EnQueue(Q,p->lchild);   //左孩子入队
      if(p->rchild != NULL)
         EnQueue(Q,p->rchild);   //右孩子入队
   }
}
```

#####  由遍历序列构造二叉树
由二叉树的先序序列和中序序列可以唯一地确定一棵二叉树。

*   先序序列 + 中序序列
*   后序序列 + 中序序列
*   层序序列 + 中序序列  
    **key**: 找到树的根节点，并根据中序序列划分左右子树，再找到左右子树根节点、

先序+后序无法唯一确定一颗二叉树，但可以确定二叉树中结点的关系。
![[Pasted image 20230905105748.png]]

#### 5.3.2 线索二叉树

1.  线索二叉树的概念与作用  
    在二叉树的结点上加上线索的二叉树称为线索二叉树，对二叉树以某种遍历方式（如先序、中序、后序或层次等）进行遍历，使其变为线索二叉树的过程称为对二叉树进行线索化。
2.  线索二叉树的存储结构

*   中序线索二叉树——线索指向中序前驱、中序后继

```
//线索二叉树结点
typedef struct ThreadNode{
   ElemType data;
   struct ThreadNode *lchild, *rchild;
   int ltag, rtag;                // 左、右线索标志
}ThreadNode, *ThreadTree;
```

tag == 0: 指针指向孩子

tag == 1: 指针是 “线索”

*   先序线索二叉树——线索指向先序前驱、先序后继
    
*   后序线索二叉树——线索指向后序前驱、后序后继
    

3.  二叉树的线索话

*   中序线索化

```
typedef struct ThreadNode{
   int data;
   struct ThreadNode *lchild, *rchild;
   int ltag, rtag;                // 左、右线索标志
}ThreadNode, *ThreadTree;

//全局变量pre, 指向当前访问的结点的前驱
TreadNode *pre=NULL;

void InThread(ThreadTree T){
    if(T!=NULL){
        InThread(T->lchild);    //中序遍历左子树
        visit(T);               //访问根节点
        InThread(T->rchild);    //中序遍历右子树
    }
}

void visit(ThreadNode *q){
   if(q->lchid = NULL){                 //左子树为空，建立前驱线索 
      q->lchild = pre;
      q->ltag = 1;
   }

   if(pre!=NULL && pre->rchild = NULL){ 
      pre->rchild = q;           //建立前驱结点的后继线索
      pre->rtag = 1;
   }
   pre = q;
}

//中序线索化二叉树T
void CreateInThread(ThreadTree T){
   pre = NULL;                //pre初始为NULL
   if(T!=NULL);{              //非空二叉树才能进行线索化
      InThread(T);            //中序线索化二叉树
      if(pre->rchild == NULL)
         pre->rtag=1;         //处理遍历的最后一个结点
   }
}
```

*   先序线索化  
    注意【转圈】问题，当 ltag==0 时，才能对左子树先序线索化

```
typedef struct ThreadNode{
   int data;
   struct ThreadNode *lchild, *rchild;
   int ltag, rtag;                // 左、右线索标志
}ThreadNode, *ThreadTree;

//全局变量pre, 指向当前访问的结点的前驱
TreadNode *pre=NULL;

//先序遍历二叉树，一边遍历一边线索化
void PreThread(ThreadTree T){
   if(T!=NULL){
      visit(T);
      if(T->ltag == 0)         //lchild不是前驱线索
         PreThread(T->lchild);
      PreThread(T->rchild);
   }
}

void visit(ThreadNode *q){
   if(q->lchid = NULL){                 //左子树为空，建立前驱线索 
      q->lchild = pre;
      q->ltag = 1;
   }

   if(pre!=NULL && pre->rchild = NULL){ 
      pre->rchild = q;           //建立前驱结点的后继线索
      pre->rtag = 1;
   }
   pre = q;
}

//先序线索化二叉树T
void CreateInThread(ThreadTree T){
   pre = NULL;                //pre初始为NULL
   if(T!=NULL);{              //非空二叉树才能进行线索化
      PreThread(T);            //先序线索化二叉树
      if(pre->rchild == NULL)
         pre->rtag=1;         //处理遍历的最后一个结点
   }
}
```

*   后序线索化

```
typedef struct ThreadNode{
   int data;
   struct ThreadNode *lchild, *rchild;
   int ltag, rtag;                // 左、右线索标志
}ThreadNode, *ThreadTree;

//全局变量pre, 指向当前访问的结点的前驱
TreadNode *pre=NULL;

//先序遍历二叉树，一边遍历一边线索化
void PostThread(ThreadTree T){
   if(T!=NULL){
      PostThread(T->lchild);
      PostThread(T->rchild);
      visit(T);                  //访问根节点
   }
}

void visit(ThreadNode *q){
   if(q->lchid = NULL){                 //左子树为空，建立前驱线索 
      q->lchild = pre;
      q->ltag = 1;
   }

   if(pre!=NULL && pre->rchild = NULL){ 
      pre->rchild = q;           //建立前驱结点的后继线索
      pre->rtag = 1;
   }
   pre = q;
}

//先序线索化二叉树T
void CreateInThread(ThreadTree T){
   pre = NULL;                //pre初始为NULL
   if(T!=NULL);{              //非空二叉树才能进行线索化
      PostThread(T);            //后序线索化二叉树
      if(pre->rchild == NULL)
         pre->rtag=1;         //处理遍历的最后一个结点
   }
}
```

4.  线索二叉树中找前驱、后继

*   中序线索二叉树找中序后继：在中序线索二叉树中找到指定节点 *p 的中序后继 next

```
若 p->rtag == 1, 则 next = p->rchild;

若 p->rtag == 0, 则 p 必有右孩子, 则 next = p的右子树中最左下结点;
```

```
//1. 找到以P为根的子树中，第一个被中序遍历的结点
ThreadNode *Firstnode(ThreadNode *p){
   //循环找到最左下的结点（不一定是叶结点）
   while(p->ltag == 0)
      p=p->lchild;
   return p;
}

//2. 在中序线索二叉树中找到结点p的后继结点
ThreadNode *Nextnode(ThreadNode *p){
   //右子树最左下结点
   if(p->rtag==0)
      return Firstnode(p->rchild);
   else 
      return p->rchild; //rtag==1，直接返回后继线索
}

//3. 对中序线索二叉树进行中序遍历
void Inorder(ThreadNode *T){            //T为根节点指针
   for(ThreadNode *p = Firstnode(T); p!=NULL; p = Nextnode(p))
      visit(p);
}
```

*   先序线索二叉树找先序后继：在先序线索二叉树中找到指定节点 *p 的先序后继 next

若 `p->rtag == 1, 则 next = p->rchild; 若 p->rtag == 0`, 则 p 必有右孩子（左孩子不知道）

case1: 若 p 有左孩子 ——— 根 左 右 / 根 (根 左 右) 右

case2: 若 p 没有左孩子 ——— 根 右 / 根 (* 根 * 左 右)

*   先序线索二叉树找先序前驱：在先序线索二叉树中找到指定节点 *p 的先序前驱 pre

若 p->ltag == 1, 则 next = p->lchild;

若 p->ltag == 0, 则 p  
必有左孩子，但是先序遍历中，左右子树的结点只可能是根的后继，不可能是前驱，所以不能从左右孩子里寻找 p 的先序前驱，（除非从头开始遍历 / 三叉链表

case1: 如果能够找到 p 的父节点，且 p 是左孩子 —— p 的父节点就是 p 的前驱；

case2: 如果能够找到 p 的父节点，且 p 是右孩子，且其左兄弟为空 —— p 的父节点就是 p 的前驱；

case3: 如果能够找到 p 的父节点，且 p 是右孩子，且其左兄弟非空 ——  
p 的前驱为左兄弟子树中最后一个被先序遍历到的结点（根节点出发，先往右，右没有往左，找到最下一层的结点）；

case4: p 没有父节点，即 p 为根节点，则 p 没有先序前驱

*   后序线索二叉树找后序前驱：在后序线索二叉树中找到指定节点 *p 的后序前驱 pre

若 p->ltag == 1, 则 next = p->lchild;

若 p->ltag == 0, 则 p 必有左孩子（不知道有没有右孩子）

case1: 若 p 有右孩子 ——— 左 右 根 / 左 (左 右 根) 根

case2: 若 p 没有右孩子 ——— 左 根 （左子树按后序遍历，最后一个结点，p 的左孩子）

*   后序线索二叉树找后序后继：在后序线索二叉树中找到指定节点 *p 的后序后继 next

若 p->rtag == 1, 则 next = p->rchild;

若 p->rtag == 0, 则 p 必有右孩子, 左孩子不知道, 但是在后序遍历中，左右子树中的结点只有可能是根的前驱，而不可能是根的后继，所以找不到后继，（除非从头开始遍历 / 三叉链表

case1: 如果能找到 p 的父节点，且 p 是右孩子 —— p 的父节点即为其后继

case2: 如果能找到 p 的父节点，且 p 是左孩子，其右兄弟为空 —— p 的父节点即为其后继

case3: 如果能找到 p 的父节点，且 p 是左孩子，其右兄弟非空 —— p 的后继为其右兄弟子树中第一个被后序遍历的结点；

case4: p 没有父节点，即 p 为根节点，则 p 没有后序后继；

![](<images/1693447315087.png>)

### 5.4 树、森林

#### 5.4.1 树的存储结构

1.  **双亲表示法 (顺序存储)**：采用一组连续空间存储每个节点，每个结点中保存指向双亲的指针（在数组中的位置）
- 数据域：存放结点本身信息。  
- 双亲域：指示本结点的双亲结点在数组中的位置。

优点：利用了每个结点 (根结点除外)只有唯一双亲的性质，可以很快得到双亲结点
缺点：求结点的孩子时需要遍历整个结构
![[Pasted image 20230905110036.png]]

```c
#define MAX_TREE_SIZE 100  //树中最多结点数

typedef struct{      //树的结点定义
   ElemType data; 
   int parent;      //双亲位置域
}PTNode;

typedef struct{                   //树的类型定义
   PTNode nodes[MAX_TREE_SIZE];   //双亲表示
   int n;                         //结点数
}PTree;
```

2. **孩子表示法** (顺序 + 链式) 
孩子表示法是将每个结点的孩子结点都用单链表链接起来形成一个线性结构，此时 n 个结点就有 n 个孩子链表（叶子结点的孩子链表为空表)
![[Pasted image 20230905110348.png]]
这种存储方式寻找子女的操作非常直接，而寻找双亲的操作需要遍历 n 个结点中孩子链表指针域所指向的 n 个孩子链表。

```c
struct CTNode{
   int child;    //孩子结点在数组中的位置
   struct CTNode *next;    // 下一个孩子
};

typedef struct{
   ElemType data;
   struct CTNode *firstChild;    // 第一个孩子
}CTBox;

typedef struct{
   CTBox nodes[MAX_TREE_SIZE];
   int n, r;   // 结点数和根的位置
}CTree;
```

1.  **孩子兄弟表示法 （二叉树表示法）**（链式）
以二叉链表作为树的存储结构。孩子兄弟表示法使每个结点包括三部分内容: 结点值、指向结点第一个孩子结点的指针，及指向结点下一个兄弟结点的指针（沿此域可以找到结点的所有兄弟结点)
优点：这种存储表示法比较灵活，可以方便地实现树转换为二叉树的操作，易于查找结点的孩子。
缺点是从当前结点查找其双亲结点比较麻烦。若为每个结点增设一个 parent 域指向其父结点，则查找结点的父结点也很方便。

![[Pasted image 20230905110408.png]]
```
typedef struct CSNode{
   ElemType data;                               //数据域
   struct CSNode *firstchild, *nextsibling;     //第一个孩子和右兄弟指针, *firstchild 看作左指针，*nextsibling看作右指针
}CSNode. *CSTree;
```

#### 5.4.3 树、森林的遍历
![[Pasted image 20230905110832.png]]

树的遍历是指用某种方式访问树中的每个结点，且仅访问一次。主要有两种方式:
1. **先根遍历**：若树非空，先访问根结点，再依次对每棵子树进行先根遍历；（与对应二叉树的先序遍历序列相同）
```
void PreOrder(TreeNode *R){
   if(R!=NULL){
      visit(R);    //访问根节点
      while(R还有下一个子树T)
         PreOrder(T);      //先跟遍历下一个子树
   }
}
```

2. **后根遍历**：若树非空，先依次对每棵子树进行后根遍历，最后再返回根节点；（与对应二叉树的中序遍历序列相同）

```
void PostOrder(TreeNode *R){
   if(R!=NULL){
      while(R还有下一个子树T)
         PostOrder(T);      //后跟遍历下一个子树
      visit(R);    //访问根节点
   }
}
```

*   层序遍历（队列实现）：
若树非空，则根结点入队；  
若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队；  
重复以上操作直至队尾为空；

2.  森林的遍历
*   先序遍历：等同于依次对各个树进行**先根遍历**；也可以先转换成与之对应的二叉树，对二叉树进行先序遍历；
*   中序遍历：等同于依次对各个树进行**后根遍历**；也可以先转换成与之对应的二叉树，对二叉树进行中序遍历；


### 5.5.1 二叉排序树（BST）
Binary Search Tree

1.  二叉排序树的定义  
    左子树结点值 < 跟结点值 < 右子树结点值
2.  查找操作

```
typedef struct BSTNode{
   int key;
   struct BSTNode *lchild, *rchild;
}BSTNode, *BSTree;

//在二叉排序树中查找值为key的结点（非递归）
//最坏空间复杂度：O(1)
BSTNode *BST_Search(BSTree T, int key){
   while(T!=NULL && key!=T->key){        //若树空或等于跟结点值，则结束循环
      if(key<T->key)       //值小于根结点值，在左子树上查找
         T = T->lchild;
      else                  //值大于根结点值，在右子树上查找
         T = T->rchild;
   }
   return T;
}

//在二叉排序树中查找值为key的结点（递归）
//最坏空间复杂度：O(h)
BSTNode *BSTSearch(BSTree T, int key){
   if(T == NULL)
      return NULL;
   if(Kry == T->key)
      return T;
   else if(key < T->key)
      return BSTSearch(T->lchild, key);
   else 
      return BSTSearch(T->rchild, key);
}
```

3.  插入操作

```
//在二叉排序树中插入关键字为k的新结点（递归）
//最坏空间复杂度：O(h)
int BST_Insert(BSTree &T, int k){
   if(T==NULL){           //原树为空，新插入的结点为根结点
      T = (BSTree)malloc(sizeof(BSTNode));
      T->key = k;
      T->lchild = T->rchild = NULL;
      return 1;                       //插入成功
   }
   else if(K == T->key)               //树中存在相同关键字的结点，插入失败
      return 0;
   else if(k < T->key)                 
      return BST_Insert(T->lchild,k);
   else 
      return BST_Insert(T->rchild,k);
}
```

4.  二叉排序树的构造

```
//按照str[]中的关键字序列建立二叉排序树
void Crear_BST(BSTree &T, int str[], int n){
   T = NULL;                     //初始时T为空树
   int i=0;
   while(i<n){
      BST_Insert(T,str[i]);     //依次将每个关键字插入到二叉排序树中
      i++;
   }
}
```

5.  删除操作
6.  查找效率分析

查找长度：查找运算中，需要对比关键字的次数，反映了查找操作时间复杂度；  
查找成功的平均查找长度 ASL  
查找失败的平均查找长度 ASL

### 5.5.2 平衡二叉树（AVL）

1.  平衡二叉树的定义  
    在插入和删除二叉树的结点时，要保证任意结点的左右子树的高度差的绝对值不超过 1，将这样的树称为**平衡二叉树**。

```
//平衡二叉树结点
typedef struct AVLNode{
   int key;         //数据域
   int balance;     //平衡因子
   struct AVLNode *lchild; *rchild; 
}AVLNode, *AVLTree;
```

2.  平衡二叉树的插入
3.  插入新节点后如何调整 “不平衡” 问题  
    调整最小不平衡子树

LL: 在 A 结点的左孩子的左子树中插入导致不平衡  
调整： A 的左孩子结点右上旋  
RR: 在 A 结点的右孩子的右子树中插入导致不平衡  
调整： A 的右孩子结点左上旋  
LR: 在 A 结点的左孩子的右子树中插入导致不平衡  
调整： A 的左孩子的右孩子，先左上旋再右上旋  
RL: 在 A 结点的右孩子的左子树中插入导致不平衡  
调整： A 的右孩子的左孩子，先右上旋再左上旋

4.  平衡二叉树的查找与效率分析  
    若树高为 h，则最坏情况下，查找一个关键字最多需要对比 h 次，即查找操作的时间复杂度不可能超过 O(h);

### 5.5.3 哈夫曼树

1.  带权路径长度：从根节点到该结点之间的路径长度与该节点的权的乘积。
2.  哈夫曼树的定义：带权路径最短的树。
3.  哈夫曼树的构造（重点）：构造森林全是根, 选用两小造新树，删除两小添新人，重复 2、3 剩单根。
4.  哈杜曼编码（重点）：  
    
    ![](<images/1693447315258.png>)
    

：由哈夫曼树得到的二进制前缀编码称为哈夫曼编码。

# 第六章 图

### 6.1 图的基本概念

*   图是一种非线性结构
*   图的特点：

1.  顶点之间的关系是任意的
2.  图中任意两个顶点之间都可能相关
3.  顶点的前驱和后继个数无限制

*   定义：图是一种数据元素间存在多对多关系的数据结构加上一组基本操作构成的抽象数据类型。  
    生成树：所有顶点均由边连接在一起但不存在回路的图。

### 6.2 图的存储结构

#### 6.2.1 数组表示法（邻接矩阵表示法）

![](<images/1693447315304.png>)

  

![](<images/1693447315362.png>)

#### 6.2.2 邻接表（类似于数的孩子链表表示法）

![](<images/1693447315411.png>)

  

![](<images/1693447315458.png>)

#### 6.2.3 十字链表

![](<images/1693447315502.png>)

### 6.3 图的遍历

定义：从图的任意指定顶点出发，依照某种规则去访问图中所有顶点，且每个顶点仅被访问一次，这一过程叫图的遍历。  
方式：

*   深度优先遍历方法（Depth_First Search——DFS）
*   广度优先遍历法（Breadth_Frist Search——BFS）

### 6.4 最小生成树

普里姆（Prim）算法。  

![](<images/1693447315547.png>)

### 6.5 最短路径

迪杰斯特拉：

![](<images/1693447315594.png>)

### 6.6AOV 网络与拓扑排序

### 6.7 AOE 网络与关键路径

# 第七章 查找
![[Pasted image 20230901093425.png]]
## 相关概念
- 查找：在数据集合中找到满足条件的元素
- 查找表：用于查找的由同一类型的数据元素（或记录）构成的集合。对查找表进行的经常操作为：查找、检索、增加、删除。
- 静态查找表：对查找表只进行前两种操作。不会增删元素。适合静态查找表的方法有顺序查找，折半查找，散列查找
- 动态查找表：不仅限于前两种操作。适合动态查找表的方法有二叉树的查找、散列查找。
- 关键字：数据元素唯一标识该元素的某个中某个数据项的值，使用基于关键字的查找，查找结果应该唯一。
- **平均查找长度（ASL）**：一次查找的长度是需要比较的关键字次数，而**平均查找长度是所有查找过程中进行关键字的比较次数的平均值**。是衡量查找算法效率的主要指标。
$$
\mathrm{ASL}=\sum_{i=1}^{n}P_{i}C_{i}
$$
-  $n$ ：查找表的长度
-  $P_i$ ：查找第 i 个数据元素的概率，一般认为每个数据元素的查找概率相等，即 $P_i= 1/n$;
-  $C_i$ ：找到第 $i$ 个数据元素所需进行的比较次数。


![](https://img-blog.csdn.net/20151016110119419?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


## 1 顺序查找

 核心：从数据的第一个元素开始，依次比较，直到找到目标数据或查找失败。

优点：
- 数据元素无要求
- 顺序存储链式存储都可以，顺序表通过数组下标依次扫描，链表通过指针 next 依次扫描。
- 对有序性也没有要求。对于有序表的查找，查找失败时可以不用再继续比较，降低顺序查找失败的 ASL。

缺点：是时间复杂度较大，n 较大时，ASL 大，效率较低。

时间复杂度：$O (n)$


```c++
/* 顺序查找，Array为数组，n为要查找的数组元素个数，key为要查找的关键字*/
int seqSearch(int Array[], int key, int n) 
{
    for (int index = 0; index < n; index++)
    {
        if (Array[index] == key)
            return index;
    }
    return -1;
}
 
/*有哨兵顺序查找-优化最简单的顺序查找*/
/*优化部分：Array[0]存放要查找的关键字key，引入它的目的是使得循环不必判断数组是否越界，因为满足i==0时，循环一定跳出。
ps：Array[0] = key的目的就是让上述的简单顺序查找的两次判断修正为一次Array[i]与Array[0]是否相等的一次判断。*/
 
int seqSearch1(int Array[], int key, int n) {
    int i;         //声明i
    Array[0] = key;//设置哨兵
    for (i = n; Array[0] != Array[i]; i--){ }//从表后往前找，直到Array[0] == Array[i]
    return i;//若i为0，表示查找失败，否则R[i]是要找的结点
}
```

## 2 二分查找（折半查找）

性能优异，**仅适用于有序的顺序表**
 
**二分查找**：每次将中间位置的数与 key 比较，若相等则查找成功，不等则选择前半部分或后半部分继续查找。（例如，在升序表中，若给定值 key 大于中间元素，则查找的元素只能在后半部分）

时间复杂度：$O (log_2n)$

```c++
/* 二分查找，Array为数组，n为要查找的数组元素个数，key为要查找的关键字*/
/*二分查找，非递归*/
int binarySearch(int Array[],int key,int n) 
{
    int left = 0;//记录范围左边界
    int right = n - 1;//记录范围右边界
    int mid;//范围是否不为空
 
    while (left<=right)
    {
        mid = (right + left) / 2; //取中间位置
        if (Array[mid]==key)
        {
            return mid;//查找成功返回
        }
        else if (Array[mid]>key)
        {
            right = mid - 1; //继续在左半边中查找
        }
        else
        {
            left = mid + 1;//继续在右半边中查找
        }
    }
 
    return -1; // 当left>right时表示查找区间为空，查找失败
 
}
 
/* 二分查找，Array为数组，n为要查找的数组元素个数，key为要查找的关键字,left为范围左边界，right为范围右边界*/
 
/*二分查找，递归*/
 
int binarySearch1(int Array[],int left,int right,int key) 
{
 
    int mid = (right + left) / 2;
    if (Array[mid]==key)
        return mid;//查找成功返回
    else if (Array[mid]>key)
        binarySearch1(Array,left, mid - 1,key);//递归调用，在左半边查询
    else
        binarySearch1(Array, mid + 1,right,key);//递归调用，在右半边查询
}
```

## 3 插值查找

在介绍插值查找之前，首先考虑一个新问题，为什么上述算法一定要是折半，而不是折四分之一或者折更多呢？

打个比方，在英文字典里面查“apple”，你下意识翻开字典是翻前面的书页还是后面的书页呢？如果再让你查“zoo”，你又怎么查？很显然，这里你绝对不会是从中间开始查起，而是有一定目的的往前或往后翻。
同样的，比如要在取值范围1 ~ 10000 之间100 个元素从小到大均匀分布的数组中查找 5，我们自然会考虑从数组下标较小的开始查找。

经过以上分析，折半查找这种查找方式，不是自适应的（也就是说是傻瓜式的）。二分查找中查找点计算如下：

```
mid=(low+high)/2, 即 mid=low+1/2*(high-low);
```

　　**通过类比，我们可以将查找的点改进为如下：**

```
mid=low+(key-a[low])/(a[high]-a[low])*(high-low)
```

也就是将上述的比例参数 1/2 改进为自适应的，根据关键字在整个有序表中所处的位置，让mid值的变化更靠近关键字key，这样也就间接地减少了比较次数。

　　**基本思想：** 基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，插值查找也**仅适用于有序的顺序表**
　　
**注：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。**

时间复杂度： **$O (log_2(log_2n))$****。

```c++
//插值查找
int InsertionSearch(int Array[],int left,int right,int key) 
{
    int mid = left + (key - Array[left]) / (Array[right] - Array[left])*(right - left);//插值公式
    if (Array[mid] == key)
        return mid;
    if (Array[mid]>key)
        return InsertionSearch(Array, key, left, mid - 1);
    if (Array[mid]<key)
        return InsertionSearch(Array, key, mid + 1, right);
}
```

## 4 分块查找（索引顺序查找）

吸取了顺序查找和折半查找各自的优点，既有动态结构，有适合快速查找。

 
**算法思想：**
将查找表分为若个子块。子块内元素可以无序，块之间必须有序；即第 1 块中任一元素的关键字都必须小于第 2 块中任一元素的关键字；而第 2 块中任一元素又都必须小于第 3 块中的任一元素。以此类推。

**算法流程：**
　　1. 建立一个索引表（按关键字有序排列），**索引表中每个元素含有各块的最大关键字和各块中的第一个元素的地址。**
　　2. 查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中顺序查找。

**时间复杂度**：$O(log2n)~O(n)$

例如, 关键码集合为{88,24,72,61,21,6,32,11,8,31, 22,83,78,54}, 按照关键码值 24,54,78,88，分为 4 个块和索引表，如图 7.3 所示。

 ![[Pasted image 20230901103623.png]]
 
```c++
typedef int KeyType;
typedef char InfoType[10];
typedef struct
{
    KeyType key;                //KeyType为关键字的数据类型 
    InfoType data;              //其他数据 
} NodeType;

typedef NodeType SeqList[MAXL]; //顺序表类型 
 
typedef struct
{
    KeyType key;            //KeyType为关键字的类型 
    int link;               //指向对应块的起始下标 
} IdxType;
 
typedef IdxType IDX[MAXI];  //索引表类型 
 
//I表示索引表如：IDX I = { { 14,0 },{ 34,5 },{ 66,10 },{ 85,15 },{ 100,20 } };
 
//m表示分块的数量如：m=5;
 
//R表示需要查找的数据表 如：KeyType a[] = { 8,14,6,9,10, 22,34,18,19,31, 40,38,54,66,46, 71,78,68,80,85, 100,94,88,96,87 };
 
//n表示a[]中的个数 n=25;
 
//K表示需要查找的数值 K=85;
 
int IdxSearch(IDX I, int m, SeqList R, int n, KeyType k) {   //二分查找法查找索引表
    int low = 0, high = m - 1, mid, i;
    int b = n / m;              //b为每块的记录个数 
    while (low <= high)       //在索引表中进行二分查找,找到的位置存放在low中 
    {
        mid = (low + high) / 2;
        if (I[mid].key >= k)
            high = mid - 1;
        else
            low = mid + 1;
    }
 
    //应在索引表的high+1块中,再在线性表中进行顺序查找 
    i = I[high + 1].link;
    
    while (i <= I[high + 1].link + b - 1 && R[i].key != k) //在顺序表中固定的块中查找
        i++;
    if (i <= I[high + 1].link + b - 1)
        return i + 1; //返回查找成功后该数值在顺序表中的序号
    else
        return 0;
}
```


## 5  斐波那契查找 (鸽)

> [!NOTE] 斐波那契数列（Fibonacci sequence）
>又称黄金分割数列，其数值为：1、1、2、3、5、8、13、21、34……在数学上，这一数列以如下递推的方法定义：$$F(0){=}1,F(1){=}1,F(n){=}F(n-1){+}F(n{-}2)(n{\geq}2,n\in\mathbb{N}^{\star})$$

**采用最接近查找长度的斐波那契数值来确定拆分点**。举个例子来讲，现有长度为 9 的数组，要对它进行拆分，对应的斐波那契数列（长度先随便取，只要最大数大于 9 即可）{1，1，2，3，5，8，13，21，34}，不难发现，大于 9 且最接近 9 的斐波那契数值是 f[6]=13，为了满足所谓的黄金分割，所以它的第一个拆分点应该就是 f[6] 的前一个值 f[5]=8，即待查找数组 array 的第 8 个数，对应到下标就是 array[7]，依次类推。

_**推演到一般情况，假设有待查找数组**_ _**array[n]**_ _**和斐波那契数组**_ _**F[k],**_ _**并且**_ _**n**_ _**满足**_ _**n>=F[k]-1&&n < F[k+1]-1**__**，则它的第一个拆分点**_ _**middle=F[k]-1**__**。**_

这里得注意，如果 n 刚好等于 F[k]-1, 待查找数组刚好拆成 F[k-1] 和 F[k-2] 两部分，那万事大吉你好我好；然而大多数情况并不能尽人意，n 会小于 F[k]-1, 这时候可以拆成完整 F[k-1] 和残疾的 F[k-2] 两部分，那怎么办呢？

聪明的前辈们早已想好了解决办法，对了，就是补齐，用最大的数来填充 F[k-2] 的残缺部分，如果查找的位置落到补齐的部分，那就可以确定要找的那个数就是最后一个最大的了。

（只是为了确定一个分割点，其余的思想和二分查找一样）

![](https://img-blog.csdn.net/20180910172426712?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29GYW5nRmVpTWVuZzE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

斐波那契查找与折半查找很相似，他是根据斐波那契序列的特点对有序表进行分割的。他要求开始表中记录的个数为某个斐波那契数小 1，即 n=F (k)-1;

 开始将 k 值与第 F (k-1）位置的记录进行比较 (及 mid=low+F (k-1)-1), 比较结果也分为三种

 1）相等，mid 位置的元素即为所求

 2）>   ,low=mid+1, k-=2; 说明:low=mid+1 说明待查找的元素在 [mid+1, hign] 范围内，k-=2 说明范围 [mid+1, high] 内的元素个数为 n-（F (k-1))= Fk-1-F (k-1)=Fk-F (k-1)-1=F (k-2)-1 个，所以可以递归的应用斐波那契查找

 3)<    , high=mid-1, k-=1; 说明:high=mid-1 说明待查找的元素在 [low, mid-1] 范围内，k-=1 说明范围 [low, mid-1] 内的元素个数为 F (k-1)-1 个，所以可以递归的应用斐波那契查找

大部分说明都忽略了一个条件的说明：n=F (k)-1，表中记录的个数为某个斐波那契数小 1。这是为什么呢？

我想了很久，终于发现，原因其实很简单：是为了格式上的统一，以方便递归或者循环程序的编写。表中的数据是 F (k)-1 个，使用 mid 值进行分割又用掉一个，那么剩下 F (k)-2 个。正好分给两个子序列，每个子序列的个数分别是 F (k-1)-1 与 F (k-2)-1 个，格式上与之前是统一的。不然的话，每个子序列的元素个数有可能是 F (k-1)，F (k-1)-1，F (k-2)，F (k-2)-1 个，写程序会非常麻烦。

斐波那契查找的核心是：  
1）当 key=a[mid] 时，查找成功；  
2）当 key<a[mid] 时，新的查找范围是第 low 个到第 mid-1 个，此时范围个数为 F[k-1] - 1 个，即数组左边的长度，所以要在 [low, F[k - 1] - 1] 范围内查找；  
3）当 key>a[mid] 时，新的查找范围是第 mid+1 个到第 high 个，此时范围个数为 F[k-2] - 1 个，即数组右边的长度，所以要在 [F[k - 2] - 1] 范围内查找。

**条件：**(1) 数据必须采用顺序存储结构；(2) 数据必须有序。
**原理：**(1) 最接近查找长度的斐波那契值来确定拆分点;(2) 黄金分割。

**时间复杂度**： $O(log_2n)$。

```
const int max_size = 20;//斐波那契数组的长度
 
/*构造一个斐波那契数组*/
 
void Fibonacci(int * F) {
 
    F[0] = 0;
 
    F[1] = 1;
 
    for (int i = 2; i<max_size; ++i)
 
        F[i] = F[i - 1] + F[i - 2];
 
}
 
 
 
/*定义斐波那契查找法*/
 
//a为要查找的数组,n为要查找的数组长度,key为要查找的关键字
 
int FibonacciSearch(int *a, int n, int key) {
 
    int low = 0;
 
    int high = n - 1;
 
    int F[max_size];
 
    Fibonacci(F);//构造一个斐波那契数组F
 
 
 
    int k = 0;
 
    while (n>F[k] - 1)//计算n位于斐波那契数列的位置
 
        ++k;
 
 
 
    int  * temp;//将数组a扩展到F[k]-1的长度
 
    temp = new int[F[k] - 1];
 
    memcpy(temp, a, n * sizeof(int));
 
    //temp是数组a的复制
 
    //temp中有F[k] - 1个数，但是a中只有n个，所以剩余的数用a中的最大值即a[n-1]填充。
 
    for (int i = n; i<F[k] - 1; ++i)
 
        temp[i] = a[n - 1];
 
 
 
    while (low <= high)
 
    {
 
        int mid = low + F[k - 1] - 1;//
 
        if (key<temp[mid])
 
        {
 
            high = mid - 1;
 
            k -= 1;
 
        }
 
        else if (key>temp[mid])
 
        {
 
            low = mid + 1;
 
            k -= 2;
 
        }
 
        else
 
        {
 
            if (mid<n)
 
                return mid; //若相等则说明mid即为查找到的位置
 
            else
 
                return n - 1; //若mid>=n则说明是扩展的数值,返回n-1
 
        }
 
    }
 
    delete[] temp;
 
    return -1;
 
}
 
 
 
//递归实现
 
int FibonacciSearch1(int *a,int *F, int key, int low, int hight,int k) {
 
    int middle = low + F[k - 1] - 1;
 
    if (key < a[middle]) {
 
        return FibonacciSearch1(a, F, key, low, middle - 1, k - 1);
 
    }
 
    else if (key > a[middle]) {
 
        return FibonacciSearch1(a, F, key, middle + 1, hight, k - 2);
 
    }
 
    else {
 
        if (middle <= hight) {
 
            return middle;
 
        }
 
        else {
 
            return hight;
 
        }
 
    }
 
}
```

## 6  二叉查找树

二叉查找树定义：又称为是二叉排序树（Binary Sort Tree）或二叉搜索树。二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：

　　1) 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；

　　2) 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；

　　3) 左、右子树也分别为二叉排序树；

　　4) 没有键值相等的节点。

二叉查找树的性质：对二叉查找树进行中序遍历，即可得到有序的数列。

二叉查找树的时间复杂度：它和二分查找一样，插入和查找的时间复杂度均为 O (logn)，但是在最坏的情况下仍然会有 O (n) 的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡（比如，我们查找上图（b）中的 “93”，我们需要进行 n 次查找操作）。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。

二叉查找树的高度决定了二叉查找树的查找效率。

二叉查找树的插入过程如下：

　　1) 若当前的二叉查找树为空，则插入的元素为根节点;

　　2) 若插入的元素值小于根节点值，则将元素插入到左子树中;

　　3) 若插入的元素值不小于根节点值，则将元素插入到右子树中。

二叉查找树的删除，分三种情况进行处理：

　　1) p 为叶子节点，直接删除该节点，再修改其父节点的指针（注意分是根节点和不是根节点）

　　2) p 为单支节点（即只有左子树或右子树）。让 p 的子树与 p 的父亲节点相连，删除 p 即可（注意分是根节点和不是根节点）

　　3) p 的左子树和右子树均不空。找到 p 的后继 y，因为 y 一定没有左子树，所以可以删除 y，并让 y 的父亲节点成为 y 的右子树的父亲节点，并用 y 的值代替 p 的值；或者方法二是找到 p 的前驱 x，x 一定没有右子树，所以可以删除 x，并让 x 的父亲节点成为 y 的左子树的父亲节点。如图 c。

```c++ fold
/*********************************

二叉排序树的相关操作实现

Author:兰亭风雨  Date：2014-02-23

Email:zyb_maodun@163.com

**********************************/
 
#include<stdio.h> 
 
#include<stdlib.h> 
 
 
 
typedef struct Node
 
{
 
    int data;
 
    struct Node *lchild;
 
    struct Node *rchild;
 
}NODE, *BSTree;
 
 
 
 
 
/*

在指针pTree所指的二叉排序树中递归查找关键字为key的元素，

若查找成功，则返回指向该元素节点的指针，否则返回NULL

*/
 
BSTree search(BSTree pTree, int key) {
 
    if (!pTree || pTree->data == key) //查找到时返回的pTree为该元素节点，没查找到时为NULL 
 
        return pTree;
 
    else if (key < pTree->data)            //如果key小于当前节点的值，则在其左子树中递归查找 
 
        return search(pTree->lchild, key);
 
    else                                //如果key大于当前节点的值，则在其右子树中递归查找 
 
        return search(pTree->rchild, key);
 
}
 
 
 
 
 
/*

在指针pTree所指的二叉排序树中递归查找关键字为key的元素，

若查找成功，则返回ture，并查找到的数据对应的节点指针保存在p中，

否则返回false，并将查找路径上访问的最后一个节点指针保存在p中。

这里的参数parent指向每次递归遍历的子树的根节点的父节点，即始终是参数pTree的父节点，

它的初始值为NULL，其目的是跟踪查找路径上访问的当前节点的父节点（即上一个访问节点）

该函数用来被后面的插入函数调用。

*/
 
bool search_BSTree(BSTree pTree, int key, BSTree parent, BSTree &p) {
 
    if (!pTree)         //如果pTree为NULL，则查找不成功 
 
    {   //这里包含了树空，即pTree为NULL的情况 
 
        p = parent;
 
        return false;
 
    }
 
    else             //否则，继续查找 
 
    {
 
        if (key == pTree->data)           //如果相等，则查找成功 
 
        {
 
            p = pTree;
 
            return true;
 
        }
 
        else if (key < pTree->data)        //在左子树中递归查找 
 
            return search_BSTree(pTree->lchild, key, pTree, p);
 
        else                            //在右子树中递归查找 
 
            return search_BSTree(pTree->rchild, key, pTree, p);
 
    }
 
}
 
 
 
/*

当在pTree所指向的二叉排序树中查找不到关键字为key的数据元素时，

将其插入该二叉排序树，并返回ture，否则返回false。

树空时插入会改变根节点的值，因此要传入引用。

*/
 
bool insert(BSTree &pTree, int key) {
 
    BSTree p;
 
    if (!search_BSTree(pTree, key, NULL, p))        //如果查找失败，则执行插入操作 
 
    {
 
        //为新节点分配空间，并对各域赋值 
 
        BSTree pNew = (BSTree)malloc(sizeof(NODE));
 
        pNew->data = key;
 
        pNew->lchild = pNew->rchild = NULL;
 
 
 
        if (!p)                          //如果树空，则直接置pNew为根节点 
 
            pTree = pNew;
 
        else if (key < p->data)            //作为左孩子插入p的左边 
 
            p->lchild = pNew;            //作为右孩子插入p的右边 
 
        else
 
            p->rchild = pNew;
 
    }
 
    else
 
        return false;
 
}
 
 
 
/*

采用第一种算法从二叉排序树中删除指针p所指向的节点,

并在保持二叉排序树有序的情况下，将其左右子树重接到该二叉排序树中.

该函数主要用来被后面的删除函数调用

*/
 
void delete_Node1(BSTree &p) {
 
    BSTree q, s;
 
    if (!p->lchild)
 
    {   //如果左子树为空，则只需重接其右子树 
 
        //这里包含了左右子树均为空的情况 
 
        q = p;
 
        p = p->rchild;
 
        free(q);
 
    }
 
    else if (!p->rchild)
 
    {   //如果右子树为空，则只需重接其左子树 
 
        q = p;
 
        p = p->lchild;
 
        free(q);
 
    }
 
    else
 
    {   //如果左右子树都不为空，我们采取第一种方法来重接左右子树， 
 
        //我们这里采取修改左子树的方法，也可以修改右子树，方法类似 
 
        s = p->lchild;       //取待删节点的左节点 
 
 
 
                             //一直向右，最终s为待删节点的前驱节点 
 
                             //如果将各节点元素按从小到大顺序排列成一个序列， 
 
                             //则某节点的前驱节点即为序列中该节点的前面一个节点 
 
        while (s->rchild)
 
            s = s->rchild;
 
        s->rchild = p->rchild;    //将p的右子树接为s的右子树 
 
        q = p;
 
        p = p->lchild;       //将p的左子树直接接到其父节点的左子树上 
 
        free(q);
 
    }
 
}
 
 
 
/*

采用第二种算法从二叉排序树中删除指针p所指向的节点,

并在保持二叉排序树有序的情况下，将其左右子树重接到该二叉排序树中.

该函数主要用来被后面的删除函数调用

*/
 
void delete_Node2(BSTree &p) {
 
    BSTree q, s;
 
    if (!p->lchild)
 
    {   //如果左子树为空，则只需重接其右子树 
 
        //这里包含了左右子树均为空的情况 
 
        q = p;
 
        p = p->rchild;
 
        free(q);
 
    }
 
    else if (!p->rchild)
 
    {   //如果右子树为空，则只需重接其左子树 
 
        q = p;
 
        p = p->lchild;
 
        free(q);
 
    }
 
    else
 
    {   //如果左右子树都不为空，我们采取第二种方法来重接左右子树， 
 
        //我们这里采取修改左子树的方法，也可以修改右子树，方法类似 
 
        q = p;
 
        s = p->lchild;       //取待删节点的左节点 
 
        while (s->rchild)
 
        {   //一直向右，最终s为待删节点的前驱节点。 
 
            //如果将各节点元素按从小到大顺序排列成一个序列， 
 
            //则某节点的前驱节点即为序列中该节点的前面一个节点 
 
            q = s;
 
            s = s->rchild;
 
        }
 
        //用s来替换待删节点p 
 
        p->data = s->data;
 
        //根据情况，将s的左子树重接到q上 
 
        if (p != q)
 
            q->rchild = s->lchild;
 
        else
 
            q->lchild = s->lchild;
 
        free(s);
 
    }
 
}
 
 
 
/*

若pTree所指向的二叉排序树中查找到关键字为key的数据元素，

则删除该元素对应的节点，并返回true，否则返回false

如果要删除的恰好是根节点，则会改变根节点的值，因此要传入引用

*/
 
bool delete_BSTree(BSTree &pTree, int key) {
 
    //不存在关键字为key的节点 
 
    if (!pTree)
 
        return false;
 
    else
 
    {
 
        if (key == pTree->data)       //查找到关键字为key的节点 
 
        {
 
            delete_Node1(pTree);
 
            //          delete_Node2(pTree); 
 
            return true;
 
        }
 
        else if (key < pTree->data)  //继续查找左子树 
 
            return delete_BSTree(pTree->lchild, key);
 
        else                        //继续查找右子树 
 
            return delete_BSTree(pTree->rchild, key);
 
    }
 
}
 
 
 
/*

根据所给的长为len的arr数组，按数组中元素的顺序构建一棵二叉排序树

*/
 
BSTree create_BSTree(int *arr, int len) {
 
    BSTree pTree = NULL;
 
    int i;
 
    //按顺序逐个节点插入到二叉排序树中 
 
    for (i = 0; i<len; i++)
 
        insert(pTree, arr[i]);
 
    return pTree;
 
}
 
 
 
/*

递归中序遍历二叉排序树，得到元素从小到大有序排列的序列

*/
 
void in_traverse(BSTree pTree) {
 
    if (pTree)
 
    {
 
        if (pTree->lchild)
 
            in_traverse(pTree->lchild);
 
        printf("%d ", pTree->data);
 
        if (pTree->rchild)
 
            in_traverse(pTree->rchild);
 
    }
 
}
 
 
 
 
 
int main() {
 
    int i;
 
    int num;
 
    printf("请输入节点个数：");
 
    scanf("%d", &num);
 
 
 
    //输入num个整数 
 
    int *arr = (int *)malloc(num * sizeof(int));
 
    printf("请依次输入这%d个整数（必须互不相等）：", num);
 
    for (i = 0; i<num; i++)
 
        scanf("%d", arr + i);
 
 
 
    //中序遍历该二叉排序树，使数据按照从小到大的顺序输出 
 
    BSTree pTree = create_BSTree(arr, num);
 
    printf("中序遍历该二叉排序树的结果：");
 
    in_traverse(pTree);
 
    printf("\n");
 
 
 
    //查找给定的整数 
 
    int key;
 
    printf("请输入要查找的整数：");
 
    scanf("%d", &key);
 
    if (search(pTree, key))
 
        printf("查找成功\n");
 
    else
 
        printf("查找不到该整数\n");
 
 
 
    //插入给定的整数 
 
    printf("请输入要插入的整数：");
 
    scanf("%d", &key);
 
    if (insert(pTree, key))
 
    {
 
        printf("插入成功，插入后的中序遍历结果：");
 
        in_traverse(pTree);
 
        printf("\n");
 
    }
 
    else
 
        printf("插入失败，该二叉排序树中已经存在整数%d\n", key);
 
 
 
    //删除给定的整数 
 
    printf("请输入要删除的整数：");
 
    scanf("%d", &key);
 
    if (delete_BSTree(pTree, key))
 
    {
 
        printf("删除成功，插入后的中序遍历结果：");
 
        in_traverse(pTree);
 
        printf("\n");
 
    }
 
    else
 
        printf("删除失败，该二叉排序树中不存在整数%d\n", key);
 
 
 
    return 0;
 
}
```

# 第八章 排序

### 8.1 排序的基本概念

1.  排序：重新排列表中的元素，使表中元素满足按关键字有序的过程（关键字可以相同）
2.  排序算法的评价指标：时间复杂度、空间复杂度；
3.  排序算法的稳定性：关键字相同的元素在排序之后相对位置不变，称为稳定的；（选择题考查）  
    Q： 稳定的排序算法一定比不稳定的好？  
    A： 不一定，要看实际需求；
4.  排序算法的分类：  
    **内部排序：** 数据都在内存——关注如何使时间、空间复杂度更低；  
    **外部排序：** 数据太多，无法全部放入内存——关注如何使时间、空间复杂度更低，如何使读 / 写磁盘次数更少；

### 8.2 插入排序

#### 8.2.1 直接插入排序

1.  **算法思想：** 每次将一个待排序的记录按其关键字大小，插入（依次对比、移动）到前面已经排好序的子序列中，直到全部记录插入完成
2.  **代码实现：**

*   不带 “哨兵”

```
void InsertSort(int A[], int n){    //A中共n个数据元素
    int i,j,temp;
    for(i=1; i<n; i++)
        if(A[i]<A[i-1]){    //A[i]关键字小于前驱
            temp = A[i];  
            for(j=i-1; j>=0 && A[j]>temp; --j)
                A[j+1] = A[j];     //所有大于temp的元素都向后挪
            A[j+1] = temp;         //复制到插入位置
        }
}
```

*   带 “哨兵” ，优点：不用每轮循环都判断 j>=0

```
void InsertSort(int A[], int n){    //A中从1开始存储，0放哨兵
    int i,j;
    for(i=1; i<n; i++)
        if(A[i]<A[i-1]){    
            A[0] = A[i];     //复制为哨兵
            for(j=i-1; A[0] < A[j]; --j)  //从后往前查找待插入位置
                A[j+1] = A[j];     //向后挪动
            A[j+1] = A[0];          //复制到插入位置
        }
}
```

3.  算法效率分析

空间复杂度：O(1)  
时间复杂度：主要来自于对比关键字、移动关键字，若有 n 个元素，则需要 n-1 躺处理  
最好情况： 原本为有序，共 n-1 趟处理，每一趟都只需要对比 1 次关键字，不需要移动元素，共对比 n-1 次 —— O(n)  
最差情况： 原本为逆序 —— O(n²)  
平均情况： O(n²)  
算法稳定性：稳定

4.  对链表进行插入排序  
    移动元素的次数变少了，因为只需要修改指针，不需要依次右移；  
    但是关键字对比的次数依然是 O(n²) 数量级，因此整体看来时间复杂度仍然是 O(n²)

#### 8.2.2 折半插入排序

1.  思路： 先用折半查找找到应该插入的位置，再移动元素；
    
2.  为了保证稳定性，当查找到和插入元素关键字一样的元素时，应该继续在这个元素的右半部分继续查找以确认位置; 即当 A[mid] == A[0] 时，应继续在 mid 所指位置右边寻找插入位置
    
3.  当 low>high 时，折半查找停止，应将 [low,i-1]or[high+1,i-1] 内的元素全部右移，并将 A[0]复制到 low 所指的位置；
    
4.  代码实现
    

```
void InsertSort(int A[], int n){ 
    int i,j,low,high,mid;
    for(i=2;i<=n;i++){
        A[0] = A[i];                    //将A[i]暂存到A[0]
        low = 1; high = i-1;            //折半查找的范围

        while(low<=high){               //折半查找
            mid = (low + high)/2;       //取中间点
            if(A[mid]>A[0])             //查找左半子表
                high = mid - 1;
            else                        //查找右半子表
                low = mid + 1;
        }
        
        for(j=i-1; j>high+1;--j)       //统一后移元素，空出插入位置
            A[j+1] = A[j];
        A[high+1] = A[0]
    }
}
```

5.  与直接插入排序相比，比较关键字的次数减少了，但是移动元素的次数没有变，时间复杂度仍然是 O(n²)

#### 8.2.3 希尔排序

1.  思路： 先追求表中元素的部分有序，再逐渐逼近全局有序；
    
2.  更适用于基本有序的排序表和数据量不大的排序表，仅适用于线性表为顺序存储的情况
    
3.  代码实现：
    

```
void ShellSort(ElemType A[], int n){
    //A[0]为暂存单元
    for(dk=n/2; dk>=1; dk=dk/2)   //步长递减（看题目要求，一般是1/2
        for(i=dk+1; i<=n; ++i)
            if(A[i]<A[i-dk]){
                A[0]=A[i];
                for(j=i-dk; j>0&&A[0]<A[j];j-=dk)
                    A[j+dk]=A[j];         //记录后移，查找插入的位置
                A[j+dk]=A[0;]             //插入
            }
}
```

4.  算法效率分析

*   空间效率：空间复杂度 = O(1)
*   时间效率: 最坏情况下时间复杂度 = O(n²)
*   稳定性：希尔排序是一种不稳定的排序方法

### 8.3 交换排序

** 基于 “交换” 的排序：** 根据序列中两个元素关键字的比较结果来对换这两个记录再序列中的位置；

#### 8.3.1 冒泡排序

1.  第一趟排序使关键字值最小的一个元素 “冒” 到最前面（其最终位置）—— 每趟冒泡的结果是把序列中最小元素放到序列的最终位置，这样最多做 n-1 趟冒泡就能把所有元素排好序；
    
2.  为保证稳定性，关键字相同的元素不交换；
    
3.  代码实现
    

```
//交换
void swap(int &a, int &b){
    int temp = a;
    a = b;
    b = temp;
}

//冒泡排序
void BubbleSort(int A[], int n){   //从0开始存放
    for(int i=0; i<n-1; i++){
        bool flag = false; // 表示本趟冒泡是否发生交换的标志
        for(int j=n-1; j>i; j--) //一趟冒泡过程
            if(A[j-1]>A[j]){      //若为逆序
                swap(A[j-1],A[j]);  //交换
                flag=true;
            }
        if(flag==false)
            return;       //本趟遍历后没有发生交换，说明表已经有序，可以结束算法
    }
}
```

4.  算法效率分析

空间复杂度：O(1)  
时间复杂度  
最好情况 (有序) ：只需要一趟排序，比较次数 = n-1，交换次数 = 0，最好时间复杂度 = O(n)  
最坏情况 (逆序) ：比较次数 = (n-1)+(n-2)+…+1 = n(n-1)/2 = 交换次数，最坏时间复杂度 = O(n²)，平均时间复杂度 = O(n²)  
冒泡排序可以用于链表、顺序表

#### 8.3.2 快速排序

1.  每一趟排序都可使一个中间元素确定其最终位置
2.  用一个元素（不一定是第一个）把待排序序列 “划分” 为两个部分，左边更小，右边更大，该元素的最终位置已确认
3.  算法实现（重点）

```
//用第一个元素将待排序序列划分为左右两个部分
int Partition(int A[], int low, int high){
    int pivot = A[low];          //用第一个元素作为枢轴
    while(low<high){
        while(low<high && A[high]>=pivot) --high; //high所指元素大于枢轴，high左移
        A[low] = A[high];   //high所指元素小于枢轴，移动到左侧

        while(low<high && A[low]<=pivot)  ++low; //low所指元素小于枢轴，low右移
        A[high] = A[low];   //low所指元素大于枢轴，移动到右侧
    }
    A[low] = pivot   //枢轴元素存放到最终位置
    return low；     //返回存放枢轴的最终位置
} 

//快速排序
void QuickSort(int A[], int low, int high){
    if(low<high)   //递归跳出条件
        int pivotpos = Partition(A, low, high);   //划分
        QuickSort（A, low, pivotpos - 1);    //划分左子表
        QuickSort（A, pivotpos + 1, high);   //划分右子表
}
```

3.  算法效率分析

每一层的 QuickSort 只需要处理剩余的待排序元素，时间复杂度不超过 O(n);

把 n 个元素组织成二叉树，二叉树的层数就是递归调用的层数，n 个结点的二叉树最小高度 = ⌊log₂n⌋ + 1, 最大高度 = n

时间复杂度 = O(n× 递归层数) （递归层数最大为 n）

最好 = O(nlog₂n) : 每次选的枢轴元素都能将序列划分成均匀的两部分；  
最坏 = O(n²) ：序列本就有序或逆序，此时时间、空间复杂度最高；  
平均时间复杂度 = O(nlog₂n) （接近最好而不是最坏）  
空间复杂度 = O(递归层数)（递归层数最小为 log₂n）

最好 = O(log₂n)  
最坏 = O(n)  
若每一次选中的 “枢轴” 可以将待排序序列划分为均匀的两个部分，则递归深度最小，算法效率最高；

若初始序列本就有序或者逆序, 则快速排序的性能最差；

快速排序算法优化思路： 尽量选择可以把数据中分的枢轴元素

选头、中、尾三个位置的元素，取中间值作为枢轴元素；  
随机选一个元素作为枢轴元素；  
快速排序使所有内部排序算法中平均性能最优的排序算法；

稳定性： 不稳定；

### 8.4 选择排序

思想：每一趟在待排序元素中选取关键字最小（或最大）的元素加入有序子序列；

#### 8.4.1 简单选择排序

n 个元素的简单选择排序需要 n-1 趟处理；

```
//交换
void swap(int &a, int &b){
    int temp = a;
    a = b;
    b = temp;
}

void SelectSort(int A[], int n){       //A从0开始
    for(int i=0; i<n-1; i++){          //一共进行n-1趟，i指向待排序序列中第一个元素
        int min = i;                   //记录最小元素位置
        for(int j=i+1; j<n; j++)       //在A[i...n-1]中选择最小的元素
            if(A[j]<A[min]) min = j;   //更新最小元素位置
        if(min!=i)                     
            swao(A[i],A[min]);         //交换
    }
}
```

3.  算法效率分析

空间复杂度 = O(1)  
无论有序、逆序、乱序，都需要 n-1 的处理，总共需要对比关键字 (n-1)+(n-2)+…+1 = n(n-2)/2 次，元素交换次数 < n-1; 时间复杂度 = O(n²)  
稳定性： 不稳定  
适用性： 既可以用于顺序表，也可以用于链表；

#### 8.4.2 堆排序

1.  什么是 “堆（Heap）”？  
    可理解为顺序存储的二叉树，注意

可以将堆视为一棵 完全二叉树 (✔)

可以将堆视为一棵 二叉排序树 (✖)

大根堆：完全二叉树中，根 ≥ 左、右  
小根堆：完全二叉树中，根 ≤ 左、右

2.  如何基于 “堆” 进行排序

基本思路：每一趟在待排序元素中选取关键字最小（或最大）的元素加入有序子序列，堆顶元素的关键字最大或最小 （以下以大根堆为例）

① 将给定初始序列 (n 个元素)，建立初始大根堆：把所有非终端结点 从后往前都检查一遍，是否满足大根堆的要求——根 ≥ 左、右，若不满足，则将当前结点与更大的孩子互换

在顺序存储的完全二叉树中:

非终端结点的编号 i≤⌊n/2⌋  
i 的左孩子 2i  
i 的右孩子 2i+1  
i 的父节点⌊i/2⌋  
更小的元素 “下坠” 后，可能导致下一层的子树不符合大根堆的要求，则采用相同的方法继续往下调整 —— 小元素不断“下坠”

② 基于大根堆进行排序：每一趟将堆顶元素加入有序子序列中，堆顶元素与待排序序列中最后一个元素交换后，即最大元素换到末尾，之后该位置就不用改变，即移出完全二叉树 (len=len-1)，把剩下的待排序元素序列再调整为大根堆；————“一趟处理”

③ 剩下最后一个元素则不需要再调整；

```
//对初始序列建立大根堆
void BuildMaxHeap(int A[], int len){
    for(int i=len/2; i>0; i--)   //从后往前调整所有非终端结点
        HeadAdjust(A, i, len);
}

/*将以k为根的子树调整为大根堆
从最底层的分支结点开始调整*/
void HeadAdjust(int A[], int k, int len){
    A[0] = A[k];                      //A[0]暂存子树的根结点
    for(int i=2*k; i<=len; i*=2){     //沿key较大的子结点向下筛选
                                      // i为当前所选根结点的左孩子
                                      //i*=2是为了判断调整后再下一层是否满足大根堆
        if(i<len && A[i]<A[i+1])      //判断：当前所选根结点的左、右结点哪个更大
            i++;                      //取key较大的子结点的下标
        if(A[0] >= A[i]) 
            break;                    //筛选结束：i指向更大的子结点
        else{
            A[k] = A[i];              //将A[i]调整至双亲结点上
            k=i;                      //修改k值，以便继续向下筛选
        }
    }
    A[k] = A[0]                       //被筛选的结点的值放入最终位置
}

//交换
void swap(int &a, int &b){
    int temp = a;
    a = b;
    b = temp;
}

//基于大根堆进行排序
void HeapSort(int A[], int len){
    BuildMaxHeap(A, len);          //初始建堆
    for(int i=len; i>1; i--){      //n-1趟的交换和建堆过程
        swap(A[i], A[1]);          //堆顶元素和堆底元素交换
        HeadAdjust(A,1,i-1);       //把剩余的待排序元素整理成堆
    }
}
```

### 8.5 归并排序和基数排序

#### 8.5.1 归并排序

归并（Merge）：把两个或多个已经有序的序列合并成一个；

k 路归并：每选出一个元素，需对比关键字 k-1 次；

外部排序通常采用归并排序，内部排序一般采用 2 路归并；

```
//创建辅助数组B
int *B=(int *)malloc(n*sizeof(int));

//A[low,...,mid],A[mid+1,...,high] 各自有序，将这两个部分归并
void Merge(int A[], int low, int mid, int high){
    int i,j,k;
    for(k=low; k<=high; k++)
        B[k] = A[k];           //将A中所有元素复制到B中
    for(i=low, j=mid+1, k=i; i<=mid && j<= high; k++){
        if(B[i]<=B[j])          //为保证稳定性两个元素相等时，优先使用靠前的那个
            A[k]=B[i++];        //将较小值复制到A中
        else
            A[k]=B[j++];
    }//for
     
    //没有归并完的部分复制到尾部，while只会执行一个 
    while(i<=mid)  A[k++]=B[i++];     //若第一个表未检测完，复制
    while(j<=high) A[k++]=B[j++];     //若第二个表未检测完，复制
}

//递归操作
void MergeSort(int A[], int low, int high){
    if(low<high){
        int mid = (low+high)/2;    //从中间划分
        MergeSort(A, low, mid);    //对左半部分归并排序
        MergeSort(A, mid+1, high); //对右半部分归并排序
        Merge(A,low,mid,high);     //归并
    }if
}
```

算法效率分析：

归并排序的比较次数与序列的初始状态无关；

2 路归并的 “归并树”——倒立的二叉树，树高 h，归并排序趟数 m = h-1，第 h 层最多 2^(h-1) 个结点，则满足 n ≤ 2^(h-1)，即 h-1 = ⌈log₂n⌉; 结论: n 个元素进行 2 路归并排序，归并趟数 m = ⌈log₂n⌉

每趟归并时间复杂度为 O(n), 算法总时间复杂度为 O(nlog₂n);

空间复杂度为 O(n); (归并排序算法可视为本章占用辅助空间最多的排序算法)

稳定性：归并排序是稳定的

对于 N 个元素进行 k 路归并排序，排序的趟数 m 满足 k^m = N, m = ⌈logkN⌉

#### 8.5.2 基数排序

**算法效率分析：**

空间效率：O®, 其中 r 为基数，需要的辅助空间 (队列) 为 r；  
时间效率：一共进行 d 趟分配收集，一趟分配需要 O(n), 一趟收集需要 O®, 时间复杂度为 O[d(n+r)]，且与序列的初始状态无关  
稳定性：稳定！  
基数排序擅长解决的问题  
①数据元素的关键字可以方便地拆分为 d 组，且 d 较小；  
②每组关键字的取值范围不大，即 r 较小；  
③数据元素个数 n 较大；