——————分割线 2020.7.20——————

翻新了一遍译文，统一了名词，补充了漏译的部分。

## 

![](<images/1685518852482.png>)

## **2.4 光栅化阶段 Rasterization**

给定经过变换和投影的顶点及其关联的着色数据之后（数据全部来自几何处理过程），下一阶段的目标是找到需要渲染的图元（例如一个三角形）内的所有像素（像素即图片元素 picture elements 的缩写）。我们称这种过程为光栅化，它被分为两个功能子阶段：三角形设置（triangle setup，也称为基本装配）和三角形遍历（triangle traversal）。这些显示在图 2.8 的左侧。请注意，它们也可以处理点和线，但是由于三角形最常见，因此子阶段的名称中带有 “三角形”。光栅化，也称为扫描转换，是从屏幕空间中的二维顶点——每个顶点具有 z 值（即深度值）以及与每个顶点相关的各种着色信息——到屏幕上像素的转换。光栅化也可以被视为几何处理和像素处理之间的同步点，因为在这里，三角形是由三个顶点形成的，并且最终将往下发送以进行像素处理。

![](<images/1685518852512.png>)

**图 2.8.**  左：光栅化分为两个功能阶段，称为三角形设置与三角形遍历。右：像素处理分为两个功能阶段，即像素着色与合并。

三角形是否被认为与像素重叠取决于你如何设置 GPU 的管线。例如，你可以使用点采样来确定 “内部”。最简单的情况是在每个像素的中心使用一个点采样，因此，如果该中心点在三角形内部，则相应的像素也被认为在三角形内部。您还可以使用超级采样或多重采样反走样技术对每个像素使用一个以上的采样（第 5.4.2 节）。还有一种方法是使用保守光栅化，其定义是，只要像素有部分与三角形重叠，则该像素就位于三角形内（第 23.1.2 节）。

### **2.4.1 三角形设置 Triangle Setup**

在这一阶段，计算了三角形的微分、边缘方程和其他数据。 这些数据可用于三角形遍历（第 2.4.2 节）以及几何阶段产生的各种着色数据的插值。 固定功能硬件既适用于此任务。

### **2.4.2 三角形遍历 Triangle Traversal**

在这个阶段，我们将检查每个像素（或样本）中心被三角形覆盖的情况，并为与三角形重叠的像素部分生成一个片元（fragment）。更多详细的采样方法可以在第 5.4 节中找到。找出三角形内的样本与像素的过程通常被称为三角形遍历。 每个三角形片元的属性都是使用在三个三角形顶点之间插值的数据生成的（第 5 章）。这些属性包括片元的深度，以及来自几何图形阶段的任何着色数据。 McCormack **[1162]** 等等提供了更多关于三角形遍历的信息。三角形上执行的透视校正插值（perspective-correct interpolation）也是在此阶段进行的（第 23.1.1 节）。 然后，图元中的所有像素或样本都会被发送到像素处理阶段，这将在接下来描述。

**引用：**

**[1162]** McCormack, Joel, and Robert McNamara, “Tiled Polygon Traversal Using Half-Plane Edge Functions,” in Graphics Hardware 2000, Eurographics Association, pp. 15–22, Aug. 2000. Cited on p. 22, 996, 997

## **2.5 像素处理阶段 Pixel Processing**

在此阶段，经过之前所有阶段的处理，已经找到了在三角形或其他图元内部应考虑的所有像素。像素处理阶段被划分为像素着色与合并，如图 2.8 右侧所示。像素处理是对图元内部的像素或样本执行逐像素或逐样本计算和操作的阶段。

### **2.5.1 像素着色 Pixel Shading**

使用插值的着色数据作为输入，此处可以执行任何逐像素的着色计算。其最终结果是一种或多种颜色被传递到下一个阶段。与通常由专用的硬连线硅（hardwired silicon）执行的三角形设置和遍历阶段不同，像素着色阶段由可编程 GPU 内核执行。为此，程序员为像素着色器（在 OpenGL 中称作片段着色器或片元着色器）提供了一个程序，该程序可以包含任何所需的计算。该程序里可以使用各种各样的技术，其中最重要的一种技术是纹理（texturing）。在第 6 章中将更详细地讨论纹理。简单地说，对一个对象进行纹理操作意味着出于各种目的将一个或多个图像 “粘” 到该对象上。此过程的一个简单示例如图 2.9 所示。图像可以是一维，二维或三维图像，其中二维图像是最常见的。以最简单的方式来说，像素着色的最终产物是每个片元的颜色值，并会将它们传递到下一个子阶段。

![](<images/1685518852615.png>)

**图 2.9.** 左上方显示了没有纹理的龙模型。图像纹理中的部分被 “粘” 到龙上，其结果显示在左下方。

### **2.5.2 合并 Merging**

每个像素的信息都存储在颜色缓冲区中，颜色缓冲区是颜色的矩形阵列（每种颜色的红色、绿色和蓝色分量）。合并阶段负责将像素着色阶段产生的片元颜色与当前存储在缓冲区中的颜色进行组合。此阶段也称为 ROP，代表 “光栅操作（管线）”（raster operations pipeline）或 “渲染输出单元”（[render](https://so.csdn.net/so/search?q=render&spm=1001.2101.3001.7020) output unit）。与着色阶段不同，执行此阶段的 GPU 子单元通常不是完全可编程的。但是，它是高度可配置的，可实现各种效果。

合并阶段还负责解决可见性。这意味着在渲染了整个场景之后，颜色缓冲区应包含场景中的原始颜色，这些颜色从相机的角度是可见的。对于大多数甚至所有图形硬件，这都是通过 z 缓冲区（也称为深度缓冲区）算法 **[238]** 完成的。z 缓冲区的大小和形状与颜色缓冲区相同，并且对于每个像素，将最近图元的 z 值存储到 z 缓冲区中。这意味着，当将图元渲染到某个像素时，该图元在该像素处的 z 值将被计算并与同一像素处 z 缓冲区的内容进行比较。如果新的 z 值小于 z 缓冲区中的 z 值，则正在渲染的图元比之前在那个像素处最接近相机的图元更接近相机。因此，该像素的 z 值和颜色将使用所绘制图元的 z 值和颜色进行更新。如果计算的 z 值大于 z 缓冲区中的 z 值，则保持颜色缓冲区和 z 缓冲区不变。z 缓冲区算法很简单，具有 

![](<images/1685518852702.png>)

 收敛（其中 n 是要渲染的图元的数量），并且适用于可为每个（相关）像素计算 z 值的任意绘图图元。也需要注意的是，该算法允许大多数图元以任意顺序呈现，这是该算法如此流行的另一个原因。但是，z 缓冲区仅在屏幕上的每个点存储一个深度，因此不能用于部分透明的图元。所以必须在所有不透明图元之后，以从后到前的顺序，或使用单独的、与顺序无关的算法（第 5.5 节）呈现这些内容。透明部分也是基本 z 缓冲区的主要弱点之一。

我们已经提到了颜色缓冲区是用于存储颜色的，而 z 缓冲区是用于存储每个像素的 z 值的。然而，还有其他通道和缓冲区可用于筛选和捕获片元信息。例如 Alpha 通道就是与颜色缓冲区关联，并为每个像素存储相关的不透明度值（第 5.5 节）。在较早的 API 中，Alpha 通道还用于通过 Alpha 测试功能选择性地丢弃像素。如今，我们可以将该丢弃操作插入到像素着色器程序中，并且可以使用任意类型的计算来触发丢弃。我们可以使用此类测试来确保完全透明的片元不会影响 z 缓冲区（第 6.6 节）。

模板缓冲区是一个屏幕外的缓冲区，它用于记录所渲染图元的位置。通常它的每个像素包含 8 位。我们可以使用各种功能将图元渲染到模板缓冲区中，然后可以使用缓冲区的内容来控制渲染到颜色缓冲区和 z 缓冲区中的内容。举个例子，假设已将填充后的圆绘制到模板缓冲区中。它可以与一个操作符相结合，该操作符只允许将后续图元进入颜色缓冲区中填充圆所在的部分。模板缓冲区是生成某些特殊效果的强大工具。管线末端的所有这些功能都称为光栅操作（raster operations，ROP）或混合操作（blend operations）。可以将当前颜色缓冲区中的颜色与三角形内要处理的像素的颜色混合。这可以实现诸如透明度或颜色样本累积的效果。如前所述，混合操作通常可以使用 API 进行配置，而不是完全可编程的。但是，某些 API 支持光栅顺序视图（raster order views），也称为像素着色器顺序（pixel shader ordering），它可启用可编程混合功能。

帧缓冲区（framebuffer）通常由系统上的所有缓冲区组成。

当图元到达并通过光栅化程序阶段时，从相机的角度可见的图元将显示在屏幕上。 屏幕显示了颜色缓冲区的内容。 为了避免让人类观察者在对它进行光栅化并将它发送到屏幕时看到它们，因此使用了双重缓冲（double buffffering）。 这意味着场景的渲染发生在后台缓冲区的屏幕外。 将场景渲染到后缓冲区（back buffffer）中后，后缓冲区的内容将与先前在屏幕上显示的前缓冲区（front buffffer）的内容交换。 交换通常发生在垂直回扫（vertical retrace）过程中，而这是进行交换操作的安全时间。

有关不同缓冲区和缓冲方法的更多信息，请参见第 5.4.2、23.6 和 23.7 节。

## **2.6 管线概览 Through the Pipeline**

点，线和三角形是用于构建模型或对象的渲染图元。假设该应用程序是交互式计算机辅助设计（CAD）应用程序，并且用户正在检查华夫饼制造商的设计。在这里，我们将遵循此模型并遍历整个图形渲染管线，包括四个主要阶段：应用程序，几何，光栅化和像素处理。然后通过透视视图将场景渲染到屏幕上的窗口中。在这个简单的示例中，华夫饼制作机模型同时包含线（以显示零件的边缘）和三角形（以显示零件的表面）。松饼机的盖子可以打开。一些三角形是由带有制造商徽标的二维图像制成的。对于此示例，除了在光栅化阶段进行的纹理应用操作之外，表面着色都是在几何阶段进行完整计算的。

**应用程序阶段（Application）**

CAD 应用程序允许用户选择和移动模型的各个部分。 例如，用户可以选择盖子，然后移动鼠标将其打开。 应用程序阶段必须将鼠标移动转换为相应的旋转矩阵，然后确认呈现该矩阵时已将其正确应用于盖子。 另一个例子：播放动画，使动画沿预定路径移动，以便从不同的角度显示华夫饼制作机。接下来就必须由应用程序根据时间更新相机参数，例如位置和视图方向。对于要渲染的每个帧，应用程序阶段将相机的位置，照明和模型的图元发送到管线中的下一个主要阶段——几何处理阶段。

**几何处理阶段（Geometry Processing）**

对于透视视图，我们在此假定应用程序已提供了投影矩阵。同样，对于每个对象，应用程序都已计算出一个矩阵，该矩阵描述了观察变换以及对象本身的位置和方向。在我们的示例中，华夫饼制造商的底座将具有一个矩阵，而盖子则具有另一个矩阵。在几何阶段，我们使用此矩阵来转换对象的顶点和法线，从而将对象放入观察空间（view space）。然后，可以使用材质和光源属性来计算顶点处的着色或其他计算。然后使用单独的用户提供的投影矩阵执行投影，将对象转换为代表眼睛所见的单位立方体的空间。单位立方体外部的所有图元都将被丢弃。将与该单位多维数据集合相交的所有图元都裁剪到该多维数据集合上，以便获得一组完全位于单位立方体内的图元。然后将这些顶点映射到屏幕上的窗口中。在完成所有这些每个三角形和每个顶点操作之后，将所得数据传递到光栅化阶段。

**光栅化阶段（Rasterization）**

接下来，将所有在上一阶段裁剪后留下的图元光栅化，这意味着将寻找图元内部的所有像素，并将它们进一步发送到管线以进行像素处理。

**像素处理阶段（Pixel Processing）**

此阶段的目标是计算每个可见图元中每个像素的颜色。那些与任何纹理（图像）相关联的三角形将根据需要来使用这些图像进行渲染。可见性的问题通过 z 缓冲区算法以及可选的丢弃操作和模板测试来解决。每个对象被依次处理，并且将最终的图像显示在屏幕上。

**总结（Conclusion）**

该管线源于针对实时渲染应用程序的数十年的 API 和图形硬件演变。重要的是我们要注意，这不是唯一可行的渲染管线。脱机渲染管线经历了不同的演进路径。电影制作的渲染通常是通过微多边形管线（micropolygon）来完成的 **[289，1734]**，但是近来已被光线追踪和路径追踪替代。11.2.2 节中介绍的这些技术也可以用于建筑和设计的预可视化。

多年来，应用程序开发人员使用此处描述的过程的唯一方法是通过使用中的图形 API 定义的固定功能管线（fixed-function pipeline）。固定功能管线之所以如此命名，是因为实现它的图形硬件包含无法灵活编程的元素。主流的固定功能设备的最后一个例子是 2006 年推出的 Nintendo 的 Wii。另一方面，可编程的 GPU 可以准确地确定在整个管线的各个子阶段中具体应用了哪些操作。 对于本书的第四版，我们假设所有开发都是使用可编程 GPU 来完成的。

**引用：**

**[289]** Cook, Robert L., Loren Carpenter, and Edwin Catmull, “The Reyes Image Rendering Architecture, Computer Graphics (SIGGRAPH ’87 Proceedings), vol. 21, no. 4, pp. 95–102, July 1987. Cited on p. 26, 774, 908

**[1734]** Tabellion, Eric, and Arnauld Lamorlette, “An Approximate Global Illumination System for Computer Generated Films,” ACM Transactions on Graphics (SIGGRAPH 2004), vol. 23, no. 3, pp. 469–476, Aug. 2004. Cited on p. 26, 491

**进一步阅读和资源（Further Reading and Resources）**

Blinn 的著作《图形管线之旅》（《A Trip Down the Graphics Pipeline》） **[165]** 是一本关于从头开始编写软件渲染器的旧书。它是学习实现渲染管线的一些精妙之处以及解释关键算法（例如裁剪和透视插值）的好资源。古老的（至今仍经常更新）《 OpenGL 编程指南》（又称 “红皮书”）**[885]** 提供了图形管线的完整描述以及与其使用相关的算法。本书的网站 realtimerendering.com 提供了指向各种管线图以及渲染引擎实现等等的链接。

**引用：**

**[165]** Blinn, Jim, Jim Blinn’s Corner: A Trip Down the Graphics Pipeline, Morgan Kaufmann, 1996. Cited on p. 27, 832, 1059

**[885]** Kessenich, John, Graham Sellers, and Dave Shreiner, OpenGL Programming Guide: The Of- ficial Guide to Learning OpenGL, Version 4.5 with SPIR-V, Ninth Edition, Addison-Wesley, 2016. Cited on p. 27, 39, 41, 55, 96, 173, 174