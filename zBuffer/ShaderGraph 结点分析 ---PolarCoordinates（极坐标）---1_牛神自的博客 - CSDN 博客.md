
来我们在 ShaderGraph 实现一下上述数学过程：  

![[d50de4123d4fff38e4dceadafcc4717a_MD5.jpg]]

  
主要思路：通过 UV 求距离和角度。

上图 1234 得到距离，567 得到角度，8 合并。

UV 坐标就是笛卡尔二维坐标，就是二维坐标而已。  
图中 UV 显示的范围：x：0-1，y：0-1

距离：  
1：调整中心位置为中心（XY 各减去 0.5），默认左下角。  
2：通过 Length 结点获得距离原点的长度。  
3：乘以 2，把范围 0~0.5 调整到 0 到 1。  
4：乘以自定义半径，来调整半径范围。  
角度：  
5：通过 Arctangent2 来获取角度，Arctangent2 的输入 A 是 y，B 是 x，根据 y/x 的值得到角度（弧度）。  
这里我们不用纠结，通过这个结点我们能够得到一个角度，而且这个角度的范围是：-PI 到 PI。  
图中的全黑并不代表全是 0，小于等于 0 的全黑，大于等于 1 的全白，其实是均匀的，只不过颜色显示 范围限制导致的。  

![[fdc75060b59a3a4e1ec2f458ab7ec471_MD5.jpg]]

6：除以 6.28，就是除以 2PI，得到的范围 - 0.5 到 0.5  
7：乘以自定义长度缩放，来调整范围。  
8：合并得到最终结果。  
注：图中 5 这步 Arctangent2 输入的 xy 是反的，A 输入了 x，B 输入了 y，是为了和 Unity 实现的极坐标结点一致，可以看下数学实现里就是反的。

```
float angle = atan2(delta.x, delta.y) * 1.0/6.28 * LengthScale;
```

正反没有影响，得到结果是旋转 90 度的图，如下图是 A 输入 y，B 输入 x 得到的图。  

![[94a8011ad9bd29fe5b39a527c42be4ca_MD5.jpg]]

  
再补一张图：  

![[7b82047ff25c9c660102970b65946c39_MD5.jpg]]