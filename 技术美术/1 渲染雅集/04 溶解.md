# 溶解方案总结
## **溶解的思路**

就是在 Frag 阶段，**判断是否丢弃像素**。

**丢弃像素的方法**

*   **（常用）**通过 clip 函数
*   通过 discard
*   通过设置 alpha 变量为 0

### 通过 clip 函数

*   clip (x)，x 小于 0 就会丢弃该像素。
*   在片段着色器中，根据当前 uv，采样噪声图，就可以获得一个遮罩值。
*   clip (遮罩值 - 阈值)，就可以看到一个动态溶解效果。

```
half dissove = tex2D(_DissTex, i.uv).r;

clip(dissolve - _Clip);
```

## 定向溶解和中心点溶解

[Unity 小工具：溶解效果（Dissolve） - zd304 的文章 - 知乎](https://zhuanlan.zhihu.com/p/138942181)

![[8ff1e9d34f5883941904931fa45a0672_MD5.gif]]

### 定向溶解

在 Vert 阶段，得到一个方向因子（worldFactor），然后 clip = clip + worldFactor，即可得到效果。

**方向因子**

*   世界变换矩阵的 w 行向量即为世界位置。

```c
float4 worldPos = mul(unity_ObjectToWorld, v.vertex);
float3 rootPos = float3(unity_ObjectToWorld[0].w, unity_ObjectToWorld[1].w, unity_ObjectToWorld[2].w);
float3 dir = worldPos.xyz - rootPos;
float posOffset = dot(normalize(_DissolveDir), dir);
o.worldFactor = posOffset;
```

**Frag - Clip**

```c
fixed dissove = tex2D(_DissTex, i.uv).r;
dissove = (dissove - _Clip) + i.worldFactor * _WorldSpaceScale;
clip(dissove);
```

### 中心点溶解

根据像素离中心点距离，即 distance 函数。

```
fixed dissove = tex2D(_DissTex, i.uv).r;
float dist = distance(_DissolveCenterUV, i.uv);
dissove = dissove + dist * _WorldSpaceScale;
```

# 溶解

### ASE 实现
![[Pasted image 20221004114121.png]]

### Shader 实现
实现裁剪效果时采用局部坐标，不采用世界坐标。原因在于当物体移动时，世界坐标发生改变无法控制裁剪效果，控制局部坐标就容易一些。
```c
float4 MainTex = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv);
float Noise = SAMPLE_TEXTURE2D(_NoiseTex, sampler_NoiseTex, i.uv).r;
//Noise +=0.1; //控制 Noise 最小值为 0.1, 避免噪声的接近 0 的部分需要乘以很大的_BurningValue（用于黑色部分很多的噪声贴图）
clip(Noise - _DissolveThreshold);

//step算出溶解边缘
float internalEdge = step(Noise, _DissolveThreshold);
float externalEdge = step(Noise, _DissolveThreshold+_EdgeWidth);;
float edge = externalEdge-internalEdge;

float4 finalColor = lerp(MainTex, _EdgeColor, edge);
```

# 从特定点开始消融

![[69a74153809c2d6850cb8a5014db7799_MD5.webp]]

DissolveFromPoint 场景

为了从特定点开始消融，我们需要把片元到特定点的距离考虑进 clip 中。  
**第一步需要先定义消融开始点，然后求出各个片元到该点的距离（本例子是在模型空间中进行）：**

```c
//Properties
_StartPoint("Start Point", Vector) = (0, 0, 0, 0) //消融开始点
...
//Vert
//把点都转到模型空间
o.objPos = v.vertex;
o.objStartPos = mul(unity_WorldToObject, _StartPoint); 
...
//Fragment
float dist = length(i.objPos.xyz - i.objStartPos.xyz); //求出片元到开始点距离
```

**第二步是求出网格内两点的最大距离，用来对第一步求出的距离进行归一化。** 这一步需要在 C# 脚本中进行，思路就是遍历任意两点，然后找出最大距离：

```c
public class Dissolve : MonoBehaviour {
    void Start () {
        Material mat = GetComponent<MeshRenderer>().material;
        mat.SetFloat("_MaxDistance", CalculateMaxDistance());
    }
    
    float CalculateMaxDistance() {
        float maxDistance = 0;
        Vector3[] vertices = GetComponent<MeshFilter>().mesh.vertices;
        for(int i = 0; i < vertices.Length; i++)
        {
            Vector3 v1 = vertices[i];
            for(int k = 0; k < vertices.Length; k++)
            {
                if (i == k) continue;

                Vector3 v2 = vertices[k];
                float mag = (v1 - v2).magnitude;
                if (maxDistance < mag) maxDistance = mag;
            }
        }

        return maxDistance;
    }
}
```

同时 Shader 里面也要同时定义_MaxDistance 来存放最大距离的值：

```c
//Properties
_MaxDistance("Max Distance", Float) = 0
//Pass
float _MaxDistance;
```

第三步就是归一化距离值

```c
//Fragment
float normalizedDist = saturate(dist / _MaxDistance);
```

第四步要加入一个_DistanceEffect 属性来控制距离值对整个消融的影响程度：

```c
//Properties
_DistanceEffect("Distance Effect", Range(0.0, 1.0)) = 0.5
...
//Pass
float _DistanceEffect;
...
//Fragment
fixed cutout = tex2D(_NoiseTex, i.uvNoiseTex).r * (1 - _DistanceEffect) + normalizedDist * _DistanceEffect;
clip(NoiseTex - _Threshold);
```

上面已经看到一个合适_DistanceEffect 的效果了，下面贴出_DistanceEffect 为 1 的效果图：

![[6793512789b8d95f9d8ea8cf139fa415_MD5.webp]]

_DistanceEffect = 1

这就完成了从特定点开始消融的效果了，不过有一点要注意，消融开始点最好是在网格上面，这样效果会好点。

[完整代码点这里](https://link.jianshu.com?t=https://github.com/KaimaChen/Unity-Shader-Demo/blob/master/UnityShaderProject/Assets/Dissolve/Shaders/FromPoint.shader)

### 应用：场景切换

利用这个从特定点消融的原理，我们可以实现场景切换。  
假设我们要实现如下效果：

![[00bfce6e7a584fe3953f5096df7d93c2_MD5.webp]]

来自 Trifox 的图

因为我们原来的 Shader 是从中间开始镂空的，和图中从四周开始镂空有点不同，因此我们需要稍微修改一下计算距离的方式：

```
//Fragment
float normalizedDist = 1 - saturate(dist / _MaxDistance);
```

这时候我们的 Shader 就能从四周开始消融了。  
第二步就是需要修改计算距离的坐标空间，原来我们是在模型空间下计算的，而现在很明显多个不同的物体会同时受消融值的影响，因此我们改为世界空间下计算距离：

```
//Vert
o.worldPos = mul(unity_ObjectToWorld, v.vertex);
//Fragment
float dist = length(i.worldPos.xyz - _StartPoint.xyz);
```

[完整代码点这里](https://link.jianshu.com?t=https://github.com/KaimaChen/Unity-Shader-Demo/blob/master/UnityShaderProject/Assets/Dissolve/Shaders/ToPoint.shader)  
为了让 Shader 应用到场景物体上好看点，我加了点漫反射代码。

第三步为了计算所有场景的物体的顶点到消融开始点的最大距离，我定义了下面这个脚本：

```
public class DissolveEnvironment : MonoBehaviour {
    public Vector3 dissolveStartPoint;
    [Range(0, 1)]
    public float dissolveThreshold = 0;
    [Range(0, 1)]
    public float distanceEffect = 0.6f;

    void Start () {
        //计算所有子物体到消融开始点的最大距离
        MeshFilter[] meshFilters = GetComponentsInChildren<MeshFilter>();
        float maxDistance = 0;
        for(int i = 0; i < meshFilters.Length; i++)
        {
            float distance = CalculateMaxDistance(meshFilters[i].mesh.vertices);
            if (distance > maxDistance)
                maxDistance = distance;
        }
        //传值到Shader
        MeshRenderer[] meshRenderers = GetComponentsInChildren<MeshRenderer>();
        for(int i = 0; i < meshRenderers.Length; i++)
        {
            meshRenderers[i].material.SetVector("_StartPoint", dissolveStartPoint);
            meshRenderers[i].material.SetFloat("_MaxDistance", maxDistance);
        }
    }
    
    void Update () {
        //传值到Shader，为了方便控制所有子物体Material的值
        MeshRenderer[] meshRenderers = GetComponentsInChildren<MeshRenderer>();
        for (int i = 0; i < meshRenderers.Length; i++)
        {
            meshRenderers[i].material.SetFloat("_Threshold", dissolveThreshold);
            meshRenderers[i].material.SetFloat("_DistanceEffect", distanceEffect);
        }
    }

    //计算给定顶点集到消融开始点的最大距离
    float CalculateMaxDistance(Vector3[] vertices)
    {
        float maxDistance = 0;
        for(int i = 0; i < vertices.Length; i++)
        {
            Vector3 vert = vertices[i];
            float distance = (vert - dissolveStartPoint).magnitude;
            if (distance > maxDistance)
                maxDistance = distance;
        }
        return maxDistance;
    }
}
```

这个脚本同时还提供了一些值来方便控制所有场景的物体。

![[ed3d96e893b43d2ec618422f6ceee286_MD5.webp]]

像这样把场景的物体放到 Environment 物体下面，然后把脚本挂到 Environment，就能实现如下结果了：

![[dae88d424f6a4eb58634b1e451b549d5_MD5.webp]]

DissolveEnvironment 场景

[具体的场景文件点这里](https://link.jianshu.com?t=https://github.com/KaimaChen/Unity-Shader-Demo/blob/master/UnityShaderProject/Assets/Dissolve/Scenes/DissolveEnvironment.unity)

# 从特定方向开始消融

![[af9dc9b6f88651963e54f903681c490b_MD5.webp]]

DissolveFromDirectionX 场景

理解了上面的从特定点开始消融，那么理解从特定方向开始消融就很简单了。  
下面实现 X 方向消融的效果。  
第一步求出 X 方向的边界，然后传给 Shader：

```
using UnityEngine;
using System.Collections;

public class DissolveDirection : MonoBehaviour {

    void Start () {
        Material mat = GetComponent<Renderer>().material;
        float minX, maxX;
        CalculateMinMaxX(out minX, out maxX);
        mat.SetFloat("_MinBorderX", minX);
        mat.SetFloat("_MaxBorderX", maxX);
    }
    
    void CalculateMinMaxX(out float minX, out float maxX)
    {
        Vector3[] vertices = GetComponent<MeshFilter>().mesh.vertices;
        minX = maxX = vertices[0].x;
        for(int i = 1; i < vertices.Length; i++)
        {
            float x = vertices[i].x;
            if (x < minX)
                minX = x;
            if (x > maxX)
                maxX = x;
        }
    }
}
```

第二步定义是从 X 正方向还是负方向开始消融，然后求出各个片元在 X 分量上与边界的距离：

```
//Properties
_Direction("Direction", Int) = 1 //1表示从X正方向开始，其他值则从负方向
_MinBorderX("Min Border X", Float) = -0.5 //从程序传入
_MaxBorderX("Max Border X", Float) = 0.5  //从程序传入
...
//Vert
o.objPosX = v.vertex.x;
...
//Fragment
float range = _MaxBorderX - _MinBorderX;
float border = _MinBorderX;
if(_Direction == 1) //1表示从X正方向开始，其他值则从负方向
    border = _MaxBorderX;
```

[完整代码点这里](https://link.jianshu.com?t=https://github.com/KaimaChen/Unity-Shader-Demo/blob/master/UnityShaderProject/Assets/Dissolve/Shaders/FromDirection.shader)

# 灰烬飞散效果

![[57f269bc58db0d7a46c35ba31347b1b7_MD5.webp]]

DirectionAsh 场景

主要效果就是上面的从特定方向消融加上灰烬向特定方向飞散。  
首先我们需要生成灰烬，我们可以延迟 clip 的时机：

```
float edgeCutout = NoiseTex - _Threshold;
clip(edgeCutout + _AshWidth); //延至灰烬宽度处才剔除掉
```

这样可以在消融边缘上面留下一大片的颜色，而我们需要的是细碎的灰烬，因此我们还需要用白噪声图对这片颜色再进行一次 Dissolve：

```
float degree = saturate(edgeCutout / _EdgeWidth);
fixed4 edgeColor = tex2D(_RampTex, float2(degree, degree));
fixed4 finalColor = fixed4(lerp(edgeColor, albedo, degree).rgb, 1);
if(degree < 0.001) //粗略表明这是灰烬部分
{
    clip(whiteNoise * _AshDensity + normalizedDist * _DistanceEffect - _Threshold); //灰烬处用白噪声来进行碎片化
    finalColor = _AshColor;
}
```

下一步就是让灰烬能够向特定方向飞散，实际上就是操作顶点，让顶点进行偏移，因此这一步在顶点着色器中进行：

```
float NoiseTex = GetNormalizedDist(o.worldPos.y);
float3 localFlyDirection = normalize(mul(unity_WorldToObject, _FlyDirection.xyz));
float flyDegree = (_Threshold - cutout)/_EdgeWidth;
float val = max(0, flyDegree * _FlyIntensity);
v.vertex.xyz += localFlyDirection * val;
```

[完整代码点这里](https://link.jianshu.com?t=https://github.com/KaimaChen/Unity-Shader-Demo/blob/master/UnityShaderProject/Assets/Dissolve/Shaders/DirectionAsh.shader)

# Trifox 的镜头遮挡消融

![[296372eb07c4c0f77893acdf4c91417e_MD5.webp]]

Trifox 场景

具体原理参考 [Unity 案例介绍: Trifox 里的遮挡处理和溶解着色器 (一)](https://link.jianshu.com?t=http://gad.qq.com/program/translateview/7187984)

[完整代码点这里](https://link.jianshu.com?t=https://github.com/KaimaChen/Unity-Shader-Demo/blob/master/UnityShaderProject/Assets/Dissolve/Shaders/Trifox.shader) 我这里的实现是简化版。

# 项目代码

项目代码在 Github 上，[点这里查看](https://link.jianshu.com?t=https://github.com/KaimaChen/Unity-Shader-Demo/tree/master/UnityShaderProject/Assets/Dissolve)

# 参考

《Unity Shader 入门精要》  
[Tutorial - Burning Edges Dissolve Shader in Unity](https://link.jianshu.com?t=http://www.codeavarice.com/dev-blog/tutorial-burning-edges-dissolve-shader-in-unity)  
[A Burning Paper Shader](https://link.jianshu.com?t=http://kylehalladay.com/blog/tutorial/2015/11/10/Dissolve-Shader-Redux.html)  
[Unity 案例介绍: Trifox 里的遮挡处理和溶解着色器 (一)](https://link.jianshu.com?t=http://gad.qq.com/program/translateview/7187984)  
[《Trifox》中的遮挡处理和溶解着色器技术（下）](https://link.jianshu.com?t=http://www.gad.qq.com/article/detail/25821)