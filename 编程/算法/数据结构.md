
# 第一章：绪论

## 1.1 数据结构的基本概念

**1. 数据**：数据是信息的载体，是描述客观事物属性的数、字符以及所有能输入到计算机中并被程序识别和处理的符号的集合。

**2. 数据元素**：数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。例如，学生记录就是一个数据元素，它由学号、姓名、性别等数据项组成。

**3. 数据对象**: 数据对象是具有相同性值的数据元素的集合，是数据的一个子集。

**4. 数据类型**: 数据类型是一个值的集合和定义再此集合上的一组操作的总称。

1）原子类型。其值不可再分的数据类型。如 bool 和 int 类型。  
2）结构类型。其值可以再分解为若干成分（分量）的数据类型。  
3）[抽象数据类型](https://so.csdn.net/so/search?q=%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&spm=1001.2101.3001.7020)。抽象数据组织及与之相关的操作。（定义一个 ADT 就是定义了数据的逻辑结构，数据的运算，也就是定义了一个完整的数据结构）

**5. 数据结构**: 数据结构是相互之间存在一种或多种特定关系的数据元素的集合。

## 1.2 数据结构的三要素

### 逻辑结构
[逻辑结构](https://so.csdn.net/so/search?q=%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84&spm=1001.2101.3001.7020)是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。与数据的存储无关，独立于计算机。

逻辑结构包括：
1. 集合：结构中的数据元素之间除 “同属一个集合” 外，别无其它关系。
2. 线性结构：结构中的数据元素之间只存在一对一的关系，除了第一个元素，所有元素都有唯一前驱；除了最后一个元素，所有元素都有唯一后继。
3. 树形结构：结构中数据元素之间存在一对多的关系。
4. 图状结构：数据元素之间是多对多的关系。

### 存储结构（物理结构）
存储结构是指数据结构在计算机中的表示（又称映像），也称物理结构。它包括数据元素的表示和关系的表示。数据的存储结构是用计算机语言实现的逻辑结构，依赖于计算机语言。

**存储结构包括：**
1. 顺序存储：把**逻辑上相邻的元素存储在物理位置也相邻**的存储单元中，元素之间的关系由存储单元的邻接关系来体现。
    - 优点：实现随机存取，每个元素占用最少的存储空间
    - 缺点：只能使用相邻的一整块存储单元，可能产生较多外部碎片
2. 链式存储：**逻辑上相邻的元素在物理位置上可以不相邻**，借助指示元素存储地址的指针来表示元素之间的逻辑关系。
    - 优点：不会产生碎片，充分利用所有存储单元
    - 去欸但：每个元素因存储指针占用额外存储空间，且只能顺序读取
3. 索引存储：在存储元素信息的同时，还建立附加的索引表，索引表中的每项称为索引项，索引项的一般形式是（关键字，地址）
    - 优点：检索速度快
    - 缺点：索引表占用存储空间，增删数据要修改索引表，时间开销大。
4. 散列存储（哈希存储）：根据元素的关键字直接计算出该元素的存储地址，又称哈希（Hash）存储。
    - 优点：检索，增删节点快速
    - 缺点：若哈希函数不好，可能出现存储单元的冲突，解决冲突会增加时间空间的开销

**3. 数据的运算**：施加在数据上的运算包括运算的定义何实现。**运算的定义**是针对逻辑结构的，指出运算的功能；**运算的实现**是针对存储结构的，指出运算的具体操作步骤。

### 1.3 算法的基本概念

**程序 = 数据结构 + 算法**  

算法（algorithm) 是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。  
**算法的特性：**  
1. 有穷性：一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。  
2. 确定性：算法中每条指令必须有确定的含义，对于相同的输入只能得到相同的输出。  
3. 可行性：算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。  
4. 输入：一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。  
5. 输出：一个算法有一个多个输出，这些输出是与输入有着某种特定关系的量。  

### 1.4 算法的时间复杂度

一般情况下，算法中基本操作重复执行的次数是问题规模 $n$ 的某个函数 $f(n)$，算法的时间量度记作 $T(n)=O(n)$，它表示随问题规模 $n$ 的增大而增大，算法执行时间的增长率和 $f(n)$ 的增长率相同，称作算法的渐近时间复杂度，简称时间复杂度。

### 1.5 算法的空间复杂度

算法的空间复杂度 $S(n)$ 定义为该算法所耗费的存储空间，它是问题规模 $n$ 的函数。记为 $S(n)=O(g(n))$。

## 第二章：线性表

### 2.1 线性表的定义

线性表是具有相同数据类型的 n(n>0) 个数据元素的有限序列，其中 n 为表长，当 n=0 时线性表是一个空表。

### 2.2 顺序表的定义

#### 2.2.1 静态分配:

//顺序表的实现--静态分配

#include<stdio.h>
#define MaxSize 10   //定义表的最大长度 
typedef struct{
	int data[MaxSize];//用静态的"数组"存放数据元素
	int length; //顺序表的当前长度  
}SqList;        //顺序表的类型定义（静态分配方式） 
void InitList(SqList &L){
	 for(int i=0;i<MaxSize;i++){
	 	L.data[i]=0;  //将所有数据元素设置为默认初始值
		  
	 }
	 L.length=0;
}
int main(){
	SqList L;//声明一个顺序表
	InitList(L);//初始化一个顺序表
	for(int i=0;i<MaxSize;i++){
		printf("data[%d]=%d\n",i,L.data[i]);
	}
	return 0; 
}

#### 2.2.2 动态分配

//顺序表的实现——动态分配
#include<stdio.h>
#include<stdlib.h>//malloc、free函数的头文件 
#define InitSize 10 //默认的最大长度
typedef struct{
	int  *data;//指示动态分配数组的指针
	int MaxSize; //顺序表的最大容量
	int length;  //顺序表的当前长度 
}SeqList; 
//初始化
void InitList(SeqList &L){
	//用malloc 函数申请一片连续的存储空间
	L.data =(int*)malloc(InitSize*sizeof(int)) ;
	L.length=0;
	L.MaxSize=InitSize;
} 
//增加动态数组的长度
void IncreaseSize(SeqList &L,int len){
	int *p=L.data;
	L.data=(int*)malloc((L.MaxSize+len)*sizeof(int));
	for(int i=0;i<L.length;i++){
		L.data[i]=p[i];   //将数据复制到新区域 
	}
	L.MaxSize=L.MaxSize+len; //顺序表最大长度增加len
	free(p);  //释放原来的内存空间 
	
} 
int main(void){
	SeqList L; //声明一个顺序表
	InitList(L);//初始化顺序表
	IncreaseSize(L,5);
	return 0; 
}

**顺序表的特点：**

1. ==随机访问== ，可以在 O(1) 时间内找到第 i 个元素。
2. 存储密度高，每个节点只存储数据元素
3. 拓展容量不方便
4. 插入、删除操作不方便，需要移动大量元素

### 2.2 顺序表的基本操作

#### 1. 插入操作 ：平均时间复杂度 O(n)

bool ListInsert(SqList &L, int i, int e){ 
    //判断i的范围是否有效
    if(i<1||i>L.length+1) 
        return false;
    if(L.length>MaxSize) //当前存储空间已满，不能插入  
        return false;

    for(int j=L.length; j>=i; j--){    //将第i个元素及其之后的元素后移
        L.data[j]=L.data[j-1];
    }
    L.data[i-1]=e;  //在位置i处放入e
    L.length++;      //长度加1
    return true;
}

#### 2. 删除操作：平均时间复杂度 O(n)

bool LisDelete(SqList &L, int i, int &e){ // e用引用型参数 
    //判断i的范围是否有效
    if(i<1||i>L.length) 
        return false;

    e = L.data[i-1]    //将被删除的元素赋值给e

    for(int j=L.length; j>=i; j--){    //将第i个后的元素前移
        L.data[j-1]=L.data[j];
    }
    L.length--;      //长度减1
    return true;
}

#### 3. 按位查找 (获取 L 表中第 i 个位置的值)：平均时间复杂度 O(1)

#define MaxSize 10            //定义最大长度 
typedef struct{
    ElemType data[MaxSize];  //用静态的“数组”存放数据元素 
    int Length;              //顺序表的当前长度
}SqList;                     //顺序表的类型定义

ElemType GetElem(SqList L, int i){
    // ...判断i的值是否合法
    return L.data[i-1];      //注意是i-1
}

#### 4. 按值查找：平均时间复杂度 O（n）

#define InitSize 10            //定义最大长度 
typedef struct{
    ElemTyp *data;  //用静态的“数组”存放数据元素 
    int Length;              //顺序表的当前长度
}SqList;   

//在顺序表L中查找第一个元素值等于e的元素，并返回其位序
int LocateElem(SqList L, ElemType e){
    for(int i=0; i<L.lengthl i++)
        if(L.data[i] == e)  
            return i+1;     //数组下标为i的元素值等于e，返回其位序i+1
    return 0;               //推出循环，说明查找失败
}

### 2.3 线性表的链式表示

#### 2.3.1 单链表的定义

**定义：** 线性表的链式存储又称单链表，它是指通过一组任意的存储单元来存储线性表中的数据元素。

typedef struct LNode{//定义单链表结点类型
    ElemType data; //数据域
    struct LNode *next;//指针域
}LNode, *LinkList;

可以利用 typedef 关键字——数据类型重命名：type <数据类型>< 别名 >

**单链表的两种实现方式：**

1. 不带头结点的单链表

```bash
typedef struct LNode{
    ElemType data;
    struct LNode *next;
}LNode, *LinkList;

//初始化一个空的单链表
bool InitList(LinkList &L){  //注意用引用 &
    L = NULL; //空表，暂时还没有任何结点；
    return true;
}

void test(){
    LinkList L;  //声明一个指向单链表的指针: 头指针
    //初始化一个空表
    InitList(L);
    //...
}

//判断单链表是否为空
bool Empty(LinkList L){
    if (L == NULL)
        return true;
    else
        return false;
}

头结点：代表链表上头指针指向的第一个结点，不带有任何数据。

2. 带头结点的单链表

typedef struct LNode{
    ElemType data;
    struct LNode *next;
}LNode, *LinkList;

//初始化一个单链表（带头结点）
bool InitList(LinkList &L){  
    L = (LNode*) malloc(sizeof(LNode));  //头指针指向的结点——分配一个头结点（不存储数据）
    if (L == NULL)          //内存不足，分配失败
        return false;
    L -> next = NULL;       //头结点之后暂时还没有结点
    return true;
}

void test(){
    LinkList L;  //声明一个指向单链表的指针: 头指针
    //初始化一个空表
    InitList(L);
    //...
}

//判断单链表是否为空（带头结点）
bool Empty(LinkList L){
    if (L->next == NULL)
        return true;
    else
        return false;
}

**带头结点和不带头结点的比较：**  
不带头结点：写代码麻烦！对第一个数据节点和后续数据节点的处理需要用不同的代码逻辑，对空表和非空表的处理也需要用不同的代码逻辑; 头指针指向的结点用于存放实际数据;  
带头结点：头指针指向的头结点不存放实际数据, 头结点指向的下一个结点才存放实际数据;

#### 2.3.2 单链表上基本操作的实现

**1. 按位序插入（带头结点）**：  
==ListInsert(&L, i, e): == 在表 L 中的第 i 个位置上插入指定元素 e = 找到第 i-1 个结点 (前驱结点)，将新结点插入其后；其中头结点可以看作第 0 个结点，故 i=1 时也适用。

typedef struct LNode{
    ElemType data;
    struct LNode *next;
}LNode, *LinkList;

//在第i个位置插入元素e（带头结点）
bool ListInsert(LinkList &L, int i, ElemType e){  
    //判断i的合法性, i是位序号(从1开始)
    if(i<1)
        return False;
    
    LNode *p;       //指针p指向当前扫描到的结点 
    int j=0;        //当前p指向的是第几个结点
    p = L;          //L指向头结点，头结点是第0个结点（不存数据）

    //循环找到第i-1个结点
    while(p!=NULL && j<i-1){     //如果i>lengh, p最后会等于NULL
        p = p->next;             //p指向下一个结点
        j++;
    }

    if (p==NULL)                 //i值不合法
        return false;
    
    //在第i-1个结点后插入新结点
    LNode *s = (LNode *)malloc(sizeof(LNode)); //申请一个结点
    s->data = e;
    s->next = p->next;
    p->next = s;                 //将结点s连到p后,后两步千万不能颠倒qwq

    return true;
}

平均时间复杂度：O(n)

**2. 按位序插入（不带头结点）**  
==ListInsert(&L, i, e): == 在表 L 中的第 i 个位置上插入指定元素 e = 找到第 i-1 个结点 (前驱结点)，将新结点插入其后; 因为不带头结点，所以不存在“第 0 个” 结点，因此！i=1 时，需要特殊处理——插入 (删除) 第 1 个元素时，需要更改头指针 L;

typedef struct LNode{
    ElemType data;
    struct LNode *next;
}LNode, *LinkList;

bool ListInsert(LinkList &L, int i, ElemType e){
    if(i<1)
        return false;
    
    //插入到第1个位置时的操作有所不同！
    if(i==1){
        LNode *s = (LNode *)malloc(size of(LNode));
        s->data =e;
        s->next =L;
        L=s;          //头指针指向新结点
        return true;
    }

    //i>1的情况与带头结点一样！唯一区别是j的初始值为1
    LNode *p;       //指针p指向当前扫描到的结点 
    int j=1;        //当前p指向的是第几个结点
    p = L;          //L指向头结点，头结点是第0个结点（不存数据）

    //循环找到第i-1个结点
    while(p!=NULL && j<i-1){     //如果i>lengh, p最后会等于NULL
        p = p->next;             //p指向下一个结点
        j++;
    }

    if (p==NULL)                 //i值不合法
        return false;
    
    //在第i-1个结点后插入新结点
    LNode *s = (LNode *)malloc(sizeof(LNode)); //申请一个结点
    s->data = e;
    s->next = p->next;
    p->next = s;          
    return true;

}

**3. 指定结点的后插操作：**

==InsertNextNode(LNode *p, ElemType e):== 给定一个结点 p，在其之后插入元素 e; 根据单链表的链接指针只能往后查找，故给定一个结点 p，那么 p 之后的结点我们都可知，但是 p 结点之前的结点无法得知;

typedef struct LNode{
    ElemType data;
    struct LNode *next;
}LNode, *LinkList;

bool InsertNextNode(LNode *p, ElemType e){
    if(p==NULL){
        return false;
    }

    LNode *s = (LNode *)malloc(sizeof(LNode));
    //某些情况下分配失败，比如内存不足
    if(s==NULL)
        return false;
    s->data = e;          //用结点s保存数据元素e 
    s->next = p->next;
    p->next = s;          //将结点s连到p之后

    return true;
}                         //平均时间复杂度 = O(1)

//有了后插操作，那么在第i个位置上插入指定元素e的代码可以改成：
bool ListInsert(LinkList &L, int i, ElemType e){  
    if(i<1)
        return False;
    
    LNode *p;       //指针p指向当前扫描到的结点 
    int j=0;        //当前p指向的是第几个结点
    p = L;          //L指向头结点，头结点是第0个结点（不存数据）

    //循环找到第i-1个结点
    while(p!=NULL && j<i-1){     //如果i>lengh, p最后4鸟会等于NULL
        p = p->next;             //p指向下一个结点
        j++;
    }

    return InsertNextNode(p, e)
}

**4. 指定结点的前插操作**  
思想：设待插入结点是 _s，将_ s 插入到 _p 的前面。我们仍然可以将_ s 插入到 * p 的后面。然后将 p->data 与 s->data 交换，这样既能满足了逻辑关系，又能是的时间复杂度为 O(1).（真是妙的不达鸟）

//前插操作：在p结点之前插入元素e
bool InsertPriorNode(LNode *p, ElenType e){
    if(p==NULL)
        return false;
    
    LNode *s = (LNode *)malloc(sizeof(LNode));
    if(s==NULL) //内存分配失败
        return false;

    //重点来了！
    s->next = p->next;
    p->next = s;       //新结点s连到p之后
    s->data = p->data; //将p中元素复制到s
    p->data = e;       //p中元素覆盖为e

    return true；
}  //时间复杂度为O(1)

王道书代码：

bool InsertPriorNode(LNode *p, LNode *s){
    if(p==NULL || S==NULL)
        return false;
    
    s->next = p->next;
    p->next = s;  ///s连接到p
    ELemType temp = p->data;  //交换数据域部分
    p->data = s->data;
    s->data = temp;

    return true;
}

**5. 按位序删除节点（带头结点）**  
==ListDelete(&L, i, &e):== 删除操作，删除表 L 中第 i 个位置的元素，并用 e 返回删除元素的值; 头结点视为 “第 0 个” 结点；

思路：找到第 i-1 个结点，将其指针指向第 i+1 个结点，并释放第 i 个结点；

typedef struct LNode{
    ElemType data;
    struct LNode *next;
}LNode, *LinkList;

bool ListDelete(LinkList &L, int i, ElenType &e){
    if(i<1) return false;

    LNode *p;       //指针p指向当前扫描到的结点 
    int j=0;        //当前p指向的是第几个结点
    p = L;          //L指向头结点，头结点是第0个结点（不存数据）

    //循环找到第i-1个结点
    while(p!=NULL && j<i-1){     //如果i>lengh, p最后会等于NULL
        p = p->next;             //p指向下一个结点
        j++;
    }

    if(p==NULL) 
        return false;
    if(p->next == NULL) //第i-1个结点之后已无其他结点
        return false;

    LNode *q = p->next;         //令q指向被删除的结点
    e = q->data;                //用e返回被删除元素的值
    p->next = q->next;          //将*q结点从链中“断开”
    free(q)                     //释放结点的存储空间

    return true;
}

时间复杂度分析：  
最坏，平均时间复杂度：O(n)

最好时间复杂度：删除第一个结点 O(1)

**6. 指定结点的删除**

bool DeleteNode(LNode *p){
    if(p==NULL)
        return false;
    
    LNode *q = p->next;      //令q指向*p的后继结点
    p->data = p->next->data; //让p和后继结点交换数据域
    p->next = q->next;       //将*q结点从链中“断开”
    free(q);
    return true;
} //时间复杂度 = O(1)

#### 2.3.3 单链表的查找

**按位查找**  
==GetElem(L, i): == 按位查找操作，获取表 L 中第 i 个位置的元素的值;

LNode * GetElem(LinkList L, int i){
    if(i<0) return NULL;
    
    LNode *p;               //指针p指向当前扫描到的结点
    int j=0;                //当前p指向的是第几个结点
    p = L;                  //L指向头结点,头结点是第0个结点(不存数据)
    while(p!=NULL && j<i){  //循环找到第i个结点
        p = p->next;
        j++;
    }

    return p;               //返回p指针指向的值
}

平均时间复杂度 O（n）

**按值查找**  
==LocateElem(L, e)==: 按值查找操作，在表 L 中查找具有给定关键字值的元素;

LNode * LocateElem(LinkList L, ElemType e){
    LNode *P = L->next;    //p指向第一个结点
    //从第一个结点开始查找数据域为e的结点
    while(p!=NULL && p->data != e){
        p = p->next;
    }
    return p;           //找到后返回该结点指针，否则返回NULL
}

#### 2.3.4 求单链表的长度

== Length(LinkList L)==