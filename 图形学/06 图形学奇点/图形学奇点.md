# 菲涅尔边缘光
## 简易版菲涅尔边缘光
```c
```text
Shader "Test/Scan"
{
	Properties
	{
		_MainTex ("Texture", 2D) = "white" {}
		_RimColor ("Rim Color", color) = (1.0,0,0,1.0)
		_RimPower ("Rim Power", Range(0.0001, 3.0)) = 1.0
	}
	SubShader
	{
		Tags { "RenderType"="Opaque" }
		LOD 100
		Pass
		{
			CGPROGRAM
			#pragma vertex vert
			#pragma fragment frag
			#include "UnityCG.cginc"

			struct appdata
			{
				float4 vertex : POSITION;
				float2 pos : TEXCOORD0;
				float3 normal : NORMAL;
			};

			struct v2f
			{
				float2 uv : TEXCOORD0;
				float4 vertex_pos : SV_POSITION;
				float3 normal_World : TEXCOORD1;
				float3 pos_world : TEXCOORD2;
			};

			sampler2D _MainTex;
			//使用了TRANSFROM_TEX宏就需要定义XXX_ST 
			float4 _MainTex_ST;
			fixed4 _RimColor;
			half _RimPower;
			
			v2f vert (appdata v)
			{
				v2f o;
				//顶点从模型空间转换裁剪空间
				o.vertex_pos = UnityObjectToClipPos(v.vertex);
				//获取当前顶点的UV
				o.uv = TRANSFORM_TEX(v.pos,_MainTex);
				//获取当前Normal的UV
				o.normal_World = mul(v.normal,(float3x3)unity_WorldToObject);
				//获取当前顶点在世界空间的位置
				float3 worldPos = mul(unity_ObjectToWorld,v.vertex).xyz;
				return o;
			}
			
			fixed4 frag (v2f i) : SV_Target
			{
				//归一化法线
				float3 normal_World = normalize(i.normal_World);
				//获取视线位置
				float3 view_world = normalize(_WorldSpaceCameraPos.xyz - i.pos_world);
				//计算法线与视线方向点积，求反（越靠近边缘夹角越大，值越小就越亮，越边缘越暗）
				//求反后: dot值越接近0，说明视线方向越偏离该点，也就是平视，该点越接近边缘
				half Rim = saturate(1 - dot(normal_World,view_world)); 
				//计算边缘光RimLight
				fixed4 RimColor = _RimColor * pow(Rim, 1 / _RimPower);
				//采样贴图的颜色
				fixed4 Color = tex2D(_MainTex,i.uv).rgba;
				fixed4 FinallyColor = Color + RimColor;
				return Color;
			}
			ENDCG
		}
	}
}
```
## 菲尼尔方程（Fresnel）
[从Lambert模型到PBR模型6：推导镜面反射和漫反射的菲涅尔部分 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/198201029)
随着物体表面法线与视线的角度增大，物体的反射能力增大，这种现象称之为**菲涅尔效应**，万物皆有菲涅尔效应。

角度跟法线角度越小，越容易穿透介质，发生折射、散射、漫反射。

角度跟法线角度越大，越难穿透介质，就越容易发生镜面反射。

![[8d86267f0452baa87f69a39044405bd5_MD5.webp]]

**菲涅尔方程**（Fresnel Equations），用来描述光在不同折射率的介质之间的行为的方程。

菲涅尔方程描述的是**被反射的光线所占的百分比**，这个比率会随着我们观察的角度不同而不同。

所以菲涅尔方程同时影响漫反射跟镜面反射。  

我们一般采用**Schlick的Fresnel近似**，因为计算量小，精度足够：

F_Schlick(v,h) = F0 + (1-F0)(1- dot(v,h))^5

### 方程里的F0与F90

**任何角度都有菲涅尔反射，我们需要计算两个特殊角度的菲尼尔反射，然后插值得到所有角度的菲尼尔反射，也就是渲染每个像素时的F。

**F0** : 指视线与法线夹角=0度角时，入射的菲涅尔反射率。F0也叫基础反射率。

**F90**：指视线与法线夹角=0度角（掠射角）时，入射的菲涅尔反射率。

![[5094948cf4ee58a5d7ee0b7adb122d75_MD5.webp]]

  

物理上对不同材质的观察，有一些结论：

1.不同材质的F90基本都接近1，所以我们一般不会暴露F90来给美术调节。

2.不同材质的F0有一定差别，基本在2-5％，所以如果有需要，可以给定一个F0来渲染不同材质。

3. 虽说大部分情况，F90接近于1。但对于粗糙表面，Fresnel效果会随着物体表面的光滑度变低快速的变弱。所以后续的F90，我们需要引入粗糙度的影响。

4. 角度越大，反射率变化越迅速。

另外，金属跟非金属的F0差异很大。
### 金属与非金属的F0

由于光由电磁波组成，因此，物质的光学特性与其导电特性密切相关。

即根据导电特性，可将现实生活中的物质分为三个主要光学类别：导体（金属）和绝缘体（电解质，非金属）、半导体。

渲染和游戏领域只关注：金属和非金属。

**1.非金属**

1.1 大部分电介质的光学性质在可见光谱上变化很小，导致无色反射率值，**它们的反射光的颜色一般跟光源颜色一致**。即非金属的F0是一个float。

1.2基本反射率，也就是F0，大多为0.02-0.05（线性值），基本都在0.17这个水平线以下，且rgb分量一致，所以Unity引擎**固定使用0.04（线性空间）**。

1.3.虽然非金属的F0很低，但F90也接近于1，,这一现象也导致了金属与非金属外观上的不同

**2 金属**

2.1 一些**金属具有**在可见光谱范围内变化的光学性质。所以反射率rgb分量值不一致（正是这个不一致性，使得白光照射下的不同的金属有显著的颜色差异，如金、铜、银）。因为金属表面会吸收所有折射光线而没有漫反射，而albedo 是我们绘制的材质对于光线的反射率，

**所以我们可以使用albedo来作为F0。**

**金属的镜面反射颜色都来自表面颜色纹理。**

**其实从这句话可以看出，菲尼尔反射效应，本质上也是一个特殊的镜面反射。**

2.2 导体本身的反射率就已经很强，随角度变化很小，所以F0较高，范围为0.5-1.0。

2.3 金属会立即吸收任何透射光，因此它们不会出现任何次表面散射或透明感。这也意味着理论上金属不会表现出任何的漫反射，使得金属看起来很闪亮。

2.4 但实际中由于金属表面氧化等原因，还是会表现出部分散射效果，所以PBR用“metalness”作为输入来表示材料的金属程度，而不是albedo（反射率） & reflectivity。 **因为金属没有透射，所以使用BRDF即可。**

**从上文，我们可以得到一个信息：**albedo纹理，在漫反射里作为漫反射rgb系数，在镜面反射里，对于金属，作为F0使用。

albedo纹理在PBR里是个很特殊的纹理。
# 纹理
## TRANSFORM_TEX
1) TRANSFORM_TEX是做什么的
2) float4 _MainTex_ST 中的_MainTex_ST变量也没有用到，为啥非要声明一下？

答：

(1)简单来说，TRANSFORM_TEX主要作用是拿顶点的uv去和材质球的tiling和offset作运算， 确保材质球里的缩放和偏移设置是正确的。 （v.texcoord就是顶点的uv）

下面这两个函数是等价的。

o.uv =   TRANSFORM_TEX(v.texcoord,_MainTex);

o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;

**_MainTex_ST.xy中是tiling**

**_MainTex_ST.zw中是offset**

(2)而_MainTex_ST的ST是应该是SamplerTexture的意思 ，就是声明_MainTex是一张采样图，也就是会进行UV运算。  如果没有这句话，是不能进行TRANSFORM_TEX的运算的。_MainTex_ST.xy为 下图中的Tiling,zw为下图中的offset.

如果Tiling 和Offset你留的是默认值，即Tiling为（1，1） Offset为（0，0）的时候，可以不用

o.uv = TRANSFORM_TEX(v.texcoord,_MainTex);

换成o.uv = v.texcoord.xy;也是能正常显示的；相当于Tiling 为（1，1）Offset为（0，0），但是使用自己填的Tiling值和Offset值就不起作用了