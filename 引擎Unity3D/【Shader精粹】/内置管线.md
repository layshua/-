[Unity小白的TA之路-Shader开发|图形渲染管线|URP|性能优化|图形渲染|PostProcessing (91maketop.github.io)](https://91maketop.github.io/ta/#/README)
# include 文件

Unity 提供了若干文件供[着色器程序](https://docs.unity3d.com/cn/2021.1/Manual/SL-ShaderPrograms.html)用于引入预定义的变量和 helper 函数。这可以通过标准 `#include` 指令来完成，例如：

```
CGPROGRAM
// ...
#include"UnityCG.cginc"
// ...
ENDCG
```

Unity 中的着色器 include 文件采用 `.cginc` 扩展名，内置的着色器 include 文件包括：

- `HLSLSupport.cginc` -_（自动包含）_用于跨平台着色器编译的 helper 宏和定义。

- `UnityShaderVariables.cginc` -_（自动包含）_常用的全局变量。

- `UnityCG.cginc` - 常用的 [helper 函数](https://docs.unity3d.com/cn/2021.1/Manual/SL-BuiltinFunctions.html)。

- `AutoLight.cginc` - 光照和阴影功能，例如[表面着色器](https://docs.unity3d.com/cn/2021.1/Manual/SL-SurfaceShaders.html)在内部使用此文件。

- `Lighting.cginc` - 标准[表面着色器](https://docs.unity3d.com/cn/2021.1/Manual/SL-SurfaceShaders.html)光照模型；当您编写表面着色器时会自动包含。

- `TerrainEngine.cginc` - 地形和植被着色器的 helper 函数。

如果您要查看任何 helper 代码具体执行的操作，可在 Unity 应用程序中找到这些文件（Windows 上位于 **{unity 安装路径}/Data/CGIncludes/UnityCG.cginc__，Mac 上位于** /Applications/Unity/Unity.app/Contents/CGIncludes/UnityCG.cginc__）。

## HLSLSupport.cginc

编译 CGPROGRAM 着色器时会自动包含此文件（但不会对 HLSLPROGRAM 着色器包含此文件）。此文件声明各种[预处理器宏](https://docs.unity3d.com/cn/2021.1/Manual/SL-BuiltinMacros.html)以帮助进行多平台着色器开发。

## UnityShaderVariables.cginc

编译 CGPROGRAM 着色器时会自动包含此文件（但不会对 HLSLPROGRAM 着色器包含此文件）。此文件声明着色器中常用的各种[内置全局变量](https://docs.unity3d.com/cn/2021.1/Manual/SL-UnityShaderVariables.html)。

## UnityCG.cginc

Unity 着色器中通常会包含此文件。此文件声明大量[内置 helper 函数](https://docs.unity3d.com/cn/2021.1/Manual/SL-BuiltinFunctions.html)和数据结构。

#### UnityCG.cginc 中的数据结构

- struct `appdata_base`：顶点着色器输入，包含位置、法线和一个纹理坐标。

- struct `appdata_tan`：顶点着色器输入，包含位置、法线、切线和一个纹理坐标。

- struct `appdata_full`：顶点着色器输入，包含位置、法线、切线、顶点颜色和两个纹理坐标。

- struct `appdata_img`: 顶点着色器输入，包含位置和一个纹理坐标。

# 属性的常用特效
1. NoScaleOffset（隐藏 Tiling 和 Offset）

`[NoScaleOffset]_MainTex ("Texture", 2D) = "white" {}`

如果不想在InSpector面板上被人修改，可以用这个特性隐藏掉

2. Normal（法线纹理）

`[Normal]_NormalTexture("Normal Texture",2D) = "white" {}`

3. HDR

`[HDR]_MainColor("Main Color",Color) = (1,1,1,1)`

4. HideInInSpector（InSpector面板隐藏）

`[HideInInSpector]_FloatValue("Float Value",Float) = 0`

5. Toggle

`[Toggle]_IsFloat("Is Float",Float) = 0`

6. IntRange（整数滑动条）

`[IntRange]_Alpha("Alpha",Range(0,255)) = 0`

7. Space（垂直间隔）

`[Space]_Prop1("Prop1",Float) = 0`

也可以加数字增大间隔

`[Space(50)]_Prop2("Prop2",Float) = 0`

8. Header（标题头）

`[Header(Title)]_Title("Title",Float) = 0`

9. PowerSlider（指数式的滑动条）

`[PowerSlider(3.0)]_Shininess("Shininess",Range(0,1)) = 0`

10. Enum（枚举）

`[Enum(Zero,0,One,1,Two,2,Three,3)] _Number ("Number", Float) = 0`

11. KeywordEnum（枚举）

`[KeywordEnum(None,Add,Multiply)]_Overlay("OverLay Mode",Float) = 0`

KeywordEnum和Enum使用上有些不同，区别在于KeywordEnum类似于if-else，同时在shader代码中需要处理

定义如下：

![img](https://91maketop.github.io/ta/ShaderLab%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C%EF%BC%88%E5%86%85%E7%BD%AE%E7%AE%A1%E7%BA%BF%EF%BC%89/Shader%E5%B1%9E%E6%80%A7%E7%9A%84%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7.assets/20200421113212796.png)

使用如下：

![img](https://91maketop.github.io/ta/ShaderLab%E7%AE%80%E6%98%8E%E6%89%8B%E5%86%8C%EF%BC%88%E5%86%85%E7%BD%AE%E7%AE%A1%E7%BA%BF%EF%BC%89/Shader%E5%B1%9E%E6%80%A7%E7%9A%84%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7.assets/20200421113507377.png)

# 变体和关键字


可以编写着色器代码片段来共享通用代码，但在启用或禁用给定关键字时具有不同功能。Unity 编译这些着色器代码片段时，它将为已启用和已禁用关键字的不同组合创建单独的着色器程序。这些各个着色器程序被称为着色器变体。

由于项目工作流程的原因，着色器变体可能会很有用；可以将同一着色器分配给不同材质，但要为每种材质配置不同关键字。这意味着可以在同一个地方编写和维护着色器代码，并减少项目中的着色器资源。还可以使用着色器变体，通过启用或禁用关键字在运行时更改着色器行为。

具有大量变体的着色器被称为“大型着色器”或“超级着色器”。Unity 的标准着色器就是此类着色器的一个示例。

## 使用着色器变体和关键字

### 创建着色器变体

使用下列[pragma 指令](https://docs.unity3d.com/cn/2021.1/Manual/SL-PragmaDirectives.html)之一:

- `#pragma multi_compile`
- `#pragma multi_compile_local`
- `#pragma shader_feature`
- `#pragma shader_feature_local`

You can use these directives in Unity shaders (including [surface shaders](https://docs.unity3d.com/cn/2021.1/Manual/SL-SurfaceShaders.html)) and [compute shaders](https://docs.unity3d.com/cn/2021.1/Manual/class-ComputeShader.html).

If a keyword affects only a single shader stage, you can add a suffix to these directives to reduce redundant shader compilation work. For more information, see [Stage-specific keyword directives](https://docs.unity3d.com/cn/2021.1/Manual/SL-MultipleProgramVariants.html#stage-specific-keyword-directives).

然后，Unity 使用不同的预处理器指令来多次编译同一着色器代码。

### 启用和禁用着色器关键字

要启用和禁用着色器关键字，请使用以下 API：

- [Shader.EnableKeyword](https://docs.unity3d.com/cn/2021.1/ScriptReference/Shader.EnableKeyword.html)：启用全局关键字
- [Shader.DisableKeyword](https://docs.unity3d.com/cn/2021.1/ScriptReference/Shader.DisableKeyword.html)：禁用全局关键字
- [CommandBuffer.EnableShaderKeyword](https://docs.unity3d.com/cn/2021.1/ScriptReference/Rendering.CommandBuffer.EnableShaderKeyword.html)：使用 `CommandBuffer` 来启用全局关键字
- [CommandBuffer.DisableShaderKeyword](https://docs.unity3d.com/cn/2021.1/ScriptReference/Rendering.CommandBuffer.DisableShaderKeyword.html)：使用 `CommandBuffer` 来禁用全局关键字
- [Material.EnableKeyword](https://docs.unity3d.com/cn/2021.1/ScriptReference/Material.EnableKeyword.html)：为常规着色器启用本地关键字
- [Material.DisableKeyword](https://docs.unity3d.com/cn/2021.1/ScriptReference/Material.DisableKeyword.html)：为常规着色器禁用本地关键字
- [ComputeShader.EnableKeyword](https://docs.unity3d.com/cn/2021.1/ScriptReference/ComputeShader.EnableKeyword.html): enable a local keyword for a compute shader
- [ComputeShader.DisableKeyword](https://docs.unity3d.com/cn/2021.1/ScriptReference/ComputeShader.DisableKeyword.html): disable a local keyword for a compute shader

启用或禁用关键字时，Unity 会使用相应变体。

### 从打包中裁剪Shader变体

可以通过下列API阻止Shader变体被打包，从而节省打包时间和文件体积:

- [IPreprocessShaders.OnProcessShader](https://docs.unity3d.com/cn/2021.1/ScriptReference/Build.IPreprocessShaders.OnProcessShader.html): receive a callback before Unity compiles a regular shader into a build ): receive a callback before Unity compiles a compute shader into a build
- [IPreprocessComputeShaders.OnProcessComputeShader](scriptref:Build.IPreprocessComputeShaders.OnProcessComputeShader): receive a callback before Unity compiles a compute shader into a build

For more information on this subject, see the Unity blog post [Stripping scriptable shader variants](https://blogs.unity3d.com/2018/05/14/stripping-scriptable-shader-variants/) .

## multi_compile 的工作方式

指令示例：

```
# pragma multi_compile FANCY_STUFF_OFF FANCY_STUFF_ON
```

此指令示例生成两个着色器变体：一个定义了 `FANCY_STUFF_OFF`，另一个定义了 `FANCY_STUFF_ON`。在运行时，Unity 根据材质或全局着色器关键字来激活其中一个变体。如果这两个关键字均未启用，则 Unity 使用第一个关键字（在此示例中为 `FANCY_STUFF_OFF`）。

可以在 multi_compile 行中添加两个以上的关键字。例如：

```
# pragma multi_compile SIMPLE_SHADING BETTER_SHADING GOOD_SHADING BEST_SHADING
```

此指令示例生成四个着色器变体：`SIMPLE_SHADING`、`BETTER_SHADING`、`GOOD_SHADING` 和 `BEST_SHADING`。

为了生成未定义预处理器宏的着色器变体，请添加一个只有下划线 (`__`) 的名称。这是避免用完两个关键字的常用方法，因为在一个项目中可以使用的关键字数量有限（请参阅后面的[关键字限制](https://docs.unity3d.com/cn/2021.1/Manual/SL-MultipleProgramVariants.html#KeywordLimits)部分）。例如：

```
# pragma multi_compile __ FOO_ON
```

此指令生成两个着色器变体：一个未定义任何关键字 (`__`)，另一个定义了 `FOO_ON`。

## shader_feature 与 multi_compile 之间的区别

`shader_feature` 与 `multi_compile` 非常相似。唯一的区别是 Unity 没有将 `shader_feature` 着色器的未用变体包含在最终构建中。因此，应该将 `shader_feature` 用于材质中设置的关键字，而 `multi_compile` 更适合通过代码来全局设置的关键字。

此外，有一个只包含一个关键字的速记符号：

```
# pragma shader_feature FANCY_STUFF
```

这只是 `#pragma shader_feature _ FANCY_STUFF` 的快捷方式。它会扩展为两个着色器变体（第一个没有定义；第二个有定义）。

## 合并多个 multi_compile 行

如果提供 `multi_compile` 行，Unity 将会针对所有可能的行组合来编译生成的着色器。例如：

```
# pragma multi_compile A B C
# pragma multi_compile D E
```

这会为第一行生成三个变体，为第二行生成两个变体。总共生成六个着色器变体（A+D、B+D、C+D、A+E、B+E、C+E）。

每个 `multi_compile` 行可以视为用于控制单个着色器“功能”。请记住，着色器变体的总数会以这种方式急速增长。例如，十个各有两个选项的 `multi_compile` 功能总共生成 1024 个着色器变体。

## 关键字限制

When using Shader variants, there is a limit of 384 keywords in Unity, and Unity uses around 60 of them internally (therefore lowering the available limit). The keywords are enabled globally across a Unity project, so be careful not to exceed the limit when you define multiple keywords in several different Shaders.

### 本地关键字

The main disadvantage of **shader_feature** and **multi_compile** is that all keywords defined in them contribute towards Unity’s global keyword count limit (384 global keywords, plus 64 local keywords). To avoid this issue, you can use different shader variant directives: **shader_feature_local** and **multi_compile_local**.

- **shader_feature_local：__类似于** shader_feature__，但是枚举的关键字为本地关键字。
- **multi_compile_local：__类似于** multi_compile__，但是枚举的关键字为本地关键字。

本地指令将已定义的关键字保留在特定于该着色器的这些指令之下，而不是将这些关键字应用于整个项目。因此，应该使用本地关键字而不是全局关键字，除非计划通过全局 API 来启用这些特定关键字。

开始使用本地关键字时，您可能会发现性能有变化，但是此差异取决于项目的设置方式。每个着色器的本地和全局关键字总数会影响性能：在理想设置中，多用本地关键字和少用全局关键字可以减少每个着色器的关键字总数。

如果全局关键字和本地关键字同名，Unity 会优先考虑本地关键字。

#### 限制

- 不能将本地关键字与进行全局关键字更改的 API 一起使用（例如 Shader.EnableKeyword 或 CommandBuffer.EnableShaderKeyword）。
- 每个着色器最多有 64 个唯一性的本地关键字。
- 如果材质启用了本地关键字，并且其着色器变为不再声明的着色器，Unity 将创建新的全局关键字。

#### 示例

```
# pragma multi_compile_local __ FOO_ON
```

此指令生成两个着色器变体：一个未定义任何关键字 (`__`)，另一个定义了 `FOO_ON`（本地关键字）。

启用本地关键字的过程与启用全局关键字的过程相同：

```
public Material mat;
Private void Start()
{
    mat.EnableKeyword("FOO_ON");
}
```

## Stage-specific keyword directives

When you create shader variants, the Unity Editor’s default behavior is to generate every stage of the shader program in every variant. For example, if your shader program contains a vertex stage and a fragment stage, Unity generates a vertex stage and a fragment stage for every keyword combination.

If a keyword does not affect all stages, this default behavior results in redundant work. For example, if a keyword affects only the fragment stage, the Editor generates an identical vertex stage for each variant. Unity identifies and removes duplicates afterwards, so this redundant work does not affect build sizes or runtime performance; however, if you have a lot of stages and/or variants, the time wasted during shader compilation can be significant.

To avoid this problem, you can use stage-specific keyword directives. These are suffixes that you apply to regular keyword directives. They tell the Editor which shader stage a given keyword affects, so it can skip the redundant work when building shaders for supported graphics APIs.

### Supported graphics APIs

Unity does not fully support the use of stage-specific keyword directives with all graphics APIs.

- When compiling shaders for OpenGL and Vulkan, the Editor automatically reverts any stage-specific keyword directives to regular keyword directives.
- When compiling shaders for Metal, any keyword targeting vertex stages will also affect tessellation stages, and vice versa.

### Using stage-specific keyword directives

The available suffixes are `_vertex`, `_fragment`, `_hull`, `_domain`, `_geometry`, and `_raytracing`. You apply the suffix at the end of a keyword directive, for example: `multi_compile_fragment`, or `shader_feature_local_vertex`. To target multiple shader stages, you use multiple stage-specific keyword directives declaring the same keywords.

**Note:** you are responsible for ensuring that the keywords are only used in the specified shader stages.

## 内置 multi_compile 快捷方式

在内置管线中，有几个“快捷方式”可以用于常用变体组合。这些组合常用于处理不同的灯光、阴影和光照贴图类型。详情请参见[rendering paths and shaders](https://docs.unity3d.com/cn/2021.1/Manual/SL-RenderPipeline.html)。

- `multi_compile_fwdbase` 编译 [PassType.ForwardBase](https://docs.unity3d.com/cn/2021.1/ScriptReference/Rendering.PassType.ForwardBase.html) 所需的所有变体。这些变体处理不同的光照贴图类型以及启用或禁用的方向光主要阴影，它相当于这些变体的组合：
    - DIRECTIONAL
    - LIGHTMAP_ON
    - DIRLIGHTMAP_COMBINED
    - DYNAMICLIGHTMAP_ON
    - SHADOWS_SCREEN
    - SHADOWS_SHADOWMASK
    - LIGHTMAP_SHADOW_MIXING
    - LIGHTPROBE_SH
    - VERTEXLIGHT_ON
- `multi_compile_fwdadd` 编译 [PassType.ForwardAdd](https://docs.unity3d.com/cn/2021.1/ScriptReference/Rendering.PassType.ForwardAdd.html) 的变体。这将编译变体来处理方向光、聚光灯或点光源类型，以及它们带有剪影纹理的变体，它相当于这些变体的组合：
    - POINT
    - DIRECTIONAL
    - SPOT
    - POINT_COOKIE
    - DIRECTIONAL_COOKIE
- `multi_compile_fwdadd_fullshadows` - 与 `multi_compile_fwdadd` 相同，但还能够让光源具有实时阴影，它相当于==multi_compile_fwdadd==变体的组合加上：
    - SHADOWS_DEPTH
    - SHADOWS_SCREEN
    - SHADOWS_CUBE
    - SHADOWS_SOFT
    - SHADOWS_SHADOWMASK
    - LIGHTMAP_SHADOW_MIXING
- `multi_compile_fog` 扩展为多个变体以处理不同的雾效类型 (off/linear/exp/exp2)。

大多数内置快捷方式会产生许多着色器变体。如果知道项目不需要这些变体，可以使用 `#pragma skip_variants` 来跳过对其中一些变体的编译。例如：

```
# pragma multi_compile_fwdadd
# pragma skip_variants POINT POINT_COOKIE
```

该指令会跳过包含 `POINT` 或 `POINT_COOKIE` 的所有变体。

## 图形层和着色器变体

在运行时，Unity 会检查 GPU 的功能并确定其对应的[图形层](https://docs.unity3d.com/cn/2021.1/ScriptReference/Rendering.GraphicsTier.html)。在内置渲染管线中，可以为每个图形层自动创建一组着色器变体；为此，请使用 `#pragma hardware_tier_variants` 指令。

该功能仅与内置渲染管线兼容。它不兼容通用渲染管线 (URP)、高清渲染管线 (HDRP) 或自定义的可编程渲染管线。

To enable this feature, add `#pragma hardware_tier_variants renderer`, where `renderer` is a valid [graphics API](https://docs.unity3d.com/cn/2021.1/Manual/SL-ShaderCompilationAPIs.html), like this:

```
# pragma hardware_tier_variants gles3
```

除了其他所有关键字，Unity 还为每个着色器生成三个着色器变体。每个生成的变体都有以下定义命令之一，它们对应于 [GraphicsTier](https://docs.unity3d.com/cn/2021.1/ScriptReference/Rendering.GraphicsTier.html) 枚举的相同编号值：

```
UNITY_HARDWARE_TIER1
UNITY_HARDWARE_TIER2
UNITY_HARDWARE_TIER3
```

您可以使用它们为更低端或更高端硬件编写条件性回退或额外功能。

Unity 首次加载应用程序时，它会检测到 `GraphicsTier` 并将结果存储在 [Graphics.activeTier](https://docs.unity3d.com/cn/2021.1/ScriptReference/Graphics.activeTier.html) 中。要覆盖 `Graphics.activeTier` 的值，请直接设置该值。请注意，必须在 Unity 加载您要更改的任何着色器之前执行此操作。一个非常适合设置此值的位置是在加载主场景之前的预加载场景中。

为了帮助尽可能降低这些变体的影响，Unity 在播放器中只加载一组着色器。相同的着色器（例如，如果您只为 `TIER1` 编写了专用版本而其他所有版本都相同）将不占用磁盘上的任何额外空间。

要在 Unity Editor 中测试图形层，请导航至 **Edit > Graphics tier**，然后选择您希望 Unity Editor 使用的层。

请注意，图形层与[质量设置](https://docs.unity3d.com/cn/2021.1/Manual/class-QualitySettings.html)无关。它们是此设置的补充。

### 每平台着色器定义设置和图形层变体

在内置渲染管线中，可以使用 [EditorGraphicsSettings.SetShaderSettingsForPlatform](https://docs.unity3d.com/cn/2021.1/ScriptReference/EditorGraphicsSettings.SetTierSettings.html) API 针对给定的 [BuildTarget](https://docs.unity3d.com/cn/2021.1/ScriptReference/BuildTarget.html) 和 [GraphicsTier](https://docs.unity3d.com/cn/2021.1/ScriptReference/Rendering.GraphicsTier.html) 来覆盖 Unity 的内部 #define。

该功能仅与内置渲染管线兼容。它不兼容通用渲染管线 (URP)、高清渲染管线 (HDRP) 或自定义的可编程渲染管线。

请注意，如果您为给定的 `BuildTarget` 的不同 `GraphicsTier` 提供不同的 `TierSettings` 值，即使您未向着色器代码添加 `#pragma hardware_tier_variants`，Unity 也会为着色器生成层变体。

# 变量
# 内置着色器变量

Unity 的内置文件包含着色器的全局变量：当前对象的变换矩阵、光源参数、当前时间等等。就像任何其他变量一样，可在[着色器程序](https://docs.unity3d.com/cn/2021.1/Manual/SL-ShaderPrograms.html)中使用这些变量，但如果已经包含相关的 include 文件，则不必声明这些变量。

有关 include 文件更多信息，请参阅[内置 include 文件](https://docs.unity3d.com/cn/2021.1/Manual/SL-BuiltinIncludes.html)。

## 变换

所有这些矩阵都是 `float4x4` 类型，并且是列主序的。

| 名称                  | 值                 |
|---------------------|-------------------|
| UNITY_MATRIX_MVP    | 当前模型 * 视图 * 投影矩阵。 |
| UNITY_MATRIX_MV     | 当前模型 * 视图矩阵。      |
| UNITY_MATRIX_V      | 当前视图矩阵。           |
|UNITY_MATRIX_P| 当前投影矩阵。           |
| UNITY_MATRIX_VP     | 当前视图 * 投影矩阵。      |
| UNITY_MATRIX_T_MV   | 模型转置 * 视图矩阵。      |
| UNITY_MATRIX_IT_MV  | 模型逆转置 * 视图矩阵。     |
| unity_ObjectToWorld | 当前模型矩阵。           |
| unity_WorldToObject | 当前世界矩阵的逆矩阵。       |


## 摄像机和屏幕

这些变量将对应于正在渲染的[摄像机](https://docs.unity3d.com/cn/2021.1/Manual/class-Camera.html)。例如，在阴影贴图渲染中，它们仍将引用摄像机组件值，而不是用于阴影贴图投影的“虚拟摄像机”。

| 名称                       | 类型     | 值                              |
| ------------------------------ | -------- | ------------------------------------------------------------ |
|` _WorldSpaceCameraPos`           | float3   | 摄像机的世界空间位置。                                       |
| `_ProjectionParams`              | float4   | `x` 是 1.0（如果当前使用[翻转投影矩阵](https://docs.unity3d.com/cn/2021.1/Manual/SL-PlatformDifferences.html)进行渲染，则为 –1.0），`y` 是摄像机的近平面，`z` 是摄像机的远平面，`w` 是远平面的倒数。 |
| `_ScreenParams`                  | float4   | `x` 是摄像机目标纹理的宽度（以像素为单位），`y` 是摄像机目标纹理的高度（以像素为单位），`z` 是 1.0 + 1.0/宽度，`w` 为 1.0 + 1.0/高度。 |
| `_ZBufferParams`                 | float4   | 用于线性化 Z 缓冲区值。`x` 是 (1-远/近)，`y` 是 (远/近)，`z` 是 (x/远)，`w` 是 (y/远)。 |
| unity_OrthoParams              | float4   | `x` 是正交摄像机的宽度，`y` 是正交摄像机的高度，`z` 未使用，`w` 在摄像机为正交模式时是 1.0，而在摄像机为透视模式时是 0.0。 |
| unity_CameraProjection         | float4x4 | 摄像机的投影矩阵。                                           |
| unity_CameraInvProjection      | float4x4 | 摄像机投影矩阵的逆矩阵。                                     |
| unity_CameraWorldClipPlanes[6] | float4   | 摄像机视锥体平面世界空间方程，按以下顺序：左、右、底、顶、近、远。 |

## 时间

时间以秒为单位，并由项目 [Time 设置](https://docs.unity3d.com/cn/2021.1/Manual/class-TimeManager.html)中的时间乘数 (Time multiplier) 进行缩放。没有内置变量可用于访问未缩放的时间。


|**名称**|**类型**|**值**|
|:--|:--|:--|
|`_Time`|float4|自关卡加载以来的时间 (t/20, t, t_2, t_3)，用于将着色器中的内容动画化。|
|`_SinTime`|float4|时间正弦：(t/8, t/4, t/2, t)。|
|`_CosTime`|float4|时间余弦：(t/8, t/4, t/2, t)。|
|unity_DeltaTime|float4|增量时间：(dt, 1/dt, smoothDt, 1/smoothDt)。|

## 光照

光源参数以不同的方式传递给着色器，具体取决于使用哪个[渲染路径](https://docs.unity3d.com/cn/2021.1/Manual/RenderingPaths.html)， 以及着色器中使用哪种光源模式[通道标签](https://docs.unity3d.com/cn/2021.1/Manual/SL-PassTags.html)。

[前向渲染](https://docs.unity3d.com/cn/2021.1/Manual/RenderTech-ForwardRendering.html)（`ForwardBase` 和 `ForwardAdd` 通道类型）：


|**名称**|**类型**|**值**|
|:--|:--|:--|
|`_LightColor0`（在 UnityLightingCommon.cginc 中声明）|fixed4|光源颜色。|
|`_WorldSpaceLightPos0`|float4|方向光：（世界空间方向，0）。其他光源：（世界空间位置，1）。|
|unity_WorldToLight（在 AutoLight.cginc 中声明）|float4x4|世界/光源矩阵。用于对剪影和衰减纹理进行采样。|
|unity_4LightPosX0、unity_4LightPosY0、unity_4LightPosZ0|float4|（仅限 ForwardBase 通道）前四个非重要点光源的世界空间位置。|
|unity_4LightAtten0| float4      | （仅限 ForwardBase 通道）前四个非重要点光源的衰减因子。    |
|unity_LightColor|half4[4]| （仅限 ForwardBase 通道）前四个非重要点光源的颜色。        |
|unity_WorldToShadow| float4x4[4] | 世界/阴影矩阵。聚光灯的一个矩阵，方向光级联最多有四个矩阵。  |



延迟着色和延迟光照，在光照通道着色器中使用（全部在 UnityDeferredLibrary.cginc 中声明）：

|**名称**|**类型**|**值**|
|:--|:--|:--|
|`_LightColor`|float4|光源颜色。|
|unity_WorldToLight|float4x4|世界/光源矩阵。用于对剪影和衰减纹理进行采样。|
|unity_WorldToShadow|float4x4[4]|世界/阴影矩阵。聚光灯的一个矩阵，方向光级联最多有四个矩阵。|

为 `ForwardBase`、`PrePassFinal` 和 `Deferred` 通道类型设置了球谐函数系数 （由环境光和光照探针使用）。这些系数包含由世界空间法线求值的三阶 SH 函数（请参阅 [UnityCG.cginc](https://docs.unity3d.com/cn/2021.1/Manual/SL-BuiltinIncludes.html) 中的 `ShadeSH9`）。 这些变量都是 half4 类型、`unity_SHAr` 和类似名称。

[顶点光照渲染](https://docs.unity3d.com/cn/2021.1/Manual/RenderTech-VertexLit.html)（`Vertex` 通道类型）：

最多可为 `Vertex` 通道类型设置 8 个光源；始终从最亮的光源开始排序。因此，如果您希望 一次渲染受两个光源影响的对象，可直接采用数组中前两个条目。如果影响对象 的光源数量少于 8，则其余光源的颜色将设置为黑色。


|**名称**|**类型**|**值**|
|:--|:--|:--|
|unity_LightColor|half4[8]|光源颜色。|
|unity_LightPosition|float4[8]|视图空间光源位置。方向光为 (-direction,0)；点光源/聚光灯为 (position,1)。|
|unity_LightAtten|half4[8]|光源衰减因子。_x_ 是 cos(spotAngle/2) 或 –1（非聚光灯）；_y_ 是1/cos(spotAngle/4) 或 1（非聚光灯）；_z_ 是二次衰减；_w_ 是平方光源范围。|
|unity_SpotDirection|float4[8]|视图空间聚光灯位置；非聚光灯为 (0,0,1,0)。|

## 光照贴图

|**名称**|**类型**|**值**|
|:--|:--|:--|
|unity_Lightmap|Texture2D|包含光照贴图信息。|
|unity_LightmapST|float4[8]|缩放 UV 信息并转换到正确的范围以对光照贴图纹理进行采样。|

## 雾效和环境光

|**名称**|**类型**|**值**|
|:--|:--|:--|
|unity_AmbientSky|fixed4|梯度环境光照情况下的天空环境光照颜色。|
|unity_AmbientEquator|fixed4|梯度环境光照情况下的赤道环境光照颜色。|
|unity_AmbientGround|fixed4|梯度环境光照情况下的地面环境光照颜色。|
|UNITY_LIGHTMODEL_AMBIENT|fixed4|环境光照颜色（梯度环境情况下的天空颜色）。旧版变量。|
|unity_FogColor|fixed4|雾效颜色。|
|unity_FogParams|float4|用于雾效计算的参数：(density / sqrt(ln(2))、density / ln(2)、–1/(end-start) 和 end/(end-start))。_x_ 对于 Exp2 雾模式很有用；_y_ 对于 Exp 模式很有用，_z_ 和 _w_ 对于 Linear 模式很有用。|

## 其他


|**名称**|**类型**|**值**|
|:--|:--|:--|
|unity_LODFade|float4|使用 [LODGroup](https://docs.unity3d.com/cn/2021.1/Manual/class-LODGroup.html) 时的细节级别淡入淡出。_x_ 为淡入淡出（0 到 1），_y_ 为量化为 16 级的淡入淡出，_z_ 和 _w_ 未使用。|
|`_TextureSampleAdd`|float4|根据所使用的纹理是 Alpha8 格式（值设置为 (1,1,1,0)）还是不是该格式（值设置为 (0,0,0,0)）由 Unity **仅针对 UI** 自动设置。|

Alt+J