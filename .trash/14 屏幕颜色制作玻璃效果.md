我们得到了世界空间的法线，计算过程中也得到了切线空间的法线。这 2 个法线去分别偏移屏幕 uv 有什么区别呢？本人通过 shader_feather 去做了 2 个 shader 变体来观察 2 种不同的偏移方式带来的不同的效果。

![[e93afaaae26c1ebf8538b3258080cc1d_MD5.webp]]

shader 变体切换不同的效果

![[e9ac434d37ae8dd96785da44a9a7269c_MD5.webp]]

如果是世界空间切线，则构建 TBN 矩阵转换；否则直接拿去计算

计算完成后，我们把颜色输出：如果使用的是世界空间法线，则扭曲的效果除了扭曲之外，还会朝着一个方向进行偏移；而切线空间下只会扭曲，并不会偏移。如果提高强度，世界空间法线下的效果会偏移到不知道什么地方的图像，而切线空间下还是只会加剧扭曲程度，原来的颜色还是停留在原地。

![[af4481f6f6caea13e070a351c9b4121e_MD5.webp]]

强度设为 1000，世界坐标下，已经把图像偏移到不知是什么区域的图像了

![[3a55c837afaf9378f71389d8bdd352c2_MD5.webp]]

强度为 1000 下，切线空间里，虽然扭曲剧烈，但是图像还是原来区域的图像

两者的差距会如此巨大，原因是世界空间的法线它是取决于整个世界坐标系；而切线空间下的法线是取决与模型本身，与世界无关。如果我们旋转模型，观察某一个面的法线朝向，世界空间法线会随着旋转而变化；而该面的切线空间的法线始终不会改变。正是因为参考系的不同，才导致了 2 种截然不同的效果，感兴趣的读者可以自己把 2 种坐标系下的法线的 x 分量，y 分量分别返回到片元着色器输出，旋转模型看看效果。

说了这么多，该附上最后的代码了，如果代码复制过去报错，那是空格复制的错误，把每行代码里最前面的空格替换成 ide 里的空格即可。
```c
Shader "WX/URP/grass"

{

    Properties

    {

        _NormalTex("Normal",2D)="bump"{}

        _NormalScale("NormalScale",Range(0,1))=1

        _BaseColor("BaseColor",Color)=(1,1,1,1)

        _Amount("amount",float)=100

        [KeywordEnum(WS_N,TS_N)]_NORMAL_STAGE("NormalStage",float)=1

    }

    SubShader

    {

        Tags{

        "RenderPipeline"="UniversalRenderPipeline"

        "RenderType"="Transparent"

        "Queue"="Transparent"

        }

        HLSLINCLUDE

        #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

        #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/lighting.hlsl"

        CBUFFER_START(UnityPerMaterial)

        float4 _NormalTex_ST;

        half4 _BaseColor;

        float _NormalScale;

        float _Amount;

        CBUFFER_END

        float4 _CameraColorTexture_TexelSize;// 该向量是非本 shader 独有，不能放在常量缓冲区

        TEXTURE2D(_NormalTex);

        SAMPLER(sampler_NormalTex);

        SAMPLER(_CameraColorTexture);

         struct a2v

         {

             float4 positionOS:POSITION;

             float4 normalOS:NORMAL;

             float2 texcoord:TEXCOORD;

             float4 tangentOS:TANGENT;

         };

         struct v2f

         {

             float4 positionCS:SV_POSITION;

             float2 texcoord:TEXCOORD;

             float4 normalWS:NORMAL;

             float4 tangentWS:TANGENT;

             float4 BtangentWS:TEXCOORD1;  

         };

        ENDHLSL

        pass

        {

        Tags{

        "LightMode"="UniversalForward"

        }

            HLSLPROGRAM

            #pragma vertex VERT

            #pragma fragment FRAG

            #pragma  shader_feature_local _NORMAL_STAGE_WS_N 

            v2f VERT(a2v i)

            {

                v2f o;

                o.positionCS=TransformObjectToHClip(i.positionOS.xyz);

                o.texcoord=TRANSFORM_TEX(i.texcoord,_NormalTex);

                o.normalWS.xyz=normalize(TransformObjectToWorldNormal(i.normalOS.xyz));

                o.tangentWS.xyz=normalize(TransformObjectToWorldDir(i.tangentOS.xyz));

                o.BtangentWS.xyz=cross(o.normalWS.xyz,o.tangentWS.xyz)*i.tangentOS.w*unity_WorldTransformParams.w;

                float3 positionWS=TransformObjectToWorld(i.positionOS.xyz);

                o.tangentWS.w=positionWS.x;

                o.BtangentWS.w=positionWS.y;

                o.normalWS.w=positionWS.z;

                return o;

            }

            half4 FRAG(v2f i):SV_TARGET

            {

                half4 normalTex=SAMPLE_TEXTURE2D(_NormalTex,sampler_NormalTex,i.texcoord)*_BaseColor;// 获取法线贴图

                float3 normalTS=UnpackNormalScale(normalTex,_NormalScale);// 得到我们想要对比的切线空间法线

                float2 SS_texcoord=i.positionCS.xy/_ScreenParams.xy;// 获取屏幕 UV

                #ifdef _NORMAL_STAGE_WS_N// 计算偏移的 2 张方式

                float3x3 matrix_T2W={i.tangentWS.xyz,i.BtangentWS.xyz,i.normalWS.xyz};// 构建 tbn 矩阵

                float3 WSnor=mul(normalTS,matrix_T2W);// 得到我们想要的世界空间法线

                //return real4(WSnor,1);// 测试世界空间法线

                float2 SS_bias=WSnor.xy*_Amount*_CameraColorTexture_TexelSize;// 如果取的世界空间的法线则执行它计算偏移，但是世界空间的法线由世界空间确定，会随着模型的旋转而变化；

                #else

                float2 SS_bias=normalTS.xy*_Amount*_CameraColorTexture_TexelSize;// 如果取的是切线空间的法线则执行它计算偏移，但是切线空间的法线不随着模型的旋转而变换；

                #endif

                float4 glassColor=tex2D(_CameraColorTexture,SS_texcoord+SS_bias);// 把最终的颜色输出到屏幕即可

                return real4(glassColor.xyz,1);

            }

            ENDHLSL

        }

    }

}```