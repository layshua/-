---
banner: "![[Pasted image 20230102193700.jpg]]"
banner_y: 0.70332
---
# A 常用遮罩
[自学ue4材质，一大堆材质节点该如何学？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/382810691/answer/1543325159)

## 1 UV坐标系转换成笛卡尔直角坐标系
![[Pasted image 20221215123919.png]]
![[Pasted image 20221215123942.png]]
## 2 圆形遮罩
**方法一：**
![[Pasted image 20221215130852.png]]
不能用power节点代替multiply，因为power节点不支持负数运算，小于0的数都会被clamp到0。

**方法二：**
![[Pasted image 20221215131923.png]]
UE材质中的Sine函数，取值范围是-1~1，周期为1（不是2pai）。
![[Pasted image 20221215131719.png|]]

**方形遮罩**使用这两个节点相乘即可：
![[Pasted image 20221215142944.png]]

**方法三：SphereMask**
![[Pasted image 20221215132224.png]]

**RadialGradientExponential（指数径向渐变）**函数
![[Pasted image 20230118202614.jpg]]![[Pasted image 20230118202557.jpg]]
**UV（矢量 2）（UVs (Vector 2)）**
用于控制渐变所在的位置及其涵盖 0-1 空间的程度。

**中心点（矢量 2）（CenterPosition (Vector2)）**
基于 0-1 的渐变中心位置偏移。

**半径（标量）（Radius (Scalar)）**
源自中心的径向渐变的大小。默认值 0.5 使渐变边缘位于纹理空间边缘附近。

**密度（标量）（Density (Scalar)）**
调整此函数所产生的渐变的硬度。这个数值越大，意味着渐变越清晰。

**反转密度（布尔值）（Invert Density (Boolean)）**
对于渐变，将白色反转为黑色，并将黑色反转为白色。

**DiamondGradient（钻石型渐变）**
![[Pasted image 20230118202708.jpg]]![[Pasted image 20230118202702.jpg]]
**衰减（标量）（Falloff (Scalar)）**
通过控制渐变从白色变为黑色的速度，提高渐变对比度。
## 3 线性遮罩
![[Pasted image 20221215133043.png]]
![[Pasted image 20221215133053.png]]
![[Pasted image 20221215145815.png]]

**LinearGradient（线性渐变）函数**和上图Mask获取RG的实现方法一样
![[Pasted image 20230118202810.jpg]]
U：![[Pasted image 20230118203005.jpg]]V:![[Pasted image 20230118203008.jpg]]

**GeneratedBand（生成的色带）** 
根据默认的纹理坐标生成水平或垂直的色带。
![[Pasted image 20230118205841.jpg]]

**GeneratedOffsetBands（生成的偏移色带）**
此函数可以生成多个色带，而不是仅生成一个色带。
![[Pasted image 20230118205924.jpg]]

## 4 角度遮罩
![[Pasted image 20221215144500.png]]

**VectorToRadialValue（矢量到径向值）** 
将"vector 2"矢量转换为角度，或者将 UV 坐标数据转换为径向坐标。对于矢量，角度将在一个通道中输出，而矢量长度在另一通道中输出。
![[Pasted image 20230118203902.jpg]]
输入

**矢量或 UV（矢量 2）（Vector or UVs (Vector2)）**
接收一个"矢量 2"或一组 UV 坐标。

**混合坐标输出（静态布尔值）（Swizzle Coordinate Output (StaticBool)）**
对调输出的 U 和 V 分量。

输出

**径向坐标（Radial Coordinates）**
返回输入的径向坐标。对于矢量，角度将在一个通道中输出，而距离在另一通道中输出。

**矢量转换为角度（Vector Converted to Angle）**
返回输入矢量的角度，对于 UV，返回径向梯度。

**线性距离（Linear Distance）**
返回输入矢量的线性长度，对于 UV，输出距离的径向梯度。
# B 常用节点
## 1 图像调整
**Desaturation（去饱和度）**
**CheapContrast（低成本对比度）**
CheapContrast_RGB（低成本对比度_RGB）
SCurve（S 曲线，也是修改对比度）
HueShift（色调改变）

**模糊Blur**
![[Pasted image 20221214235032.png]]
ue模糊节点的工作原理：复制图像，偏移，更改透明度
## 2 拆分分量
![[Pasted image 20230118204705.png|200]]
## 3 法线贴图
### 法线混合
BlendAngleCorrectedNormals
修正重叠在其他法线贴图上的法线方向。(通常这将是一个细节映射。)
![[Pasted image 20221214125918.png|]]
### 法线强度
修改法线强度必须乘vector3，且确保z值为1，不影响蓝通道
![[Pasted image 20221214130101.png]]
### 根据高度图建立法线贴图
**NormalFromHeightmap（根据高度贴图建立法线贴图）**
此函数提供一种快捷的方法来根据现有的黑白高度贴图建立法线贴图，而不必将另一个纹理装入到内存中。
![[Pasted image 20230118210142.jpg]]

**NormalFromHeightmapChaos（根据高度贴图建立混乱法线贴图）**
![[Pasted image 20230118210823.jpg]]
## 5 旋转图片
**Custom Rotator**
![[Pasted image 20230118211937.png]]

旋转90度
![[Pasted image 20221215134217.png]]
BreakOutFloat2Components效果和分两个mask一样

**按时间顺、逆时针旋转**
![[Pasted image 20221215135929.png]]

## 4 序列动画
### FlipBook

![[Pasted image 20221213232453.png]]
**动画相位 (0-1)（标量）（Animation Phase (0-1) (Scalar)）**
如果此输入接收到静态输入，那么结果将是图像序列中最接近的帧，就像这些帧的编号介于 0 与 1 之间一样。如果未提供输入，那么将自动使用时间。

**行数（标量）（Number of Rows (Scalar)）**
接收图像序列纹理的行数。

**列数（标量）（Number of Columns (Scalar)）**
接收图像序列纹理的列数。

**纹理（2D 纹理）（Texture (Texture2D)）**
接收一个"2D 纹理"，其中包含精灵表，即动画纹理的帧网格。

**UV（矢量 2）（UVs (Vector2)）**
接收一组 UV 坐标，以帮助进行平铺。

### SubUV_Function
SubUV_Function（子 Uv函数）适合于处理精灵表或纹理上具有多帧的动画。此函数接收一个纹理对象，并可根据输出来显示该纹理上各个帧的混合帧动画。
![[Pasted image 20230118212228.jpg]]

## 5 双面/多面纹理
**TwoSidedTexturing（双面纹理处理）**
为双面材质的两个面分别提供材质输入。如果材质的 _双面（Two Sided）_属性未激活，那么此函数不执行任何操作。
![[Pasted image 20230118212427.jpg]]
**使用表面法线（静态布尔值）（Use Surface Normals (StaticBool)）**
向着色器指出是否应使用传入的法线贴图来帮助计算网格的正面和反面。

**TwoSidedSign（双面符号）表达式**
适合在双面定制照明材质的背面翻转法线，以便与冯氏（Phong）明暗处理算法匹配。+1 表示双面材质的正面，-1 表示背面。
![[Pasted image 20230118214406.jpg]]



**WorldCoordinate3Way（全局坐标三向）**
按全局坐标将纹理投射到对象表面。用户可控制多个纹理在边缘处进行混合的方式，并可添加法线贴图以便在计算前扰乱表面。
![[Pasted image 20230118212518.jpg]]
**XY 纹理（纹理对象）（XY Texture (Texture Object)）**
要投射到 XY 平面的纹理。

**YZ 纹理（纹理对象）（YZ Texture (Texture Object)）**
要投射到 YZ 平面的纹理。

**XZ 纹理（纹理对象）（XZ Texture (Texture Object)）**
要投射到 XZ 平面的纹理。

**XY 比例（标量）（XY Scale (Scalar)）**
针对要投射到 XY 平面的纹理应用的比例调整。

**YZ 比例（标量）（YZ Scale (Scalar)）**
针对要投射到 YZ 平面的纹理应用的比例调整。

**XZ 比例（标量）（XZ Scale (Scalar)）**
针对要投射到 XZ 平面的纹理应用的比例调整。

**混合指数 Y Z（标量）（Blend Exponent Y Z (Scalar)）**
控制沿 Y 和 Z 投射的纹理之间的过渡比率。

**混合乘 Y Z（标量）（Blend Mult Y Z (Scalar)）**
使面之间的混合倍增。

**混合指数 X（标量）（Blend Exponent X (Scalar)）**
控制沿 X 投射的纹理之间的过渡比率。

**混合乘 X（标量）（Blend Mult X (Scalar)）**
使面之间的混合倍增。

**单个纹理（静态布尔值）（Single Texture (StaticBool)）**
设置为 _true_ 时，将仅使用应用于 _XY 纹理（XY Texture）_输入的纹理，并将其投射到全部三个面。

**法线（矢量 3）（Normal (Vector3)）**
接收一个法线贴图用于混合计算（使用此贴图来确定表面所面对的方向）。

**全局位置（矢量 3）（WorldPosition (Vector3)）**
这个可选的输出用于使投射中心的位置产生偏移。

**输出**
**XYZ 输出（XYZ Output）**
输出全部三个纹理，这些纹理从相应平面投射并在边缘处混合。

**XY**
仅输出沿 XY 平面投射的纹理。

**XZ**
仅输出沿 XZ 平面投射的纹理。

**YZ**
仅输出沿 YZ 平面投射的纹理。

## 6 明暗处理
 ### FuzzyShading
此函数模仿类似于天鹅绒或苔藓的表面，并与菲涅耳计算类似。另外，此函数也适合于着色器效果，例如扫描电子显微镜。
![[Pasted image 20230119223401.png]]
**漫射（矢量 3）（Diffuse (Vector3)）**
接收要用作漫射颜色的纹理。

**法线（矢量 3）（Normal (Vector3)）**
接收一个法线贴图，用于扰乱模糊结果的表面。

**核心暗度（标量）（CoreDarkness (Scalar)）**
此值用于使对象在其法线与摄像机平行（通常朝向中心）的位置变暗。这个数值越大，意味着核心位置越暗。默认值为 0.8。

**幂（标量）（Power (Scalar)）**
控制从核心到边缘的衰减率。默认值为 6.0。

**边缘亮度（标量）（EdgeBrightness (Scalar)）**
控制表面的法线变为与摄像机垂直（通常朝向边缘）时表面的亮度。

### FuzzyShadingGrass
此函数用于提供草地明暗处理的漫射部分。与 FuzzyShading（模糊明暗处理）相似，此函数允许您在边缘处混入一种新颜色，方法如下：首先按给定的百分比去饱和度，然后对去饱和度后的区域应用定制颜色。
# C 表达式
[材质表达式参考 | 虚幻引擎文档 (unrealengine.com)](https://docs.unrealengine.com/4.27/zh-CN/RenderingAndGraphics/Materials/ExpressionReference/)
## 1 数学
`add`：
float + float2有效：如1+（1，1） = （2，2）
float2+ float3无效

`Pi`：π
`one minus`：1-x
`SquareRoot`即`sqrt`：平方根，如果应用于向量，则每个分量将分别处理。
`Panner`：平移
`Rotator`：旋转
`Mask`：ComponentMask

`Ceil`：向上取整
`Floor`：向下取整
`Round`：舍入为最接近的整数

`Frac`：取小数
`Truncate`：丢弃小数部分，保留整数。
`Fmod`：除法运算浮点余数

`normalize`：归一化向量（也称"单位向量"）的整体长度为1.0，输入的每个分量都除以向量的总大小（长度）。
`saturate`：作用跟Clamp限制差不多，但是无法自定义范围，只能输出0-1的线性范围，小于0的值被提升到0；大于1的值降低为1；0到1之间（包括0和1在内）的值保持不变。因为是硬件支持，所以它基本无消耗。

`lerp`：搜索LinearInterpolate（线性插值）,快捷键L

`Sign`：指示数字输入是负数、正数还是恰好为0。
-   如果输入为负数，该节点输出-1。
-   如果输入恰好为0，该节点输出0。
-   如果输入为正数，该节点输出1。

`Step`：注意连接顺序，如果x>=y，则返回1（和ASE中是反的）
![[Pasted image 20230118235310.jpg]]
`SmoothStep`：SmoothStep允许你在0和1之间进行插值，并且可以设置最小和最大阈值。
如果你想让边缘有一定的光滑度，该表达式对于过渡来说十分有用。
![[Pasted image 20230118235853.jpg]]
最小和最大值被设置为0.6和0.8。低于0.6的部分是黑色的，高于0.8的部分是白色的，**中间则是平滑的梯度（Step中则是硬过渡）**。
SmoothStep接收三个参数：
-   **最小（Min）** 定义了插值的下边界。对于小于等于最小值的值，SmoothStep返回0（黑色）。
-   **最大（Max）** 定义了插值的上边界。对于大于等于最大值的值，SmoothStep返回1（白色）。
-   **值（Value）** 定义了插值的源，例如梯度图或灰度纹理贴图。

`ConstantBiasScale`：**常量偏差比例**，可以设置bias和Scale值，相当于先加bias后乘Scale
![[Pasted image 20221213231726.png|300]]

`DDX/DDY`：求导，像素着色器中的GPU硬件功能

`Distance`：计算两个点/颜色/位置/矢量之间的欧氏距离，并输出结果值。此表达式可作用于单分量、双分量、三分量和四分量矢量，但此表达式的两个输入必须具有相同数目的通道。

## 2 常量
### ViewProperty
**ViewProperty（视图属性）** 表达式输出依赖于视图的常量属性，例如视野或渲染目标大小。要访问的视图属性可配置，并且，输出类型取决于所配置的待访问属性。
![[Pasted image 20230120204533.png]]
![[Pasted image 20230120204544.jpg]]

### 环境光遮蔽AO蒙版
**PrecomputedAOMask（预先计算的 AO 蒙版）**
用来访问材质中光照系统计算的环境光遮蔽 (AO)， 这可能很适合于过程式纹理贴图，或者在老化效果及尘埃随时间推移而缓慢积累的区域加入老化效果及尘埃。

**支持对Lightmass烘焙出的AO信息进行取样，然后使用该信息来进行混合**，例如污渍。**AO经过烘焙成为光照和阴影的一部分以供“材质编辑器”读取，在材质编辑器中使用此信息来确认边缘位置（即柱面和墙面相交的位置）**，随后可在其中添加污渍。

必须使用静态光照，可以在取到烘培后场景得出的角落和边缘，以此添加污渍等
![[Pasted image 20221215000042.png]]
预计算环境光遮蔽蒙版
PrecomputedAOMask
![[Pasted image 20221215095015.png]]

## 3 坐标/向量
### 世界空间位置
**`ActorPositionWS`**  **Actor**世界空间位置

**`ObjectPositionWS`** 对象**bounds**的世界场景空间中心位置

**`Absolute World Position`** 当前**像素**在世界空间中的**位置**，常见用法是确定从摄像机到像素的径向距离，而不是像 PixelDepth（像素深度）那样确定正交距离。

>[!example] 区别
>**我们创建一个蓝图，添加四个球体静态Mesh组件，赋予相同材质，四个球体组成一个Actor。
>![[Pasted image 20230119143549.png]]
>
>**ActorPositionWS**，输出为Actor的世界空间位置，所以颜色都一样
>
![[Pasted image 20230119143405.png|300]]
>
每一个Mesh都是一个对象，都有各自的bound，**ObjectPositionWS**返回对象bounds的世界场景空间中心位置，所以四个球颜色不同，我们可以在运行时在命令行输入Show Bounds查看bound
>
![[Pasted image 20230119143452.png|300]]
>
**AbsoluteWorldPosition** 当前**像素**在世界空间中的**位置**，和Actor与bound无关，每个像素颜色分别计算
>
![[Pasted image 20230119143531.png|300]]

**`ParticlePositionWS`** 每个单独粒子的世界场景空间位置

**`CameraPositonWS`** 摄像机世界空间位置
**`CameraVectorWS`** 像素到摄像机的方向

### 顶点
**`VertexNormalWS`** 世界场景空间顶点法线，它只能用于在顶点着色器中执行的材质输入，例如WorldPositionOffset。该表达式对于设置网格体增大或缩小很有用。请注意，沿法线偏移位置会导致几何图形沿UV缝隙拆分。
在下面的示例中，由于每个顶点在各自的法线方向上移动，预览球体似乎会随着正弦运动按比例放大和缩小。
![[Pasted image 20221214113626.png]]
用于计算fresnel：
![[Pasted image 20221214115737.png|200]]

**`VertexTangentWS`** 表达式会输出世界空间的顶点切线。和VertexNormalWS一样，它可用于操控网格体的顶点位置，结合 **世界位置偏移** 输入，你可以制作出十分微妙的环境动画。

`Vertex Color`
**笔刷工具刷顶点色**
![[Pasted image 20221214131231.png]]
![[Pasted image 20221214131255.png|300]]
![[Pasted image 20221214131210.png|300]]

通过笔刷黑白颜色控制lerp
![[Pasted image 20221214131621.png|300]]
![[Pasted image 20221214131649.png|300]]

### 像素
**`PixelNormalWS`** 根据当前法线输出矢量数据，表示**每个像素的法线方向**
![[Pasted image 20221214115142.png]]

**`ScreenPosition`** 像素的屏幕空间位置，一个用于采样纹理贴图，一个返回位置
![[Pasted image 20230118222824.png]]

**`SceneColor`** 表达式输出现有的场景颜色。
![[Pasted image 20230119150138.png]]
**OffsetFraction**
接收用于在屏幕空间中使场景颜色发生偏移的2D矢量。将此项目设置为0,1或1,0可提供略微明亮的场景颜色版本。将此项目设置为1,1可提供更加明亮的结果。
### 空间变换
`transform`：切换
将三通道向量值从一种参考坐标系转换到另一种参考坐标系。
![[Pasted image 20221215151220.png]]
**默认情况下，材质的所有着色器计算都在切线空间中完成**。向量常量、摄像机向量和光线向量等在材质中使用之前，都会转换到切线空间。Transform表达式允许将这些向量从切线空间转换到全局空间、局部空间或视图空间坐标系。另外，它允许将全局空间和局部空间向量转换到任何其他参考坐标系。


> [!danger] Warning
> **由于插值器受限制，VertexColor（顶点颜色）与 Transform节点互斥。**如果您同时使用 Transform节点和 VertexColor（顶点颜色），那么 VertexColor（顶点颜色）的结果为全白色。
> 
>**目前，Transform节点无法正确处理不一致的比例缩放。**


### 光
**`ReflectionVectorWS`** 本质上类似于`CameraVectorWS`，但它输出一个三通道向量值，该值**表示通过表面法线反射的摄像机方向**。
**使用示例：** mReflectionVector通常用于环境贴图CubeMap，其中反射向量的x/y分量被用作UV输入立方体贴图纹理。
![[Pasted image 20230119163016.jpg]]

**`LightVector`**
LightVector材质表达式与 **延迟贴花（Deferred Decal）** 材质和贴花Actor一起使用时会输出向量（RGB）数据，**这些数据表示当前像素在贴花的坐标空间中相对于贴花投影框的位置，并以归一化单位表示（0到1的区间内）。**

如果与 **LightFunction** 材质一起使用，LightVector材质表达式会输出向量（RGB）数据，表示**光源的坐标空间中从光源到像素的向量**。

> [!Danger] Warning
> LightVector材质表达式应该仅用于 **延迟贴花（Deferred Decal）** 或 **LightFunction** 材质域。

## 4 深度
### DepthFade
**`DepthFade`（深度消退）** 用来隐藏半透明对象与不透明对象相交时出现的不美观接缝。
![[Pasted image 20230118225045.png]]
![[Pasted image 20230118225019.jpg]]
**消退距离（Fade Distance）**
这是应该发生消退的全局空间距离。未连接 FadeDistance（FadeDistance）输入时，将使用此距离。

### PixelDepth
**`PixelDepth`（像素深度）** 输出当前所渲染像素的深度，即该**像素与摄像机之间的距离**。只支持正数，不支持负数
### SceneDepth
**`SceneDepth`（场景深度）** 表达式输出现有的场景深度。这类似于 PixelDepth（像素深度），但是 PixelDepth（像素深度）只能在当前屏幕所绘制像素处进行深度取样，而 SceneDepth（场景深度）可以在 **任何位置** 进行深度取样。
只能在半透明（Translucent）和后期处理（Post Process）材质上使用。

>[!Example] 区别
>我们首先设定一个情景，plane的半透明材质输出深度值，将不透明度设置为1便于观察
>
plane后面有红色透明球体和两个白色不透明物体
![[Pasted image 20230119142834.png|300]]
当plane输出**PixelDepth**时，距离越远深度越大，颜色越白，只绘制当前屏幕上的像素深度，所以后方物体不会对其产生影响。
![[ashkk221.gif|300]]
当plane输出**SceneDepth**时，不透明物体写入了深度，但是没有看到透明球，这是因为半透明物体不会写入深度。
![[Pasted image 20230119142925.png|300]]

## 5 地形材质（鸽）
[虚幻引擎地形材质表达式 | 虚幻引擎5.1文档 (unrealengine.com)](https://docs.unrealengine.com/5.1/zh-CN/landscape-material-expressions-in-unreal-engine/)

简单实用
![[Pasted image 20230903160559.png|500]]
节点设置（命名等）
![[Pasted image 20230903160520.png]]

在地形-绘制面板创建层信息，选择对应层绘制即可
![[Pasted image 20230903160845.png]]
## 6 材质属性
**主要用于分层材质**

开启材质属性
![[Pasted image 20230119144255.jpg|300]]![[Pasted image 20230119144518.png|200]]
### Make Material Attributes
**建立材质属性（Make Material Attributes）** 
用于定义[主材质节点](https://docs.unrealengine.com/5.0/zh-CN/using-the-main-material-node-in-unreal-engine)上的标准材质属性，将其集合，然后在一个输出进行传送。这对于创建[分层材质](https://docs.unrealengine.com/5.0/zh-CN/creating-layered-materials-in-unreal-engine)非常有用，因为它允许你在材质函数中定义一整个材质并在父级材质中使用该数据。你还可以将其用于复杂的材质设置，定义多个材质类型并将其混合，全部在一个材质资产中进行。
![[Pasted image 20230119144543.jpg]]

> [!NOTE] 
> Make Material Attributes会被Set Material Attributes节点覆盖，大部分情况下应该使用后者。

### Set Material Attributes
**设置材质属性（Set Material Attributes）**
建立材质属性的功能一样。它用于定义一组材质属性，并将其打包后在单根引线中传输。
建立材质属性节点默认显示所有标准材质属性，而设置材质属性节点上显示的输入由用户在 **细节面板（Details panel）** 中定义。这意味着你可以仅使用需要的材质属性。用设置材质属性表达式替代建立材质属性可以节约空间，让材质图表更加简洁。
![[Pasted image 20230119144655.jpg]]
大部分情况下，会优先使用设置材质属性而不是建立材质属性。
该节点唯一的缺点在于它不会随场景而变化，这意味着用户必须知道他们需要向数组中添加哪些属性，以此来创建各种不同的混合模式和阴影模型。如果你不确定，可以使用建立材质属性节点，它包含所有需要的输入。
### Break Material Attributes
**中断材质属性（Break Material Attributes）** 表达式可以切分输入的一组材质属性，并将每个属性在单独的引脚输出。
### Get Material Attributes
**获取材质属性（Get Material Attributes）** 与中断材质属性作用相同，但是有很多工作流程上的好处。它不会像中断材质属性那样分割所有的输入材质属性，而是可以选择要提取的属性。选中该节点然后在 **细节面板（Details Panel）** 中点击 **添加元素（Add Element）** 图标来添加输出节点。
### Blend Material Attributes
**混合材质属性（Blend Material Attributes）** 表达式使用两组材质属性，并且用Alpha输入中定义的像素级别操作来将其混合在一起。

举个例子，该材质分层混合将上下两组材质属性用一个遮罩纹理进行混合。
![[Pasted image 20230119144946.jpg]]

## 7 工具类

### 黑体（BlackBody）
用来在材质中模拟[黑体辐射](http://en.wikipedia.org/wiki/Black-body_radiation)。用户输入色温(开尔文)，产生的颜色和强度可用来驱动"底色"（Base Color）和"自发光"（Emissive）值，以获得在物理上准确的结果。
![[Pasted image 20230119151016.jpg]]

![[Pasted image 20221215000822.png]]
>[!note]
>
**色温**是表示光线中包含颜色成分的一个计量单位。从理论上说，**黑体温度**指绝对黑体从绝对零度（－273℃）开始加温后所呈现的颜色。黑体在受热后，逐渐由黑变红，转黄，发白，最后发出蓝色光。当加热到一定的温度，黑体发出的光所含的光谱成分，就称为这一温度下的色温，计量单位为“K”（开尔文）。
>
如果某一光源发出的光，与某一温度下黑体发出的光所含的光谱成分相同，就称为某K色温。如100W灯泡发出的光的颜色，与绝对黑体在2527℃时的颜色相同，那么这只灯泡发出的光的色温就是：（2527+273）K=2800K。

### 视差贴图（BumpOffset）
**凹凸贴图偏移（BumpOffset）** 是虚幻引擎4术语，又称**视差贴图**。BumpOffset表达式可以使材质产生深度错觉，而不需要额外的几何体。BumpOffset材质使用灰阶_高度贴图_来提供深度信息。高度贴图中的值越亮，材质的"凸出"效果越明显；当摄像机在表面上移动时，这些区域将产生视差（移位）。高度贴图中较暗的区域将显得"距离较远"，其移位程度最小。

![[Pasted image 20221214125514.png]]
**坐标（Coordinate）**
接收此表达式所要修改的基本纹理坐标。

**高度（Height）**
接收要用作高度贴图的纹理（或值）。

**高度比输入（HeightRatioInput）**
从_高度贴图_中取得的深度的乘数。这个值越大，深度越极端。典型值的范围是0.02到0.1。如果使用此输入，那么它将取代"高度比"（Height Ratio）属性中的任何值。

更强大的函数表达式：
![[Pasted image 20221214155727.png|400]]


## 其他
**ViewSize** 输出一个 2D 向量，以给出当前视图的大小（以像素为单位）。
### ObjectBounds
**对象边界（Object Bounds）** 表达式输出**对象在每个轴中的大小**。如果用颜色表示，X轴、Y轴、Z轴分别对应于R、G、B。
![[Pasted image 20221214114239.png|300]]

### CameraVector
**CameraVector** 表达式输出一个三信道矢量值，表示**像素到摄像机的方向。****
### ReflectionVector
**ReflectionVectorWS** 表达式在本质上类似于[CameraVectorWS](https://docs.unrealengine.com/4.27/zh-CN/RenderingAndGraphics/Materials/ExpressionReference/Vector/#cameravectorws)，但它输出一个三信道矢量值，该值表示**通过表面法线反射的摄像机方向**。
**使用示例**：ReflectionVector通常用于环境贴图，其中反射矢量的x/y分量被用作UV输入立方体贴图纹理。
![[Pasted image 20221214113249.png]]

# D 高级特性
## 距离场（Distance Fields）
使用 **距离场（Distance Fields）** 实现游戏中静态网格体Actor的动态环境光遮蔽和阴影。除此之外，Actor的网格体距离场表达还可用于其他一些特性，例如GPU粒子碰撞，甚至还可以使用材质编辑器创建动态流动贴图等等。
### 工作原理
此技术中使用的距离场是代表静态网格体表面的 **有向距离场（Signed Distance Field）** **（SDF）**。==有向距离场在每个点将距离最近表面的距离保存到体积纹理中。网格体外的每个点保存的距离为正值，网格体内的每个点保存的距离为负值。==
网格体距离场是**离线生成**的，**使用了将效果保存在体积纹理中的三角形光线追踪**。因此，网格体距离场是无法在运行时生成的。这种方法会**计算所有方向上的有向距离场，找到距离最近的表面，然后将该信息保存起来**。

待看：[虚幻引擎网格体距离场 | 虚幻引擎5.1文档 (unrealengine.com)](https://docs.unrealengine.com/5.1/zh-CN/mesh-distance-fields-in-unreal-engine/)
使用网格体距离场信息更便于计算距离。（例如用于草坪上的岩石块，计算接触面做更加柔和真实的过度）

### 设置
> [!NOTE] 开启网格体距离场
>  Project Settings-> Rendering->Generate Mesh Distance Fields
>  
>  如果为项目启用 **生成网格体距离场** 设置，那么即使不在任何Actor上使用任何距离场渲染功能，内存占用仍会上升。如果关闭此设置并重启虚幻编辑器，网格体距离场将不再被加载，内存占用就会下降。

网格体距离场可视化：
上面还有个Global Distance Field全局距离场，是分辨率较低的距离场。
![[Pasted image 20230119155040.png]]

模型影响距离场光照：
![[Pasted image 20230119155400.png]]

网格体距离场表达的质量由其体积纹理分辨率控制，也可以通过 **距离场分辨率比例（Distance Field Resolution Scale）** 进行控制，该选项位于BuildSetting（在 **静态网格体编辑器** 中）。
![[Pasted image 20230120134822.jpg]]
网格体距离场在使用大小相似的网格体构建的关卡中质量最佳，因为较大的网格体往往会产生错误。
网格体距离场的分辨率应调整到足够捕捉重要的特征。网格体的分辨率提高后，网格体距离场占用的内存量也会随之增加。在静态网格体编辑器中，视口的左上角列出了可供查看的网格体距离场的大小。

### DistanceToNearestSurface

**与最近表面的距离（DistanceToNearestSurface）** 材质表达式节点允许材质对"全局距离场"关卡中的任何点进行取样。 
输出从距离场到场景中最近遮挡体的**带符号距离**（以全局空间单位计）。

通常用来做一个遮罩实现各种效果
![[Pasted image 20230120171521.png]]
![[Pasted image 20230120171552.png]]

或者对世界坐标偏移，做史莱姆一般的黏附效果
![[Pasted image 20230120171730.png]]
![[Pasted image 20230120171753.png]]
### DistanceFieldGradient
**距离场梯度（DistanceFieldGradient）** 材质表达式节点进行normalize后，将输出对象在距离场中的（X,Y, Z）移动方向。 这使DistanceFieldGradient材质表达式节点非常**适合于需要模拟液体流**的材质。

就是输出RGB值为（X，Y，Z）的颜色
在静态网格体的X轴方向就是红色，Y轴方向就是绿色，Z轴方向就是蓝色
![[Pasted image 20230120155152.png|100]]![[Pasted image 20230120155244.png|100]]![[Pasted image 20230120155307.png|100]]

单独mask出一个方向
比如我们mask（R），那么只有网格体的X方向才会产生影响
![[Pasted image 20230120171821.png]]
## 虚拟纹理（待学）
待看：[[中文直播]第18期 | Virtual Texture（虚拟纹理）的理解和应用 | Epic 李文磊_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1KK411L7Rg/?spm_id_from=333.999.0.0&vd_source=9d1c0e05a6ea12167d6e82752c7bc22a)
# E 后处理

待看视频：[[中文直播]第19期 | 后期材质基础(上) | Epic 贾越_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Pk4y1R7MN/?spm_id_from=333.788.recommend_more_video.-1&vd_source=9d1c0e05a6ea12167d6e82752c7bc22a)
[# 【UE4】虚幻4使用后处理材质实现风格化渲染效果（转虚幻官方在线学习）_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1By4y127SG?p=19&vd_source=9d1c0e05a6ea12167d6e82752c7bc22a)

材质域设置为Post Process，后处理体积细节面板添加该材质即可
![[Pasted image 20230119210508.png]]
材质细节面板可以设置在何时应用此通道

> [!Danger] 闪烁问题
> 使用AfterTonemapping画面可能会出现闪烁现象，切换BeforeTonemapping就不会闪了

![[Pasted image 20230119210759.png]]
**色调映射前（Before Tonemapping）**
PostProcessInput0为HDR（每个像素8字节）中的所有照明提供场景颜色。用它来修复时间抗锯齿和GBuffer查找的问题，如深度，法线。

**色调映射后（After Tonemapping）**
首选性能位置，因为颜色是LDR（每个像素4字节），因此需要的精度和带宽较少。这是在色调映射和颜色分级之后。

**半透明前（Before Translucency）**
这在通道中甚至比半透明与场景颜色结合之前的"色调映射前"还要早。注意SeparateTranslucency的混合比法线透明度要晚。

**替换色调映射器（Replacing the Tonemapper）**
PostProcessInput0为HDR提供场景颜色，PostProcessInput1具有SeparateTranslucency（Alpha是遮罩），PostprocessInput2具有低分辨率泛光输入。

**SSR Input**不清楚作用



## SceneTexture
> [!Danger] Warning
> 只有Surface材质域才可以使用“SceneColor”节点
> 在后处理中，使用**PostProcessInput0**输出场景颜色！

![[Pasted image 20230119212441.png]]
**UV** 输入允许您指定要进行纹理查找的位置（仅用于颜色输出）。 颜色输出是4通道输出（实际的通道分配取决于场景纹理id）。
**大小（Size）** 是一个包含纹理宽度和高度的 两分量矢量。
**InvSize** 输出Size的倒数（1/宽度、1/高度）。

## 自定义深度 CustomDepth
这个单独的特性**通过将某些对象渲染到另一个深度缓冲区（称为自定义深度缓冲区）来屏蔽它们。** 这增加了额外的绘制调用，但不使用更多材质。渲染相当便宜，因为我们只输出深度。

该特性可以在网格体上激活 （例如静态网格体属性/渲染自定义深度）：
细节面板->Rendering->Render CustomDepth Pass
![[Pasted image 20230119213956.png]]
## 自定义深度模板Custom Depth Stencil

> [!NOTE] 
> 开启自定义深度模板：默认是Enable，只有深度没有模板
> 项目设置->Rendering->Postprocessing->Custom Depth-Stencil Pass
>
> ![[Pasted image 20230120222057.png]]

自定义深度模板（Custom Depth Stencil）是自定义深度（Custom Depth）的扩展，您可以在其中使用渲染对象的模板Stencil或挖剪cutout，然后做一些视觉效果上比较有趣的东西（如下例所示）， 使您能够可视化遮挡对象，绘制对象轮廓，或仅从特定视角可见。
通过访问场景中Actor的模板，您可以做很多事情 。使用以下设置启用并分配模具值。
![[Pasted image 20230120222550.png]]

默认模板值是0，不会被识别，我们需要手动设置模板值，设置模板值后我们查看Stencil Buffer，可以看到模型上有模板值的标记。

![[Pasted image 20230120224212.png|300]]
Mask出模板值，通过if比较来输出不同的效果。
![[Pasted image 20230120230127.png]]
## 通过蓝图修改状态
![[Pasted image 20230120231132.png|300]]


# B 材质大师
**REF.**
视频：[介绍 - 材质大师课程 (epicgames.com)](https://dev.epicgames.com/community/learning/courses/vpP/unreal-engine-dcd9bc/MYoY/unreal-engine-b14324)
主体：[UE4官方课程：材质大师（笔记） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/105032305)

![[a4ea644e7c1af1235de5d164576d4671_MD5.webp]]

## 1 整体架构
![[Pasted image 20221128172057.png]]
1.  引擎编译好的 HLSL Shader 模板+在材质编辑器上写的节点 = 新的 HLSL Shader；
2.  新的 HLSL Shader + 材质实例填写的参数具体值 = 最终的材质；
3.  注：如下材质界面左右是两个**独立**的部分，材质细节中不同的设置，会导致右侧的不同，即导致使用不同的 HLSL 内置模板，而左侧的节点是完全由我们控制的。
![[Pasted image 20221128172353.png|300]]

- **为何会有成千上万个着色器在编译？**
- **材质permutation（组合）**
- 同一个材质可能应用于不同实例，在一个材质中，不可能将所有情况都考虑进去，会导致很费性能。因此引擎会自动地帮我们针对同一个材质创建出不同的版本，即不同的**permutation（组合）**。

如下图，一个材质被应用到了Cube上，但是该 Cube 采用静态光照，并且已经有了光照贴图，
![[Pasted image 20221128173004.png]]
那么材质里的光照贴图就不会再混合到 Cube 上，材质会自动追加一部分代码，告诉不必再用。
![[Pasted image 20221128173030.png]]
类似的情况还有很多，因此针对不同情况，引擎会拷贝原来的材质，然后自己修改，编译，就会导致很多编译。

因此对于一些材质，最好直接指明他的用途。引擎默认会选择自动，但是打包出去之后有时会不对。而且这也是我们有时候明明没有修改资源，引擎仍然会提醒我们有修改过的一个原因：引擎自动改了这个材质的用途。
![[Pasted image 20221128173448.png]]
-   **对编辑器公开的内容：**
-   **质量开关节点( quality switch ）**：引擎会为其中一个输入的每个版本都生成不同版本的着色器。
-   **开关节点( switch )**：真假各生成一个版本。
-   **特征等级开关（feature level switch）**：可用于禁用DirectX 10（SM4），从而产生相应的影响。
-   在项目设置中的“允许静态光照”，关闭后会减少自动生成的着色器数量。
-   此外有专门的着色器permutation减少的列表，禁用那些选项，引擎就会从着色器中剥离某些功能。
- **一般情况下保持默认**，除非需要减少项目着色器数量。
![[Pasted image 20221128173826.png]]
---
## 2 性能
**影响因素**

-   性能受操作的像素/顶点的 **数量** 及像素/顶点的 **计算复杂度** 影响；
-   材质编辑器中的表达式（又称节点）数量并不等于指令数，指令数量影响性能（节点很多不一定很消耗性能，相反很少的节点如Noise节点可以消耗很多性能）；
-   可以通过 ViewMode/Optimization Viewmodes/Shader Complexity 或 Alt+8 查看复杂度，如下图，十字星对准某位置时，下方会有 PS 和 VS 分别代表当前像素和顶点着色器的复杂度。
- ![[Pasted image 20221213184325.png|300]]
![[Pasted image 20221213184236.png]]
![[Pasted image 20221213185217.png]]

**指令指标（仅供参考）**
![[Pasted image 20221213185426.png]]
对于PC端来说，移动端和VR要低更多

-  尽量使用基于**纹理**，而不是基于过程化（通过节点组合）的计算；（例如材质里面Noise节点生成噪点纹理会比噪点贴图消耗很多。）
-   半透明材质都应尽可能保持简单。（会针对存在的每个半透明层反复重新计算每个像素，从而快速提升计算次数，并且难以理清半透明表面的排序顺序。）
- 如图：透明层叠加的部分为红色
 ![[Pasted image 20221213185731.png]]
 - 使用**蒙版**处理电线、草等物体

![[Pasted image 20221213190203.png]]
-   FeatureLevelSwitch和QualitySwitch(材质节点）
 ![[Pasted image 20221213190423.png]]
-   windows基本使用的是**SM5(shader model 5)**
-   ios设备上可以使用ES2或ES3,那么就可以使用简化的材质设置

**这些前文都已经提过**
在材质的细节面板有Full Rough选项，启用后简化指令，降低质量，关闭pbr
![[Pasted image 20221213190600.png]]
-   项目设置里面有shader permutation一栏
-   可以禁用固定天空光照，禁用点光源全场景阴影，禁用大气雾。

## 3 基于物理的渲染
[基于物理的材质 | 虚幻引擎文档 (unrealengine.com)](https://docs.unrealengine.com/4.27/zh-CN/RenderingAndGraphics/Materials/PhysicallyBased/)
[DONTNOD Physically based rendering chart for Unreal Engine 4 | Sébastien Lagarde (wordpress.com)](https://seblagarde.wordpress.com/2014/04/14/dontnod-physically-based-rendering-chart-for-unreal-engine-4/)
基于物理的渲染（Physical Based Rendering），通过调整 Roughness，Specular，Metallic 属性进行着色。材质数值之间的依赖比较小，因此能简单和提高效率。
![[Pasted image 20221213201158.png]]

**BaseColor**： 定义材质的整体颜色。它接收 Vector3 (RGB) 值，并且每个通道都自动限制在 0 与 1 之间。
**粗糙度（Roughness）** ：输入控制材质表面的粗糙或平滑程度。与平滑的材质相比，粗糙的材质将向更多方向散射所反射的光线。 这决定了反射的模糊或清晰度（或者镜面反射高光的广度或密集度）。 粗糙度 0（平滑）是镜面反射，而粗糙度 1（粗糙）是漫射（或无光）表面。  1
-    **粗糙度很重要，大部分时间花在这里；**
-    **粗糙度贴图是您处理大部分镜面反射纹理的位置。**

**金属色（Metallic）** ：非金属的金属色（Metallic）值为 0， 金属的金属色（Metallic）值为 1。对于纯表面，例如纯金属、纯石头、 纯塑料等等，此值将是 0 或 1，而不是任何介于它们之间的值。创建受腐蚀、落满灰尘或生锈金属之类的混合表面时， 您可能会发现需要 _介于_ 0 与 1 之间的值。

****高光**(Specular)** ： 并不常用，通常有其固定值，且当 Metallic 为1时，Specular 失效。默认高光值为0.5，**一般我们不会改变这个值。**

## 4 压缩和内存

纹理在导入时默认被压缩，几乎所有的纹理都会被压缩，具体视平台而定；

### BC/DXTC压缩的不同

-   对其的压缩方式视平台而异，BC表示“块压缩”（block compression),DXTC表示“DirectX纹理压缩”(DirectX Texture Compression)同DXT.
-   压缩方式的名字后会附带一个编号来识别压缩类型。
-   虚幻里面贴图的细节面板当中，如果Format是B8G8R8A8，那么就表示该图片没有被压缩（例如压缩设置为VectorDisplaymentmap时），注意：在选择压缩模式时要关注纹理资源大小的变化。
![[Pasted image 20221213202438.png]]
-   贴图细节面板中的Defer Compression将禁用导入时对纹理压缩的执行(保存时才执行压缩)，可以加快大图的导入。

![[6c2ab421aa2af5e0be15c5e84b8681c0_MD5.webp]]
- **BC1 （DXTC1）为不含透明的纹理，BC3（DXTC5） 为含有透明的纹理**，ue会自动识别选择对应的压缩格式。其中 **alpha 通道不会被压缩**；
-   DXTC5表示压缩红色绿色和蓝色通道，alpha通道几乎不压缩。这种情况下alpha通道的大小和RGB通道合起来的大小一致。贴图细节面板里有一个去透明通道压缩的选项compress without alpha ，可以缩小一半的贴图大小。

![[4b0136e6dd44acffcfad8c08bba3eea7_MD5.webp]]
因为透明通道几乎不压缩，所以去除透明通道可以节省很多空间


![[c415316fb606b82529bee4b5187d5c10_MD5.webp]]

**法线贴图使用特殊的压缩方式：**
![[Pasted image 20221213203641.png]]
BC5压缩仅保留RG通道，蓝通道在压缩时被移除了。
引擎内部通过这样的步骤恢复蓝色:
![[Pasted image 20221213204058.png]]
**DeriveNormalZ**函数使用红色和绿色数据，来确定蓝色应位于哪些位置，从而复原原始法线贴图图像，你无需在材质进行这样的运算，因为只要你使用了正确的压缩类型，在引擎内部已经做了这样的计算。
>[!note]
DeriveNormalZ（派生法线 Z）表达式在给定 X 和 Y 分量的情况下派生切线空间法线的 Z 分量，并输出所产生的三通道切线空间法线。Z 计算方法为：${Z = sqrt(1 - (x *x + y*y))}$；

有了这个方法，我们可以在用一张Default压缩格式的贴图的RG通道存取法线贴图RG信息，B通道可以存其他信息，这样通过计算得到法线信息，还能多一个其他信息，减少了采样次数。

**通过RG通道计算B通道：**
[如何通过法线贴图的RG通道算出B通道？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/42668577)
![[v2-cc627dea443a560ffbb6f4d34740df12_720w.webp]]
![[Pasted image 20221220141019.jpg]]
这条红线就是法线，箭头处往下做的垂线就是去掉B通道的贴图，我们怎么算呢？

首先先算出C²等于X平方加Y平方得到C方后，因为法线是单位向量所以值为1，根据勾股定理我们就可以算出B通道也就是Nz的值了。

为什么要搞的这么麻烦呢，我想是为了节省贴图量减少游戏的包体。

### 跟踪纹理大小

-   贴图数量和大小出问题的话，就**会影响带宽和内存，可能会导致延迟，冻结和卡顿**，但**不会造成帧率损失**，这是一种判断可能出现的性能问题的方法。
![[Pasted image 20221213204709.png]]
数据统计窗口
![[Pasted image 20221213204755.png]]
纹理统计选项查看

-   以上查看到的是编辑器模式下的纹理大小，更加精准的列表，左上角选择打包后的数据： 然后右上角选择对应的平台，便会加载更加精准的列表：
![[Pasted image 20221213205337.png]]

- 在游戏运行的时候在控制台（~）输入Stat Memory,查看内存使用情况：
![[Pasted image 20221213205240.png]]

## 5 多级渐进纹理，纹理尺寸和纹理池

1.  流送池
2.  mipmaps及其工作方式
3.  mipmap如何转而与纹理流送捆绑，什么是纹理流送以及纹理大小
4.  纹理组
5.  每个材质的纹理数限制
6.  归并贴图

### 纹理流送池 TextureStreamingPool
**纹理流送（TextureStreaming）是确定引擎在何种情况下需要何种纹理以及何种mipmap等级的过程，它仅装入所需的对象**

-   引擎在计算机内存中为纹理保留一定量的空间，即所谓的纹理预算。
-   这些空间保留在内存中，被称为TextureStreamingPool纹理流送池
-   有一个名为 `r.Streaming.PoolSize` 的属性可控制标准纹理流送池的大小（默认情况下数值约为2000，即2GB的空间）
-   根据每个项目不同的要求来加以妥善配置
- 在控制台输入`r.Streaming.PoolSize xxx`调整大小，单位MB。也可以通过修改项目的配置文件（方法略）
 ![[Pasted image 20221213210519.png]]
-   纹理流送池不够时，部分材质会出现非常模糊的纹理（引擎采用了较低分辨率的mipmap）

### Mipmaps

-   为了最大程度提升内存效率，并平滑掉图像，我们使用mipmap
-   mipmap基本上就是纹理的副本，但大小约为前一mipmap等级的四分之一
![[Pasted image 20221213211037.png]]
-   如果没有mipmap画面会包含很多噪点
![[Pasted image 20221213211052.png]]
近处使用精度高的mipmap远处使用精度低的制造模糊效果

-   帮助加速加载速度
-   和纹理流送紧密关联
-   使我们能够根据需要缓慢导入数据

-   **纹理必须是2的幂**，或者任意两个二的幂的组合，例如2x2,32x32或2x16,32x4096等
-   **不属于2的幂的纹理将无法生成mipmap**,导致在纹理预算中占用空间从而超出合理范围，或者会看到到处都产生噪点
-   UI贴图不会出现在远处，所以不需要使用mipmap，可以分辨率可以不遵循上述规则。
-   TextureMipGenSetting: mipmap一般都是默认设置也就是FromTextureGroup，可以在属性中修改这样就会对远处对象施加额外的清晰度或者模糊
- ![[Pasted image 20221213212208.png|300]]
- LOD Bias: 预览不同mipmap等级的贴图。0对应原始mipmap

**此外mipmap可以在摄像机较远时能优化像素着色器性能，而顶点着色器无论远近顶点数目不变，没有优化作用。**
### 纹理分组 TexureGroup
- Texture Group：除UI外，大部分都不会改变什么。默认为 World 或者 WorldNormal，可以自己指定，方便对一组的纹理统一管理。
-   方便对每一个图片组进行快速调整：如果进行的是一个大项目，把角色载具和武器的纹理分组，就可以更加方便地对其进行进一步的管理。大部分分组类别不会对贴图属性进行默认修改，但是少数例如UI组和LUT组会自行更改部分设置
- 分组选项，纹理导入后默认时世界分组
统一设置方式：Developer Tools/Device Profilers
![[Pasted image 20221213212807.png|300]]
-   使用说明窗口：在开发者工具里面的设备描述窗口中，针对不同的平台可以对纹理LOD组别进行属性修改
![[Pasted image 20221213212913.png]]
-   TexureGroup可修改属性如下：
![[Pasted image 20221213212923.png]]

### 纹理采样器限制
-   每个材质拥有16张贴图采样器
-   其中部分采样器供内部步骤使用，例如光照贴图阴影贴图等，所以**大约有13个纹理可使用**

-  **绕过纹理限制**
- 方法一：修改材质里面贴图的取样器源，"Shared:Wrap"共享包装和”Shared:Clamp“共享限制不同于纹理是否平铺，大部分可以修改成wrap，这样的话这个材质就最多可包含128个纹理了。
 ![[Pasted image 20221213213321.png|300]]
-  **方法二（更常用，更容易处理透明贴图）：归并贴图Mergemaps，即RGB通道放置不同信息的纹理，这样就可以用一个采样器代替三个采样器了。
  ![[Pasted image 20221213213549.png|300]]
- 可以将透明度纹理放在rgb通道，这样节省Alpha通道的消耗（前文提到过透明度通道不会被压缩）
### 纹理过滤器 Fliter
设置为nearest就不会将像素全部同时平滑掉（可用于老式复古风格效果），默认的话就会模糊掉像素格子
![[Pasted image 20221213214042.png]]

## 6 渲染目标RenderTargets
烘焙材质或者烘焙镜头或者以其他方式生成纹理成为渲染目标。

-   本质是由引擎或者编辑器生成的纹理；
-   用于 Camera、支持复杂材质或者其他高级效果如踩雪等；

应用一：捕获镜头产生一个动态纹理
![[Pasted image 20221213214917.png]]

一个获取的是2D纹理，一个获取的是立方体纹理
性能开销太大，因为在重复渲染视图

应用二：将材质纹理烘焙到RT中
诸如可交互水体、学雪地等

## 7 材质编辑器时介绍
![[Pasted image 20221213222116.png]]
材质编辑器的组成和构架

## 8 理解Texture
**TexCoord是纹理的uv坐标，不是模型的uv坐标**

**Texture Sample和TexCoord的关系**
![[Pasted image 20221213230846.png|400]]

**Texture Sample和Texture Object的关系**
![[Pasted image 20221213233127.png]]
Sample只是对Object进行采样。如果Tex不连线，在Sample中设置贴图，引擎默认给一个object，原理一样。

**对Texture Sample和Texture Object的特殊操作**
[UE4野生百科全书：Texture Object vs. Texture Sampler_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Pt4y1B7Q6/?vd_source=9d1c0e05a6ea12167d6e82752c7bc22a)

## 9 使用外部信息
**红色节点通常支持访问外部信息**
![[Pasted image 20221214233028.png]]

## 11 材质输入
材质板接口：
![[Pasted image 20221214160616.png]]
-   **BaseColor**基础色值域：被限制在小于等于1的值，所以输入500和1没有差别。
-   **EmicssiveColor**自发光:大小基本上是控制Bloom光晕的范围。

使用**WorldDisplacement（UE5已弃用 ）** 和**Tessellation**需要先在Details面板开启：
![[Pasted image 20221214154850.png]]

### WorldDisplacement
- **WorldDisplacement**置换效果:**高度图乘以顶点法线**，才能正确地实现置换效果。高度图的范围一般在0-1，所以还需要额外地乘以40或者其他大小来制造位移。ParallaxOccl·usionMapping函数也可以制造出类似的效果。
 ![[Pasted image 20221214155212.png]]
![[Pasted image 20221214155233.png|300]]
### Tessellation 
-   **Tessellation Multipier**曲面细分:最大值在16左右，默认是关闭的在细节面板打开。
### WorldPositionOffset
-   **WorldPositionOffset**世界位置偏移：使用顶点着色器将顶点偏移。。要想达到好的效果，需要足够细分的顶点。

与置换WorldDisplacement的区别是：
1.  WorldDisplacement需要配合Tessellation为你细分网格体然后使其变形；
2.  WorldPositionOffset则需要已经细分过的模型，然后在此基础上使其变形。
3.  WorldDisplacement则可以选择性在低端硬件上关闭过多的细分；
4.  WorldPositionOffset展示的效果更加精细，但是不可关闭细分。

**WorldPositionOffset用法一：草的摆动**
![[Pasted image 20221214160830.png]]
![[Pasted image 20221214160914.png]]
草的**底部顶点颜色为黑色**，所以底部不会移动，上面移动形成随风摇摆的效果

-   **WorldPositionOffset 用法二：水面、布料、飘动旗帜。
 ![[Pasted image 20221214160757.png]]
![[Pasted image 20221214162230.png]]
0 append 0 的作用是让波动效果之作用在Z轴，这时X和Y轴都为0;

-   **WorldPositionOffset :** 常见用法之三：物体的旋转，例如玩家走到的草丛，草丛向外侧弯曲。
![[Pasted image 20221214162549.png]]
原理简单版,盒子的旋转，time是旋转速度，001是沿着Z轴旋转
建议通过C++/蓝图完成简单的物体旋转
### AO
-   **Ambient Occlusion :** 只能在静态光照模型上使用和显示，为了在动态效果上也能显示，用lerp(0,1,0.5)混合AO给到高光。
![[Pasted image 20221214163117.png]]
### PixelDepthOffset  
- **PixelDepthOffset 像素深度偏移:** 对于毛发或者植物而言很有用
![[Pasted image 20221214163634.png]]
![[e38763643ece9cdf92ef4f09b4c1f9be_MD5.webp]]

用于PDO的Mask

![[a80ff446ee20b94a0522e45dccba7a63_MD5.webp]]

before

![[59213a33fea4635929a1f3563b14fd09_MD5.webp]]

after

和parallax一起使用，即使就是一个平面模型也可以制造出凹凸面相交的效果，如下图：

![[f19f03d07dffcf8eda9e50bf6c8c5f9f_MD5.webp]]

## 12 材质域 MaterialDomains
材质域用于控制材质的整体使用场景，定义材质在你的项目中的用途。例如，表面、用户界面和后期处理材质是不同的材质域。
![[Pasted image 20230118141055.png]]
**表面（Surface）**
该设置将材质定义为将用于对象表面的东西；可以是金属、塑料、皮肤或任何物理表面。因此这是你大部分时间里都会用到的设置。

**延迟贴花（Deferred Decal）**
制作[贴花材质](https://docs.unrealengine.com/5.0/zh-CN/decal-actors-in-unreal-engine)时，你将使用此设置。

**光照函数（Light Function）**
创建结合光照函数使用的材质时应使用此设置。

**体积（Volume）**
将材质的属性描述为3D体积时使用。

**后期处理（Post Process）**
如果材质将用作[后期处理材质](https://docs.unrealengine.com/5.0/zh-CN/post-process-materials-in-unreal-engine)，则使用此设置。

**用户界面（User Interface）**
材质用于UMG或Slate用户界面时使用。

**虚拟纹理（Virtual Texture）**
需要使用[运行时虚拟纹理](https://docs.unrealengine.com/5.0/zh-CN/virtual-texturing-in-unreal-engine)时使用。

### 延迟贴花DeferredDecal
Decal也是Actor
可与设置混合模式
![[Pasted image 20221214184050.png]]

### 光照函数LightFunctions 
材质板只剩下Emissive Color，始终输出灰阶
支持创建材质与光照混合，使得光照可以投射材质
可以将材质赋给光源：
![[Pasted image 20221214184517.png]]
![[Pasted image 20221214184258.png|300]]
**- 多用于水焦散效果，云的阴影效果，火光闪烁。**
### 后处理PostProcess
材质板只剩下Emissive Color
可以将材质赋给PostProcessVolume（后处理盒子）
![[Pasted image 20221214184754.png]]
### Volume体积
base color会变成Albedo反射率，extinction消光接口也会亮起。
可以配合粒子制作体积雾VolumetricFog 
### UI
![[Pasted image 20221214185221.png]]

## 13 混合模式 BlendMode 
![[Pasted image 20230118141349.png]]
混合模式（Blend Mode）描述当前材质的输出如何与背景中已经绘制的内容进行混合。从技术的角度来讲，你可以控制引擎在渲染时将这个材质（**源颜色（Source color）**）与帧缓冲中已经存在的材质（**目标颜色（Destination color）**）结合起来的方式。可用混合模式有：

**不透明BLEND_Opaque**
最终颜色 = 源颜色。这意味着材质将在背景上绘制。此混合模式与光照兼容。

**遮罩BLEND_Masked**
最终颜色 = 如OpacityMask > OpacityMaskClipValue（默认0.3333，可22在Advanced中设置），则为源颜色；否则该像素将被丢弃。此混合模式与光照兼容。
注意clip和半透明的区别：clip是剔除像素，不需要对剔除像素进行渲染，而半透明需要对其渲染，生成反射等效果，如果想要保留反射或镜面反射外貌，那么最好使用"半透明"（Translucent）混合模式，或考虑建立分层材质。
另外，因为这些特性不会在遮罩的区域中进行渲染，所以完全不会进行计算，这进而提高了 GPU 的性能。

**半透明BLEND_Translucent**
最终颜色 = 源颜色 _不透明度 + 目标颜色_ (1 - 不透明度)。此混合模式与动态光照 **不** 兼容。
使用半透明材质时，一个重要的注意事项是它们目前不支持镜面反射。这意味着您在表面上不会看到任何反射。但是，可使用Cubemap通过类似于以下的网络来模拟此类反射：
![[Pasted image 20230118155244.jpg]]

**叠加型BLEND_Additive**
最终颜色 = 源颜色 + 目标颜色。此混合模式与动态光照 **不** 兼容。
![[Pasted image 20230118155712.png]]
"叠加型"（Additive）混合模式无非获取材质的像素，并将其与背景的像素相加。这与Photoshop中的_线性减淡（添加）_混合模式非常相似。这表示不会进行暗化；因为所有像素值都_添加_到一起，因此黑色将直接渲染为透明。这种混合方式适合于各种特殊效果，例如火焰、蒸汽或全息图。

与"半透明"（Translucent）混合方式相同，这种混合方式不支持镜面反射（即反射）。这种混合的叠加型性质可能意味着您不会以任何方式使用这种混合，但您可以使用上文中"半透明"（Translucent）小节中所示的"立方体贴图"方法来模拟类似于反射的效果。

**调制BLEND_Modulate**
最终颜色 = 源颜色 x 目标颜色。此混合模式与动态光照或雾 **不** 兼容，除非该材质为贴花材质。
![[Pasted image 20230118160114.png|300]]
"调制"（Modulate）混合模式无非将材质的值与背景的像素相乘。这种行为与Photoshop中的_**正片叠底模式**_混合模式非常类似。

**AlphaComposite**
用于那些纹理已经预先与alpha值相乘的材质。也就是说，颜色通道已经乘以alpha，所以当与帧缓冲区混合时，GPU可以跳过通常用于alpha混合的（SrcAlpha * SrcColor）算法。可以改善叠加混合的视觉效果。

**AlphaHoldout**
允许你"继续使用"材质的alpha，在视图空间中，直接在半透明对象上显示一个孔洞。

### Translucent
由于GBuffer的限制，半透明表面非常难以显示反射，也非常难以与一般光照和着色效果进行正常互动，因此有光照无光照看上去没什么区别。因此处理半透明材质时推荐使用Unlit材质（视情况而定）。

追求美观：default lit ·最高质量的受光半透材质设置（开销太大）![[Pasted image 20221214175045.png]]
光照模式可以设置**前向着色**
这里还可以**禁用深度测试**，实现一些特殊效果：始终渲染该材质，不受物体遮挡，实现透视

半透材质在不应模糊的时候出现模糊，关掉材质里的RenderAfterDOF；

Volumetric PerVertex NonDirectional光照模式，会通过顶点来分辨照亮面积，这样可以降低开销但是效果没那么理想。光照颜色不是平滑移动的，光照会突然消失。
![[Pasted image 20221214175641.png]]
![[Pasted image 20221214175658.png]]
通过控制台增加细分来平滑受光范围

   **Refraction接口 :**
   着色模型和法线的关系：
      ![[Pasted image 20221214182345.png]]
   当设置Lit时，法线影响Refraction
   当设置Unlit时，法线不会执行任何操作
   Refraction的值可以查表。
   
水面材质的折射如下图右，需要在材质的折射选项中开启 pixel normal offset：
![[1c153d0bde80f33fd58844dc23e837b4_MD5.webp]]
默认折射效果为左图
![[Pasted image 20221214182539.png]]
材质的折射选项中开启 pixel normal offset 像素法线偏移

**对于半透明材质的一些规则和建议：**  
1. 可以使用Maked的时候，就使用Maked。
2. 如果它必须是半透明的，保持着色模式为Unlit。
3. 如果效果可以尽量使用Unlit+半透明。如果做不到这一点，使用简化的光照半透明，设置为Lit+半透明，但尽可能保留简单的版透明设置。不要使用前向着色、屏幕空间反射。
4. 尽量少用复杂高开销的半透明设置，半透明层数尽量保持一层（通过透明玻璃看透明玻璃开销很高）
### Masked
-   **Masked :** MaskOpacity部分仍然会被渲染，注意消耗（运用不规则面片，裁剪掉不需要的透明部分）
![[Pasted image 20221214180022.png]]
-   **DitherTemporalAA :** 通过将表面分为大量交替显现的小型像素，来使其呈现半透明效果。渲染速度比半透明更快，但是效果不太好。
 ![[Pasted image 20221214180407.png]]
### Additive
- **Additive** : 用于在顶层添加颜色。
### Modulate
-   **Modulate**调制 : 移除所有明亮部分，仅保留较暗的像素处于可见状态，用于污渍泥土和爆炸痕迹等。

![[1406ccd5fe6f113b6e978627b628b89b_MD5.webp]]
图一Additive，图二Modulate

## 14 着色模型 ShadingModel
着色模型决定了材质输入（如自发光、漫反射、高光度、法线）如何组合以形成最终颜色。
通常，你的材质将简单地使用默认光照着色模型。但是，虚幻引擎包含针对 **毛发（Hair）**、**布料（Cloth）** 和 **皮肤（Skin）** 等事物的特定着色模型，这些模型提供上下文专属输入，以便更轻松地创建这些类型的表面。
![[Pasted image 20230118141435.png]]

### Unlit
材质仅由自发光（Emissive）和不透明度（Opacity）输入定义。它不响应光照。
节省性能，指令数少；仅有自发光的材质就用unlit（defaultLit只连Emisive color的会存在少量反射，导致材质没有那么清晰）。
![[Pasted image 20230118160523.jpg]]
请注意，在此示例中，材质并不会将光线投射到场景中。其较高的自发光值会产生发光效果，且应用到摄像机的尘土遮罩也能获得该效果。它看起来会发光，但是**此对象不会投射光线或阴影**。
**如果启用了Lumen，或者当开启了使用静态光照自发光（Use Emissive for Static Lighting）时使用Lightmass，自发光材质便可以向场景中投射光线。**

**自发光投射**
	在关卡中选中模型，材质加上自发光，勾上模型细节中“使用自发光作为静态光照”选项
 ![[Pasted image 20221214235249.png]]
模型发光并影响到周围环境
 ![[Pasted image 20221214235439.png|300]]


### Default Lit
默认着色模型，此着色模型使用直接和间接光照，以及反射高光。

### SubSurface
**次表面（Subsurface）** 着色模型能够模拟次表面散射效果。这是一种真实世界中的现象，光线会穿透表面，然后在整个物体中弥散。这种现象常出现在冰、蜡烛、皮肤等物体上。
次表面（Subsurface）模型以及下面讲述的预积分皮肤（Preintegrated Skin）模型都依赖于 **次表面颜色（Subsurface Color）** 输入。该输入定义物体表面下物质的颜色。光线在表面散射时，便能够看见次表面颜色。

-   **SubSurface（次表面） :** 开启Opacity（不透明度）和SubsurfaceColor接口。**不透明度即允许穿过次表面的光照量**。给一张光照穿透度的Mask到半透明即可判断模型哪些部分的透光度更高（例如耳朵更加透光）。
-   **SubSurfaceProfile （次表面轮廓）**：仅开启Opacity，它模糊了屏幕空间的图像，通过给模型拍张照片，按照散射半径将其偏移来模拟次表面散射。
![[Pasted image 20221214165729.png]]
创建次表面描述文件：
![[Pasted image 20221214165938.png]]
![[Pasted image 20221214170053.png]]

### Preintegrated Skin
**预整合皮肤（Pre-integrated Skin）** 着色模型的性质与次表面模型非常相似，但**牺牲了部分精确度以换取较低的性能开销**。尽管在物理效果上并不完美，但此着色模型较次表面法而言性能表现更好，而且通常能实现不错的角色效果。
![[Pasted image 20230118161211.jpg]]

### TwoSidedFoliage
**TwoSidedFoliage（双面植物）

允许光线穿透材质表面，形成自然、统一的外观效果，比如光线穿透树叶。**次表面颜色用于定义光线穿透量，同时用于为叶片茎脉等部分创建遮罩**。

双面植被着色模型还有助于消除次表面散射模型中存在的问题，该模型对皮肤或较厚的表面非常有效，但对于叶片等较薄的表面则无法保证精确。使用植被的 **默认光照（Default Lit）** 着色模型还会导致错误的外观结果。

在下面的示例中，由于默认光照没有模拟任何形式的光透射，而这是形成逼真的植物效果的关键，因此会导致下表面看上去一片漆黑。
![[Pasted image 20230118162148.png]]
案例：
 ![[Pasted image 20221214170557.png]]
### ClearCoat  
**透明涂层、清漆层（Clear Coat）** 着色模型可用来更好地模拟标准材质表面有一层半透明薄膜的多层材质。此着色模型经专门设计，用于将光滑彩色薄膜贴在无颜色的金属上。不过，它也可用于金属或非金属表面。

例如丙烯酸或喷漆透明涂层，以及苏打罐和汽车漆等金属表面的彩色薄膜。
![[Pasted image 20230118161252.jpg]]

更改为该模式后会激活透明涂层（Clear Coat）和透明涂层粗糙度（Clear Coat Roughness）输入。
以及一个特殊的输出接口：ClearCoatBottomNormal，提供第二组法线和粗糙度。这样材质能够更精确地为复杂材质建模，例如碳纤维和车漆，这些材质的几何或反射表面与透明涂层有所不同。

![[Pasted image 20221214171516.png]]

![[Pasted image 20221214172152.png]]
因为第二层法线是可以被禁止掉的，所以输出接口没有合并在一起
可以在设置中开关透明图层第二组法线：
![[Pasted image 20221214172309.png]]

### Subsurface Profile
[虚幻引擎次表面轮廓明暗处理模型 | 虚幻引擎5.0文档 (unrealengine.com)](https://docs.unrealengine.com/5.0/zh-CN/subsurface-profile-shading-model-in-unreal-engine/)
**次表面轮廓**，与次表面（Subsurface）和预整合皮肤（Preintegrated Skin）着色模型非常相似，但**该模型只适用于高端皮肤渲染。如果希望模拟皮肤，尤其是人类皮肤，该模型是着色模型的最佳选择**。
![[Pasted image 20230118161846.png]]
![[Pasted image 20230118161938.png]]
### Skin/Hair/Cloth/Eye  
- 皮肤头发衣服眼睛的请查看虚幻相关文档以及项目材质
[照片级角色 | 虚幻引擎文档 (unrealengine.com)](https://docs.unrealengine.com/4.27/zh-CN/Resources/Showcases/PhotorealisticCharacter/)
### Single Layer Water
[虚幻引擎单层水着色模型 | 虚幻引擎5.0文档 (unrealengine.com)](https://docs.unrealengine.com/5.0/zh-CN/single-layer-water-shading-model-in-unreal-engine/)
可以通过 **单层水（Single Layer Water）** 着色模型在使用 **不透明（Opaque）** 混合模式时**实现透明水面**的效果。这样可以降低需要使用 **透明（Transparent）** 混合模式的材质的使用开销和复杂度。
![[Pasted image 20230118162402.png]]

### Thin Translucent
**薄半透明（Thin Translucent）** 着色模型支持基于物理原理的半透明材质类型，可以通过该模型创建能准确处理高光度和背景对象的真实有色或彩色玻璃。

需要进行以下设置：
-   **混合模式（Blend Mode）**：半透明
-   **着色模型（Shading Model）**：薄半透明
-   **光照模式（Lighting Mode）**：表面**ForwardShading**

举例而言，创建有色玻璃材质时需要白色高光和着色背景。此着色模型使用基于物理原理的着色器在单通道中渲染，着色器会负责处理光线从空气反射到玻璃以及从玻璃反射到空气中的情况。
![[Pasted image 20230118162507.png]]

使用Thin Translucent Material 节点：
![[Pasted image 20230119161712.jpg]]
### 基于材质表达式
[虚幻引擎基于材质表达式 | 虚幻引擎5.0文档 (unrealengine.com)](https://docs.unrealengine.com/5.0/zh-CN/from-material-expression-shading-model-in-unreal-engine/)
**基于材质表达式（From Material Expression）** （或逐像素）着色模型是一项高级功能，允许通过材质图表中的逻辑，<font color="#ff0000">将多个着色模型合并到单个材质（或材质实例）中</font>。

当 **着色模型（Shading Model）** 设置为 **基于材质表达式（From Material Expression）** 时，**着色模型** 输入将变为可用，可以使用材质图表（Material Graph）中的 **阴影模型（Shading Model）** 节点进行设置。
![[Pasted image 20230118163010.jpg]]
## 15 材质实例
1. 节点转变为参数后可以在实例中编辑，供外部访问
蓝图修改材质参数：
![[Pasted image 20221214191657.png]]
2. 主材质不放贴图，设置好TextureSample接口在实例中导入贴图即可。
3. 主材质需要编译，实例不需要编译
4. 权衡主材质的数量，不要再一个主材质之中实现大量功能。
## 16 材质函数
![[Pasted image 20221214203623.png]]
1. 材质函数即表达式的组合，基本都是蓝色的节点
2. 可以双击打开查看
3. 项目开始要创建函数库，将经常使用的表达式制作成函数，并且可以在不同项目中移植
4. 项目里面可以简单地分两个函数组，一个是基础材质函数，一个是效果函数
5. 缺点：更改大量已经用过的函数，可能需要编译一段时间

为了使用材质函数，需要确保它显示在"材质编辑器控制板（Material Editor Palette）"的 **材质函数库（Material Function Library）** 中。为此，必须将 **公开到库（Expose to Library）** 属性设置为true。
![[Pasted image 20230118173830.jpg]]

**库类目文本（Library Categories Text）** 可让你选择材质函数将出现在哪个类目中。你可以添加额外的类目，方法是单击 **插入（Insert）**，然后键入新的类目名称。但是，明智的做法是尽可能简洁，不要添加超出绝对必要的类目。
![[Pasted image 20230118173900.jpg]]
## 17 材质图层MaterialLayer
材质图层也是一种材质函数，将整个材质放置到一种特殊类型的函数中，该函数就成为所谓的材质图层。
![[Pasted image 20221214204154.png]]
选中后材质板变为
![[Pasted image 20221214211227.png]]

**创建Material Layer** ，项目中通常根据项目中存在的表面类型设置，这些图层相互混合成不同的材质。
![[Pasted image 20221214211128.png]]
![[Pasted image 20221214211155.png]]
**在Material中将两个图层混合**
![[Pasted image 20221214211254.png]]

-   详细分层用法可以参考官方放出地Sequencer项目中的角色材质。

## 18 材质参数集MaterialPatameterCollection
- 不常用。通过建立一个共用的参数集，修改参数集中的参数的同时可以**修改所有实例**。
- 材质最多可以引用两个不同的材质参数集合。一个通常用于表示游戏范围的值， 另一个可以用于表示特定于关卡的参数。一个集合最多可以包含1024个标量参数和1024个向量 参数。
- 项目中建立一个通用参数集就够了

**建立材质参数集**
![[Pasted image 20221214212317.png]]
**设置参数，testvalue1，testvalue2**
![[Pasted image 20221214212559.png]]
**在Material中就可以使用Collection Param节点**
![[Pasted image 20221214212745.png]]

## 19 HLSL
**使用HLSL主要通过两种方式：
- **自定义节点 Custom
- **全局着色器 GlobalShader**

### Custom
![[Pasted image 20221214223415.png]]
-   你需要在材质编辑器中获取信息，但通过其他方式无法获取此信息。比如让阴影显示特定的图案
[Textured Shadows Trick in Unreal Engine - Tom Looman](https://www.tomlooman.com/unreal-engine-textured-shadow/)
![[Pasted image 20221214221848.png]]
-   有时你想要的功能**必须多次重复，而重复次数未知**，仅通过表达式几乎是不可能做到的。

**注意：默认的函数以及材质节点都是在后台得到很好优化的，非以上两种情况尽量不用custom节点

### GlobalShader
[新建全局着色器为插件 | 虚幻引擎文档 (unrealengine.com)](https://docs.unrealengine.com/4.27/zh-CN/ProgrammingAndScripting/Rendering/ShaderInPlugin/QuickStart/)
全局着色器一个项目只能存在一个，因此不能用于常规的表面材料。**需要重新编译引擎**。
通常用于：
1. 任何后期处理相关的，如热成像或夜视效果
2. 将高级动画效果渲染到Render Target
3. 涉及与光照或着色存在不同交互的任何操作，如风格化渲染
4. 移动端性能优化

### 使用方法和工作流

组合这六种工具的不同方法
- 仅材质编辑器，不适用于多人项目。
- 函数-材质编辑器-材质实例，推荐
- 材质图层-材质编辑器
- HLSL和CollectingParam集合

项目一般不会把六种工具一起使用，这会增加复杂性。通常必须在大量实例流程与大量图层流程之间二选一，不要一半用实例一半用图层。

**材质函数-材质编辑器-材质实例**
![[Pasted image 20221214225359.png]]

**材质函数-材质图层-材质编辑器-材质实例**
![[Pasted image 20221214230423.png]]


-   材质图层比材质实例更加灵活，比如其中一个模型的材质实例需要自发光效果，就需要在主材质里面开启自发光功能，对于“材质函数-材质编辑器-材质实例”这种做法效率就不高。
![[Pasted image 20221214230550.png]]
-   修改全局模型的色相并且全局添加水渍，就是材质图层的弱项（需要每个材质一一修改），视频中提供了一个方法，**使你在使用材质图层时，也可以频繁统一修改一大类材质的某个属性：在项目开始时就将通用图层嵌入所有材质。**
1.  创建一个材质函数命名为"GeneralMaterialLayer"，保持默认![[Pasted image 20221214230920.png]]
2.  然后加入你需要统一修改的材质里 ![[Pasted image 20221214230946.png]]
3.  当你需要统一添加新属性时，在材质函数"GeneralMaterialLayer"中添加![[Pasted image 20221214230855.png]]


# C 官方文档
## 材质编辑器Details
### 1 高级材质属性
Details->Material->Adcanced
![[Pasted image 20230118145425.png]]
**贴花响应（Decal Response）**
此属性定义了材质对DBuffer贴花的响应（影响外观、性能和纹理/样本使用）。你可以在基元primitive（例如静态网格体）上禁用非DBuffer贴花

<font color="#ff0000">不透明遮罩剪切值（Opacity Mask Clip Value）</font>
此属性是遮罩材质的OpacityMask输入根据每个像素进行剪切的参考值。高于OpacityMaskClipValue的任何值将符合要求，像素将被绘制（不透明）；而低于OpacityMaskClipValue的任何值则不符合要求，像素将被丢弃（透明）。

<font color="#ff0000">允许负自发光颜色（Allow Negative Emissive Color）</font>
材质是否应允许输出负自发光颜色值。只有 **无光照** 材质支持此属性。

**自定义UV数量（Num Customized UVs）**
此属性设置要显示的自定义UV输入的数量。未连接的自定义UV输入只通过顶点UV。

<font color="#ff0000">生成球形粒子法线（Generate Spherical Particle Normal's）</font>
围绕使用此材质的粒子系统旋转时，此属性会生成保持球形的表面法线。这适用于体积粒子系统，因为sprite会固定旋转朝向摄像机。通过此选项，它们将拥有更似球形的体积外观。

**切线空间法线（Tangent Space Normal）**
使用切线空间法线

**自发光（动态区域光）（Emissive(Dynamic Area Light)）**
如启用，材质的自发光颜色会注入光传播体积。

**完全粗糙（Fully Rough）**
强制材质为完全粗糙。这样做可以节省很多材质指令和一个采样器。

<font color="#ff0000">线框（Wire Frame）</font>
启用应用该材质的网格体的线框视图。

**着色率（Shading Rate）**
选择可变着色率的平台使用何种着色率。

**为天空（Is Sky）**
材质中使用的无光照（Unlit）和不透明（Opaque）混合模式可以用作穹顶网格体上的天空材质。启用后，这些网格体不会接收来自空中透视的任何贡献。仍将应用高度雾和体积雾效果。

### 2 半透明度
Details->Translucency

**屏幕空间反射（Screen Space Reflections）**
启用此属性后，将支持**半透明材质上的屏幕空间反射（SSR）**。

**接触阴影（Contact Shadows）**
启用此属性后，将支持半透明材质上的接触阴影。

<font color="#ff0000">光照模式（Lighting Mode）</font>
这可以控制半透明（Translucency）在该材质中使用的光照模式。这特别适用于利用半透明（例如自投影烟雾或蒸汽）的粒子系统。
![[Pasted image 20230118150855.png]]
- **体积非定向（Volumetric NonDirectional）**
- 光照将针对体积计算，且没有方向性。此设置用于烟雾和灰尘等粒子特效。这是开销最低的逐像素光照法，但是材质法线并未纳入计算。

- **体积定向（Volumetric Directional）**
- 光照将针对体积计算，且拥有方向性，因此材质法线将纳入计算。请注意：默认粒子切线空间面向摄像机，因此启用 **GenerateSphericalParticleNormals** 能获取更有用的切线空间（在高级材质空间中开启）。

- **体积逐顶点非定向（Volumetric PerVertex NonDirectional）**
- 与体积非定向（Volumetric NonDirectional）相同，但光照只在顶点处计算，因此像素着色器的开销将大幅降低。请注意，光照仍然来自于一个体积纹理，所以它被限制在一定范围内。定向光源在远处将变得没有阴影。

- **体积逐顶点定向（Volumetric PerVertex Directional）**
- 与体积定向（Volumetric Directional）相同，但光照只在顶点处计算，因此像素着色器的开销将大幅降低。请注意，光照仍然来自于一个体积纹理，所以它被限制在一定范围内。定向光源在远处将变得没有阴影。

- **表面半透明体积（Surface Translucency Volume）**
- 将针对表面计算光照。光在一个体积中累积，因此结果是模糊而有限的距离，但逐像素的开销非常低。**适合在半透明表面（如玻璃和水）上使用**。仅支持漫反射光照。

- **表面前向着色（Surface Forward Shading）**
- 将为表面计算光照。适合在半透明表面（如玻璃和水）上使用。这是通过前向着色实现的，因此支持来自本地光源的镜面反射高光，但不支持许多纯延迟功能。这是 **开销最高** 的半透明光照法，因为每个光源的贡献都是逐像素计算。

**Advanced**
![[Pasted image 20230118152506.png]]

**响应式抗锯齿（Responsive AA (Ant aliasing)）**
小型移动对象（尤其是粒子）有时会被抗锯齿所消除；将此属性设为 **true**，便会使用另一种AA算法，此算法提供了更多定义。换言之，**如果你创建了一个暴风雪或类似的粒子系统，但觉得无法真正看到雪花，那就启用此属性，它会有所帮助**。但是，此属性应仅用于小型移动对象，因为它会在背景上产生锯齿瑕疵。

**移动单独半透明度（Mobile Separate Translucency）**
此属性表明材质将在单独半透明通道（Separate Translucency Pass）中渲染（这意味着，它不会受到景深的影响，并且需要在.INI文件中设置 **bAllowSeparateTranslucency**）。

<font color="#ff0000">禁用深度测试（Disable Depth Test）</font>
允许材质禁用深度测试，此属性只有在半透明混合模式下才有意义。禁用深度测试将使渲染明显变慢，因为被遮挡的像素无法进行Z剔除。

**仅写入透明度（Write Only Alpha）**
半透明通道是否将其透明度（且仅透明度）写入帧缓冲。

<font color="#ff0000">允许自定义深度写入（Allow Custom Depth Writes）</font>
编译其他着色器，允许半透明材质与自定义深度写入配合使用。

### 3 半透明自投影
Trannslucency Self Shadowing
![[Pasted image 20230118153223.png]]
半透明自身阴影是一种获得体积光照半透明对象（例如烟柱或蒸汽柱）的好方法。自投影分为两个主要部分：自身阴影密度（Self Shadow Density）和第二自身阴影密度（Second Self Shadow Density）。这两个部分的存在为变化提供了可能。你可以单独定义各个部分的密度，并使用它们之间的差异在整个自身阴影中获得你需要的模式。

**阴影密度比例（Shadow Density Scale）**
此属性设置了由该半透明材质投射到其他表面的阴影的密度。这有点像阴影的主比例；如果设为0，则没有任何阴影。当你将数值增加到1或更高时，投影和自身阴影都会变暗。

**自身阴影密度比例（Self Shadow Density Scale）**
设置该材质投射在自身上的阴影的密度。考虑烟雾柱中的阴影。

**第二密度比例（Second Density Scale）**
这是第二个自身阴影密度，可以设置变化。这个值和半透明自身阴影密度比例（Translucent Self Shadow Density Scale）之间形成了一个内部梯度。

**第二不透明度（Second Opacity）**
此属性设置了第二自身阴影的不透明度值，用于缩放自身阴影与第二自身阴影之间的梯度效应。

**反向散射指数（Backscattering Exponent）**
此属性控制使用次表面着色模型和半透明（Translucency）时使用的反向散射。较大的值会产生较小、较亮的反向散射高光。此值仅用于由定向光源形成的体积半透明阴影中。

**多重散射消光（Translucent Multiple Scattering Extinction）**
针对拥有体积半透明阴影的对象（如烟雾或蒸汽），此属性将给出一个彩色消光值（基本上相当于阴影颜色）。

**初始偏移（Start Offset）**
这是在半透明体中创建的自身阴影的世界空间偏移。数值越高，阴影离光源越远。

### 4 用途（Usage）
用途（Usage）标记可控制材质应用对象的类型。这些设置允许引擎为每个应用程序编译特殊版本。这些仅在使用 **表面材质域（Surface Material Domain）** 设置时有效。

在编辑器中，将为地图中已经存在的所有对象自动设置这些标记。举例而言，如果你有一个粒子系统，它使用放置在某个关卡某处的材质；当你在编辑器中加载该地图时，它将自动设置 **结合粒子系统使用（Used with Particle System）** 标记。你需要保存材质资产，才能让游戏在特定网格体上使用该材质。

默认根据在编辑器中应用材质的对象来自动设置用途标志

### 5 后期处理材质
Post Process Material
首先将材质域设置为Post Process
![[Pasted image 20230118153741.png]]
**可混合位置（Blendable Location）**
如果此材质用作后期处理材质，则可以通过此属性来控制材质在色调映射之前还是之后计算。如果你的材质将用于修改后期处理的颜色，那么此属性很重要。

**输出透明度（Output Alpha）**
如果启用，可混合对象将输出透明度。

**可混合优先级（Blendable Priority）**
当多个节点同时出现，该参数将决定它们的优先级，以及它们是否会合并。仅当材质域设置为 **后处理（PostProcess）** 时使用。

**为可混合（Is Blendable）**
允许关闭可混合性。仅当材质域（Material Domain）设为后期处理（Post Process）时才使用。

**高级属性**

<font color="#ff0000">启用模板测试（Enable Stencil Test）</font>
仅针对通过自定义深度/模具缓冲模具测试的像素选择性地执行材质后期处理。未通过模具测试的像素将填充之前的材质后期处理输出或场景颜色。

**模板对比（Stencil Compare）**
使用下拉菜单比较模具测试。

**模板参考值（Stencil Ref Value）**
设置模具参考值。

### 6 折射Refraction
**折射模式（Refraction Mode）**
此模式控制你材质将采用的折射类型。

- **折射率（Index Of Refraction）**
- 根据进入介质的摄像机向量计算折射，该介质的折射率由Refraction材质输入定义。新介质的表面由材质的法线定义。在此模式下，从侧面看，平面将拥有恒定的折射偏移。这是折射物理模型，但会导致在场景颜色纹理外读取。因此不适用于对大折射表面（例如水面）。

- **像素法线偏移（Pixel Normal Offset）**
- 基于逐像素法线与逐顶点法线之间的差异计算场景颜色的折射偏移。在此模式下，法线为默认值（0,0,1）的材质永远不会引起折射。此模式仅对切线空间法线有效。折射材质输入可缩放偏移量，值1.0映射为无折射，值2映射为偏移量缩放1.0。这是非物理折射模型，但适用于类似于水面的大型折射表面，因为偏移量必须保持很小，以免读取场景外的颜色。
[在虚幻引擎中使用像素法线偏移实现折射 | 虚幻引擎5.1文档 (unrealengine.com)](https://docs.unrealengine.com/5.1/zh-CN/refraction-using-pixel-normal-offset-in-unreal-engine/)
**折射偏差（Refraction Bias）**
此属性弥补折射测试的深度。当折射值导致附近不需要的对象（通常在半透明对象前面）呈现到材质表面时，此属性十分实用。但较高的数值将开始分离折射，造成表面和折射对象之间出现可见的分裂。此属性在将某个表达式节点连接到Refraction输入之前不会启用。

## 分层材质
- 很高的性能开销
- 所有层会同时渲染，然后混合。
**可以应用多个材质的时候就不要使用分层材质**。如果你必须逐像素控制材质的放置，则使用分层材质函数或[材质层](https://docs.unrealengine.com/5.0/zh-CN/using-material-layers-in-unreal-engine)。

尽管将多个单独的材质压缩为一个材质会减少绘制调用，但产生的分层材质通常开销太大，**无法在移动平台上使用**。

## 材质曲线
### 曲线线性颜色资源
**曲线线性颜色（Curve Linear Color）** 用于存储插值RGBA点，在给定范围内将评估这些点以产生能够与材质搭配使用的颜色渐变。  
![[d1493a8f57afd86457584fa5aa6c4be6_MD5.jpg]]
>用曲线线性颜色资源创建的曲线梯度示例
![[Pasted image 20230119191529.jpg]]
### 曲线图集
**曲线图集** 资源用于存储和访问多个曲线资源，使你能够管理梯度查找表（LUT）。曲线图集资源编辑器类似于纹理编辑器，你可以用来调整亮度、饱和度、色调等设置。
![[Pasted image 20230119192240.jpg]]
要向曲线图集添加新的梯度曲线，单击 **加号**（**+**）图标以添加数组元素
![[Pasted image 20230119192322.jpg]]
### 与材质搭配使用
**曲线图集行参数（Curve Atlas Row Parameter）**
![[Pasted image 20230119192417.jpg]]

> [!NOTE] 
> 该节点就像标量参数一样，让你可以使用动态材质实例（MID），通过蓝图将这些实例用于图集UV的V轴，但该节点会为你执行采样任务，并返回矢量3和R、G、B和A遮罩。
### 蓝图访问曲线图集
在蓝图中，你可以使用 **获取曲线位置（Get Curve Position）** 节点在动态材质实例上设置标量参数值。获取曲线位置（Get Curve Position）以曲线图集为输入，将标量值传递到 **设置标量参数值（Set Scalar Parameter Value）**，然后返回一个布尔值来指示是否在图集中找到了曲线。
![[Pasted image 20230119193124.jpg]]
## 自定义UV
[虚幻引擎中的自定义UV | 虚幻引擎5.1文档 (unrealengine.com)](https://docs.unrealengine.com/5.1/zh-CN/customized-uvs-in-unreal-engine-materials/)
> [!NOTE] 
> 目前，仅针对特定的元件类型实现了自定义 UV：静态网格、骨骼网格、BSP、景观和网格粒子。尤其是，**精灵粒子尚不支持Custom UV**。

Detail设置开启Custom UV，如果 **自定义 UV 数目（Num Customized UVs）** 设置为大于 0 的数目，那么主材质节点上会显示"CustomizedUVs引脚。
![[Pasted image 20230119202357.png]]
![[Pasted image 20230119202449.png]]

CustomUV仅在顶点着色器中运行，可以提高性能。
通过修改下面的uv就会改变对上面纹理的采样uv

**等价操作**
使用vertex Interpolator
![[Pasted image 20221214234216.png]]
**这两种方法功能在于将纹理uv改为在顶点着色器中计算，而不是在片元着色器中。**

# C 材质宝典
## 17 OpenGL和DirectX法线判断技巧与转换
![[Pasted image 20221215150037.png]]
UE默认左手坐标系，和DirectX相同，和OpenGL相反
Maya默认右手坐标系
![[Pasted image 20221215150133.png]]
只有中轴代表的Y轴方向不同，我们只需要在UE中将法线贴图G通道反向
将OpenGL贴图转换：
![[Pasted image 20221215150709.png]]

