
## 2、光照探针

灯光设置为 Mixed，光照探针烘焙的是 “环境光” 与“光能传递的效果”（间接照明）

创建光照探针，可以通过按钮编辑、复制

![[db018a46c2e28732d311dd1d8b8669f4_MD5.jpg]]

开启灯光烘焙

![[0e35977b90b0de7be09ed5920f68f1f7_MD5.jpg]]

读取光照探针 Shader

```
Shader "Universal Render Pipeline/CRLuo/CRLuo_URP_11_LightProde" //URP路径名
{
     //面板属性
    Properties
    {

    }
        SubShader
        {
			//渲染类型为URP
           Tags { "RenderType" = "Opaque" "RenderPipeline" = "UniversalRenderPipeline"}
			//多距离级别
            LOD 100 


		 Pass
        {

            HLSLPROGRAM  //URP 程序块开始

			//顶点程序片段 vert
			#pragma vertex vert

			//表面程序片段 frag
            #pragma fragment frag

			//URP函数库
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
			

			CBUFFER_START(UnityPerMaterial) //变量引入开始

            CBUFFER_END //变量引入结束

			//定义模型原始数据结构
            struct VertexInput          
            {
				//获取物体空间顶点坐标
                float4 positionOS : POSITION; 

				//获取模型UV坐标
                float2 uv : TEXCOORD0;

					//模型法线
				float4 normalOS  : NORMAL;
            };


			//定义顶点程序片段与表i面程序片段的传递数据结构
            struct VertexOutput 
            {
			   //物体视角空间坐标
                float4 positionCS : SV_POSITION; 
				
				//UV坐标
                float2 uv : TEXCOORD0;
				 float3 positionWS: TEXCOORD1;
				//世界空间法线
				float3 normalWS : TEXCOORD2;

            };

			
				//顶点程序片段
                VertexOutput vert(VertexInput v)
                {
				   //声明输出变量o
                    VertexOutput o;


					//输入物体空间顶点数据
					VertexPositionInputs positionInputs = GetVertexPositionInputs(v.positionOS.xyz);
					//获取裁切空间顶点
                    o.positionCS = positionInputs.positionCS;

                    o.positionWS = positionInputs.positionWS;
					
										//输入物体空间法线数据
					VertexNormalInputs normalInputs = GetVertexNormalInputs(v.normalOS.xyz);

					//获取世界空间法线
					o.normalWS = normalInputs.normalWS;

					//输出数据
                    return o;
                }

				//表面程序片段
                float4 frag(VertexOutput i): SV_Target 
                {
				////贴图法线转换为世界法线
				float3 normalWS = i.normalWS;

				//创建输出颜色变量
                   float4 _Color =1;
				   //获取光照探针颜色
				   _Color.rgb = SampleSH(normalWS);
                    return  _Color;
                }

                ENDHLSL  //URP 程序块结束
            
        }
    }
}
```

## 3、反射探针

![[53c6b09c4ad01b7295f0649b42361379_MD5.jpg]]

反射探针 Shader

```
Shader "Universal Render Pipeline/CRLuo/CRLuo_URP_12_ReflectCube" //URP路径名
{
     //面板属性
    Properties
    {
	      _ReflectBlur("反射模糊", Range( 0 , 1)) = 0
    }
        SubShader
        {
			//渲染类型为URP
           Tags { "RenderType" = "Opaque" "RenderPipeline" = "UniversalRenderPipeline"}
			//多距离级别
            LOD 100 


		 Pass
        {

            HLSLPROGRAM  //URP 程序块开始

			//顶点程序片段 vert
			#pragma vertex vert

			//表面程序片段 frag
            #pragma fragment frag

			//URP函数库
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
			

			CBUFFER_START(UnityPerMaterial) //变量引入开始

			float _ReflectBlur;

            CBUFFER_END //变量引入结束

			//定义模型原始数据结构
            struct VertexInput          
            {
				//获取物体空间顶点坐标
                float4 positionOS : POSITION; 

				//获取模型UV坐标
                float2 uv : TEXCOORD0;

					//模型法线
				float4 normalOS  : NORMAL;
            };


			//定义顶点程序片段与表i面程序片段的传递数据结构
            struct VertexOutput 
            {
			   //物体视角空间坐标
                float4 positionCS : SV_POSITION; 
				
				//UV坐标
                float2 uv : TEXCOORD0;

				//世界空间顶点
				float3 positionWS :  TEXCOORD1;
				//世界空间法线
				float3 normalWS : TEXCOORD2;
            };

			
				//顶点程序片段
                VertexOutput vert(VertexInput v)
                {
				   //声明输出变量o
                    VertexOutput o;


					//输入物体空间顶点数据
					VertexPositionInputs positionInputs = GetVertexPositionInputs(v.positionOS.xyz);
					//获取裁切空间顶点
                    o.positionCS = positionInputs.positionCS;
					//获取世界空间顶点
					o.positionWS = positionInputs.positionWS;
					
					//输入物体空间法线数据
					VertexNormalInputs normalInputs = GetVertexNormalInputs(v.normalOS.xyz);

					//获取世界空间法线
					o.normalWS = normalInputs.normalWS;

					//输出数据
                    return o;
                }

				//表面程序片段
                float4 frag(VertexOutput i): SV_Target 
                {
				//贴图法线转换为世界法线
				half3 normalWS = i.normalWS;
				//摄像机方向
				float3 viewDir = normalize(GetCameraPositionWS().xyz-i.positionWS);
				//获取当前视角反射
				float3 reflectDirWS = reflect(-viewDir,normalWS);
				//读取反射探针贴图
				   float4 _CubeMapColor = SAMPLE_TEXTURECUBE_LOD(unity_SpecCube0, samplerunity_SpecCube0, reflectDirWS,_ReflectBlur*8);

					//输出颜色
                    return  _CubeMapColor;
                }

                ENDHLSL  //URP 程序块结束
            
        }
    }
}
```

## 4、烘焙光照

光照烘焙物体，必须是静态的，不可移动的物体。

设置灯光为烘焙

![[0e35977b90b0de7be09ed5920f68f1f7_MD5.jpg]]

设置被烘焙对象为 Static（静态）

![[47d705aa5ef48a041e50de3ab5b3c229_MD5.jpg]]

打开灯光烘焙窗口

![[bcfb6a72452bc567ff33117f15b041c0_MD5.jpg]]

烘焙光照

![[abfc441748d19f473a9973a7c8625915_MD5.jpg]]

查看烘焙结果

![[30c037dfab4531dfacd74fd22d98821e_MD5.jpg]]

如果原始模型没有 2 套灯光 UV（平铺 UV），需要开启允许烘焙光照二套 UV。

![[daaa669ffa0f5c807558a8a9e08cd6b7_MD5.jpg]]

光照烘焙 Shader

```
Shader "Universal Render Pipeline/CRLuo/CRLuo_URP_13_LightBaked" //URP路径名
{
     //面板属性
    Properties
    {
    }
        SubShader
        {
			//渲染类型为URP
           Tags { "RenderType" = "Opaque" "RenderPipeline" = "UniversalRenderPipeline"}
			//多距离级别
            LOD 100 


		 Pass
        {

            HLSLPROGRAM  //URP 程序块开始

			//顶点程序片段 vert
			#pragma vertex vert

			//表面程序片段 frag
            #pragma fragment frag
		#pragma multi_compile _ LIGHTMAP_ON

			//URP函数库
            #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
			      #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"

			CBUFFER_START(UnityPerMaterial) //变量引入开始

            CBUFFER_END //变量引入结束

			//定义模型原始数据结构
            struct VertexInput          
            {
				//获取物体空间顶点坐标
                float4 positionOS : POSITION; 

				//获取模型UV坐标
                float2 uv : TEXCOORD0;
				float2 uvLM : TEXCOORD1;
					//模型法线
				float4 normalOS  : NORMAL;
				//UNITY_VERTEX_INPUT_INSTANCE_ID
            };


			//定义顶点程序片段与表i面程序片段的传递数据结构
            struct VertexOutput 
            {
			   //物体视角空间坐标
                float4 positionCS : SV_POSITION; 
				
				//UV坐标
                float2 uv : TEXCOORD0;

				//世界空间顶点
				float3 positionWS :  TEXCOORD1;
				//世界空间法线
				float3 normalWS : TEXCOORD2;
				float2 uvLM : TEXCOORD3;

				float3 vertexSH   : TEXCOORD4;
            };

				//顶点程序片段
                VertexOutput vert(VertexInput v)
                {
				   //声明输出变量o
                    VertexOutput o;


					//输入物体空间顶点数据
					VertexPositionInputs positionInputs = GetVertexPositionInputs(v.positionOS.xyz);
					//获取裁切空间顶点
                    o.positionCS = positionInputs.positionCS;
					//获取世界空间顶点
					o.positionWS = positionInputs.positionWS;
					
										//输入物体空间法线数据
					VertexNormalInputs normalInputs = GetVertexNormalInputs(v.normalOS.xyz);

					//获取世界空间法线
					o.normalWS = normalInputs.normalWS;

					OUTPUT_LIGHTMAP_UV(v.uvLM, unity_LightmapST, o.uvLM);

					//输出数据
                    return o;
                }

				//表面程序片段
                float4 frag(VertexOutput i): SV_Target 
                {

				//贴图法线转换为世界法线
				float3 normalWS = i.normalWS;

				half3 bakedGI = SAMPLE_GI(i.uvLM, i.vertexSH, normalWS);

				return float4(bakedGI,1);

                }

                ENDHLSL  //URP 程序块结束
            
        }
    }
}
```