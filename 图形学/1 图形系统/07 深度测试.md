
# 3.3 深度测试
![[Pasted image 20221031204347.png]]
## 一、什么是深度测试

-   帮助我们处理物体的遮挡关系
### 1. 从渲染管线理解

-   ![[59e936613d6e957a313031be895df47d_MD5.jpeg]]
-   深度测试同样位于**逐片元操作过程**中，在**模板测试之后**，**透明度混合之前**。
### 2. 从逻辑上理解
深度缓冲：
![[Pasted image 20221031203329.png]]
颜色缓冲：
![[Pasted image 20221031203332.png]]
-   **理解：**

-   和模板测试差不多，都是通过一个比较来判断一系列操作
-   图 1：
-   开启深度写入，当前深度值和深度缓冲区的值作比较，如果通过就写入深度，不通过就忽略深度

-   图 2：
-   当前深度值和深度缓冲区中的值做比较，如果通过就写入颜色缓冲区，不通过就不写入颜色缓冲区

### 3. 从书面概念上理解

-   **深度测试的概念**

-   就是针对当前屏幕上（更准确的说是**FrameBuffer（帧缓冲区）**）对应的像素点，将对象自身的深度值与当前深度缓冲区的深度值做比较，如果通过了，这个对象在该像素点才会将颜色写入颜色缓冲区。

### 4. 从发展上看
-   ![[58a9ae0fb86496f5c18efc1ebd30bc99_MD5.svg]]
-   我们要渲染一个场景的话，通常会有多个物体。
-   首先要**控制渲染顺序**

-   画家算法：
-   这里是指油画的画法，也就是画一幅油画，是从远处开始画，然后近处的东西一点点叠加在上面（GAMES 系列的课提到过多次）
-   存在的问题：例如一列物体，最前面的物体最大，站在正前面看只能看到最前面的物体，这样一来后边的就不用画了，不然就是性能浪费（OverDraw）。

> [!NOTE] 
> OverDraw: 重复渲染同一个像素

-   **Z-Buffer 算法：**
-   通过深度缓冲区来控制渲染顺序
-   **控制 Z-Buffer 对深度的存储**
-   例如：什么时候更新深度缓冲区、什么时候使用深度缓冲区
-   **两个典型的功能：**
-   **Z Test**
-   **Z Write**

-   **控制不同类型物体的渲染顺序**
-   透明物体
-   不透明物体
-   **渲染队列**（很有用的概念，后边会讲）

-   **减少 OverDraw
-   Early-Z，一种优化手段，后边会讲
[[3 进阶应用#3.5 Early-z和Z-prepass]]
-   Z-cull（优化手段）
-   Z-check（确认正确遮挡关系）

## 二、基本原理和使用方法
### 1. Z-Buffer（深度缓冲区）

-   和颜色缓冲区一样，在每个片段中存储了信息，并且通常和颜色缓冲有着一样的宽度和高度。深度缓冲是由窗口系统自动创建的，它会以 16、24、32 位 float 形式存储深度值。**大部分系统中深度值是 24 位的**，另外 8 位存模板缓冲。

> [!NOTE] 颜色缓冲区
> 就是最终在显示屏硬件上显示颜色的 GPU 显存区域了，这个缓冲区储存了每帧更新后的最终颜色值，图形流水线经过一系列测试，包括片段丢弃、颜色混合等，最终生成的像素颜色值就储存在这里，然后提交给显示硬件显示。

-   **Z-Buffer 中存储的是当前的深度信息，对于每个像素存储一个深度值。**
-   我们可以通过 Z-Write 、Z-Test 来调用 Z-Buffer，来达到想要的渲染效果。

### 2. Z Writer（深度写入）

-   深度写入包括两种状态

-   ZWrite On 、 ZWrite Off
-   当我们开启深度写入，物体被渲染时针对物体在屏幕（FrameBuffer）上每个像素的深度都写入到深度缓冲区。
-   关闭深度写入状态，物体的深度就不会写入深度缓冲区。

-   除了 ZWrite 的是否写入深度缓冲区，更重要的是：是否通过深度测试，也就是 Z-Test。如果 Z-Test 都没通过，也就不会写入深度了。

-   也就是说，**只有 ZTest 和 ZWrite 都可行的情况下才写入深度缓冲区**

-   综上，ZWrite 有 On、Off 两种情况；ZTest 有通过、不通过两种情况，两者结合的四种情况如下：

**深度测试失败，一定不写入**
 ![[Pasted image 20221031204208.png]]
### 3. Z-Test 的比较操作
![[Pasted image 20221031204303.png]]
-   **默认情况下**：

-   Z Write：On
-   Z Test：LEqual

-   深度缓冲区一开始为无穷大
### 4. Unity 的渲染队列
-   **Unity 内置的几种渲染队列**：
![[Pasted image 20221031204519.png]]
-   **按照渲染顺序从先到后排序，队列数越小，越先渲染；反之同理。**

-   **Unity 中设置渲染队列**：

-   语法：Tags { “Queue” = “渲染队列名”}
-   默认是 Geometry

-   Unity 中**不透明物体的渲染顺序**：从前往后
-   **也就是说深度小的先渲染，其次再渲染深度大的**

-   Unity 中**透明物体的渲染顺序**：从后往前（类似画家算法，会造成 OverDraw）

-   可以在 shader 的 Inspector 面板中查看渲染队列相关属性
![[Pasted image 20221031204940.png]]

### 5. 简述 Early-Z 技术

-   Early-Z 是位于三角形遍历之后、逐片元操作之前的。
-   传统的渲染管线中，ZTest 是在 Blending 阶段，这时进行深度测试的话，所以对象的像素着色器都会计算一遍，没有性能提升，只是为了得到正确的效果，造成了大量的无用计算。（**深度测试失败的片元是已经经过计算的片元，也就是说：到在一步测试不通过而被抛弃，前边的计算就是无用功了**）
-   为了减少这些不必要的计算，**现代 GPU 运用了 Early-Z 技术，在顶点和片元阶段之间（光栅化之后，片元着色器之前）进行一次深度剔除 Z-Cull（如下左图黑框部分）**。
![[Pasted image 20221031205146.jpg]]
![[Pasted image 20221031205054.png]]
-   如果这次像素被剔除，那就不用在片元着色器中作无关紧要的计算了，这样一来就会带来性能提升。
-   最终的 ZTest 仍然要进行，以保证正确的遮挡关系。
-   如右图前一次的 Z-Cull 是为了裁剪达到性能优化的目的，后一次的 Z-check 是为了保证正确的遮挡关系。

### 6. 深度值
#### 正确的理解深度值的概念

-   首先先了解一下模型在渲染管线中的几次空间变换
![[Pasted image 20221031205336.png]]
-   模型一开始所在的模型空间：**无深度。**
-   通过 M 矩阵变换到世界空间，此时模型坐标已经变换到了齐次坐标（x，y，z，w）：**深度存在 z 分量**。
-   通过 V 矩阵变换到观察空间（摄像机空间）：**深度存在 z 分量（线性）**
-   通过 P 矩阵变换到裁剪空间：**深度缓冲中此空间的 z/w 中（已经变成了非线性的深度）**
-   最后通过一些投影映射变换到屏幕空间

#### 为什么深度缓冲区中要存储一个非线性的深度？
1. 正确的投影特性的非线性深度方程是和 1/z 成正比的。这样一来会有如下效果：<font color="#ff0000">在 Z 很近的时候有高精度，Z 很远的时候低精度</font>。
![[LearnOpenGL#深度值精度]]


-   **平截头体**：又称视景体、视锥，是三维世界中在屏幕上可见的区域，即虚拟摄像机的视野
-   下图中红框的位置是平截头体，就是摄像机拍摄的范围。
![[Pasted image 20221031211925.png]]
#### 另一个原因：Z-Fight-深度冲突
![[LearnOpenGL#深度冲突]]

## 三、渲染顺序解析
![[Pasted image 20221031223142.png]]

-   场景中有三个正方体，并赋予了不同的颜色。正常的情况应该是从前到后依次为蓝、绿、红
- ### 图 1 详解：正常渲染顺序
- ![[Pasted image 20221031223159.png]]
-   梳理渲染过程：

-   没渲染时，此时 Unity 的深度缓冲区默认值为无穷大
-   渲染蓝色正方体
![[Pasted image 20221031223209.png]]
-   相对于默认深度缓冲区的无穷大，肯定是小于等于，所以测试通过

-   渲染绿色正方体

-   此时蓝色物体位置的深度缓冲区的值已经不是无穷大了，其它位置还是
-   注：深度缓冲区和颜色缓冲区都是相对于片元来讲的（片元可以理解为未完成的一个像素，还处于渲染管线中的像素）
-   绿色正方体进行深度测试，深度测试同样是 LessEqual，并且绿色的深度值比蓝色正方体的大。
-   结果就是：两个正方体重叠部分是大于深度缓冲区的，也就是测试不通过，所以重叠部分没有写入绿色，还是蓝色的
-   没有重叠部分，深度当然比无穷大小，所以写入，渲染出来了绿色正方体未重叠的部分。

-   红色同理。
### 图 2 详解：关闭前排正方体的深度写入

![[b86429618c9afad29395410cb346a3f1_MD5.png]]

  
●梳理渲染过程：  
○设置：将蓝色正方体的深度写入 ZWrite 关掉了；  
○思路：第一个蓝色正方体的渲染时，测试通过，但是并没有写入深度。  
○也就是说，渲染完蓝色正方体时，深度缓冲区的值还是无穷大。  
○这就是蓝绿重叠部分，显示绿色的原因。
### 图 3 详解：

-   相较于图 2，只是把绿色正方体的 ZTest 改为了 always
-   无论是 LessEqual 还是 always，测试都通过，所以效果和图2一样

### 图 4 详解：改变 ZTest 条件

-  ![[Pasted image 20221031223413.png]]

-   将红色正方体的 ZTest 也改为了 always，这样一来红色正方体的深度测试也是一直通过，并且写入。
-   因为是从前往后渲染的，所有依次为蓝、绿、红，深度缓冲区中的值也是后边渲染的
-   可以理解为后边遮住前边的效果。

### 图 5 详解：改变渲染队列

-   ![[Pasted image 20221031223509.png]]
-   相对于图 4，改变了绿色正方体的渲染队列为 Geometry+1
-   此时的帧缓冲区面板如下
![[Pasted image 20221031223515.png]]
-   尽管场景中绿色正方体在红色正方体前面，但是因为队列+1，它的渲染顺序变为了红色正方体后

-   也就是说，**渲染队列优先级 > 透明物体的渲染顺序（从前到后）**

### 图 6 详解：再次理解 ZTest 条件

![[Pasted image 20221031223523.png]]
-   相对于图 1，将绿色正方体的 ZTest 改为了 Greater，
-   也就是说蓝色正方体和绿色正方体重叠部分，大于模板缓冲区的部分通过测试，写入模板缓冲区
-   结果就是重叠部分为绿色，而未重叠部分的深度当然小于无穷大，所以没通过测试，自然也就不渲染。
-   红色部分正常。
#### shader 自定义面板
![[Pasted image 20221031223721.png]]
```c
Properties
    {
        _Color ("Color", Color) = (1,1,1,1)
        [Enum(Off, 0, On, 1)]_ZWriteMode("Zwrite Mode",Float) = 1
        [Enum(UnityEngine.Rendering.CompareFunction)] _ZComp("ZTest Comp",Float) = 4 //第四个选项
    }
    SubShader
    {
        Tags { "RenderType"="Opaque" "Queue" = "Geometry"}
        ZWrite [_ZWriteMode]
        ZTest  [_ZComp]
        Cull Off
        
        Pass
        {
	        ......
        }
```

## 四、 X-Ray 效果
![[Pasted image 20221031231326.png]]
### 实现思路

-   分为三部分：前边的墙、被墙挡住的 X-Ray 效果部分、高出墙部分的物体
-   回想一下前边 6 张图，哪张图是前边渲染完，后边渲染显示在先渲染完前边的？ --->图 6
-   也就是说，**X-Ray 效果部分我们使用到了 ZTest ：Greater，深度写入关闭**
-   **高出墙体部分是默认的渲染：LessEqual、ZWrite On**
- 两个 passd 对物体绘制两次
### shader
![[Pasted image 20221031231520.png]]

![[Pasted image 20221031231522.png]]

![[Pasted image 20221031231524.png]]

![[Pasted image 20221031231526.png]]

![[Pasted image 20221031231528.png]]

![[Pasted image 20221031231531.png]]
-   **代码理解**

-   写 CGINCLUDE 的好处：将顶点和片元着色器写在里边，在多 passshade 的时候，直接调用就可以了。（跟 C++头文件类似）

-   X-Ray 绘制部分
-   和之前实现思路相同，ZWrite Off，ZTest Greater
-   Cull back 是剔除背面，为了优化
-   Blend     SrcAlpha One ：由于有一个透明的效果，除了上边的，还需要一步 Blend，来做透明度混合
-   渲染类型和渲染队列为 Transparent

-   正常绘制部分略
## 五、粒子系统中的深度测试

-   创建一个粒子系统 ParticleSystem，可以看到默认的是透明的

![[Pasted image 20221031232902.png]]
-   为了加深理解，我们自己来复刻一下这个粒子系统的效果

-   我们自己创建一个材质，给到粒子上

-   此时粒子系统变成了这样

![[Pasted image 20221031232935.png]]
-   创建一个 shader（Unlit），把粒子的贴图选上，附到材质上，效果如下（是不透明的），这显然不是我们要的效果

![[Pasted image 20221031232947.png]]

-   打开 shader 修改代码

-   首先回顾前边说的：<font color="#ff0000">Unity 中默认的 ZWrite On、ZTest 是 LessEqual、渲染队列是 Geometry</font>
-   我们想要让粒子透明，就需要做如下配置

-   渲染队列改为透明物体的渲染队列：Transparent
-   ZWrite Off，对于透明物体，是有相互叠加关系的，所以关掉写入
-   ZTest 默认（LessEqual），对于透明物体是这样的：如果透明物体前有不透明物体，此时透明物体看不到；如果透明物体后面有不透明物体，此时透明物体可以看到。
-   要渲染半透明物体，还要进行 Blend 操作：Blend One One（加法混合，叠加效果的显示）

-   修改完成后效果如下：（正是我们想要的效果）
![[Pasted image 20221031233100.png]]
## 六、总结

-   最重要的两个值：当前深度缓冲区的值（ZBufferValue） 和深度参考值（ReferenceValue）。通过比较操作还实现理想的渲染效果
-   **Unity 中的渲染顺序**：
-   先渲染不透明物体（从前到后），再渲染透明物体（从后往前）

-   **Unity 中的默认条件：**
-   ZWrite：On
-   Ztest：LessEqual
-   渲染队列：Geometry（2000）

-   通过对 ZWrite 和 ZTest 的相互组合配置来控制**半透明物体的渲染（关闭深度写入，开启深度测试，透明度混合）**

-   引入 Early-Z 之后深度测试相关的内容（Z-Cull、Z-Check）
-   深度缓冲区中存储的深度值为[0，1]的非线性值
## 七、扩展
![[Pasted image 20221031233631.png]]
**参考资料**
参考一下作者作业部分：[3.1 模板测试和深度测试 (yuque.com)](https://www.yuque.com/sugelameiyoudi-jadcc/okgm7e/nqoaio)

其他：
-   [https://blog.csdn.net/puppet_master/article/details/53900568](https://blog.csdn.net/puppet_master/article/details/53900568)
-   [https://learnopengl-cn.readthedocs.io/zh/latest/04%20Advanced%20OpenGL/01%20Depth%20testing/](https://learnopengl-cn.readthedocs.io/zh/latest/04%20Advanced%20OpenGL/01%20Depth%20testing/)
-   [https://docs.unity3d.com/cn/2018.4/Manual/SL-CullAndDepth.html](https://docs.unity3d.com/cn/2018.4/Manual/SL-CullAndDepth.html)
-   [https://blog.csdn.net/yangxuan0261/article/details/79725466](https://blog.csdn.net/yangxuan0261/article/details/79725466)
-   [https://roystan.net/articles/toon-water.html](https://roystan.net/articles/toon-water.html)

# 3.5 Early-z 和 Z-prepass

### 一、深度测试：Depth Test

#### 1. 回顾深度测试的内容
-   深度测试位于逐片元操作中、模板测试后、透明度混合前
-  ![[8369c261f03a16b5b6e9645d9e6b6786_MD5.png]]

-   深度测试可以解决：物体的可见遮挡性问题

-   我们可以用一个例子说明
![[Pasted image 20221208224546.png]]
![[Pasted image 20221208224556.png]]
-   上图的解释：

-   首先先渲染紫色三角形，紫色三角形的深度值为 5，当渲染它的时候，它与深度缓冲区中的∞做比较，因为默认的 test 比较条件为 LEqual，所以 5 小于∞，并且写入了深度缓冲器
-   之后进行黄色三角形的渲染，和上一步同理，会进行深度对比并进行相关操作，渲染完成后的结果如右图下边所示

**深度测试流程图**

-   具体每一步都可以对应之前讲的笔记理解
![[Pasted image 20221208224640.png]]

### 2. 深度测试带来的问题

-   前边已经说过很多次了，就是性能浪费、OverDraw
![[Pasted image 20221208224714.png]]
-   简单地概括就是
-   在**深度测试前**计算过的片元，有一些通过不了深度测试将会被直接抛弃（图中的红色片元），那么之前做得计算就都是无效计算了。
-   这个问题的解决方法就是：**early-z**

### 二、提前深度测试：early-z

#### 1. Early-Z 的内容
-   是在传统管线中的光栅化阶段之后、片元着色器之前加的一步操作。
![[Pasted image 20221208224906.png]]
![[Pasted image 20221208224921.png]]
-   图中的例子：

-   片元 1 写入深度后，在渲染片元 2、3 的时候，会进行**提前深度测试（z-cull）**，因为没有通过，所以这两个片元不会被计算

-   **区分两次深度测试**
-   提前的深度测试叫作**Z-Cull**
-   后续的深度测试为了确定正确的遮挡关系，叫作**Z-Check**

-   也就是在计算之前就做一次深度测试，如果不通过就直接不计算了，这样就避免了无效的计算

-   **补充**：
-   Early-Z 同样可以搭配使用模板测试

#### 2. Early-Z 失效的情况

-   ①开启 Alpha Test 或 clip/discard 等手动丢弃片元操作
-   通常 Early-Z 不仅会进行深度测试，还要进行深度写入
-   例如以下情况：
-   如果经过 AlphaTest，前面渲染的片元被丢弃了（但写入了深度），那么后续的像素都将无法正常渲染。

-   ②手动修改 GPU 插值得到的深度
-   类似上述情况

-   ③开启 Alpha Blend
-   开启了透明度混合不会开启深度写入，也就不符合 Early-Z 了

-   ④关闭深度测试
-   都关了还测试啥
#### 3. 高效利用 Early-Z
- **不透明物体由远往近渲染，early-z 将没有任何优化效果**

-   在渲染前，将不透明物体**从近往远渲染**的话，Early-Z 能发挥最大的性能优化
-   具体怎么排序？
-   ->可以让 cpu 将物体按照由近到远的顺序排好，再交付给 gpu 进行渲染

-   问题：
-   复杂的场景，cpu 性能消耗很大
-   严格按照由近到远的顺序渲染，将不能同时搭配批处理优化手段。
-   **有没有其他方法？ ->pre-z**
### 三、Z-Prepass（Pre-Z）
#### 1. 方式 1：双 pass

- **内容**
-   使用两个 pass
-   pass1：Z-prepass 中**仅仅写入深度**，不计算输出任何颜色。目的只是为了深度值写入缓冲区
-   pass2：关闭深度写入，将深度比较函数改为相等，进行正常的透明度混合（AlphaBlend）

-   **效果：**
-   每个物体都会渲染两个 pass，且所有物体的 z-prepass 的结果就自动形成了一个最小深度值的缓冲区 Z-buffer，无需 cpu 进行排序

-   **代码：**
- ![[Pasted image 20221208225600.png]]
- **问题 1：动态批处理**

-   多 pass shader 无法进行动态批处理 ---> Draw Call 问题

- **问题 2：Draw Call**

-   使用 z-prepass shader 的物体，draw call 会多一倍
- ![[Pasted image 20221208225622.png]]
**《入门精要》中写过的 Pre-Z**
![[冯乐乐入门精要#2. 开启深度写入的半透明效果]]
#### 2. 方式 2：提前分离的 Prepass

用于解决 DrawCall 问题

- **内容**

-   仍然使用两个 pass

-   将 pass1 的 z-prepass 单独分离出一个 shader，并用这个 shader 将场景的不透明物体先渲染一遍
-   原来 shader 中的 pass，仍然关闭深度写入，深度比较函数仍然为相等，进行正常的透明度混合

**补充**
-   URP 的 SRP batch 做的合批是不会减少 Draw Call 的
-   他的最大的优化在于合并 set pass call，减少 set pass call 的开销
-   因为 CPU 上的最大开销来自于准备工作（设置工作）
-   而非 DrawCall 本身（这只是要放置 GPU 命令缓冲区的一些字节而已），draw call 是不会减少的

-   [https://www.xuanyusong.com/archives/4759](https://www.xuanyusong.com/archives/4759)
-   [https://blog.csdn.net/lsjsoft/article/details/90734932](https://blog.csdn.net/lsjsoft/article/details/90734932)

### 3. Pre-Z 也是透明渲染的一种解决方案
![[Pasted image 20221208225657.png]]
-   这样会存在一个问题：无法看到透明物体的背面
-   解决方法：透明物体的双面渲染

-   核心思路：将渲染分为正面背面两部分
-   pass1：
-   只渲染背面（cull front）

-   pass2
-   只渲染正面（cull back）

-   由于 Unity 会顺序执行 Subshader 中的各个 Pass，所以我们可以保证背面总是在正面被渲染之前渲染，来得到正确的深度渲染关系
### 四、Z-prepass 的其他问题

#### 1. Z-prepass 的性能消耗是否能被忽视

-   国外论坛一位名为 lipsryme 的老哥做了一项实验：
![[Pasted image 20221208225723.png]]
-   可以看到，Z-prepass 的消耗为 2.0ms，而带来的优化只减少了 0.3ms（2.7-2.4）
-   后续讨论中，发现 Z-prepass 是需要根据项目的实际情况来决定是否采用的。

-   **总结有以下建议**

-   当一个有非常多 OverDraw 的场景，且不能很好的将不透明物体从前往后进行排序时，可以考虑使用 PreZ 进行优化
-   注意，PreZ 会增加 DrawCall，如果用错了可能是负优化
- 
### 五、Early-Z 和 Z-prepass 的实例应用

#### 1. 面片叠加的头发渲染

-   对于半透明的面片来说，需要**从后往前进行排序渲染**才能得到正确的透明度混合结果
- ![[Pasted image 20221208230553.png]]
![[Pasted image 20221208230548.png]]
#### 2. 排序后的头发渲染
![[Pasted image 20221208230615.png]]
-   分为 3 个 pass

-   pass1

-   处理不透明部分，开启 Alpha test 透明度测试，仅通过不透明的像素，
-   关闭背面剔除
-   开启深度写入

-   pass2

-   剔除正面，渲染背面

-   pass3

-   剔除背面，渲染正面

-   问题：会带来非常多 OverDraw 的问题
#### 3. 性能改善
![[Pasted image 20221208230629.png]]
-   使用 Early-Z 剔除
-   透明度测试开启时 Early-Z 无法使用的解决方案：    

-   使用一个简单的 shader 进行透明度测试形成 Z-Buffer，（就是我们上边说的提前分离的 z-prepass）
#### 4. 改善的渲染方案
![[Pasted image 20221208230643.png]]
-   pass1：准备 Z-Buffer

-   开启透明度测试
-   关闭背面剔除
-   开启深度写入，深度测试设置为 less
-   关闭颜色缓冲区写入
-   用于一个简单的片元着色器来返回透明度值

-   pass2、pass3、pass4 参考之前排序后的头发渲染部分，同理
### 六、其他参考资料

-   [https://www.cnblogs.com/ghl_carmack/p/10166291.html](https://www.cnblogs.com/ghl_carmack/p/10166291.html) ---深入剖析 GPU Early Z 优化