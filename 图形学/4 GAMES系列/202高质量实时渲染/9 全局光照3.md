主要内容：**屏幕空间GI的SSDO和SSR算法**

GAMES202 高质量实时渲染笔记 Lecture09：Real-Time Global Illumination (Screen space cont.)

![[4114d0f6fb19f0afa5230cf87cf3bcd7_MD5.jpg]]

本节课主要去讲述剩余的两种 Screen Space 的 GI 算法思路:**SSDO 和 SSR.**

## **I) Screen space Direction Occlusion （SSDO）屏幕空间方向遮蔽**

**什么是 SSDO？**

![[be991ed6ac26be9842ea50b8597bec67_MD5.jpg]]

*   对 SSAO 的一个提高 / 升级；
*   比起 AO 考虑间接光照是一个常数, 在 DO 里我们更精确的考虑了间接光照。

**关键思路**

*   我们不去假设间接光照是固定不变的；
*   RSM 中我们用 shadow map 去找到接收直接光照的点当作间接光照为其他的 Shading point 提供直接光照, 也就是说**我们一定程度上是可以已经得到间接光照的信息。**

![[d19da18abc08a12e34c6ef947ce38044_MD5.jpg]]

通过 AO 和 DO 的对比我们可以看到, AO 能够产生变暗的效果使得物体相对感更强烈, 但 AO 并不能做到 Clolor Blending（不同颜色的 Diffuse 会互相照亮）

![[0e3f9e1c07ac4bfb1bbd40670265df1d_MD5.jpg]]

而我们想要的是更加真实具有 color blending 的效果

![[2cbd578f22e2a3dffb28486f1908fab9_MD5.jpg]]

如图, 我们可以看到蓝色面上会接收到一点黄光，黄色面上也会有一点蓝光, 而并不是像 AO 一样简单的遮蔽位置整体暗一点，因此 DO 是更加精准的获得全局光照的一种方法。

*   **在 SSDO 中, 我们要用直接光照的信息, 但不是从 RSM 中获得, 而是从 screen space 中得到.**

**做法:**

![[149e2bf21c46913562fca0972c90c998_MD5.jpg]]

SSDO 的做法于 path tracing 很像, 假设在 Shading Point 的 P 点，随机的往某一个方向打出一根光线:

1.  如果光线没碰到物体，则认为 P 点这里接收直接光照
2.  如果碰到了一个点 Q, 那么算出 Q 点接受的直接光照打到 P 点的贡献, 从而求出 P 点的间接光照。

![[f740e8c260bb0ea3cdb0aa507ef50bec_MD5.jpg]]

我们可以发现, SSAO 和 SSDO 是完全相反的两个假设:

AO：在 AO 中我们认为红色的框里能接收间接光照，黄色框里无法接收间接光照，然后求出加权平均的 visibility 值, 也就是**假设间接光照是从比较远的地方来的**；

DO：在 DO 中, 我们认为红色框里接收的是直接光照, 而黄色框里才是接收到的间接光照. 因为红色框里的光线打不到用来反射的面，因此这些方向上就不会有间接光照，黄色框里的光线能打到物体上，P 点接收到的是来自红色框的**直接光照** + 黄色框里的**间接光照**, 也就是**假设间接光照是从比较近的反射物来的。**

其实这两个假设都不是完全正确的，物理真实的情况是这两种的混合：近处的是 DO，远距离是 AO，因此 AO 与 DO 也并没有矛盾。

回到渲染方程上, 将没有遮蔽的与遮蔽的方向上的光照分开考虑，那么对于 DO 如何解 Rendering Equation:

*   当 V=1 时是直接光照，而 DO 的计算是计算间接光照的，因此这个我们完全不用去计算与考虑

![[e0e4f83e428cfc66751fccda880ec791_MD5.png]]

*   当 V=0 时也就是间接光照的情况，这个是我们需要关注与计算的。

![[64328a7cabe51ce5dddad5be11f95d78_MD5.png]]

从一个 pixel 或者 patch 计算间接光照在 lecture07 - 下半部分的 RSM 中我们讲过了。

SSDO 的核心是要找哪些 patch 会被挡住，也就是对点 P 提供间接光照贡献的是哪些点，做法是与 AO 完全一样的。

我们同样考虑点 P 法线部分的半球，判断从 P 点往 A、B、C、D 四个方向看会不会被挡住，由于是屏幕空间的算法, 因此这里我们同样不考虑在 3D 场景中 A,B,C,D 四点会不会与 P 连成光线, 只考虑从 camera 看去 A,B,C,D 与 P 连成的光线会不会被挡住。

这里 A/B/D 这三个点的深度比从 camera 看去的最小深度深, 也就是说 PA,PB,PD 方向会被物体挡住, 因此会为 P 点提供间接光照。然后把我们用在 RSM 中讲的计算间接光照的方法这些点对 P 的贡献加起来。

![[24ed6db730a69ca1f3eb6c17a6d984ac_MD5.jpg]]

SSDO 也会出现一些问题, 如下图是假设与实际情况不同的情况，因为我们是在屏幕空间处理的, 因此在 A 点虽然会被 canmera 看不到，但是 AP 之间是不会挡住的, 实际上 A 点需要提供间接光照给 P 点, 但在 SSDO 算法中则不提供。

![[be3d8fe7c845be568f03b576ccba1696_MD5.jpg]]

从计算量上来看与 SSAO 差不多，但是不同之处是，判定会被挡住的时候，会额外计算被挡住的小片的贡献，质量非常接近离线渲染。

**问题:**

P 点对于半球上的点可见性是通过 Camera 对这些点的可见性来近似计算的，存在于屏幕空间中丢失信息的问题，下图是一个很明显的例子，当黄色的面朝向屏幕的时候地面的 SSDO 信息是正确的，而当旋转过去之后，就看不到 SSDO 的信息了。

![[2b511f61aa0344447f6e049372a6265f_MD5.jpg]]

SSDO 只能解决一个很小范围内的全局光照，下图是接近正确的情况，而如果使用 SSDO 来计算，方块右边是追踪不到远处绿色的墙的，方块上也就不会有绿色的反光。

![[abe30d7c21add42b6f81cee3e28aff5c_MD5.jpg]]

## **II) Screen space Reflection（SSR）屏幕空间反射**

老师说更愿意把他叫做 Screen space Raytracing(SSR), 只把它理解成反射的话其实是听狭隘的.

### **首先什么是 SSR?**

**(**肯定不是酒吞, 茨木, 妖刀姬他们**)**

*   仍然是一种在 RTR 中实现 GI 的方式；
*   是在屏幕空间做光线追踪
*   不需要知道 3D 空间中的三角形、网格、加速结构等 3D 信息，只需要屏幕空间中已有的信息，也就是从 camera 看去场景的得到的这样一层 “壳”。

![[8fbb70c060b30c5d61e2d20ae92a2170_MD5.jpg]]

*   由于我们认为它是 screen space raytracing, 我们考虑的是**任何光线** (不单单是反射光) 与场景中这层壳去做求交.
*   找到交点后, 算出对 shading point 的贡献值.

我们用生活中的一些实例来看:

![[8455e1e7fb66da4ed689ac394e1b785f_MD5.jpg]]

![[f1bb817aa11f9a31c7d60e3a5476eae1_MD5.jpg]]

![[fab5ce2066717e13694350c63ec52197_MD5.jpg]]

那么任何一个点反射的信息是什么, 是从哪里得到的?

白框里反射的是红框内的场景信息, 也就是说我们并不需要 3D 场景的什么信息, 而是从屏幕空间里已有的信息得到, 也就是反射的绝大多数信息是屏幕内已有的信息，这就是屏幕空间反射的核心思路。

### **基础的 SSR 算法：镜面反射**

假设场景中已经渲染出来了上面的部分，对于地面还没有进行渲染，如何把反射的信息加进去。

![[3ffebd1dfa02ac0e3eda9772eec91667_MD5.jpg]]

对于任何一个像素:

*   知道 shading point 的观察方向后, 可以得出其反射方向
*   从 Shading point 点沿着反射方向延长找到与屏幕的壳的交点
*   将交点的颜色作为反射的颜色记录到 shading point。

除了可以做 specular 反射, 还可以做 glossy 反射:

![[4bf3417fd18615c698a712abe9aa201c_MD5.jpg]]

如果说 specular 反射只需要反射一个方向的话, 那么对于一定 roughness 的材质来说我们要根据其 BRDF 的 Lobe 来考虑, 如果 lobe 比较细, 则需要很少的光线, 如果 lobe 比较越大, 像 diffuse 那种的话我们需要射出很多根光线

![[822a1b66d8a64b8e61c2889d862a8898_MD5.jpg]]

即使是地面凹凸不平, 也就是在地面的各法线方向不一致的情况下, 仍然可以得到反射的结果.

也就是说当我们知道几何和 normal 时, 不论是什么物体, 我们都可以往任何一个方向去 trace

**即在知道几何和法线信息后, SSR 可以做任何的光线追踪**

![[b12d5d41ea597196696f9f37b08274d5_MD5.jpg]]

我们来总结一下 SSR 的思路:

### **specular 反射:**

*   我们有一个还没有进行反射的场景, 如 shaded scene 上的地面还并没有得到反射的结果
*   得到图中的 normal 信息和深度信息
*   进行 SSR, 我们想要的是对于地面的每一个 pixel, 我们都想计算出其反射到场景中的得到的值是多少
*   得到反射的值后, 将结果加到场景中去, 也就是在地面上的黄点反射到场景的壳上的绿色, 进行求交算到的结果加入到黄点中
*   得到一个镜面反射的效果

### **怎么求反射光与场景的相交?**

最简单的方法是:**Linear Raymarch**

**黄色是 shading point, 虚线是反射光, 假设 camera 在右边, 那么从 camera 看去, 场景的壳就是曲线.**

![[aaae5bc5d81df4c8ee46a83e1ad58eaa_MD5.jpg]]

我们是为了找到反射光与场景 “壳” 的交点:

*   沿着反射方向以一个固定的步长逐步前进, 并将每次停止时的深度与壳的深度进行比较, 如果浅于壳, 则继续前进, 比壳深, 则停止求交, 也就是我们用**深度**来进行**可见性判断**
*   质量取决于步长的大小，步长小越精准，同时计算量也越大，因此步长太大太小都不行，在没有 SDF 的情况下，步长只能是一个定值。

由于步长是由我们来决定的, 太长太短都有其各自的问题, 因此我们引入另一种动态决定步长的方法:

### Hierachical ray trace

![[32748b5d9f2fba702b4286368bcb4a95_MD5.jpg]]

我们可以看到右边那条是反射光, 我们认为一个像素是一格, 我们在只 trace 一根反射光线的情况下,, 如果按一格一格的走, 每一个 fragment shader 都要做深度比较, 那么八格就是八次, 很浪费时间, 而且在这个图上, 我们就算一次走四格都不会与物体相交, 如果我们可以快速的得到一次往前走几格这个信息的话是很美妙的.

为了能得到这个信息我们需要做一个准备工作, 把场景的深度图, 做一个 mip-map, 但这个跟平常的 mip-map 不一样:

![[22fb2d0c7446e8c8f90cbbb41ad24035_MD5.jpg]]

**高一级的 Mipmap 存的并不是周围四个像素的深度平均，而是四个像素中深度的最小值**

![[640ff7adbb1c99d1c1c58d4a4504b8d8_MD5.jpg]]

**也就是鼠标所指的这一层的一个像素对应的是下图中四个像素中的最小值.**

![[eb939ba0bbb42b725ebbac06ce06d26f_MD5.jpg]]

**所谓的最小值, 指的是四个像素中离深度最小的那个值.**

### 为什么要做深度图 mipmap 呢？

![[38df0a21836fced4e7f8e2cc70866c11_MD5.jpg]]

1.  在 3D 空间做光线追踪时, 为了加速光线与场景求交，我们通常会做一个加速的层次结构（BVH/KD-tree）
2.  在屏幕空间同样做一个类似加速结构，可以快速跳过不可能相交的像素；
3.  如果我们用最小值操作的 mip-map 会得到一个保守逻辑:

*   **如果一根光线与 mip-map 中的上层结点不相交, 那他肯定也不会与这个结点的子节点相交.**

![[9717134f804d8d03975e748b2b7b77af_MD5.jpg]]

我们知道 mip-map 是一个 2 维的东西, 这里是 1 维的表示, 一个格子表示一个像素, 一共有八个格子.

*   每格一判断是 level 0
*   每两个是 Level 1
*   每四个是 level 2.
*   我们这里先以 level 1 为例子.

![[f08eaf9dc1d87ba5f22f928699ce6578_MD5.jpg]]

对于像素 1, 他记录的最浅深度为 a, 对于像素 2 它记录的最浅深度为 b.

对于这一层来说由于我们要的是最小值而不是平均, 因此深度取到了 a.

由于这根光线不会与蓝色层所表示的最小深度 a 相交, 因此就不可能与层里的 1 或 2 相交了.

这就是他的一个基本逻辑, 从而让我们可以快速的跳过很多格子

![[bbbc355350347dea0325c88c90351488_MD5.jpg]]

这里是 level 2, 当光线能够与右边部分相交时, 也就是说他能够与其的两个字节点相交, 因此我们要去判断与哪个子节点相交, 由于左边的最小深度不符合, 因此与右边的相交.

也就是我们对场景的壳从深度方面做了一个加速结构, 我们来看一下他的伪代码:

![[8b9db57c1d84ba63d3f47447b96ac105_MD5.jpg]]

1. 先走一个格子 (最小的步长)，发现没有交点, 那么胆子大一点

![[f0cc7601f32d5c7eed2c1a73f0c2d376_MD5.jpg]]

2. 然后在原来的基础上再走两格 (level 1 包含的格子)，发现还没交点, 胆子再大一点

![[20e627edadb82c952a30279cb6791b21_MD5.jpg]]

3. 继续走 4 格 (level 2)，有了交点；

![[d2080f476d36568bfe4a4e85f1566054_MD5.jpg]]

4. 考虑更精细的层 (退回 level 1)，发现还是有交点

![[b3c6849b4f7f546115a3e6213efcfb12_MD5.jpg]]

5. 由于这里在考虑 level 1 情况时交点出现在了左半边，因此退回 level 0 先判断与左边有没有交点，这时候发现没有交点，进入 Level 1；

![[cd4edf770f8d825f91d7039cbe9485b9_MD5.jpg]]

6. 再往前走 2 格发现有交点，并且交点在左半边；

![[35e287597976878a70ec03e1c77c86e0_MD5.jpg]]

7. 这时候就要退回 Level 0, 向前走一格最终发现了交点，求交结束。

![[2f464558c074715e699243ecb5723fea_MD5.jpg]]

停下来的两个条件:

*   找到了交点
*   一直没找到交点

Mipmap 可以做范围查询，可以做正方形查询，但是做不了准确的起点不在 2 的 K 次方上的深度的查询。

![[b0442cc5353d34fe6b9c1212b91eddb4_MD5.jpg]]

![[ef12ec51501adc7c330f7eb93886c58a_MD5.jpg]]

也就是红色方框区域的最小深度, 我们硬要求的话, 我们需要算出 1 和 2 的最小深度, 然后进行插值才能得到它的最小深度.

我们来回顾一下:

由于我们不知道以一个多长的固定的步长来逐步前进求交点, 因此我们用高一级的 Mipmap 存的并不是周围四个像素的深度平均，而是四个像素中深度的最小值来动态的决定步长, 从而可以快速的求到任何光线与场景壳的交点.

但是 SSR 仍然有屏幕遮挡的问题:

不在屏幕中这层 “壳” 的信息是不会被反射的，丢失正常的反射信息。

![[b8565e4e800d23c7b786f12ccb4afafa_MD5.jpg]]

我们可以看到手指那边得到了一个可笑的结果, 这就是 SSR 的问题, 他只会反射出 camera 所看到的, 而不是 3D 场景中真实存在的所有, 这也是我们学到的 screen space 的三个算法的一个通病, 整体看来只有 SSDO 要稍微好点.

还有一个就是屏幕边缘信息的缺失问题:

![[4af4dfb69da82b24f18b01da7eabdffc_MD5.jpg]]

我们可以知道地板上的红色部分是有反射的, 但是黄色部分由于是在屏幕外, 因为得不到反射, 但是实际上他应该是有反射的.

这种问题可以根据反射光走的距离做一个衰减 减少违和感。

**至此我们完成了屏幕空间光线追踪的部分, 但是我们还没完成如何计算 shading.**

这部分与路径追踪的方法完全相同，仅仅是把光线与场景求交变成了光线与 “壳” 求交，因此路径追踪的算法在这里是可以直接使用的。

对于任何一个 shading point，看到的 radicance 就是对半球进行积分, 如果是 specular 的物体, 那么相当于光线打到物体的哪里, 就用它所发出的 radiance 就可以.

![[5b2af4e37e959fb1739963e1475307e6_MD5.jpg]]

如果是 glossy 情况下, 同样的用蒙特卡洛多采样几根光线, 不管怎么所打到的物体反射过来的 radiance, 一定就是 shading point 点接收到的 incident radiance.

**这里我们同样需要假设反射物 / 次级光源 是 Diffuse 的情况, 地板之类的接收物可以是任何物体.**

问题：

  
1.Flux Intensity 是否存在平方反比衰减的问题？

- 不存在，这里做的是 BRDF sampling，并不是某个指定次级光源到 shading point，因此并不存在平方反比衰减的情况。  

2. 是否能够处理好次级光源与 shading point 的可见性的问题？  
- 由于是路径追踪 Tracing 计算出来的，看到的一定是能够看见的，因此是没有这个问题的。  

屏幕空间反射中的自然特殊现象:  
由于结果是 tracing 出来的，因此很多现象是自然就能做到的，并不用做 trick，类似很多模糊等现象可以直接实现。  
① Sharp and blurry reflection：Glossy 物体反射的模糊现象。

![[f386dd0a4c0e9aa5222cf2d5484b42fd_MD5.jpg]]

  
② Contact hardening：对于物体来说，近处的物体反射清晰，远处反射模糊，当反射物是 Glossy 时反射的 lobe 是一个锥形，当距离越远锥形的截面越越大，也就会发生模糊现象。

![[e4740bd1241f15cf517bf5a2fe9de93c_MD5.jpg]]

  
③ Specular elongation：反射在垂直方向被拉长的现象，在雨天常见的现象，当我们认为地面是各向同性的，也就是法线分布是一个圆，反射出去的 lobe 就是一个椭圆。

![[4cf3fd27eb85592f060baba4d7fd7574_MD5.jpg]]

  
④ Per-piex roughness and normal：对于不同的法线与粗糙度不同的现象。

![[5b12b557e6d6363a436d39520d72db73_MD5.jpg]]

SSR 总结  
优点：

*   可以很快的做 glossy 与 specular 的反射
*   质量很好
*   没有 spikes 尖点与遮蔽的问题

缺点：

*   在 Diffuse 物体上并不是非常高效
*   丢失屏幕外的信息, 但这个是屏幕空间的局限性, 而不是光线追踪的问题