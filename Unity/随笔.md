# 射线检测最近顶点
- 模型必须有 MeshCollider 并取消勾选 Convex
- 不需要有刚体
![[Pasted image 20230606173448.png]]

```cs
if (Input.GetMouseButtonUp(0))
{
    //参数hit 为out类型，可得到碰撞检测的返回值；
    RaycastHit hit;
    //参数ray 为射线碰撞检测的光线(返回一个从相机到屏幕鼠标位置的光线)
    Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);

    if (Physics.Raycast(ray, out hit)) //如果碰撞检测到物体
    {
        print(hit.collider.gameObject.name); //打印鼠标点击到的物体名称

        MeshCollider hitCollider = hit.collider as MeshCollider;
        if (hitCollider == null || hitCollider.sharedMesh == null)
            return;
        //获取碰撞器所在物体的Mesh网格
        Mesh mesh = hitCollider.sharedMesh;
        //获取Mesh网格的所有顶点
        Vector3[] vertices = mesh.vertices;
        //获取mesh的三角形索引，这里的索引的就是模型顶点数组的下标
        int[] triangles = mesh.triangles;
        //然后通过hit.triangleIndex(摄像碰撞到的三角形的第一个点的索引)
        //然后+1 ，+2，获取三角形另外两个点的坐标
        Vector3 p0 = vertices[triangles[hit.triangleIndex * 3 + 0]];
        Vector3 p1 = vertices[triangles[hit.triangleIndex * 3 + 1]];
        Vector3 p2 = vertices[triangles[hit.triangleIndex * 3 + 2]];
        
        Transform colliderTransform = hitCollider.transform;
        
        //上面的三个顶点是Mesh的本地坐标，需要用模型的Transform进行转换到世界坐标
        p0 = colliderTransform.TransformPoint(p0);
        p1 = colliderTransform.TransformPoint(p1);
        p2 = colliderTransform.TransformPoint(p2);
        
        //判断hit.point与三角形的三个顶点哪个顶点最近，这个就是鼠标选择顶点
        float distance1 = (p0 - hit.point).sqrMagnitude;
        float distance2 = (p1 - hit.point).sqrMagnitude;
        float distance3 = (p2 - hit.point).sqrMagnitude;

        
        //获取最近的顶点的坐标
        Vector3 NearestvertexPos = new Vector3(0,0,0);
        
        if (distance1 < distance2 && distance1 < distance3)
            NearestvertexPos = p0;
        if (distance2 < distance1 && distance2 < distance3)
            NearestvertexPos = p1;
        if (distance3 < distance1 && distance3 < distance2)
            NearestvertexPos = p2;
}
```

