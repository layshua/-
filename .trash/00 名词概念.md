**图形 API：** 通过 Direct3D 这种底层**图形应用程序编程接口（Application Programming Interface, API)**, 即可在在应用程序中对**图形处理器 (Graphics Processing Unit, GPU)** 进行控制和编程。我们能够借此以硬件加速的方式渲染出虚拟的 3D 场景。

**渲染目标（render target）** 是为了渲染场景而将像素绘制到的特定缓冲区 (buffer)。通常是占用部分显存的后台缓冲区，以及纹理（详见后文）。

**像素（pixl）**  是构成图像的基本元素。从图形角度来讲，可认为像素是一种图像的采样单位（将图像以像素为基础进行划分，再于像素中进行采样)。因此，两张同样大小的图片，分辨率高者，意味着像素数量越多，细节越丰富，画面就越清晰。由于实际显示上的原因（后面注释会提到)，也赋予了像素“大小”的概念。**在 Direct3D 中，像素被抽象为具有一定长宽的色块。** 
2D 坐标和像素是不同的，2D 坐标精确表示一个点在 2D 空间中的位置，而 2D 像素是这个点的近似值，2D 像素受到你的屏幕/窗口分辨率的限制。

**纹素 (texel)** ：构成纹理的基本元素又称纹素，**通常我们将纹素视为像素**。尽管后台缓冲区是一个纹理, 但我们仍常将其组成元素称为像素，因为就后台缓冲区这种情况而言，它所存储的内容是颜色信息。即便纹理中存储的不是颜色信息，大家有时也称纹理的元素为像素（如“法线图中的像素”)。**至于二者是否需要区分，具体还要看应用场景。** 比如谈到像素与纹素的映射关系时，必须将这两个概念予以区分。文中谈到的基本上是约定俗成的叫法。

**采样 ( sampling )**：又称取样，本是信号处理方面的术语。在本书中, 可认为该操作是以特定的模式，从连续的图像数据中采集出离散的关键颜色信息。

**显存（GPU memory）**：也有直译作 GPU 内存等。显卡通常是一块带有 PCIe 总线接口的物理电路（这里仅谈独立显卡)。
GPU 较之于显卡的地位大致相当于 CPU 较之于主板。相应的，GPU 控制的显存基本相当于 CPU 控制的内存，而后者在本书中也常被称为系统内存 ( system memory)。CPU 内部有多级缓存与寄存器，分别用于缓存指令与控制 CPU; GPU 内部亦有缓存与寄存器，分别用于缓存纹理、缓存着色器指令等以及控制 GPU。有的文献在划分 GPU 的组成结构时，会把 GPU 的寄存器及其控制的内存统称为 GPU memory ( GPU 存储器)。


## 图元 (Primitive)

为了让 OpenGL 知道我们的坐标和颜色值构成的到底是什么，OpenGL 需要你去指定这些数据所表示的渲染类型。我们是希望把这些数据渲染成一系列的点？一系列的三角形？还是仅仅是一个长长的线？做出的这些提示叫做图元 (Primitive)，任何一个**绘制指令**的调用都将把图元传递给 OpenGL。这是其中的几个：**GL_POINTS、GL_TRIANGLES、GL_LINE_STRIP**。

## 片段 (Fragment)

OpenGL 中的一个片段是 OpenGL 渲染一个像素所需的所有数据。

## 网格（Mesh）

当使用建模工具对物体建模的时候，艺术家通常不会用单个形状创建出整个模型。通常每个模型都由几个子模型/形状组合而成。组合模型的每个单独的形状就叫做一个网格 (Mesh)。比如说有一个人形的角色：艺术家通常会将头部、四肢、衣服、武器建模为分开的组件，并将这些网格组合而成的结果表现为最终的模型**。一个网格是我们在 OpenGL 中绘制物体所需的最小单位（顶点数据、索引和材质属性）。一个模型（通常）会包括多个网格。**网格 (Mesh)代表的是单个的可绘制实体。
