![[fe529498461ea9ee1e2a25a37b24cc82_MD5.webp]]

首先重建世界坐标
```c
//用深度纹理和屏幕空间uv重建像素的世界空间位置
//屏幕空间uv
float2 ScreenUV = GetNormalizedScreenSpaceUV(i.positionCS);
#if UNITY_REVERSED_Z
float depth = SampleSceneDepth(ScreenUV);
#else
float depth = lerp(UNITY_NEAR_CLIP_VALUE, 1, SampleSceneDepth(ScreenUV));
#endif

// 重建世界空间位置，注意，这里的深度为非线性深度
float3 rebuildPosWS = ComputeWorldSpacePosition(ScreenUV, depth, UNITY_MATRIX_I_VP);
```

取余数
得到世界坐标后，因为我们的坐标轴取值范围是从 -∞到 +∞，而颜色的范围只是 0-1 之间，如果对世界坐标使用 frac 取小数就可以得到只在 0-0.99 的值了
```c
return float4(frac(rebuildPosWS),1);
```

![[61fb3efd59dc2c6cf9b00ff81ee5c9b4_MD5.webp]]

取余数

对于在 0-1 之间均匀变换的我们想得到它的边界位置，所以直接来个 step 函数，我们只取 0.98 到 1.0 之间的值为 1，其他的值为 0，我们把它输出出来。是不是有那味了，线框就直接出来了。

![[89da9b0159e843562f581518306b433d_MD5.webp]]

但是这个线框的颜色红蓝绿（为什么是红蓝绿？是因为它对应 XYZ 三个轴向）很乱而且不好看，我们想要自由控制颜色，我们定义三个颜色，去分别控制 XYZ 方向的线框颜色，并把它输出。

![[248dd835198f5ef05b6c64552a6603ca_MD5.webp]]

线框颜色

        然后我们再看看输出后的效果如何，颜色加上 HDR 确实变漂亮了许多。

![[491827e4610af03207193f11c6a4878a_MD5.webp]]

得到正常的线框效果

       然后采样颜色，两者相加，即可得到正常的效果。

![[15daf97e90e4be4a42969ff2164f2944_MD5.webp]]

和屏幕颜色混合后的效果

    最后我们通过一个参数 Spacing 去控制线框的间距，Width 参数去控制线框宽度。下一篇，我们将通过世界坐标制作一个 mask 遮罩，通过 sobel 算子去得到描边效果，再修改 RenderFeather 去控制这些效果。先附上这一篇的源码，如果直接复制过去报错是空格问题，请替换掉所有空格。

**Shader 源码**

Shader "WX/URP/Post/scan"

{

    Properties

    {

      [HideInInspector]_MainTex("MainTex",2D)="white"{}

      [HDR]_colorX("ColorX",Color)=(1,1,1,1)

      [HDR]_colorY("ColorY",Color)=(1,1,1,1)

      [HDR]_ColorZ("ColorZ",Color)=(1,1,1,1)

      [HDR]_ColorEdge("ColorEdge",Color)=(1,1,1,1)

      _width("Width",float)=0.02

      _Spacing("Spacing",float)=1

      _Speed("Speed",float)=1

    }

    SubShader

    {

        Tags{

        "RenderPipeline"="UniversalRenderPipeline"

        }

        Cull Off ZWrite Off ZTest Always

        HLSLINCLUDE

        #include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"

        CBUFFER_START(UnityPerMaterial)

        float4 _MainTex_ST;

        CBUFFER_END

        real4 _colorX;

        real4 _colorY;

        real4 _ColorZ;

        real4 _ColorEdge;

        float _width;

        float _Spacing;

        float _Speed;

        TEXTURE2D(_MainTex);

        SAMPLER(sampler_MainTex);

        TEXTURE2D(_CameraDepthTexture);

        SAMPLER(sampler_CameraDepthTexture);

        float4x4 Matrix;

         struct a2v

         {

             float4 positionOS:POSITION;

             float2 texcoord:TEXCOORD;

         };

         struct v2f

         {

             float4 positionCS:SV_POSITION;

             float2 texcoord:TEXCOORD;

             float3 Dirction:TEXCOORD1;

         };

        ENDHLSL

        pass

        {

            HLSLPROGRAM

            #pragma vertex VERT

            #pragma fragment FRAG

            v2f VERT(a2v i)

            {

                v2f o;

                o.positionCS=TransformObjectToHClip(i.positionOS.xyz);

                o.texcoord=i.texcoord;

                int t=0;

                if(i.texcoord.x<0.5&&i.texcoord.y<0.5)

                t=0;

                else if(i.texcoord.x>0.5&&i.texcoord.y<0.5)

                t=1;

                else if(i.texcoord.x>0.5&&i.texcoord.y>0.5)

                t=2;

                else

                t=3;

                o.Dirction=Matrix[t].xyz;

                return o;

            }

            real4 FRAG(v2f i):SV_TARGET

            {

                real4 tex=SAMPLE_TEXTURE2D(_MainTex,sampler_MainTex,i.texcoord);

                half depth=LinearEyeDepth(SAMPLE_TEXTURE2D(_CameraDepthTexture,sampler_CameraDepthTexture,i.texcoord).x,_ZBufferParams).x;

                float3 WSpos=_WorldSpaceCameraPos+depth*i.Dirction+float3(0.1,0.1,0.1);// 得到世界坐标

                //return real4(frac(WSpos),1);

                float3 Line=step(1-_width,frac(WSpos/_Spacing));// 线框

                //return real4(Line,1);

                float4 Linecolor=Line.x*_colorX+Line.y*_colorY+Line.z*_ColorZ;// 给线框上色

                return Linecolor+tex;

            }

            ENDHLSL

        }

    }

}

**RenderFeather 源码**

using UnityEngine;

using UnityEngine.Rendering;

using UnityEngine.Rendering.Universal;

[ExecuteInEditMode]

public class scan : ScriptableRendererFeature

{

    [System.Serializable]public class setting

    {

        public Material mat;

        public RenderPassEvent Event=RenderPassEvent.AfterRenderingTransparents;

    }

    public setting mysetting =new setting();

    class CustomRenderPass : ScriptableRenderPass

    {

        public Material mat;

        RenderTargetIdentifier sour;

        public void set(RenderTargetIdentifier sour)

        {

            this.sour=sour;

        }

        public override void Execute(ScriptableRenderContext context, ref RenderingData renderingData)

        {

            int temp=Shader.PropertyToID("temp");

            CommandBuffer cmd=CommandBufferPool.Get("扫描特效");

            RenderTextureDescriptor desc=renderingData.cameraData.cameraTargetDescriptor;

            Camera cam= renderingData.cameraData.camera;

            float height=cam.nearClipPlane*Mathf.Tan(Mathf.Deg2Rad*cam.fieldOfView*0.5f);

            Vector3 up=cam.transform.up*height;

            Vector3 right=cam.transform.right*height*cam.aspect;

            Vector3 forward=cam.transform.forward*cam.nearClipPlane;

            Vector3 ButtomLeft=forward-right-up;

            float scale=ButtomLeft.magnitude/cam.nearClipPlane;

            ButtomLeft.Normalize();

            ButtomLeft*=scale;

            Vector3 ButtomRight=forward+right-up;

            ButtomRight.Normalize();

            ButtomRight*=scale;

            Vector3 TopRight=forward+right+up;

            TopRight.Normalize();

            TopRight*=scale;

            Vector3 TopLeft=forward-right+up;

            TopLeft.Normalize();

            TopLeft*=scale;

            Matrix4x4 MATRIX=new Matrix4x4();

            MATRIX.SetRow(0,ButtomLeft);

            MATRIX.SetRow(1,ButtomRight);

            MATRIX.SetRow(2,TopRight);

            MATRIX.SetRow(3,TopLeft);

            mat.SetMatrix("Matrix",MATRIX);

            cmd.GetTemporaryRT(temp,desc);

            cmd.Blit(sour,temp,mat);

            cmd.Blit(temp,sour);

            context.ExecuteCommandBuffer(cmd);

            cmd.ReleaseTemporaryRT(temp);

            CommandBufferPool.Release(cmd);

        }

    }

    CustomRenderPass m_ScriptablePass;

    public override void Create()

    {

        m_ScriptablePass = new CustomRenderPass();

        m_ScriptablePass.mat=mysetting.mat;

        m_ScriptablePass.renderPassEvent = mysetting.Event; 

    }

    public override void AddRenderPasses(ScriptableRenderer renderer, ref RenderingData renderingData)

    {

        m_ScriptablePass.set(renderer.cameraColorTarget);

        renderer.EnqueuePass(m_ScriptablePass);

    }

}