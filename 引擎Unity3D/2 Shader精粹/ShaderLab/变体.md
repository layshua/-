# 变体基础
![[Pasted image 20230628192002.png]]

能否写一个 All in One 的 Shader？
有三种方式，根据具体需求选择：
1. 静态分支 `#if`
2. 动态分支 `if`
3. 着色器变体 `#pragma`

## 静态分支 `#if`
![[Pasted image 20230628192227.png|500]]

**原理**：着色器**编译时**选择代码分支

**选择**：编译时，能够确定 Shader 执行的条件

**用法**：
- 使用 `#define` 定义激活分支
- 使用 `#if` 、 `#elif` 、 `#else` 和 `#endif` 预处理程序指令来创建静态分支
- 让 shader 代码执行其中一个分支
- 编译器会裁剪未激活代码分支，只会将执行的部分编译

**注意**：静态分支仅在手写代码可用，不能在 Shader Graph 中创建静念分文。

## 动态分支 `if`
![[Pasted image 20230628192654.png|300]]
**原理**：着色器**运行时**选择代码分支

**选择**：运行时，是否有可能动态选择分支? 

**用法**:
- 在手写代码中，使用 if 语句来执行分支
- 在 Shader Graph 中，使用 Branch 节点

动态分支的优点（相对于着色器变体方式)：
- 可以动态选择分支
- 不会造成代码膨胀

动态分支缺点（相对于着色器变体方式)：会导致运行时性能损失

## 着色器变体 `#pragma`

![[Pasted image 20230628193118.png]]

**着色器变体原理： (静态分支的加强版)**
- 编译时，生成多个**静态分支**的着色器版本
- 运行时，根据选择的变体**动态确定**要执行的着色器版本

**变体形成的 Shader 集合:** shader variants (SL) / shader states (SG)
  >SL 意思是手写的 shaderlab ，SG 意思是 shadergraph
  
**变体关键字:** shader keyword (SL) / keyword node (SG)

**包含多个变体的 Shader 被称为 Mega / Uber Shader**
- 例如: Standard/Lit Shader
- 详见《TA 进阶之路》: Unity Shader 源码解析

**着色器变体优点**：不会导致运行时性能损失
**着色器变体缺点**：构建时间、文件大小、运行时内存使用、加载时间

![[Pasted image 20230628193737.png]]

## 变体分类
  ![[Pasted image 20230628194409.png|700]]
**使用方法：**
属性快：声明变体
代码头：定义变体
代码体：使用变体

**变体有两种：**
1. multi_ compile：打包会为所有关键词生成变体，因此**可以在运行的时候通过脚本切换效果**
2. shader_feature：只会为材质使用到的关键词生成变体，没有使用到的关键词被裁剪不会生成变体，减小打包体积，**但无法在运行的时候通过脚本切换效果**。

**如何选择：**
1. 变体用于所有 Shader 还是单个材质?
    - 应该将 shader_feature 用于单个材质中设置的关键字
    - 而 multi_compile 更适合**通过代码**来全局设置的
2. 关键字运行时是否会通过 CS 脚本修改？
如果设定好的变体在运行时不会通过 CS ，则应选择 shader_feature，否则选择 multi_compile


# multi_ compile

![[Pasted image 20230628194839.png]]
## 变体激活
Unity 默认激活第一个变体，因此我们可以将默认关闭的开关放在第一个，防止意外打开开关。
```c
//如下：将产生两个变体，默认激活LIGHT_OFF变体
#pragma multi_compile LIGHT_OFF LIGHT_ON 
```

由于 Unity 变体数量的限制 (255 个，Unity已用 60+个)
因此，可以用_表示开关关闭 
```c
 #pragma multi_compile _ LIGHT_ON
 //生成两个变体
 //_:无关键字，即表示不用 LIGHT_ON，又不产生变体LIGHT_ON
 //第二个就是变体LIGHT_ON
```

对于单一条件的判定，没必要写两个变体浪费变体数量。
直接使用以下方式即可：
```c
#if defined(LIGHT_ON)
...
#else 
...
```


## 变体组合

![[Pasted image 20230628195933.png]]
 ![[Pasted image 20230628195959.png]]

## 变体开关
![[Pasted image 20230628200255.png]]


## 快捷方式
- ? URP 管线的变体有吗？

有些情况需要定义很多变体，代码很长，Unity 提供了一些快捷方式
在**内置管线**中，有几个 “快捷方式” 可以用于常用变体组合。这些组合常用于处理不同的灯光、阴影和光照贴图类型。


*   `multi_compile_fwdbase` 编译 [PassType.ForwardBase](https://docs.unity3d.com/cn/2021.1/ScriptReference/Rendering.PassType.ForwardBase.html) 所需的所有变体。这些变体处理不同的光照贴图类型以及启用或禁用的方向光主要阴影，它相当于这些变体的组合：
    *   DIRECTIONAL
    *   LIGHTMAP_ON
    *   DIRLIGHTMAP_COMBINED
    *   DYNAMICLIGHTMAP_ON
    *   SHADOWS_SCREEN
    *   SHADOWS_SHADOWMASK
    *   LIGHTMAP_SHADOW_MIXING
    *   LIGHTPROBE_SH
    *   VERTEXLIGHT_ON
*   `multi_compile_fwdadd` 编译 [PassType.ForwardAdd](https://docs.unity3d.com/cn/2021.1/ScriptReference/Rendering.PassType.ForwardAdd.html) 的变体。这将编译变体来处理方向光、聚光灯或点光源类型，以及它们带有剪影纹理的变体，它相当于这些变体的组合：
    *   POINT
    *   DIRECTIONAL
    *   SPOT
    *   POINT_COOKIE
    *   DIRECTIONAL_COOKIE
*   `multi_compile_fwdadd_fullshadows` - 与 `multi_compile_fwdadd` 相同，但还能够让光源具有实时阴影，它相当于 `multi_compile_fwdadd`  变体的组合加上：
    *   SHADOWS_DEPTH
    *   SHADOWS_SCREEN
    *   SHADOWS_CUBE
    *   SHADOWS_SOFT
    *   SHADOWS_SHADOWMASK
    *   LIGHTMAP_SHADOW_MIXING
*   `multi_compile_fog` 扩展为多个变体以处理不同的雾效类型 (off/linear/exp/exp2)。

大多数内置快捷方式会产生许多着色器变体。如果知道项目不需要这些变体，可以使用 `#pragma skip_variants` 来跳过对其中一些变体的编译。例如：

```
# pragma multi_compile_fwdadd
# pragma skip_variants POINT POINT_COOKIE
```

该指令会跳过包含 `POINT` 或 `POINT_COOKIE` 的所有变体。

# shader_feature
shader_feature 是 multi_compile 的子集 
```c
#pragma shader_feature FANCY_STUFF

//等价于
#pragma multi_compile _ FANCY_STUFF
```


