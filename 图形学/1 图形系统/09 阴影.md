
---
title: 09 阴影
aliases: [09 Shadow]
tags: []
create_time: 2023-06-20 10:42
uid: 202306201042
banner: "![[Pasted image 20230620104207.png]]"
---

需要补一下 games202 阴影内容
[实时阴影技术总结 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/45805097)
[实时渲染中的软阴影技术 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/26853641)
# 非基于图像的实时阴影
## 平面投影阴影
平面投影映射不是一个基于图像的解决方案

**内容**：根据光的方向，把物体的每个顶点投影到平面地面上。
![[Pasted image 20221209130631.png]]
**数学原理**：相似三角形
光 Light 所在的点 L 已知，V 已知，P 很容易就能求得

**缺点**：
- 只能投影到平面（阴影的接收物只能是平面）
- 投影物体必须在光线和平面之间
## 投影阴影

平面投影阴影的阴影接收物只能是平面，为了**在曲面上得到阴影**，做了以下改进：

**投影阴影**：
1. 把光源当做一个相机/投影器
2. 然后将阴影投影渲染到一张纹理
3. 最后**渲染阴影接收者时**，将上一步得到的阴影合并进去
- ![[Pasted image 20221209144815.png]]

**投影阴影在 Unity 中的实现**
![[Pasted image 20221209144939.png]]
-   第一步，设置 Project 组件，通过它的参数使用给它的材质生成一个视锥体
-   第二步，使用 Render Texture 生成一张纹理，将阴影绘制到纹理中
-   第三步，将设置 Project 组件的物体和阴影纹理进行混合

# 一、基于图像的实时阴影技术
**shadow mapping 是一个完全在图像空间 (images space)中的算法**
**优点:**
一旦 shadow Map 已经生成, 就可以利用 shadow map 来获取场景中的几何表示
**缺点:**
会产生自遮挡 (self occlusion)和走样 (aliasing) 现象.

## 2、阴影映射（ShadowMapping）
### 理解阴影

-   **如何确定“是不是阴影”**
	-   我们能看见+光能看见 = 正常渲染
	-   我们能看见 + 光看不见 = 阴影

-   **GAMES101 中，讲过的关于阴影的理解：**
	-   是一个经典的双 Pass 做法
	-   Pass1：从光源看向场景，记录看到点的深度
		-   需要从光源的位置渲染整个场景的深度图（这张图就是**shadowmap**）

	-   Pass2：从相机看向场景
		-   再从相机位置渲染这个场景

	- 在投影回光源所在的图像上，比较在相机位置渲染和光位置的深度，结果可以这样理解：
		-   **深度一致：说明相机和光都能看到**
		-   **深度不一致：我们能看到，但是光看不到 =>阴影**
		![[Pasted image 20221209145349.png]]
### 阴影图/深度图（Shadow Map）
![[Pasted image 20221209145547.png]]
-   光源视角下（shadowmap）
-   我们从光源看向场景的角度渲出一张深度图，这张深度图：
-   离光源越近就越黑（0）；越远就越白（1）
-   这张图就反映出了场景中物体的远近关系

![[Pasted image 20221209145655.png]]
**阴影映射的流程**
-  1. 从光源的位置生成一张深度图，这一步称之为阴影映射（ShadowMap）。
-  2. 从摄像机的视角，渲染整个渲染整个场景的物体。每次渲染时，需要和 shadowmap 的深度做比较（深度测试）。
>比如左下角红色点的位置，他的深度是摄像机视角的深度，所以要先转换成阴影映射的坐标系，保证坐标系是一致的。然后比较深度值，如果一个**片元的深度>它在 shadowmap 中的深度**，那么就认为它在阴影中。

**总结/注意事项：**
-   ShadowMapping 本质上是一种图像空间做法，也就是说生成 shadow 这一步不需要这个场景的几何信息
-   ShadowMapping 只能做**硬阴影**


### ShadowMapping 背后的数学

在微积分中有很多有用的不等式, 如图中的两个不等式为例：

![[Pasted image 20230622211119.png]]

**在实时渲染中, 我们只关心近似约等, 我们不考虑不等的情况, 因此我们将这些不等式当约等式来使用。**
![[Pasted image 20230622211059.png]]

如果你有两个函数的乘积, 你又想把他们的乘积积分起来, 你可以将其拆出来, 也就是:

**两个函数乘积的积分 $≈$ 两个函数积分的乘积**


1. **为什么右边第一个函数多了个分母？**

**分母这一项的作用是为了保证左右能量相同而做的归一化操作。**

我们来用一个例子来解释这个归一化操作。我们假设 $f(x)$ 是一个**常值函数**, 也就是 $f(x) = 2$, 我们的积分域恒为 $\int_0^3$.

那么约等式左边, 把 $f(x) = 2$ 代入, 则可以提出来变为 $2$ 倍的 $g(x)$ 积分

而等式右侧第一个函数代入 $f(x)$ 的积分是 $\int_0^3 2dx=2x|_0^3=2 * 3 =6$，分母的积分是 $\int_0^3 dx=x|_0^3=3$，结果也正好是 $2$. 正好也是 $2$ 倍的 $g(x)$ 积分.

2. **在什么情况下约等式结果更加准确:**

一般需要以下两个条件:

1.  g (x) 积分的 support 较小。这里的 support 我们可以暂时理解为积分域。

2. g (x) 在积分域内变化不大（学术界称为 Smooth integrand）。

**此时我们把渲染方程代入这个约等式中:**
我们把 visibility 看作是 $f(x)$, 提取出来并作归一化处理:
![[Pasted image 20230622212736.png]]

红色区域部分时 visibility, 那么剩下的 $g(x)$ 部分, 也就是 shading 的结果.

因此其表示的意义就是, 我们计算每个点的 shading，然后去乘这个点的 visibality 得到的就是最后的渲染结果。

这也就是 shadow mapping 的基本思想。

**那么什么时候这个约等式比较正确呢？**

1. 我们要控制积分域足够小，也就是说我们只有一个点光源或者方向光源。环境光不行。

2. 我们要保证 shading 部分在积分域内变化不大，也就是说 brdf 的部分变化足够小，那么这个 brdf 部分是 diffuse 的。gloss  brdf 不行。

3. 我们还要保证光源各处的 radience 变化也不大，类似于一个面光源。
## 3、Unity 中的屏幕空间阴影映射
### 步骤
1.  渲染屏幕空间的深度贴图
2.  从光源方向渲染出 shadowmap
3.  **在屏幕空间**做一次阴影收集计算（Shadows Collector，将前两步生成的图做深度比较），
		a.  **这次计算会得到一张屏幕空间的 shadowmap（Collect Shadows）**
		b.  //实际上就是对前两步的深度图做一个比较，得到一张新的深度图
4.  在绘制物体时，用物体的**屏幕坐标 uv**采样第三步中生成的屏幕空间 shadowmap

从 FrameDebugger 查看过程
![[Pasted image 20221209151539.png]]
![[Pasted image 20221209151553.png]]
# 二、阴影映射的问题与优化
## 1 自阴影/自遮挡/阴影粉刺
### 自阴影 self-shadowing：
自阴影/自遮挡也被称为**阴影粉刺（Surface Acne）

![[6ead296a05b80777473845429dcbbef8_MD5.png]] ![[6368ed87749ac4a26550234e84ff7c15_MD5.png]]
- 地板上的东西会感觉像摩尔纹, 但并不是**它是由数值精度造成的一种现象。**
- 因为 shadowmapping 的分辨率有限，离散的采样点以及数值上的偏差可能造成不正确的自遮挡效果


 **出现自阴影的原因：**
-   如下图所示，在映射 shadowmap 的过程中，用表面上**点的 uv**采样阴影映射的深度值都是一个值（shadowmap 的一格代表的是一个纹素，在这一格里面采样阴影映射得到的值都是一样的）
- 例如：红点和蓝点采样后得到的深度值都是一样的，这一段所有点采样得到的深度值都和红线（代表深度值）相等。
![[Pasted image 20221209153218.png]]
当比较深度时，为了避免表面自阴影，需要设置容错阈值：
- 深度偏移（Depth Bias），增加深度偏移会使该像素向光源靠近
- 法线偏移（Normal Bias），沿着表面法线方向向外偏移
- 偏移单位是 shadowmap 的纹素

**深度偏移会造成的问题（Peter Panning）**
-   当 Bias 设置过大时，会导致漏光现象，即阴影与投影者之间发生脱节：也叫做**Peter panning 问题（学术界叫作 detached shadow）**
>Peter Panning 名称的由来：Peter 是西方漫画中的人物，他和影子是可以分开的
![[Pasted image 20221209152205.png]]

GAMES202 提到了一个解决方案:**Second-depth shadow mapping**，实际中并没有人去使用这个技术, 因为场景内的物体必须都是 watertight（非面片），还有就是开销太大。

简单介绍下原理：
舍弃 biasd 的概念, 在**渲染时不仅存最小的深度, 我们还要存第二小的深度, 然后我们用最小深度和第二小深度中间的深度来作比较：**

![[530dda48b31bab142f1bec8a0ad4f2d6_MD5.png]]

假设一根光线照过来, 我们不用最小深度来比较, 而是用由最小和第二小深度所得到的红色线来做后续的阴影, 此处就没有 Bias 的事情了.



### GAMES101 补充理解
![[Pasted image 20221209152350.png]]
-   从 light 往场景看（左边太阳的线）时，比如沿着某一个像素往过看，看到的位置（红色斜线）就是像素所代表的深度，（假设任何一个像素是一个常值的深度）。也就是说，在 shadowmap 看来，场景离散成了图中红色斜线形成的结果。
-   第二个 pass 渲染的时候，从 camera 出发（右边连着眼睛的蓝色虚线），常规操作：连向 light （左边蓝色虚线），这段虚线长度就是它的深度
-   **问题**：在 shadowmap 记录的对应的深度是橙色的部分（更浅），而实际上从相机看向这个像素，它的深度应该是被橙色部分遮挡住的点（两条蓝色虚线的交点）→这就是自遮挡情况
-   **特殊情况**：
    -   光垂直的，从上往下照时候，不存在问题
    -   光非常偏的时候，问题最大（例如：塞尔达中夕阳西下时）
    -   不难理解，斜着的时候就完全被挡住了，垂直的时候就不会被遮挡，图已经画的很清楚了

**如何解决这个问题：**
![[Pasted image 20221209153545.png]]
-   加上一个 Bias 避免自遮挡（图中橙色那段）
	- **具体方式就是当一个点深度大于记录深度的值超过一个阈值时，我们才认为这个点在阴影内**
	-   认为 shadowmap 上的深度，明显比实际的深度小的情况下，橙色的这一段障碍物就不算了。
	-   bias 可以不是一个常数，可调整，如果垂直打光，可以非常小，夹角很大的情况，可以更长一点。

**投影后的 Z 值**
关于深度, 我们在 101 中讨论过一个问题, 在做透视投影时, 我们是将透视投影挤压成正交投影, 然后再拍平, 在这个过程中中间的点是会向近平面移动还是向远平面移动?

答案是中间的所有点会被推向远平面.
[[02 视图变换#思考：挤压后 z 值为(n+f)/2的点会挤向 n 还是 f]]

所以, 在经过投影之后得到的 Z 其实不是实际上几何上的点到 Light 的距离, 因此在真正生成阴影时比较两个 pass 中的 depth 时需要一致。也就是要么都用**投影后的 Z 值**比较, 要么通过**两点的位置得一向量算实际距离**.
### Unity 中实现自阴影的优化
-   思路：
-   在生成 shadowmap 时去做 Bias（偏移）
![[Pasted image 20221209153656.png]]
## 2 走样
### 走样问题
走样，最明显的表现就是锯齿，我们可以看下边的例图

![[Pasted image 20221209153803.png]]

**在什么阶段会走样？**
初始采样：渲染 shadowmap 时
重采样：从相机位置对 shadowmap 进行重采样时

**初始采样阶段**
最严重的问题：**透视走样**
![[Pasted image 20221209162811.png]]
**透视走样是如何形成的？**
- shadowmap 在世界空间均匀分配（左图的三段纹素对应的世界空间的一个像素大小是一样的）
-   **经过透视投影后**，根据近大远小的原理，原来大小不一样的近平面和远平面，在屏幕内占的像素便不一样了。（右图）
-   这时远平面对应在 shadowmap 中的纹素就比近平面大了
-   这种离相机近的部分走样的情况一般称为**透视误差**。

**如何解决**？
-   思路 1：
    -   因为我们在使用 shadowmap 时，相机是经过透视投影的，但生成 shadowmap 时并没有经过透视投影
    -   所以我们在生成 shadowmap 时就进行一次透视投影

-   思路 2：
    -   尽量减少近平面和远平面之间的像素差距
    -   Unity 中的**级联阴影映射**（投影走样最有效的解决方案）就是用的这个思路
![[Pasted image 20221209163324.png]]

# 级联阴影映射
(Cascaded Shadow Map)
- 投影走样最有效的解决方案
- 把视锥体分割为多个子视锥体；
- 为每个子视锥体计算独立的相等大小的阴影映射；
-  就是给 shadowmap 不同位置不同的分辨率
# 重采样误差
-   shadowmap 可以理解为一张动态生成的纹理
-   重采样误差的解决方法：**滤波（Filter）**
 ![[Pasted image 20221209163546.png]]
-   滤波：在图像处理中，通过滤波强调一些特征或者去除图像中一些不需要的部分 (高斯模糊就是一种滤波方式)
-   滤波是一个**领域操作算子**，利用给定像素周围的像素的值决定该像素的最终输出值

-   **补充**：
-   滤波就是抹掉特殊频率的东西
-   高通滤波 = 边界
-   低通滤波 = 模糊
-   //滤波（Filtering）=卷积（Convolution）=平均（Averaging）

-   **阴影滤波**：
-   使用一部分 shadowmap 采样点来计算某个指定 View 采样点的最终阴影结果的方法

# 软阴影和硬阴影
**软硬阴影的区别**：硬阴影没有一个明显的从有阴影到没有的过度/界限（因为绝大多数的生活中的光源是面光源）
![[Pasted image 20221209164343.png]]
![[Pasted image 20230622213757.png]]
Umbra：本影区（影子中光源完全照射不到的部分）
Penumbra ：半影区（黑暗与光明之间的），半影区的影子比较软

ShadowMapping 只能直线硬阴影
软阴影方案：PCF/pCsS

# PCF 百分比渐进过滤
Percentage Closer filtering **百分比渐进过滤**
PCF 的初衷是为了抗锯齿, 反走样，后来发现可以用在软阴影上。

![[Pasted image 20221209163837.png]]

PCF 中，不是取 shadowmap 上一个点的深度去比较，而是取 shadowmap 上任意一个点的周围一个 Filter 大小的区域（滤波核），将**这个区域的所有点都去做一次**深度比较（0 或 1 的结果），最后再对这些结果做一个平均（不是非 0 即 1 的结果，而是一个权重值/像素的颜色值）



**Filter Size 滤波核大小**
-   可以是规则滤波，3x3 或者 5x5 等
-   也可以采用**泊松滤波（Poisson DIsk）** 的形式来分布一定数量的采样点 ![[Pasted image 20221209164052.png]]

**Filter Size重要吗？**
-   如果小（比如 1×1 = 没做 Filter），结果是锐利（sharpener）对应硬阴影
-   如果大，结果是 softer，对应软阴影
-   既然 Filter 的大小可以决定阴影的软硬，我们不妨这样理解：
-   软阴影 = 硬阴影做一个非常大的 Filter

**注意：**
1.  PCF 不是直接在最后生成的阴影上进行 filtering。
   如下图，可以发现没有解决走样的问题。就跟我们在反走样时一样, 我们不能先得到一个走样的结果再去做在这个走样的结果上进行模糊。
![[2586f23c8f8f35667133cf9c8c941265_MD5.jpg|500]]

2.  也不是对 shadow map 进行 filtering
如果直接在 shadow map 上 filtering 就会造成阴影和物体交界直接糊起来，而且在第二个 pass 上做深度测试还是非 0 即 1 的结果, 最后得到的仍然是硬阴影。



**现实世界的软硬阴影**
![[Pasted image 20221209164914.png]]
我们发现阴影在笔尖的地方是硬的，远的地方就很虚（软），得出两个结论：
1. **遮挡物 Blocker 与阴影接受物 Reciever 的距离越小, 阴影越锐利.**
2. 要想做一个软阴影的效果，应该给硬阴影各个位置不同大小的 filter，这样就能做到符合现实世界的阴影效果。

**那么这个不同位置不同的 Filter 的大小怎么解决呢？**
定义一个**blocker distance（遮挡物和阴影接收物的距离**）
-   //更准确的说法：相对的、平均的、投射的遮挡物的深度

-   **到此为止我们做个总结：**
-   我们知道了 PCF 怎么做
-   要做 PCF，我们还需要知道 Filter 的大小，接下来就是 PCSS 的舞台了

# PCSS 百分比渐进软阴影
Percentage Closer Soft Shadows 

**PCSS 本质上就是求出了阴影中需要做 PCF 的半影部分后再进行 PCF 的计算**，这样动态调节了半影范围，也就是动态设置了 PCF 的搜索范围，这样我们的硬阴影部分清晰，软阴影部分模糊，动态的实现了不错的软阴影效果。

> [!summary] PCSS 的步骤
> 
> 1.  寻找 blocker，并计算**指定范围（即通过计算得到的范围 [[09 阴影#^2480r1]]）** 的 blocker 平均深度。
> 2.  估计半影区大小（filter size），通过 blocker 平均深度计算 filter size。
> 3.  按照 PCF 方式绘制软阴影。

**要解决的一个问题是我们如何决定一个软阴影的半影区 Penumbra 大小。换句话说，就是 filter size 有多大的问题:**
**blocker distance** 即图中的 $d_{Blocker}$：遮挡物和光源的距离。更详细的说，是相对的平均的投影遮挡物深度

![[Pasted image 20221209165125.png]]
-   上方黄色线段表示 Light（光），中间绿色线段表示 Blocker（遮挡物），下边蓝色线段就是 Receiver（阴影的接收物）
-   我们可以看到左下和右上两个黄色虚线形成的三角是两个**相似三角形**。

如果我们将 Blocker 的位置移动一下, 比如越靠近 receiver, 我们会发现 $W_{Penumbra}$ 也就会越小。

用数学来表示半影区（$W_{Penumbra}$）, 由相似三角形 :

$$
\frac{W_{Light}}{W_{Penumbra}}=\frac{d_{Blocker}}{d_{Receiver}}
$$
即
$$
W_{Pemumbra}= W_{Light}\cdot \frac{d_{Receiver}}{d_{Blocker}}
$$

这里的 $d_{Recevier}$ 和 $W_{Light}$ 的大小我们是知道的，所以我们只需要拿到 blocker 的深度即可。

- ? **如何确定一个 blocker 距离面光源的位置   $d_{Blocker}$？**

**不能直接使用 shadow map 中对应单个点的深度来代表 blcoker 距离**, 因为如果该点的深度与周围点的深度差距较大（遮挡物的表面陡峭或者对应点正好有一个孔洞），将会产生一个错误的效果, 我们选择使用**平均遮挡距离**来代替，所以平常我们指的 blocker depth 其实是 **Average blocker depth**.

**blocker 上的每个点距离光源的距离是不同的，深度也是不一样的。这里我们采用取平均深度的方式来表示 blocker 的深度。**

- @ **求 blocker 距离的过程如下：**

1. **把观察空间下的目标 shading point 转换到 light space**，目的是获取 shading point 的深度
2. 找到 shading point 在 shadow map 上对应的像素。
3. 如果 shading point 的深度大于这个 shadow map 上点对应的深度, 则说明 shadow map 上的点就是一个 Blocker, 然后我们**取 shadow map 上这个点 (像素) 周围的一些像素**
4. 在周围像素张**找出能够挡住 shading point 的点的像素**, 并求出他们的**深度平均值**作为 blocker 的深度，得到了一个在 0 到 1 之间的软阴影效果。

这个方法关键点在于**取 shadow map 上这个点 (像素) 周围的一些像素**，我们需要确定取多少像素。  ^2480r1

一般我们有两种方法可以解决这个问题。
**第一种**，就是自己规定一个, 比如 4 * 4, 16 * 16, 比较简单但不实用.
**第二种**，shading point 连向 light，覆盖 shadowmap 的区域（红色区域），我们只在这个区域范围内找 blocker
![[Pasted image 20230622222325.png|500]]
![[17a5f4b8a24467710c615889bd174d97_MD5.jpg|500]]

我们计算 shadow map 的时候在光源处设置过相机，如图所示，我们把 shadow map 放在由相机看向场景形成的视锥中的近截面上, 然后 shading point 连向 light，**在 shadow map 上截出来的面就是要查询计算平均遮挡距离的部分**。这部分的深度求一个均值，就是 **Blocker 到光源的平均遮挡距离**。
# VSSM

-   针对解决了 PCSS 中第一步和第三步慢的问题（甚至不用做任何采样和循环，但是做了大量的近似）
-   对应的是 GAMES202-L4 部分
-   考虑的篇幅问题，就不再整理了，我直接贴笔记地址，感兴趣的自行扩展
-   [https://www.yuque.com/sugelameiyoudi-jadcc/okgm7e/gcuczo](https://www.yuque.com/sugelameiyoudi-jadcc/okgm7e/gcuczo)

# Moment Shadowmapping
-   VSSM 的发明是为了解决 PCSS 的问题，其实 VSSM 自己同样会有问题
-   当分布非常简单的情况下，就会出错（分布描述的不准）
-   Moment Shad