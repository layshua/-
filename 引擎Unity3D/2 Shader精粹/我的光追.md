# 链接 ComputeShader 和后处理框架
创建**RayTracingShader.cs**
```cs
#pragma kernel CSMain  
  
RWTexture2D<float4> Result;  
  
[numthreads(8,8,1)]  
void CSMain (uint3 id : SV_DispatchThreadID)  
{  
    Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);  
}
```

创建，**RayTracingPass.cs**。
没有找到如何在 volume 面板上公开 Computeshader 类型的变量，所以直接传给脚本即可：
![[Pasted image 20230711170341.png]]

```cs
using System;
using UnityEngine;
using UnityEngine.Experimental.Rendering;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;
using UnityEngine.Serialization;

[Serializable, VolumeComponentMenuForRenderPipeline("Custom Post-processing/Ray Tracing", typeof(UniversalRenderPipeline))]
public class RayTracingPass : CustomPostProcessingManager
{
    //ComputeShader相关
    //public ComputeShader rayTracingShader;
    public ComputeShader rayTracingShader;
    // private Material m_ScreenMaterial;
    // private const string ScreenShaderName = "Unlit/Texture";
    private RenderTexture m_Target;
    private int m_KernelIndex;
    
    //Pass插入点
    public override PassInjectionPoint passInjectionPoint => PassInjectionPoint.BeforeRenderingPostProcessing;
    
    //在Pass内的排序
    public override int orderInPass => 2;
    
    //激活状态
    public override bool IsActive() => rayTracingShader != null;
    
    //配置
    public override void Setup()
    {
        //创建一张和屏幕大小一样的RT
        if (m_Target == null||m_Target.width!=Screen.width||m_Target.height!=Screen.height)
        {
            if (m_Target != null)
                m_Target.Release();
            
            m_Target = new RenderTexture(Screen.width,Screen.height,0,RenderTextureFormat.ARGBFloat,RenderTextureReadWrite.Linear);
            //RWTexture为UAV类型，支持无序(随机）访问读写操作
            m_Target.enableRandomWrite = true; 
            m_Target.Create();
        }
        
    }
    
    //渲染
    public override void Render(CommandBuffer cmd, ref RenderingData renderingData, RTHandle source, RTHandle destination)
    {
        if (m_Target == null)
            return;
        
        //核函数索引
        m_KernelIndex = rayTracingShader.FindKernel("CSMain");
        
        //RT设置到核函数的RWTexture2D中
        rayTracingShader.SetTexture(m_KernelIndex,"Result",m_Target);

        int threadGrouphsX = Mathf.CeilToInt(Screen.width / 8.0f);
        int threadGrouphsY = Mathf.CeilToInt(Screen.height / 8.0f);
        
        //调度线程组，执行核函数
        rayTracingShader.Dispatch(m_KernelIndex, threadGrouphsX, threadGrouphsY, 1);
        
        //进行屏幕绘制
        cmd.Blit(m_Target,destination);
    }
    
    //释放资源
    public override void Dispose(bool disposing)
    {
        base.Dispose(disposing);
        CoreUtils.Destroy(m_Target);
    }
}
```

绘制下图：
![[Pasted image 20230711170202.png]]

# 射线

通过一个变换矩阵得到相机的射线。

```cs
//相机  
private Camera m_Camera;

//配置  
public override void Setup()  
{  
    m_Camera = Camera.main;  
}
//渲染
public override void Render(CommandBuffer cmd, ref RenderingData renderingData, RTHandle source, RTHandle destination)
{
    if (m_Target == null)
        return;
    
    //通过变换到世界空间，得到射线
    rayTrracingShader.SetMatrix("_CameraToWorld",m_Camera.cameraToWorldMatrix); //获得观察空间->世界空间的矩阵 
        rayTracingShader.SetMatrix("_CameraInverseProjection",m_Camera.projectionMatrix.inverse); //获得裁剪空间->观察空间的矩阵
    
    
    //核函数索引
    m_KernelIndex = rayTracingShader.FindKernel("CSMain");
}
```

在 ComputerShader 当中定义射线的行为