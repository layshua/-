
---
title: 05 透明和剔除
aliases: []
tags: []
create_time: 2023-06-20 10:20
uid: 202306201020
banner: "![[Pasted image 20230620102455.png]]"
---
# Unity 渲染顺序
RenderQueue 只是控制渲染顺序的因素之一，实际上更复杂：
[Unity 渲染顺序（Rendering Order） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/473875401)
[Unity 中渲染顺序的理解以及一些坑点 以及2.5D游戏中的渲染排序解决方案_unity半透明渲染顺序_子胤的博客-CSDN博客](https://blog.csdn.net/yinfourever/article/details/106073131)
# 1 Unity 的解决方案

> [!NOTE] Unity 中的渲染顺序
> 按 shader 指定的渲染队列顺序
> Background—>Geometry (默认队列)—>AlphaTest—>Transparent—>Overlay
   这里总结不全，看一下上面的文章

**一般采用的方案**：
(1) 先渲染所有不透明物体，并**开启它们的深度测试和深度写入**。
(2) 把半透明物体按它们距离摄像机的远近进行排序，然后按照从后往前的顺序渲染这些半透明物体，并**开启它们的深度测试，但关闭深度写入**。

即便按照上述这种正确的渲染顺序，仍会存在问题： [[08 透明#^t3bkkp]]，半透明排序的问题只能尽量减少，无法避免。

Unity 为了解决渲染顺序的问题提供了 **渲染队列 (render queue)** 这一解决方案。我们可以使用 **`SubShader Queue`** 标签来决定我们的模型将归于哪个渲染队列。 **Unity 在内部使用一系列整数索引来表示每个渲染队列，且索引号越小表示越早被渲染**。![[Pasted image 20221003232825.png]]

# 2 透明度测试和透明度混合
Unity 中，我们通常使用两种方法来实现透明效果：

1. **透明度测试(Alpha Test)**：无法得到半透明，要么完全透明，要么完全不透明
    - **只要一个片元的透明度不满足条件（通常是小于某个阙值），那么它对应的片元就会被舍弃。** 被舍弃的片元将不会再进行任何处理，也不会对颜色缓冲产生任何影响；
    - **否则，就会按照普通的不透明物体的处理方式来处理它，即进行深度测试、深度写入等。** 
    - 也就是说，透明度测试是<mark style="background: #FF5582A6;">不需要关闭深度写入</mark>的，它和其他不透明物体最大的不同就是它会根据透明度来舍弃些片元。**虽然简单，但是它产生的效果也很极端，要么完全透明，即看不到，要么完全不透明，就像不透明物体那样。**
2. **透明度混合 (Alpha Blending)**： 这种方法可以得到真正的半透明效果
    - 它会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。
    - 透明度混合需要**关闭深度写入，破坏了深度缓冲机制，这使得我们要非常小心物体的渲染顺序**。需要注意的是，透明度混合<mark style="background: #FF5582A6;">只关闭了深度写入，但没有关闭深度测试</mark>。
    - 当使用透明度混合渲染一个片元时，会进行深度测试，测试通过才会进行混合操作。这一点决定了当一个不透明物体出现在一个透明物体前，我们先渲染不透明物体并进行了深度写入，后面的透明物体无法通过深度测试所以被遮挡。
    - **深度缓冲中的值其实是像素级别的，即每个像素有一个深度值。但是由于我们关闭了深度写入，无法对模型进行像素级别的排序**。当模型网格之间有互相交叉的结构时，往往会得到错误的半透明效果


- ? **为什么要关闭深度写入？**
正常来说，我们可以透过半透明物体的前表面看到后表面，假设不关闭深度写入，按照半透明从后往前的渲染顺序。先渲染后表面写入深度缓冲和颜色缓冲，然后渲染前表面。由于前表面更靠近摄像机，深度测试通过，并写入深度和颜色缓冲，覆盖掉了后表面，我们就无法看到后表面了。所以为了半透明的正常显示，不得不关闭深度写入。

- ? **为什么关闭了深度写入，渲染顺序很重要？**
![[Pasted image 20230620142344.png]]
第一种情况，我们先渲染 B, 再渲染 A（**先渲染不透明物体，再渲染半透明物体，结果正确**）。那么由于不透明物体开启了深度测试和深度写入，而此时深度缓冲中没有任何有效数据，因此 B 首先会写入颜色缓冲和深度缓冲。随后我们渲染 A，透明物体仍然会进行深度测试，因此我们发现和 B 相比 A 距离摄像机更近，因此，我们会使用 A 的透明度来和颜色缓冲中的 B 的颜色进行混合，得到正确的半透明效果。
第二种情况，我们先渲染 A，再渲染 B（**先渲染半透明物体，再渲染不透明物体，结果错误**）。渲染 A 时，深度缓冲区中没有任何有效数据，因此 A 直接写入颜色缓冲，但由于对半透明物体关闭了深度写入，因此 A 不会修改深度缓冲。等到渲染 B 时，B 会进行深度测试，它发现，“咦，深度缓存中还没有人来过，那我就放心地写入颜色缓冲了!”，结果就是 B 会直接覆盖 A 的颜色。从视觉上来看，B 就出现在了 A 的前面，而这是错误的。 ^t3bkkp


![[Pasted image 20230620142352.png]]
第一种情况，我们先渲染 B，再渲染 A （**从后往前渲染半透明物体，结果正确**）。那么 B 会正常写入颜色缓冲，然后 A 会和颜色缓冲中的 B 颜色进行混合，得到正确的半透明效果。
第二种情况，我们先渲染 A，再渲染 B （**从前往后渲染半透明物体，结果错误**）。那么 A 会先写入颜色缓冲，随后 B 会和颜色缓冲中的 A 进行混合，这样混合结果会完全反过来，看起来就好像 B 在 A 的前面，得到的就是错误的半透明结构。

按照正确的渲染顺序仍存在问题，在一些情况下，半透明物体还是会出现“穿帮镜头”。

**深度缓冲中的值其实是像素级别的，即每个像素有一个深度值。但是由于我们关闭了深度写入，无法对模型进行像素级别的排序**。
**我们只是按照距离摄像机的远近进行排序，这是对单个物体级别进行排序**，这意味着排序结果是，要么物体 A 全部在 B 前面渲染，要么 A 全部在 B 后面渲染。如果存在**循环重叠**的情况，那么使用这种方法就永远无法得到正确的结果。

![[Pasted image 20230620143149.png]]
在图 8.3 中，由于 3 个物体互相重叠，我们不可能得到一个正确的排序顺序。这种时候，我们可以选择把物体拆分成两个部分，然后再进行正确的排序。但即便我们通过分割的方法解决了循环覆盖的问题，还是会有其他的情况来”捣乱”。考虑图 8.4 给出的情况。

这里的问题是: 如何排序? 我们知道，一个物体的网格结构往往占据了空间中的某一块区域, 也就是说，这个网格上每一个点的深度值可能都是不一样的，**我们选择哪个深度值来作为整个物体的深度值和其他物体进行排序呢? 是网格中点吗? 还是最远的点? 还是最近的点? 不幸的是, 对于图 8.4 中的情况，选择哪个深度值都会得到错误的结果**, 我们的排序结果总是 A 在 B 的前面，但实际上 A 有一部分被 B 遮挡了。这也意味着，一旦选定了一种判断方式后，在某些情况下半透明物体之间一定会出现错误的遮挡问题。

**减少错误排序的方法**
1. 分割网格，尽可能让模型是凸面体, 并且考虑将复杂的模型拆分成可以独立排序的多个子模型
2. 如果不想分割网格，可以试着让透明通道更加柔和，使穿插看起来并不是那么明显
3. 使用开启了深度写入的半透明效果来近似模拟物体的半透明 (详见 8.5 节)
4. Unity 为了解决渲染顺序的问题，提供了渲染队列（render queue）解决方案。

### 透明度测试 Alpha Test（Alpha Cutout）
透明度测试：只要一个片元的透明度不满足条件 (通常是小于某个阙值)，那么它对应的片元就会被舍弃。被舍弃的片元将不会再进行任何处理，也不会对颜色缓冲产生任何影响; 否则，就会按照普通的不透明物体的处理方式来处理它。


> [!NOTE] Clip 函数
> void clip(float4 x);void clip(float3 x);void clip(float2 x);void clip(float1 x);void clip(float x);
> **给定参数任何一个分量是负数，就舍弃当前像素的输出颜色**
>
> void clip (float4)
> {
>         if ((any<0))
>         discard;
> }
>

透明度测试的显示效果比较极端：要么完全透明（看不到），要么完全不透明。而且，透明效果的边缘有锯齿，这是因为在边界处纹理的透明度变化精度问题，为了得到更加柔滑的透明效果，就可以使用透明度混合。

![image-20220704153317101](image-20220704153317101.png) ![image-20220704153515750](image-20220704153515750.png)

```c
Shader "Unlit/MyAlphaTest"
{
    Properties
    {
        _Color ("Main Tint", Color) = (1, 1, 1, 1)
        _MainTex ("Main Tex", 2D) = "white" {}
        _Cutoff ("Alpha Cutoff", Range(0, 1))= 0.5   
        //为了控制透明度测试时使用的阈值。_Cutoff参数用于决定我们调用clip进行透明度测试时使用的判断条件，范围是[0,1]，这是因为纹理像素的透明度就在此范围内

    }
    SubShader
    {
        Tags 
        { 
            "Queue"="AlphaTest"                //透明度测试使用AlphaTest渲染队列
            "IgnoreProjector"="True"           //该Shader不会受到投影器的影响
            "RenderType"="TransparentCutout"    //把该Shader归入到提前定义的组中（TransparentCutout组），以指明该Shader时一个使用了透明度测试的Shader，该标签通常被用于着色器替换功能
        }

        Pass
        {
            Tags{"LightMode"="ForwardBase"}

            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include "Lighting.cginc"

            fixed4 _Color;
            sampler2D _MainTex;
            float4 _MainTex_ST;
            fixed _Cutoff;

            struct a2v
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 texcoord : TEXCOORD0; 
            };

            struct v2f
            {
                float4 pos : SV_POSITION;
                float3 worldNormal : TEXCOORD0;
                float3 worldPos : TEXCOORD1;
                float2 uv : TEXCOORD2;
            };
            
            v2f vert(a2v v)
            {
                v2f o;
                o.pos = UnityObjectToClipPos(v.vertex);
                o.worldNormal = UnityObjectToWorldNormal(v.normal);
                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);

                return o;
            }

            fixed4 frag(v2f i) : SV_TARGET
            {
                fixed3 worldNormal = normalize(i.worldNormal);
                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));

                fixed4 texColor = tex2D(_MainTex, i.uv);

                //透明度测试
                clip(texColor.a - _Cutoff);

                fixed3 albedo = texColor.rgb * _Color.rgb;
                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;
                fixed3 diffuse = _LightColor0.rgb * albedo * saturate(dot(worldNormal,worldLightDir));

                return fixed4(ambient + diffuse, 1.0);
            }
            
            ENDCG
        }
    }
    Fallback "Transparent/Cutout/VertexLit"
}

```


### 透明度混合 Alpha Blend

#### 1. 一般方法
透明度混合：这种方法可以得到真正的半透明效果。它会使用当前片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。但是，**透明度混合需要关闭深度写入，这使得我们要非常小心物体的渲染顺序。**

![image-20220704153735600](image-20220704153735600.png)

本节使用的 Blend 命令为： `Blend SrcAlpha OneMinusSrcAlpha`
$DstColor_{new}=SrcAlpha×SrcColor+(1-SrcAlpha)× DstColorold$
比如源颜色 $\alpha$ 值为 0.25，那么可以理解为用最终颜色由 25% 的源颜色，和 75%的目标颜色组成。

**透明度混合可以得到更加柔和的透明效果，但是这种方法仍有弊端：关闭深度写入后，造成错误排序，无法对模型进行像素级别的深度排序。**

![image-20220704154122183](image-20220704154122183.png)

**实现效果：**

![image-20220704153821708](image-20220704153821708.png)

![image-20220704154027806](image-20220704154027806.png)

```c
Shader "Unlit/MyAlphaBlendMat"
{
    Properties
    {
        _Color ("Main Tint", Color) = (1, 1, 1, 1)
        _MainTex ("Main Tex", 2D) = "white" {}
        _AlphaScale ("Alpha Scale", Range(0, 1))= 0.5   
    }
    SubShader
    {
        Tags 
        { 
            "Queue"="Transparent"                //透明度混合使用Transparent渲染队列
            "IgnoreProjector"="True"           //该Shader不会受到投影器的影响
            "RenderType"="Transparent"    //把该Shader归入到提前定义的组中（Transparent组），以指明该Shader时一个使用了透明度混合的Shader，该标签通常被用于着色器替换功能
        }

        Pass
        {
            Tags{"LightMode"="ForwardBase"}
            ZWrite Off //关闭深度写入
            Blend SrcAlpha OneMinusSrcAlpha  //Blend设置混合模式

            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include "Lighting.cginc"

            fixed4 _Color;
            sampler2D _MainTex;
            float4 _MainTex_ST;
            fixed _AlphaScale;  //用于在透明纹理的基础上控制整体的透明度

            struct a2v
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 texcoord : TEXCOORD0; 
            };

            struct v2f
            {
                float4 pos : SV_POSITION;
                float3 worldNormal : TEXCOORD0;
                float3 worldPos : TEXCOORD1;
                float2 uv : TEXCOORD2;
            };
            
            v2f vert(a2v v)
            {
                v2f o;
                o.pos = UnityObjectToClipPos(v.vertex);
                o.worldNormal = UnityObjectToWorldNormal(v.normal);
                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);

                return o;
            }

            fixed4 frag(v2f i) : SV_TARGET
            {
                fixed3 worldNormal = normalize(i.worldNormal);
                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));


                fixed4 texColor = tex2D(_MainTex, i.uv);

                fixed3 albedo = texColor.rgb * _Color.rgb;
                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;
                fixed3 diffuse = _LightColor0.rgb * albedo * saturate(dot(worldNormal,worldLightDir));

                return fixed4(ambient + diffuse, texColor.a * _AlphaScale);  //设置了该片元着色器返回值中的透明通道，它是纹理像素的透明通道和材质参数_AlphaScale的乘积
            }
            
            ENDCG
        }
    }
    Fallback "Transparent/VertexLit"
}
```

#### 2. 开启深度写入的半透明效果
由于透明度混合关闭深度写入，我们就无法对模型进行像素级别的深度排序。当模型本身有复杂的遮挡关系或是包含了复杂的非凸网格的时候, 就会有各种各样因为排序错误而产生的错误的透明效果。

**我们可以想办法重新利用深度写入, 一种解决办法是是使用两个 Pass 来渲染模型:** 
1. 第一个 Pass： 开启深度写入，但不输出颜色，它的目的仅仅是为了把该模型的深度值写入深度缓冲中;
2. 第二个 Pass ：进行正常的透明度混合，由于上一个 Pass 已经得到了逐像素的正确的深度信息，该 Pass 就可以按照像素级别的深度排序结果进行透明渲染。

使用这种方法我们仍可以实现模型与他后面的背景混合的效果，同时模型内部之间不会有任何的半透明效果。但这种方法的缺点在于，多使用一个 Pass 会对性能造成一定的影响。

**这个新添加的 Pass 的目的仅仅是为了把模型的深度信息写入深度缓冲中，从而剔除模型中被自身遮挡的片元。** 因此，Pass 的第一行开启了深度写入。
在第二行，我们使用了一个新的渲染命令—— `ColorMask`。
**在 ShaderLab 中，`ColorMask` 用于设置颜色通道的写掩码 (write mask)。它的语义如下:**
`ColorMask RGB/A/0/其他任何 R、G、B、A 的组合`

**当 ColorMask 设为 0 时，即使用 `ColorMask 0` 指令，意味着该 Pass 不写入任何颜色通道，即不会输出任何颜色。** 这正是我们需要的，该 Pass 只需写入深度缓存即可。


![image-20220704154337978](image-20220704154337978.png)

```c h:20,28
Shader "Unlit/MyAlphaBlendZwriteMat"
{
    Properties
    {
        _Color ("Main Tint", Color) = (1, 1, 1, 1)
        _MainTex ("Main Tex", 2D) = "white" {}
        _AlphaScale ("Alpha Scale", Range (0, 1))= 0.5   
    }
    SubShader
    {
        Tags 
        { 
            "Queue"="Transparent"                //透明度混合使用Transparent渲染队列
            "IgnoreProjector"="True"           //该Shader不会受到投影器的影响
            "RenderType"="Transparent"    //把该Shader归入到提前定义的组中（Transparent组），以指明该Shader时一个使用了透明度混合的Shader，该标签通常被用于着色器替换功能
        }
        
        //使用两个Pass来渲染模型

        //第一个Pass开启深度写入，但不输出颜色，目的仅仅是为了把该模型的深度值写入深度缓冲中
        pass
        {
            Zwrite On
            ColorMask 0
            //ColorMask用于设置颜色通道的写掩码（write mask）,设为0，意味着该Pass不写入任何颜色通道
        }

        //第二个Pass进行正常的透明度混合，由于上一个Pass已经得到了逐像素的正确深度信息，该Pass就可以按照像素级别的深度排序结果进行透明渲染
        Pass
        {
            Tags{"LightMode"="ForwardBase"}
            ZWrite Off //关闭深度写入
            Blend SrcAlpha OneMinusSrcAlpha  //Blend设置混合模式

            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #include "Lighting.cginc"

            fixed4 _Color;
            sampler2D _MainTex;
            float4 _MainTex_ST;
            fixed _AlphaScale;  //用于在透明纹理的基础上控制整体的透明度

            struct a2v
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 texcoord : TEXCOORD0; 
            };

            struct v2f
            {
                float4 pos : SV_POSITION;
                float3 worldNormal : TEXCOORD0;
                float3 worldPos : TEXCOORD1;
                float2 uv : TEXCOORD2;
            };
            
            v2f vert(a2v v)
            {
                v2f o;
                o.pos = UnityObjectToClipPos(v.vertex);
                o.worldNormal = UnityObjectToWorldNormal(v.normal);
                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
                o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);

                return o;
            }

            fixed4 frag(v2f i) : SV_TARGET
            {
                fixed3 worldNormal = normalize(i.worldNormal);
                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));


                fixed4 texColor = tex2D (_MainTex, i.uv);

                fixed3 albedo = texColor.rgb * _Color.rgb;
                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;
                fixed3 diffuse = _LightColor0.rgb * albedo * saturate(dot(worldNormal,worldLightDir));

                return fixed4(ambient + diffuse, texColor.a * _AlphaScale);  //设置了该片元着色器返回值中的透明通道，它是纹理像素的透明通道和材质参数_AlphaScale的乘积
            }
            
            ENDCG
        }
    }
    Fallback "Transparent/VertexLit"
}
```

### 双面渲染


![image-20220704155211450](image-20220704155211450.png)

#### 1. 透明度测试的双面渲染
代码和透明度测试一样，只需要添加 `Cull Off` 指令
![image-20220704155008714](image-20220704155008714.png)

#### 2. 透明度混合的双面渲染

再透明度混合代码的基础上直接添加 `Cull Off` 指令，无法保证同一个物体的正面和背面图元的渲染顺序。

为此，我们选择把双面渲染的工作分成两个 Pass：
- 第一个 Pass 只渲染背面
- 第二个 Pass 只渲染正面

**由于 Unity 会顺序执行 SubShader 中的各个 Pass，因此我们可以保证背面总是在正面被渲染之前渲染，从而可以保证正确的深度渲染关系。**

![image-20220704155047959](image-20220704155047959.png)


# 3 Alpha 通道预乘问题
![[AP01_L15_5.jpg]]
