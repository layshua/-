
---
title: 《数据持久化》
aliases: []
tags: []
create_time: 2023-06-08 00:15
uid: 202306080015
banner: "![[]]"
---

![[Pasted image 20230611210946.png]]
**什么是数据持久化？**
数据持久化就是将内存中的数据模型转换为存储模型, 以及将存储模型转换为内存中的数据模型的统称
说人话: **将游戏数据存储到硬盘，硬盘中数据读取到游戏中，也就是传统意义上的存盘。**

**如何理解不同后缀的文件?**
文件后缀名决定了文件的格式
不同的软件可以根据后缀名用来判断文件的类型并且在打开文件时以特定的读取规则去解析它
文件后缀名是人为定的规则可以有无数种，可以自定义

# Playerprefs
## 基本方法
prefs：控制台

- Playerprefs 是 unity 提供的可以用于**存储读取玩家数据的公共类**
- PlayerPrefs 的数据存储类似于**键值对**存储，一个键对应一个值
    - 提供了存储 3 种数据的方法：int float string
    - 键：string 类型
    - 值：int float string  对应 3 种 API
- 如果不同类型用同一键名进行存储，会覆盖数据


> [!NOTE] 数据的唯一性
> PlayerPrefs 中不同数据的唯一性是由 key 决定的，不同的 key 决定了不同的数据，同一项目中如果不同数据 key 相同，会造成数据丢失要保证数据不丢失，就要建立一个保证 key 唯一的规则。

```cs file:存储数据
//直接调用set相关方法只会把数据存到内存里
//当游戏结束时 Unity会自动把数据存到硬盘中
PlayerPrefs.SetInt("myAge",18);  
PlayerPrefs.SetFloat("myHeight",1.75f);
PlayerPrefs.SetString("myName","张三");

//如果游戏不是正常结束的，而是崩溃，数据是不会存到硬盘中的
//可以调用save方法手动把数据存到硬盘中
PlayerPrefs.Save();
```

**注意运行时只要你 set 了对应键值对，即使你没有马上存储 save 在本地，也能够读取出信息**
```cs file:读取数据
int age = PlayerPrefs.GetInt("myAge",20); //可选第二参数，如果找不到myAge的值，就会返回第二个参数   
float height = PlayerPrefs.GetFloat("myHeight");
string name = PlayerPrefs.GetString("myName");
```

```cs file:判断数据是否存在
if(PlayerPrefs.HasKey("myAge"))
{
    print("myAge存在");
}
```

```cs file:删除数据
//删除单个数据
PlayerPrefs.DeleteKey("MyAge");
//删除所有存储的数据
PlayerPrefs.DeleteAll();
```

## 存储其他类型
PlayerPrefs 是有局限性的它只能存 3 种类型的数据，如果你想要存储别的类型的数据只能降低精度或者上升精度来进行存储，当然也可采用下面的小 trick：

```cs file:trick存储bool类型
bool sex = true;
PlayerPrefs.SetInt( "sex", sex ? 1 : 0);
```

**存储更复杂的 List<> 类型**

```cs file:存储更复杂的List<>类型


public class Player
{
    private string _name;
    public int _age;
    private int _atk;
    private int _def;

    //装备信息
    public List<Equipment> EquipmentsList;

    //该变量时一个存储和读取的唯一key标识。识别多个玩家，分别存储
    private string _keyName;

    public void Save()
    {
        PlayerPrefs.SetString(_keyName + "name", _name);
        PlayerPrefs.SetInt(_keyName + "age", _age);
        PlayerPrefs.SetInt(_keyName + "atk", _atk);
        PlayerPrefs.SetInt(_keyName + "def", _def);

        //装备信息
        PlayerPrefs.SetInt("EquipmentsCount", EquipmentsList.Count);
        for (int i = 0; i < EquipmentsList.Count; i++)
        {
            //存储每一个装备的id和数量
            PlayerPrefs.SetInt("EquipmentsID" + i, EquipmentsList[i]._id);
            PlayerPrefs.SetInt("EquipmentsCount" + i, EquipmentsList[i]._count);
        }
    }

    public void Load(string keyName)
    {
        this._keyName = keyName; 
        
        _name = PlayerPrefs.GetString(keyName + "name", "test");
        _age = PlayerPrefs.GetInt(keyName + "age", 18);
        _atk = PlayerPrefs.GetInt(keyName + "atk", 100);
        _def = PlayerPrefs.GetInt(keyName + "def", 1000);

        //装备信息
        int num = PlayerPrefs.GetInt("EquipmentsCount", 0);
        EquipmentsList = new List<Equipment>();
        for (int i = 0; i < num; i++)
        {
            Equipment equipment = new Equipment();
            equipment._id = PlayerPrefs.GetInt("EquipmentsID" + i, 0);
            equipment._count = PlayerPrefs.GetInt("EquipmentsCount" + i, 0);
            EquipmentsList.Add(equipment);
        }
    }
}

public class Equipment
{
    public int _id;
    public int _count;
}

public class NewBehaviourScript1 : MonoBehaviour
{
    void Start()
    {
        Player player1 = new Player();
        player1.Load("Player1");

        print("装备列表数量：" + player1.EquipmentsList.Count);

        for (int i = 0; i < player1.EquipmentsList.Count; i++)
        {
            print("道具ID：" + player1.EquipmentsList[i]._id);
            print("道具数量：" + player1.EquipmentsList[i]._count);
        }


        Equipment equipment1 = new Equipment();
        equipment1._id = 1;
        equipment1._count = 1;

        Equipment equipment2 = new Equipment();
        equipment2._id = 2;
        equipment2._count = 2;

        player1.EquipmentsList.Add(equipment1);
        player1.EquipmentsList.Add(equipment2);

        player1.Save();

        print("装备列表数量：" + player1.EquipmentsList.Count);
        for (int i = 0; i < player1.EquipmentsList.Count; i++)
        {
            print("道具ID：" + player1.EquipmentsList[i]._id);
            print("道具数量：" + player1.EquipmentsList[i]._count);
        }
        
        Player player2 = new Player();
        player2.Load("Player2");
        //...
        player2.Save();
        
        //...
    }
}
```

## 存储位置
不同平台存储位置不同
**Win**
存储在 `HKCU\Software\[公司名称]\[产品名称]` 项下的注册表中
其中公司和产品名称是在“Project settings”中设置的名称。 

1. 运行 regedit
2.  `HKEY_CURRENT_USER/SOFTWARE/Unity/UnityEditor/`公司名称/产品名称
**安卓**
`/data/ data/包名/shared_prefs/pkg-name .xml`
 
**IOS**
`/Librany/Preferences/[应用 ID]. plist`


单独使用它的原生功能，非常适合存储一些对安全性要求不高的简单数据
但是也不能小看它，对它进行简单的封装，也可以让它变得方便又安全

## Playerprefs 数据管理类 
```cs
/*
 * 数据管理类提供给外部的方法：
 * 1. 存储数据
 * 2. 读取数据
 * 3. 外部可以传入数据直接进行存储
 * 4. 外部可以传入数据类型直接进行数据获取
 */
using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using Unity.VisualScripting;
using Unity.VisualScripting.FullSerializer;
using UnityEngine;
using UnityEngine.UI;

/// <summary>
/// PlayerPrefs数据管理类，统一管理数据的存储和读取
/// </summary>
public class PlayerPrefsDataManager
{
    //单例模式
    private static PlayerPrefsDataManager instance = new PlayerPrefsDataManager();

    public static PlayerPrefsDataManager Instance
    {
        get { return instance; }
    }

    private PlayerPrefsDataManager()
    {

    }

    /// <summary>
    /// 存储数据
    /// </summary>
    /// <param name="data">数据对象</param>
    /// <param name="keyName">数据对象的唯一性key，自己控制</param>
    public void SaveData(object data, string keyName)
    {
        //就是要通过Type得到传入数据对象的所有的字段
        //然后结合aYerPrefs来进行存储

        #region 第一步：获取传入数据对象的所有字段

        Type dataType = data.GetType();
        //得到所有字段
        FieldInfo[] fieldInfos = dataType.GetFields();

        #endregion

        #region 第二步：自己定义一个key的规则，进行数据存储

        //我们存储都是通过PlayerPrefs来进行存储的
        //保证key的唯一性我们就需要自己定一个key的规则
        //key的规则：keyName_数据类型_字段类型_字段名

        #endregion

        #region 第三步：遍历这些字段，进行数据存储

        string saveKeyName = "";
        FieldInfo info;
        for (int i = 0; i < fieldInfos.Length; i++)
        {
            //对每一个字段，进行数据存储
            //得到具体的字段信息
            info = fieldInfos[i];
            //通过FieldInfo可以直接获取到字段的类型和字段的名字
            saveKeyName = keyName + "_" + dataType.Name + "_" + info.FieldType + "_" + info.Name;

            //现在得到了Key按照我们的规则
            //接下来就要来通过PlayerPrefs来进行存储
            SaveValue(info.GetValue(data), saveKeyName);
        }
        
        PlayerPrefs.Save();
        #endregion

    }

    /// <summary>
    /// 存储值
    /// </summary>
    /// <param name="value">数据对象</param>
    /// <param name="saveKeyName">数据对象的唯一性key</param>
    private void SaveValue(object value, string saveKeyName)
    {
        //直接通过PlayerPrefs来进行存储了
        //就是根据数据类型的不同来决定使用哪一个API来进行存储
        //PlayerPrefs只支持3种类型存储
        //判断数据类型是什么类型 然后调用具体的方法来存储
        Type fieldType = value.GetType();

        //int,float,string类型存储
        //类型判断
        if (fieldType == typeof(int))
        {
            PlayerPrefs.SetInt(saveKeyName, (int)value);
        }
        else if (fieldType == typeof(float))
        {
            PlayerPrefs.SetFloat(saveKeyName, (float)value);
        }
        else if (fieldType == typeof(string))
        {
            PlayerPrefs.SetString(saveKeyName, value.ToString());
        }
        else if (fieldType == typeof(bool))
        {
            //自己顶一个存储bool的规则
            PlayerPrefs.SetInt(saveKeyName, (bool)value ? 1 : 0);
        }

        //List<T>类型存储
        //如何判断泛型类的类型？比如List<T>
        //通过反射判断父子关系
        //这相当于判断字段是不是IList的子类
        //为什么想到IList，可以通过List查看他的父类，IList是List的父类，因此可以用父类装子类
        else if (typeof(IList).IsAssignableFrom(fieldType))
        {
            //父类装子类
            IList list = value as IList;
            //先存储数量
            PlayerPrefs.SetInt(saveKeyName, list.Count);
            int index = 0;
            foreach (object obj in list)
            {
                //存储具体的值
                SaveValue(obj, saveKeyName + index); //递归！
                ++index;
            }
        }

        //Dictionary<T>类型存储
        //同理，IDictionary是Dictionary的父类
        else if (typeof(IList).IsAssignableFrom(fieldType))
        {
            //父类装子类
            IDictionary dictionary = value as IDictionary;
            //先存储字典长度
            PlayerPrefs.SetInt(saveKeyName, dictionary.Count);
            //遍历存储字典里面的具体值
            int index = 0;
            foreach (object key in dictionary.Keys)
            {
                SaveValue(key, saveKeyName + "_key_" + index); //递归！
                SaveValue(dictionary[key], saveKeyName + "_value_" + index);
                ++index;
            }

        }

        //存储自定义类类型
        else
        {
            SavaData(value, saveKeyName); //递归
        }
    }


    /// <summary>
    /// 读取数据
    /// </summary>
    /// <param name="type">想要读取数据的数据类型</param>
    /// <param name="keyName">数据对象的唯一性key，自己控制</param>
    public object LoadData(Type type, string keyName)
    {
        //不用object对象传入 而使用Type传入的原因是:
        //object对象传入的话，必须在外部new一个对象传入
        //而Type传入的话，只需要一个Type typeof(Player)，就可以直接使用Activator.CreateInstance(type)来创建对象
        //这样可以少写一行代码

        //根据你传入的类型和keyName
        //依据你存储数据时key的拼接规则来进行数据的获取赋值返回出去

        //根据传入的Type 创建一个对象用于存储数据
        object data = Activator.CreateInstance(type);

        //要往这个new出来的对象中填充数据
        //得到所有字段
        FieldInfo[] fieldInfos = type.GetFields();
        //用于拼接key的字符串
        string saveKeyName = "";
        FieldInfo info;
        for (int i = 0; i < fieldInfos.Length; i++)
        {
            info = fieldInfos[i];
            //key的拼接规则，一定和存储时一模一样
            saveKeyName = keyName + "_" + type.Name + "_" + info.FieldType + "_" + info.Name;
            //有key就可以结合Playerprefs来读取数据
            //填充数据到data中
            info.SetValue(data, LoadValue(info.FieldType, saveKeyName));
        
        }

        return data;
    }

    /// <summary>
    /// 得到单个数据的方法
    /// </summary>
    /// <param name="fieldType">字段类型，用于判断用哪个api来读取</param>
    /// <param name="saveKeyName">用于获取具体数据</param>
    /// <returns></returns>
    private object LoadValue(Type fieldType, string saveKeyName)
    {
        if (fieldType == typeof(int))
        {
            return PlayerPrefs.GetInt(saveKeyName, 0);
        }
        else if (fieldType == typeof(float))
        {
            return PlayerPrefs.GetFloat(saveKeyName, 0);
        }
        else if (fieldType == typeof(string))
        {
            return PlayerPrefs.GetString(saveKeyName, "");
        }
        else if (fieldType == typeof(bool))
        {
            return PlayerPrefs.GetInt(saveKeyName, 0) == 1 ? true : false;
        }
        else if (typeof(IList).IsAssignableFrom(fieldType))
        {
            //得到长度
            int count = PlayerPrefs.GetInt(saveKeyName, 0);
            //创建一个list用于存储数据
            IList list = Activator.CreateInstance(fieldType) as IList;
            for (int i = 0; i < count; i++) 
            {
                //递归
                list.Add(LoadValue(fieldType.GetGenericArguments()[0], saveKeyName + i));
            }
        
            return list;
        }
        else if (typeof(IDictionary).IsAssignableFrom(fieldType))
        {
            //得到长度
            int count = PlayerPrefs.GetInt(saveKeyName, 0);
            //创建一个dictionary用于存储数据
            IDictionary dictionary = Activator.CreateInstance(fieldType) as IDictionary;
            for (int i = 0; i < count; i++)
            {
                //递归
                dictionary.Add(LoadValue(fieldType.GetGenericArguments()[0], saveKeyName + "_key_" + i),
                    LoadValue(fieldType.GetGenericArguments()[1], saveKeyName + "_value_" + i));
            }

            return dictionary;
        }
        else
        {
            //自定义类类型
            return LoadData(fieldType, saveKeyName);
        }
    }
}
```

### 案例
```cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PlayerInfo
{
    public int age;
    public string name;
    public float height;
    public bool sex;

    public List<int> list;

    public Dictionary<int, string> dic1;
    
    //以下都属于自定义类型存储
    public ItemInfo itemInfo;

    public List<ItemInfo> itemList;

    public Dictionary<int, ItemInfo> dic2;

}

public class ItemInfo
{
    public int id;
    public int num;

    public ItemInfo()
    {
        
    }
    
    public ItemInfo(int id, int num)
    {
        this.id = id;
        this.num = num;
    }
}
public class Test : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {
        //读取数据
        PlayerInfo p1 = PlayerPrefsDataManager.Instance.LoadData(typeof(PlayerInfo),"Player1") as PlayerInfo;
        
        //游戏逻辑中回去修改这个玩家数据
        p1.age = 18;
        p1.name = "张三";
        p1.height = 185;
        p1.itemList.Add(new ItemInfo(1, 123));
        p1.itemList.Add(new ItemInfo(2, 456));
        p1.dic1.Add(3, "长剑");
        p1.dic2.Add(4, new ItemInfo(3,789));
        
        //需要把这个数据对象的信息 存储到硬盘
        PlayerPrefsDataManager.Instance.SaveData(p1, "player1");
    }
    
    // Update is called once per frame
    void Update()
    {
        
    }
}
```
# Json
全称：JavaScript 对象简谱 (JavaScript Object Notation) 
Json 是国际通用的一种轻量级的数据交换格式
主要在网络通讯中用于传输数据，或本地数据存储和读取
易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率
![[Pasted image 20230611211123.png]]
我们一般**使用 Json 文件来记录和传输数据**

Json 文档就是使用 Json 格式配置填写的文档后缀一般为.json
我们在游戏中可以把游戏数据按照 Json 的格式标准存储在 Json 文档中，再将 Json 文档存储在硬盘上或者传输给远端，达到数据持久化或者数据传输的目的。

|**Json 和 Xml 的异同（Json 更好用！）** |   |
|:--|:--|
|**共同点**|**不同点**|
|都是纯文本|Json配置更简单|
|都有层级结构|Json在某些情况下读写更快速|
|都具有描述性|  |

**优点**
1. 和 XML 一致的优点
    1.  Json 是国际通用规则
    2. 跨平台（游戏，软件，网页等等都能用，不同操作系统也能用)
    3. 文件结构清晰易懂，非常容易编辑和理解
    4. 可以用于网络通信交换数据

**缺点**
1. 重复工作量繁多
    1. 自定义数据类，都需要自己去实现存储读取的功能
    2. 而且代码的相似度极高
2. 数据容易被修改，只要找到文件位置，就可以轻易的进行数据修改

**主要用处：**
网络游戏：可以用于存储一些客户端的简单不重要数据，可以用于传输信息
单机游戏：用于存储游戏相关数据，用于配置游戏数据（结合 UI 第三部曲一起讲解)

## 语法规则
注释格式和 cs 一样，`//` 或者 `/* */`
![[Pasted image 20230611211909.png]]

![[Pasted image 20230611212009.png]]
```json
{
    "name":"大卫",
    "age":18,
    "sex":true,
    "ids":[1,2,3,4,5,6],
    "students":[
        {"name":"小红","age":16,"sex":true},
        {"name":"小明","age":15,"sex":false}
    ],
    "home":{"address":"成都","street":"春熙路"},
    "son":null,
    
    //字典类型，键会变成双引号以后转换时要注意!!!
    "dic":{"1":"123","2": "234"}
}
```
Json 格式是一种键值对结构
![[Pasted image 20230611211722.png|450]]

> [!NOTE] 注意事项
> 
> 1. 如果数据表示对象，那么最外层有大括号
> 2. 一定是键值对形式
> 3. **键一定是字符串格式** 
> 4. 键值对用逗号分开 
> 5. 数组用 `[ ]` 包裹 
> 6. 对象用`{}`包裹

### Excel 转 Json
1. 在 Excel 表中配置游戏数据——更方便策划人员配置
2. 将 Excel 表中配置的数据转为 Json 配置——方便将数据读取到内存中

![[Pasted image 20230611213325.png]]
上图 XML 中的数据对应的 Excel 表如下：

| hp | speed  | volume | resName           | scale |
|----|--------|--------|-------------------|-------|
| 4  | 6      | 5      | Airplane/Airplan1 | 15    |
| 3  | 7      | 4      | Airplane/Airplan2 | 15    |
| 2  | 8      | 3      | Airplane/Airplan3 | 15    |
| 10 | 3      | 10     | Airplane/Airplan4 | 6     |
| 6  | 5      | 7      | Airplane/Airplan5 | 10    |

转换方法：
1. 在百度或者 Google 搜索 Excel 转 Json.
2.  在线转换网站 https://www.bejson.com/json/col2json/
3. 进行转换
4. 保存 Json 格式的数据

**转换结果如下：**
![[Pasted image 20230611214123.png|450]]

```Json file:Roleinfo.json
[
{"hp":4,"speed ":6,"volume":5,"resName":"Airplane/Airplan1","scale":15},
{"hp":3,"speed ":7,"volume":4,"resName":"Airplane/Airplan2","scale":15},
{"hp":2,"speed ":8,"volume":3,"resName":"Airplane/Airplan3","scale":15},
{"hp":10,"speed ":3,"volume":10,"resName":"Airplane/Airplan4","scale":6},
{"hp":6,"speed ":5,"volume":7,"resName":"Airplane/Airplan5","scale":10}
]
```

## JsonUtlity
`JsonUtlity` 是 unity 自带的用于解析 Json 的公共类

> [!NOTE] 序列化与反序列化
>1. 序列化是将对象转换为二进制流的过程
>2. 反序列化是将二进制流转换为对象的过程。
>3. 序列化主要解决对象的传输问题。  

**功能：**
1. 将内存中对象序列化为 Json 格式的字符串 
2. 将 Json 字符串反序列化为类对象

### 在文件中读写字符串
导入命名空间 `using System.IO;`

文件夹路径相关： [[《Unity Primer》#1 文件夹路径获取]]

```cs
//1.存储字符串到指定路径文件中
//参数一：是存储的路径（若路径中有文件夹名，必须保证文件夹存在）
//参数二：存储的字符串内容
File.WriteAllText(Application.persistentDataPath + "/test.json", "Hello World"); 
print(Application.persistentDataPath); //打印路径方便定位文件

//2.在指定路径文件中读取字符串
string str = File.ReadAllText(Application.persistentDataPath + "/test.json");
print(str); 
        
```


### 序列化
**序列化：把内存中的数据（类的对象数据）存储到硬盘（以 Json 文件等方式保存）上**  
**方法**：`JsonUtility.ToJson(对象)` 把对象转换成json字符串

**注意:**
1. float 序列化时看起来会有一些误差
2. 自定义类需要加上序列化特性`[System.Serializable]`
3. 想要序列化私有变量需要加上特性 `[SerializeField]`
4. `JsonUtility` 不支持字典
5. `JsonUtlity` 存储 null 对象不会是 null ，而是默认值的数据

```cs file:序列化
[System.Serializable]
public class Student
{
    public int age;
    public string name;

    public Student(int age, string name)
    {
        this.age = age;
        this.name = name;
    }
}

[System.Serializable]
public class MyData
{
    public string name;
    public int age;
    public float height;
    public double weight;
    public bool sex;

    public int[] ids1;
    public List<int> ids2;
    public Dictionary<int, string> dic1;
    public Dictionary<string,string> dic2;
    
    public Student stu;
    public List<Student> stus;
    
    [SerializeField]
    private int id;
    [SerializeField]
    protected string address;
}

public class Test : MonoBehaviour
{
    void Start()
    {
        //1. 创建类的对象
        MyData data = new MyData();
        
        data.name = "张三";
        data.age = 18;
        data.height = 1.75f;
        data.weight = 175.0;
        data.sex = true;
        
        data.ids1 = new int[]{1,2,3,4,5};
        data.ids2 = new List<int>(){1,2,3,4,5};
        data.dic1 = new Dictionary<int, string>()
        {
            {1,"张三"},
            {2,"李四"},
            {3,"王五"},
        };
        data.dic2 = new Dictionary<string, string>()
        {
            { "1", "123" },
            { "2", "456" },
            { "3", "789" },
        };

        data.stu = null;
        
        data.stus = new List<Student>()
        {
            new Student(18, "张三"),
            new Student(12, "张s"),
            new Student(18, "张sd"),
        };

        //2. 序列化，存储字符串
        string jsonStr = JsonUtility.ToJson(data);
        File.WriteAllText(Application.persistentDataPath+ "/data.json", jsonStr);
        print(Application.persistentDataPath);
    }
}
```

得到的 Json 文件内容如下：
```json file:data.json
{"name":"张三","age":18,"height":1.75,"weight":175.0,"sex":true,"ids1":[1,2,3,4,5],"ids2":[1,2,3,4,5],"stu":{"age":0,"name":""},"stus":[{"age":18,"name":"张三"},{"age":12,"name":"张s"},{"age":18,"name":"张sd"}],"id":0,"address":""}
```

### 反序列化
**反序列化：把硬盘上的数据（Json 文件数据）读取到内存（类的对象数据）中**

方法：`JsonUtility.FromJson(字符串)`

以 data. json 为例，我们对它反序列化：
```json file:data.json
{"name":"张三","age":18,"height":1.75,"weight":175.0,"sex":true,"ids1":[1,2,3,4,5],"ids2":[1,2,3,4,5],"stu":{"age":0,"name":""},"stus":[{"age":18,"name":"张三"},{"age":12,"name":"张s"},{"age":18,"name":"张sd"}],"id":0,"address":""}
```

```cs file:反序列化
//反序列化要求我们要写出符合Json文件内容的数据结构
[System.Serializable]
public class Student
{
    public int age;
    public string name;

    public Student(int age, string name)
    {
        this.age = age;
        this.name = name;
    }
}
[System.Serializable]
public class MyData
{
    public string name;
    public int age;
    public float height;
    public double weight;
    public bool sex;

    public int[] ids1;
    public List<int> ids2;
    public Dictionary<int, string> dic1;
    public Dictionary<string,string> dic2;
    
    public Student stu;
    public List<Student> stus;
    
    [SerializeField]
    private int id;
    [SerializeField]
    protected string address;
}


public class Test : MonoBehaviour
{
    void Start()
    {
        //1. 读取文件中的Json字符串
        string jsonStr = File.ReadAllText(Application.persistentDataPath+ "/data.json");
        
        //2. 反序列化,将Json字符串转换为类对象
        //MyData data = JsonUtility.FromJson(jsonString,typeof(MyData)) as MyData;
        //更推荐使用泛型方法！！！
        MyData data = JsonUtility.FromJson<MyData>(jsonStr);
        
        //3. 获取data对象的信息
        print(data.age); 
        print(data.name);
        print(data.height);
        //...省略
    }
}
```

### 注意事项
1. **`JsonUtlity` 无法直接读取数据集合（用 `[]` 包含的数组）**
2. Json文本编码格式要时 UTF-8 不然无法加载

前文我们得到了一个 json 文件内容如下，如果直接对其反序列化会报错，因为 Unity 反序列化不支持读取数组
```Json file:Roleinfo.json
[
{"hp":4,"speed ":6,"volume":5,"resName":"Airplane/Airplan1","scale":15},
{"hp":3,"speed ":7,"volume":4,"resName":"Airplane/Airplan2","scale":15},
{"hp":2,"speed ":8,"volume":3,"resName":"Airplane/Airplan3","scale":15},
{"hp":10,"speed ":3,"volume":10,"resName":"Airplane/Airplan4","scale":6},
{"hp":6,"speed ":5,"volume":7,"resName":"Airplane/Airplan5","scale":10}
]
```

```cs
[System.Serializable]
public class Roleinfo
{
    public int hp;
    public int speed;
    public int volume;
    public string resName;
    public int scale;
} 

jsonStr = File.ReadAllText(Application.streamingAssetsPath + "/Roleinfo.json");
print(jsonstr);

//企图用一个List数组储存,报错！
List<Roleinfo> roleinfoList = JsonUtility.FronJson<List<Roleinfo>>(jsonStr);
```

**正确的读取方法：**
1. 修改 Json 文件：
```cs
{
    "List":[
    {"hp":4,"speed ":6,"volume":5,"resName":"Airplane/Airplan1","scale":15},
    {"hp":3,"speed ":7,"volume":4,"resName":"Airplane/Airplan2","scale":15},
    {"hp":2,"speed ":8,"volume":3,"resName":"Airplane/Airplan3","scale":15},
    {"hp":10,"speed ":3,"volume":10,"resName":"Airplane/Airplan4","scale":6},
    {"hp":6,"speed ":5,"volume":7,"resName":"Airplane/Airplan5","scale":10}
    ]
}
```

2. 添加类, 然后读取
```cs
[System.Serializable]
public class Roleinfo
{
    public int hp;
    public int speed;
    public int volume;
    public string resName;
    public int scale;
} 

[System.Serializable]
public class RoleData
{
    public List<RoleInfo> list;
}


jsonStr = File.ReadAllText(Application.streamingAssetsPath + "/Roleinfo.json");
print(jsonstr);

RoleData data = JsonUtility.FronJson<RoleData>(jsonStr); //反序列化成功
```

## LitJson
- LitJson 是一个第三方库，用于处理 Json 的序列化和反序列化 
- LitJson 是 cs 编写的，体积小、速度快、易于使用
- 它可以很容易的嵌入到我们的代码中
- 只需要将 LitJson 代码拷贝到工程中即可


### 获取 LitJson
1. 前往 LitJson 官网[LitJSON - Home](https://litjson.net/)
2. 通过官网前往 GitHub 获取最新版本代码
3. 将 src 文件夹下的 LitJson 文件夹拷贝到 unity 工程中，即可开始使用 LitJson
4. 使用时引用 LitJson 命名空间 `using LitJson;`
### 序列化
方法：`JsonMapper.ToJson(对象)`

注意:
1. 相对 JsonUtlity **不需要加特性**
2.  **不能序列化私有变量**
3. **支持字典类型**，建议**字典的键值都是字符串**，因为 Json 的特点，键会加上双引号
4. 可以保存 null 类型

```cs file:序列化
public class Student
{
    public int age;
    public string name;

    public Student(int age, string name)
    {
        this.age = age;
        this.name = name;
    }
}

public class MyData
{
    public string name;
    public int age;
    public float height;
    public double weight;
    public bool sex;

    public int[] ids1;
    public List<int> ids2;
    public Dictionary<string,string> dic;
    
    public Student stu;
    public List<Student> stus;
    
    private int id;
    protected string address;
}


public class Test : MonoBehaviour
{
    void Start()
    {
        //1. 创建类的对象
        MyData data = new MyData();
        
        data.name = "张三";
        data.age = 18;
        data.height = 1.75f;
        data.weight = 175.0;
        data.sex = true;
        
        data.ids1 = new int[]{1,2,3,4,5};
        data.ids2 = new List<int>(){1,2,3,4,5};
        data.dic = new Dictionary<string, string>()
        {
            { "1", "123" },
            { "2", "456" },
            { "3", "789" },
        };

        data.stu = null;
        
        data.stus = new List<Student>()
        {
            new Student(18, "张三"),
            new Student(12, "张s"),
            new Student(18, "张sd"),
        };
        
        //2. 序列化，存储字符串
        string jsonStr = JsonMapper.ToJson(data);
        File.WriteAllText(Application.persistentDataPath+ "/data.json", jsonStr);
        print(Application.persistentDataPath);
    }
}

```

得到的 Json 文件内容如下：

```json file:data.json
{"name":"\u5F20\u4E09","age":18,"height":1.75,"weight":175.0,"sex":true,"ids1":[1,2,3,4,5],"ids2":[1,2,3,4,5],"dic":{"1":"123","2":"456","3":"789"},"stu":null,"stus":[{"age":18,"name":"\u5F20\u4E09"},{"age":12,"name":"\u5F20s"},{"age":18,"name":"\u5F20sd"}]}
```

### 反序列化
**方法：** `JsonMapper.ToObject(字符串)`

**注意：**
1. **类结构需要无参构造函数**，否则反序列化时报错
2. 字典虽然支持，但是**键**在使用为数值时会有问题，**需要使用字符串类型**


```cs
public class Student
{
    public int age;
    public string name;

    //因为这里自己写了构造函数覆盖掉了无参构造函数
    //所以要手动添加无参构造函数
    public Student()
    { }
    
    public Student(int age, string name)
    {
        this.age = age;
        this.name = name;
    }
}

public class MyData
{
    public string name;
    public int age;
    public float height;
    public double weight;
    public bool sex;

    public int[] ids1;
    public List<int> ids2;
    public Dictionary<string,string> dic;
    
    public Student stu;
    public List<Student> stus;
    
    private int id;
    protected string address;
}

public class Test : MonoBehaviour
{
    void Start()
    {
        //1. 读取文件中的Json字符串
        string jsonStr = File.ReadAllText(Application.persistentDataPath+ "/data.json");
        
        //2. 反序列化，将Json字符串转换为类对象
        MyData data = JsonMapper.ToObject<MyData>(jsonStr);
        
        //3. 获取data对象的信息
        print(data.age);
        print(data.name);
        print(data.height);
        //省略...
    }
}
```

### 注意事项
1. LitJson **可以直接读取数据集合**（用 `[]` 包含的数组）
2. 文本编码格式需要是 UTF-8， 不然无法加载

前文我们得到了一个 json 文件内容如下，对其进行反序列化
```Json file:Roleinfo.json
[
{"hp":4,"speed ":6,"volume":5,"resName":"Airplane/Airplan1","scale":15},
{"hp":3,"speed ":7,"volume":4,"resName":"Airplane/Airplan2","scale":15},
{"hp":2,"speed ":8,"volume":3,"resName":"Airplane/Airplan3","scale":15},
{"hp":10,"speed ":3,"volume":10,"resName":"Airplane/Airplan4","scale":6},
{"hp":6,"speed ":5,"volume":7,"resName":"Airplane/Airplan5","scale":10}
]
```

```cs
public class RoleInfo
{
    public int hp;
    public int speed;
    public int volume;
    public string resName;
    public int scale;
} 

jsonStr = File.ReadAllText(Application.streamingAssetsPath + "/RoleInfo.json");
print(jsonstr);

//反序列化
//方式一：
RoInfo[] arr = JsonMapper.ToObject<RoleInfo[]>(jsonStr);
//方式二：
List<RoInfo> list = JsonMapper.ToObject<List<RoInfo>>(jsonStr); 
```

## Json 数据管理类
