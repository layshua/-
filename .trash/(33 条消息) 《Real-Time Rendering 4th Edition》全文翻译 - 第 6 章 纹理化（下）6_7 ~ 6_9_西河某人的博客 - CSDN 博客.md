最近比较有动力，再来一篇！~

![](https://img-blog.csdnimg.cn/20191121190022895.png)

## **6.7 凹凸映射 Bump Mapping**

本节描述了一大类的小型细节表示技术，我们将其统称为凹凸映射。所有这些方法通常都是通过修改每个像素的着色流程来实现的。们比起单独的纹理贴图具有更多的三维外观，但却不用添加额外的几何结构。

一个对象的细节可以分为三个等级：覆盖许多像素的宏观特征（macro-features），横跨几个像素的细观特征（meso-features），和实质上小于一个像素的微观特征（micro-features）。这些分类在某种程度上是流动的，因为在动画或交互式操作期间，观看者可能在不同距离观察到同一对象。

宏观几何由顶点和三角形或其他几何图元表示。创建三维角色时，通常以宏观尺度对肢体和头部进行建模。微观的几何结构被封装在着色模型中，该着色模型通常在像素着色器中实现，并使用纹理贴图作为参数。所用的着色模型可模拟表面微观几何结构的相互作用，例如，发光物体在微观上是光滑的，而漫射表面在微观上是粗糙的。角色的皮肤和衣服似乎具有不同的材质，因为它们使用不同的着色器，或者至少使用这些着色器中的不同参数。

细观几何结构描述了宏观与微观尺度之间的一切。它包含的细节过于复杂，无法使用单个三角形进行有效渲染，但是对于观察者来说，它足以区分表面曲率在几个像素上的变化。例如角色脸上的皱纹，肌肉结构细节以及衣服上的褶皱和接缝都是细观尺度的。细观尺度建模通常使用一类方法，它们被统称凹凸映射技术。它们在像素级别调整着色参数，以使观看者感觉到远离基本几何结构的微小干扰，而基本几何结构实际上保持平坦。不同种类的凹凸映射之间的主要区别是它们如何表示细节特征。其变量包括现实级别和细节特征的复杂性。例如，数字艺术家通常将细节雕刻到模型中，然后使用软件将这些几何元素转换为一种或多种纹理，例如凹凸纹理和缝隙变暗的纹理。

布林（Blinn）在 1978 年提出了在纹理中编码细观尺度细节的想法 **[160]**。他观察到，如果在着色过程中用稍微受扰动的表面法线代替真实的表面，则表面似乎具有小范围的细节。他将描述表面法线微扰动的数据存储在数组中。

这里的关键思想是，我们不使用纹理来更改照明方程式中的颜色分量，而是访问纹理来修改表面法线。模型表面的几何法线实际上保持不变。我们仅修改照明方程式中使用的法线。此操作没有物理等效项。我们在曲面法线上执行更改，但曲面本身在几何意义上保持平滑。就像每个顶点具有法线一样，它给人一种幻觉，即三角形之间的表面很光滑。修改每个像素的法线会改变三角形表面本身的视觉感知，但不会改变其几何结构。

对于凹凸映射，法线必须相对于某个参考系改变方向。为此，我们将切线框架（ tangent frame，也称为切线空间基底 ，tangent-space basis）存储在每个顶点上。此参考系用于将灯光转换到表面位置的空间（反之亦然），以计算干扰法线的效果。除了顶点法线外，在多边形表面上应用了法线贴图的情况下，我们还存储了切线（tangent）和副切线向量（bitangent vectors）。双切线向量也被错误地称为副法线向量（binormal vector） **[1025]**。

切线和副切线向量表示法线贴图本身在对象空间中的轴，因为目标是将光照转换为相对于贴图的光照。参见图 6.32。

![](https://img-blog.csdnimg.cn/20201012205129202.png)

**图 6.32.** 展示了一个球形三角形，其切线框显示在每个角上。形状像圆球和圆环的，具有自然的切线空间基础，正如圆环上的纬度和经度线所示。

法线 n，切线 t 和切线 b 这三个向量形成一个基本矩阵：

![](https://img-blog.csdnimg.cn/20201012204928963.png)

这个矩阵有时缩写为 TBN，它将光的方向（对于给定的顶点）从世界空间转换为切线空间 这些向量不必真正彼此垂直，因为法线贴图本身可能会变形以适合曲面。但是，非正交的基底会导致纹理倾斜，这可能意味着需要更多的存储空间，并且可能会对性能产生影响，即矩阵无法通过简单的转置来反转 **[494]**。节省内存的一种方法是仅在顶点存储切线和副切线，并取它们的叉积来计算法线。但是，只有在矩阵的手性（handedness）始终相同的情况下，此技术才有效 **[1226]**。通常，模型是对称的：飞机，人，文件柜和许多其他对象。由于纹理消耗大量内存，因此它们通常会被镜像到对称模型上。因此，虽然仅存储对象纹理的一侧，但是纹理映射将其放置在模型的两侧。在这种情况下，切线空间的旋向性在两侧会有所不同，所以无法进行假设 **(?)**。如果在每个顶点存储了额外的信息位来指示手性，那么在这种情况下仍然可以避免存储法线。如果已经设置完毕，则此位数用于求反切线和双切线的叉积，以生成正确的法线。如果切线框架是正交的，则还可以将基础存储为四元数（第 4.3 节），这既节省空间，又可以节省每个像素的一些计算 **[494、1114、1154、1381、1639]**。尽管在实践中很少见，但质量可能会略有下降。

切线空间的思想对于其他算法很重要。如下一章所述，许多着色方程仅依赖于曲面的法线方向。但是，诸如拉丝铝或天鹅绒之类的材质也需要知道观察者和照明相对于表面的相对方向。切线框架可用于定义材质在表面上的方向。Lengyel **[1025]** 和 Mittring **[1226]** 的文章提供了该领域的广泛叙述。Schüler **[1584]** 提出了一种在像素着色器中动态计算切线空间的方法，而无需逐顶点去存储预先计算的切线帧。Mikkelsen **[1209]** 对这项技术进行了改进，并推导了一种不需要任何参数化方法，而是使用表面位置的导数和高度场的导数来计算扰动法线的方法。但是，与使用标准切线空间映射相比，此类技术会导致显示的细节大大减少，并可能产生美术工作流的问题 **[1639]**。

### 6.7.1 布林的方法 Blinn’s Methods

布林最初的凹凸映射方法在纹理的每个纹理像素上存储两个有符号的值 

![](https://private.codecogs.com/gif.latex?%5Clarge%20b_%7Bu%7D)

 和 

![](https://private.codecogs.com/gif.latex?%5Clarge%20b_%7Bv%7D)

。这两个值对应于沿 u 和 v 图像轴改变法线的量。即，这些通常是双线性插值的纹理值用于缩放垂直于法线的两个向量。将这两个向量添加到法线以更改其方向。两个值

![](https://private.codecogs.com/gif.latex?%5Clarge%20b_%7Bu%7D)

和 

![](https://private.codecogs.com/gif.latex?%5Clarge%20b_%7Bv%7D)

 描述了曲面在该点面向哪个方向。见图 6.33。这种类型的凹凸贴图纹理称为偏移向量凹凸贴图（offset vector bump map）或偏移贴图（offset map）。

![](https://img-blog.csdnimg.cn/20201013135554191.png)

**图 6.33.** 在左侧，法线向量 n 通过从凹凸纹理获取的（

![](https://private.codecogs.com/gif.latex?%5Clarge%20b_%7Bu%7D)

，

![](https://private.codecogs.com/gif.latex?%5Clarge%20b_%7Bv%7D)

）值在 u 方向和 v 方向上进行修改，得到 n'（未归一化）。右侧显示了一个高度场及其对着色法线的影响。可以在高度之间对这些法线插值，以获得更平滑的外观。

表示凹凸的另一种方法是使用高度场（heightfield）来修改表面法线的方向。每个单色纹理值代表一个高度，因此在纹理中，白色是高区域，黑色是低区域（反之亦然）。有关示例，请参见图 6.34。这是首次创建或浏览凹凸贴图时使用的常见格式，它也是 1978 年由 Blinn 引入的。heightfield 用于导出 u 和 v 符号值，类似于第一种方法中使用的值。这是通过获取相邻列之间的差异来获得 u 的斜率以及相邻列之间的差异来获取 v **[1567]** 来完成的。一种变体是使用 Sobel 滤波器，该滤波器赋予直接的近邻以更大的权重 **[535]**。

![](https://img-blog.csdnimg.cn/20201013191652136.png)

**图 6.34.** 波浪形的高度场凹凸图像及其在球体上的使用。

### 6.7.2 法线映射 Normal Mapping 

凹凸贴图的常见方法是直接存储法线贴图。其算法和结果在数学上与布林的方法相同； 只有存储格式和像素着色器计算会更改。

法线图编码映射到 [-1,1] 的（x，y，z），例如，对于 8 位纹理，x 轴值 0 表示 -1.0，255 表示 1.0。一个例子如图 6.35 所示。颜色 (128,128,255)（浅蓝色）将代表所示颜色映射的平坦表面，即法线 (0,0,1)。

![](https://img-blog.csdnimg.cn/20201013192145510.png)

**图 6.35.** 使用法线贴图的凹凸映射。每个颜色通道实际上都是一个表面法线坐标。红色通道是 x 偏差； 红色越多，指向右边的法线越多。绿色是 y 偏差，蓝色是 z 。右侧是使用法线贴图生成的图像。注意立方体顶部的扁平外观。（图片由 Manuel M. Oliveira 和 Fabio Policarpo 提供。）

法线图的表示最初是作为世界空间法线图 **[274，891]** 引入的，然而这在实践中很少使用。对于这种类型的贴图，扰动非常简单：在每个像素处，从贴图中检索法线，并将其与光的方向一起直接使用，以计算表面上该位置的着色。还可以在物体空间中定义法线贴图，以便可以旋转模型，之后法线仍然有效。但是，世界和物体空间的表示都将纹理绑定到特定方向的特定几何形状，这限制了纹理的重复使用。

取而代之的是，我们通常在切线空间（即相对于曲面本身）中检索扰动的法线。这种方法允许表面变形以及正常纹理的最大重复使用。切线空间法线贴图也可以很好地压缩，因为 z 分量的符号（与不受扰动的表面法线对齐的符号）通常可以假定为正值。

使用法线贴图可以很好地提高真实感 —— 见图 6.36。

![](https://img-blog.csdnimg.cn/20201013192935872.png)

**图 6.36.** 在类似游戏的场景中使用的法线贴图凹凸映射的示例。左上方：不使用右侧的两个法线贴图。左下方：已使用法线贴图。右：法线贴图。（3D 模型和法线贴图由 Dulce Isis SegarraLópez 提供。）

与颜色纹理的滤波相比，法线贴图的滤波是一个难题。通常，法线颜色与着色颜色之间的关系不是线性的，因此标准滤波方法可能会导致令人反感的走样。想象一下看楼梯由闪亮的白色大理石块制成。在某些角度下，楼梯的顶部或侧面可以捕捉光线并反射出明亮的镜面高光。但是，楼梯的平均法线为 45 度角。它会从与原始楼梯完全不同的方向捕获亮点。如果在没有正确滤波的情况下渲染具有锐利的镜面高光的凹凸贴图，当采样的位置恰好时，高光闪烁就会出现，从而产生分散注意力的火花效果。

Lambertian 曲面是一种特殊情况，其中法线贴图对着色几乎具有线性影响。Lambertian 着色几乎完全是一个点积，它是线性运算。平均一组法线并对其结果执行点积等效于对具有法线的单个点积进行平均：

![](https://img-blog.csdnimg.cn/20201013195347205.png)

请注意，平均向量在使用前未归一化。公式 6.14 表明，对于 Lambertian 曲面，标准滤波和 mipmap 几乎可以产生正确的结果。由于 Lambertian 着色方程不是点积，因此结果不是很正确。它是一个夹取的（clamped）点乘积 —— max（l·n，0）。夹取操作使其变为非线性。这将使表面过于暗淡，以至于无法直视光的方向，但是在实践中，这通常能够被接受 **[891]**。需要警示的是，通常用于法线贴图的某些纹理压缩方法（如从其他两个法线重构 z 分量）不支持非单位长度的法线，因此使用未归一化的法线贴图可能会带来压缩上的困难。

在非 Lambertian 曲面的情况下，可以通过将着色方程的输入作为一组滤波，而不是单独对法线贴图滤波来产生更好的结果。在第 9.13 节中讨论了此方法的相关技术。

最后，从高度图 h（x，y）导出法线图可能是有用的。按下面的步骤进行 **[405]**。首先，使用中心差为 x 来计算 x 和 y 方向上的导数的近似值

![](https://img-blog.csdnimg.cn/20201013200829228.png)

然后，在纹理像素（x，y）处的未归一化法线为

![](https://img-blog.csdnimg.cn/20201013200848674.png)

这里必须注意纹理的边界。

通过使用凹凸映射，能够将阴影投射到其自身的表面上，可以使用 “水平贴图” （horizon mapping）**[1027]** 进一步增强法线贴图。这是通过预先计算其他纹理来实现的，每个纹理与沿着表面平面的方向相关联，并为每个纹理像素存储该方向上的地平线角度。相关更多信息，请参见第 11.4 节。

## 6.8 视差映射 Parallax Mapping

凹凸和法线贴图的问题在于，凹凸永远不会随视角移动位置，也不会相互阻挡。例如，如果你以真实的角度看一眼真实的砖墙，你将看不到砖之间的砂浆。墙壁的凹凸贴图永远不会显示这种类型的遮挡，因为它只会改变法线。最好的办法是让凸块实际影响在每个像素处渲染表面上的哪个位置。

视差映射（parallax mapping）的概念由 Kaneko **[851]** 于 2001 年提出，并由 Welsh **[1866]** 进行了完善和推广。视差指的是当观察者移动时，对象的位置相对于彼此移动的想法。当观察者移动时，凹凸应该看起来具有高度。视差映射的关键思想是通过检查发现的可见物体的高度，来对像素中应该看到的物体进行有根据的猜测。

![](https://img-blog.csdnimg.cn/2020101320223670.png)

**图 6.37.** 我们想达成的效果在左侧：从视图向量刺穿高度场的位置找到表面上的实际位置。视差贴图通过获取矩形上某个位置的高度并使用它来查找新位置 

![](https://private.codecogs.com/gif.latex?%5Clarge%20%5Ctextbf%7Bp%7D_%7Badj%7D)

 来进行一阶近似。（在 Welsh **[1866]** 之后。）

对于视差贴图，将凹凸数据存储在高度场纹理中。在给定像素处查看表面时，将在该位置检索高度场值，并将其用于移动纹理坐标以检索表面的不同部分。偏移量基于所获取的高度和眼睛与表面的角度。参见图 6.37。高度场值要么存储在单独的纹理中，要么打包为其他纹理的未使用的颜色或 Alpha 通道（将不相关的纹理打包在一起时必须格外小心，因为这会对压缩质量产生负面影响）。在用于移动坐标之前，将对高度字段值进行缩放和偏置。比例尺决定了高度场要在表面上方或下方延伸的高度，并且偏差提供了不发生任何偏移的 “海平面” 高度。给定纹理坐标位置 p，调整后的高度场高度 h 和具有高度值 

![](https://private.codecogs.com/gif.latex?%5Clarge%20v_%7Bz%7D)

和水平分量 

![](https://private.codecogs.com/gif.latex?%5Clarge%20%5Ctextbf%7Bv%7D_%7Bxy%7D)

 的归一化视图向量 

![](https://private.codecogs.com/gif.latex?%5Clarge%20%5Ctextbf%7Bv%7D)

，新的视差调整后的纹理坐标 

![](https://private.codecogs.com/gif.latex?%5Clarge%20%5Ctextbf%7Bp%7D_%7Badj%7D)

为

![](https://img-blog.csdnimg.cn/20201013201951462.png)

请注意，与大多数着色方程式不同，此处执行计算的空间很重要 —— 视图向量必须在切线空间中。

尽管是一个简单的近似值，但如果凸块高度的变化相对较慢 **[1171]**，则这种移位在实践中效果很好。这样，附近的相邻纹理像素的高度大约相同，因此使用原始位置的高度作为新位置的高度估计的想法是合理的。但是，此方法在浅视角下会露馅。当视图向量接近表面的水平线时，高度变化较小会导致纹理坐标偏移较大。这近乎失效，因为检索到的新位置与原始曲面位置几乎没有高度相关性。

为了改善这个问题，Welsh **[1866]** 引入了偏移限制的思想。想法是将移动量限制为永远不大于获取的高度。公式是

![](https://img-blog.csdnimg.cn/20201013202614178.png)

请注意，该公式的计算速度比原始公式要快。从几何上讲，这种解释是，高度定义了一个半径，位置不能超出该半径。如图 6.38 所示。

![](https://img-blog.csdnimg.cn/20201013202719775.png)

**图 6.38.** 在视差偏移量限制中，偏移量最多偏离原始位置的高度，以虚线圆弧表示。灰色虚线偏移是原始的结果，黑色虚线偏移显示有限结果。右边是用该技术渲染的墙。（图片由特里 · 威尔士（Terry Welsh）提供。）

由于 

![](https://private.codecogs.com/gif.latex?%5Clarge%20v_%7Bz%7D)

接近 1，因此在陡峭的角度（面对面）时，该公式与原始公式几乎相同。在较小的角度时，偏移的作用受到限制。从视觉上看，这使得在浅角度的凹凸感减小，但是这比纹理的随机采样好得多。游泳时，随着视图的改变，纹理也存在问题，或者对于立体渲染，观看者同时感知到两个必须给出一致的深度提示的视点 **(?) [1171]**。即使有这些缺点，具有偏移限制的视差映射也只花费了一些额外的像素着色器程序指令，并且相对于基本法线映射提供了可观的图像质量改进。hishkovtsov **[1631]** 通过在凹凸贴图法线方向上移动估计的位置来改善视差遮挡的阴影。

### 6.8.1 视察遮蔽映射 Parallax Occlusion Mapping

凹凸贴图不会基于 heightfield 修改纹理坐标； 它仅在某个位置改变法线着色。假设像素的高度与其相邻像素的高度大致相同，视差贴图则提供了高度场效果的简单近似值。然而这个假设可能会很容易露馅。凹凸贴图可能永远不会相互遮挡，也不会蒙上阴影。我们想要的是在像素处可见的东西，即视图向量首先与高度场相交的地方。

为了以更好的方式解决此问题，一些研究人员建议沿视图向量使用光线步进（ray marching），直到找到一个（近似）交点。这项工作可以在像素着色器中完成，高度数据可以作为纹理访问。我们将对这些方法的研究归纳为视差映射技术的子集，该技术以一种或另一种方式利用光线步进 **[192，1171，1361，1424，1742，1743]**。

这些类型的算法除一些其他名称外，通常被称为视差遮挡映射（parallax occlusion mapping，POM）或浮雕映射（relief mapping）方法。其关键思想是首先沿着投影向量测试固定数量的高度场纹理样本。这通常会在观察角度为视线生成更多样本，以免错过最近的交点 **[1742，1743]**。检索沿射线方向的每个三维位置，将其转​​换为纹理空间，然后进行处理以确定其是否在高度场之上或之下。一旦找到高度场下方的样本，则其下方的数量以及之前一个样本上方的数量将用于查找相交位置 **(?)**。见图 6.39。然后该位置会被用来应用附加的法线贴图，颜色贴图和任何其他纹理，以对表面进行着色。多层高度场可用于产生悬垂（overhangs），独立的重叠表面以及两侧浮雕映射的假物体（impostors）。请参阅第 13.7 节。高度场跟踪方法也可以用于使凹凸的表面在自身上投射阴影，包括硬阴影 **[1171、1424]** 和软阴影 **[1742、1743]**。它们之间的比较请参见图 6.40。

![](https://img-blog.csdnimg.cn/20201014135617529.png)

**图 6.39.**  代表观察者的绿色射线投射到表面上，以固定的时间间隔（紫色点）进行采样，并获取高度。该算法找到了观察射线与黑色线段的第一个交点，近似于弯曲的高度场。

![](https://img-blog.csdnimg.cn/20201014211255740.png)

**图 6.40.** 与光线步进（右）相比，没有光线步进的视差贴图（左）。不使用光线步进时，立方体的顶部会变平。使用光线步进时，也会产生自阴影效果。（图片由 Manuel M. Oliveira 和 Fabio Policarpo 提供。）

关于这个话题有很多文献。尽管所有这些方法都沿着光线步进，但存在一些差异。我们可以使用简单的纹理来获取高度，但是也可以使用更高级的数据结构和更高级的根查找方法。一些技术可能涉及着色器丢弃像素或写入深度缓冲区，这可能对性能产生损害。下面我们总结了一大堆方法，但是请记住，随着 GPU 的发展，最佳方法也会随之发展。这种 “最佳” 方法取决于光线步进期间的内容和完成的步数。

确定两个常规样本之间的实际交点的问题是根查找问题（root-finding problem）。实际上，高度场更多地被视为深度场，其矩形的平面定义了表面的上限 **(?)**。这样的话，平面上的初始点会在高度场上方。在找到高度场的上方的最后一个点和下方的第一个点之后，Tatarchuk **[1742，1743]** 使用割线方法的单个步骤来找到一个近似解。Policarpo 等 **[1424]** 在发现的两个点之间使用二分法搜索，以在更近的交叉点上进行磨练（hone in）**(?)**。Risser 等人 **[1497]** 通过使用割线方法进行迭代来加快收敛速度。折衷的方案是可以并行地进行常规采样，尽管迭代方法仅需更少的整体纹理访问，但是必须等待结果并执行较慢的依赖纹理提取。这种蛮力方法似乎在整体上表现良好 **[1911]**。

以足够高的频率对高度场进行采样是至关重要的。McGuire 和 McGuire **[1171]** 提出对 mipmap 查找进行偏置（biasing），并使用各向异性的 mipmap 以确保对高频高度场（例如代表尖峰或头发的高频高度场）进行正确采样。人们还可以用比法线贴图更高的分辨率存储高度场纹理。最后，某些渲染系统甚至不存储法线贴图，而是更喜欢使用交叉滤镜（cross filter）**[40]** 从高度场中动态导出法线。第 696 页的公式 16.1 展示了该方法。

提高性能和采样精度的另一种方法是，首先不以固定的间隔对高度场进行采样，而是尝试跳过中间的空白空间。Donnelly **[367]** 将高度场预处理为一组体素，在每个体素中存储它与高度场表面的距离。以这种方式，可以快速跳过中间的空间，但代价是每个高度场的存储空间会更大。Wang 等 **[1844]** 使用五维位移映射方案来保持从所有方向和位置到表面的距离。这种方法将会允许复杂的曲面，自遮蔽和其他效果，但是要消耗大量内存。Mehra 和 Kumar **[1195]** 出于类似目的使用定向距离图。Dummer **[393]** 引入了圆锥阶跃映射（cone step mapping）的概念，而 Policarpo 和 Oliveira **[1426]** 对其进行了改进。这里的概念是还要为每个高度场位置存储一个圆锥半径（cone radius）。该半径定义了射线的间隔，在该间隔中与高度场最多有一个交点。该属性允许沿射线快速跳过而不会丢失任何可能的交点，但是代价是需要依赖纹理读取。另一个缺点是创建圆锥阶跃贴图（cone step map）所需的预计算，这使得该方法无法用于动态更改高度场。Schroders 和 Gulik **[1581]** 提出了四叉树浮雕映射（quadtree relief mapping），这是一种在遍历期间跳过体积的分层方法。Tevs 等 **[1760]** 使用 “最大 mipmap” 来进行跳过，同时将预计算成本降至最低。Drobot **[377]** 还使用存储在 mipmap 中的类似四叉树的结构来加速遍历，并提出了一种在不同的高度场之间进行混合的方法，其中一种地形类型（terrain type）会转换为另一种地形类型。

上述所有方法的一个问题是，立体的幻觉会沿着对象的轮廓边缘逐渐分崩离析，最后会显示出原始表面的平滑轮廓。参见图 6.41。这里的关键思想是渲染的三角形应该定义哪些像素由像素着色器程序计算，而不是表面实际所在的位置。另外，对于弯曲表面，轮廓问题变得更加复杂。Oliveira 和 Policarpo **[1325，1850]** 描述和开发了一种方法，该方法使用了二次轮廓逼近技术（ quadratic silhouette approximation technique）。Jeschke 等 **[824]** 和 Dachsbacher 等 **[323]** 都给出了一种更通用，更鲁棒的方法（并回顾了以前的工作）来正确处理轮廓和曲面。这在最初是由 Hirche **[750]** 进行探索，其总体思想是向外挤出网格中的每个三角形并形成一个棱镜。渲染此棱镜时会强制计算可能会出现高度场的所有像素。这种方法称为外壳映射（shell mapping），因为扩展的网格在原始模型上形成了一个单独的外壳。通过保留棱镜与光线相交时的非线性特性，可以实现高度场的无伪像渲染，尽管这个计算成本很高。图 6.42 显示了这种技术的令人印象深刻的用法。

![](https://img-blog.csdnimg.cn/202010142152137.png)

**图 6.42.** 视差遮挡贴图（也称为浮雕贴图），用于使路面上的石头看起来更逼真。路面实际上是一组应用了高度场的简单三角形。（图片来自游戏，孤岛危机 “Crysis”，由 Crytek 提供。）

## 6.9 纹理灯光 Textured Lights

![](https://img-blog.csdnimg.cn/20201014221339230.png)

**图 6.43.** 投射的纹理光。纹理被投影到茶壶和地面上，并用于在投影视锥中调整光的分布（在视锥外设置为 0）。（图片由 NVIDIA Corporation 提供。）

纹理还可以用于为光源增加视觉丰富度，并允许复杂的强度分布或聚光灯功能。对于所有照明都限于圆锥形或截头圆锥形的灯，可以使用投影纹理来调整光照强度 **[1192，1597，1904]**。这样可以形成聚光灯，图案光，甚至 “幻灯机” 效果（图 6.43）。在专业剧院和电影照明中使用的剪影（cutouts）术语之后 **(?)**，这些灯通常称为戈波灯（gobo light）或曲奇灯（cookie light）。有关以类似方式投射阴影的投影映射的讨论，请参见第 7.2 节。

对于不限于视锥体但可以在所有方向照亮的灯光，可以使用立方体贴图（cubemap）来调整光照强度，而不是使用二维投影纹理。一维纹理可用于定义任意距离衰减函数。结合二维角度衰减图，可以考虑复杂的体积照明模式 **[353]**。更普遍的可能是使用三维（体积）纹理控制光的衰减 **[353、535、1192]**。这种方法允许任意数量的效果，包括光束效果（light beams）。此技术会占用大量内存（所有体积纹理都是如此）。如果光线的影响体积是沿三个轴对称的，那么就可以通过将数据镜像到每个八分之一球体中来将内存占用量减少八倍。

可以将纹理添加到任何灯光类型，以启用其他视觉效果。带纹理的灯光使艺术家可以轻松控制照明，而艺术家可以简单地编辑所使用的纹理。

### 进一步阅读和资源

赫伯特（Heckbert）对纹理映射理论进行了很好的综述 **[690]**，并对该主题进行了更深入的报道 **[691]**。Szirmay-Kalos 和 Umenhoffer **[1731]** 对视差遮挡映射和位移方法进行了出色而详尽的调查。关于正态表示的更多信息可以在 Cigolle 等人的著作中找到。**[269]** 并且由 Meyer 等人 **[1205]** 撰写。

《使用 OpenGL 进行高级图形编程》 （Advanced Graphics Programming Using OpenGL）**[1192]** 一书广泛涵盖了使用纹理算法的各种可视化技术。有关三维程序纹理的广泛介绍，请参见《纹理化和建模：一种程序化方法》（Texturing and Modeling: A Procedural Approach） **[407]**。《使用可编程图形硬件进行高级游戏开发》（Advanced Game Development with Programmable Graphics Hardware） **[1850]** 一书详细介绍了如何实现视差遮挡映射技术，Tatarchuk 的演示文稿 **[1742，1743]** 以及 Szirmay-Kalos 和 Umenhoffer 的调查报告 **[1731]** 也是如此。

对于程序纹理（和建模），我们在 Internet 上最喜欢的网站是 Shader-toy。网站上展示了许多有价值且引人入胜的程序纹理函数，并且你可以轻松地修改任何示例，同时查看结果。

访问本书的网站 realtimerendering.com，以获取许多其他资源。