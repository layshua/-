## 溶解

### ASE 实现
![[Pasted image 20221004114121.png]]

### Shader 实现
实现裁剪效果时采用局部坐标，不采用世界坐标。原因在于当物体移动时，世界坐标发生改变无法控制裁剪效果，控制局部坐标就容易一些。
```c
Shader "Unlit/myshader"  {  
    Properties  
    {  
        _MainTex("Main Texture", 2D) = "white"{}     //贴图参数  
        _NoiseTex("Noise Texure", 2D) = "white"{}    //噪声贴图  
        _BurningValue("_BurningValue", Float) = 1  //控制噪声大小  
        _BurningWidth("_BurningWidth", Float) = 0.01  //控制溶解效果边缘宽度  
        _BurningOffset("_BurningOffset", Float) = 0.55 //   
[HDR]_Color("_Color", Color) =  (1,1,1,0)    //颜色参数,注意标注[HDR]，才能开启bloom效果  
    }  
    SubShader{  
        Tags {"RenderType" = "Opaque"}  
          
        Pass  
        {  
            CGPROGRAM  
  
            #pragma vertex vert;  
            #pragma fragment frag;  
  
            #include "UnityCG.cginc"    //头文件  
  
            //数据变量  
            sampler2D _MainTex;  
            float4 _MainTex_ST;  
            sampler2D _NoiseTex;  
            float _BurningValue;  
            float _BurningWidth;  
            float _BurningOffset;  
            float4 _Color;  
              
            struct a2v  
            {  
                float4 vertex : POSITION;   //顶点局部坐标  
                float2 uv     : TEXCOORD0;          //顶点的uv1  
                float4 normal : NORMAL;             //顶点的法线  
                float4 color  : COLOR;              //顶点的颜色  
            };  
  
            struct v2f  
            {  
                float4 vertex       : SV_POSITION;  //顶点的裁剪坐标系下的坐标  
                float2 uv           : TEXCOORD0;    //顶点的uv  
                float4 worldNormal  : TEXCOORD1;    //顶点世界法线  
                float3 worldPosition  : TEXCOORD2;  //顶点世界坐标  
                float3 localPosition  : TEXCOORD3;  //顶点局部坐标  
            };  
  
            v2f vert(a2v v)  
            {  
                v2f o;  
                o.vertex = UnityObjectToClipPos(v.vertex);  
                o.worldNormal = mul(v.normal, unity_WorldToObject);  
                o.uv = v.uv;  
  
                o.localPosition = v.vertex.xyz; //局部坐标  
                o.worldPosition = mul(unity_ObjectToWorld, v.vertex);  
                  
                return o;  
            }  
  
            float4 frag(v2f i) : SV_Target  
            {  
                float height = i.localPosition.y + _BurningOffset; //若不加0.55，当_BurningValue为0时，会出现水平的分界线在模型原点(这个值可以随便调)  
                //采样贴图  
                float4 final = tex2D(_MainTex, i.uv);  
                float noise = tex2D(_NoiseTex, i.uv).r;    
                //noise +=0.1; //控制 noise 最小值为 0.1, 避免噪声的接近 0 的部分需要乘以很大的_BurningValue（用于黑色部分很多的噪声贴图）  
                float burn = noise * _BurningValue; //控制噪声大小  
                float s1 = step (height, burn);  
                float s2 = step(height, burn + _BurningWidth);  
                float colorRange = s2 - s1;     //得出溶解边缘  
                clip(height - burn);  
                return lerp(final,  _Color, colorRange);  
            }  
            ENDCG  
        }  
          
    }  
}
```

菲尼尔边缘光效果
```c
Shader "Unlit/robotshader"  {  
    Properties  
    {  
        _MainTex("Main Texture", 2D) = "white"{}     //贴图参数  
        _NoiseTex("Noise Texure", 2D) = "white"{}    //噪声贴图  
        _BurningValue("_BurningValue", Float) = -6  //控制噪声大小  
        _BurningWidth("_BurningWidth", Float) = 0.1  //控制溶解效果边缘宽度  
        _BurningOffset("_BurningOffset", Float) = 0.55   
[HDR]_Color("_Color", Color) =  (1,1,1,0)    //颜色参数,注意标注[HDR]，才能开启bloom效果  
        //菲涅尔  
        _FresnelScale("FresnelScale", Range(0,0.05)) = 0  
        [HDR]EdgeColor("FresnelColor", COLOR) = (1,1,1,1)  
          
          
    }  
    SubShader{  
        Tags {"RenderType" = "Opaque"}  
          
        Pass  
        {  
            CGPROGRAM  
  
            #pragma vertex vert;  
            #pragma fragment frag;  
  
            #include "UnityCG.cginc"    //头文件  
  
            //数据变量  
            sampler2D _MainTex;  
            float4 _MainTex_ST;  
            sampler2D _NoiseTex;  
            float _BurningValue;  
            float _BurningWidth;  
            float _BurningOffset;  
            float4 _Color;  
            float _FresnelScale;  
            fixed4 EdgeColor;  
              
            struct a2v  
            {  
                float4 vertex : POSITION;   //顶点局部坐标  
                float2 uv     : TEXCOORD0;          //顶点的uv1  
                float4 normal : NORMAL;             //顶点的法线  
                float4 color  : COLOR;              //顶点的颜色  
            };  
  
            struct v2f  
            {  
                float4 vertex       : SV_POSITION;  //顶点的裁剪坐标系下的坐标  
                float2 uv           : TEXCOORD0;    //顶点的uv  
                float4 worldNormal  : TEXCOORD1;    //顶点世界法线  
                float3 worldPosition  : TEXCOORD2;  //顶点世界坐标  
                float3 localPosition  : TEXCOORD3;  //奠定局部坐标  
            };  
  
            v2f vert(a2v v)  
            {  
                v2f o;  
                o.vertex = UnityObjectToClipPos(v.vertex);  
                o.worldNormal = mul (v.normal, unity_WorldToObject);  
                o.uv = v.uv;  
  
                o.localPosition = v.vertex. xyz;   
                o.worldPosition = mul(unity_ObjectToWorld, v.vertex);  
                  
                return o;  
            }  
  
            float4 frag(v2f i) : SV_Target  
            {  
                float3 viewDir = UnityWorldSpaceViewDir(i.worldPosition);  
                float3 worldNormal = normalize(i.worldNormal);  
  
                //Schlick菲涅尔近似式  
                float Fresnel =  _FresnelScale+ (1 -_FresnelScale) * pow(1 - saturate(dot(worldNormal,viewDir)), 5);  
                  
                float4 FresnelColor = EdgeColor * Fresnel;  
                  
                float height = i.localPosition.y + _BurningOffset;   
                float4 final = tex2D(_MainTex, i.uv) + FresnelColor;  
                float noise = tex2D(_NoiseTex, i.uv).r;    
                  
                      
                float burn = noise * _BurningValue * _CosTime.z * 5;; //控制噪声大小  
                float s1 = step(height, burn);  
                float s2 = step(height, burn + _BurningWidth);  
                float colorRange = s2 - s1;     //得出溶解边缘  
                clip(height - burn);  
                  
                return lerp(final, _Color, colorRange);  
            }  
            ENDCG  
        }  
    }  
}
```
