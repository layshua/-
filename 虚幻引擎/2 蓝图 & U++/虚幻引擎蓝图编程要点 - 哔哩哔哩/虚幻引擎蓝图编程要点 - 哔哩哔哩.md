本文总结了在虚幻引擎蓝图编程时的主要知识点

源视频来自油管 CoquiGames 的系列教程：Learn to Code in Unreal Engine 5 with Blueprints - Full Course - YouTube

链接：https://youtu.be/79MM83fnFUI?list=PLziQlhUd357jEk5y77AHniPa2ywcMExlG

![](1675437614700.png)

第一节：编程概述

编程是为了让机器**理解**并**执行**某种**行动**

程序员通过编写代码来让机器工作

编写的代码被称作 “源代码”（source code），如果要让机器理解并执行，需要将源代码进行 “编译”（compile）

虚幻引擎使用 c++ 和蓝图

虚幻引擎使用面向对象（OOP）的方式开发

类是面向对象的核心概念，类拥有属性和行为

类可以继承和派生

虚幻引擎内置了许多类，涵盖游戏开发的各种功能。可以从这些类派生出新的类

第二节：蓝图类

蓝图编辑器的组成：

![](1675437614790.png)

*   1. 菜单栏：通用设置与功能
    
*   2. 工具栏：常用功能
    
*   3. 组件列表：添加组件
    
*   4.Myblueprint
    
    添加多张事件图表，管理事件图表
    
    新建或重载函数
    
    接口实现  
    
    新建宏
    
    添加变量
    
    事件分发器
    
*   5. 视口、构建图表、事件图表
    
    视口用来预览 3D 表现
    
    构建图表里的逻辑在每当实例发生变化时生效（用于修改 actor 的初始状态）
    
    事件图表里的逻辑在游戏运行时生效（用于运行时游戏逻辑）
    
*   6. 细节面板
    

类的继承与派生

继承：

![](1675437614829.png)

在 class setting 中可更改父类

![](1675437614884.png)

或在内容浏览器中从父类创建子类

派生：

![](1675437615018.png)

通过重载函数、添加新的变量，子类可以和父类不同

类的组件化

![](1675437615079.png)

类的定义和实例：

![](1675437615126.png)

*   类的定义存在于资源浏览器中
    
*   每当把类添加进运行的游戏中时，即添加了这个类的一个实例
    

第三节：变量

![](1675437615179.png)

变量会根据它的类型预先申请一块内存。它的类型不会改变，但内容可以改变

常用变量类型：

*   布尔
    
*   整数
    
*   浮点数
    
*   string/text/name
    
*   向量
    
*   旋转
    
*   变换
    

变量需要一个缺省值 / 初始值

第四节：构造图表与事件图表

构造图表与事件图表的区别：

构造图表用于设计：

*   构造图表在每次编译蓝图时运行
    
*   通过构造图表添加可以在编辑器操作的功能
    
*   给实例随机化
    

事件图表用于游戏运行：

*   在事件图表里写游戏性的代码
    

EventBeginPlay：游戏开始时运行一次。可以用于初始化

EventTick：每帧运行。可用于实时更新

getter：获取变量

setter：设置变量

第五节：构造图表实操

第六节：数组  

数组是一组同类型的变量

![](1675437615230.png)

常用数组命令：

    创建数组

    获取元素（get）

    添加元素（add、addunique、insert）

    移除元素（remove、clear）

    搜索元素（contains、find）

    数组长度（length、last index）

    有效性验证（isEmpty、isValid）

    随机（shuffle、random）

第七节：函数控制流

sequence 序列

flip flop 翻转

do once 做一次

do N 做 N 次

if/branch 条件判断

loop 循环

    for each loop（需要数组）  

    for loop  

    while loop  

switch on 选择

第八节：其他数据结构

enum 枚举：用户自定义的不同的选项 / 状态的集合

struct 结构体：异构但相关的数据集合

    结构体用来组织数据  

    结构体可以嵌套结构体  

data table 数据表：存储结构体信息的表，可以导入导出为外部制表格式

    数据表的表头由结构体来定义

data asset 数据资产：在内容浏览器中由 primary data asset 定义，能够包含变量和逻辑。

    数据资产也是用来组织异构但相关的数据集合，但通常更高级、更抽象、更庞杂。

第九节：函数与自定义事件

函数是一段可以重用的代码

函数在被调用时运行

函数可以有输入值，可以有输出值

全局变量：在函数之间可以访问的变量

局部变量：只能在函数内部自己访问的变量

函数内不能使用 delay 节点

自定义事件：执行某个功能的入口，主要用于封装某个功能

自定义事件可以选择调用或者不调用

自定义事件可以有输入值，但没有输出值

自定义事件不能有局部变量

自定义事件可以使用 delay 节点

自定义事件可以在编辑器被调用（不能有输入，只能作为执行按钮）

第十节：时间相关节点

delay 

首次激活时开始倒计时，期间再次激活执行流时，忽略执行流，等待时间结束后才能再次接受执行流

retriggerable delay 

首次激活时开始倒计时，期间再次激活执行流时，重置等待时间。可以不断地被触发，直到不再触发时，再开始倒计时

delay until next tick

延迟一帧

Timer 计时器

set timer by event

set timer by function name

计时器可以被储存下来：set handle

计时器可以被暂停：pause timer by handle

计时器可以被解除暂停：unpause timer by handle

计时器可以被清除：clear and invalidate timer by handle

第十一节：插值

Interp

Lerp

AddTimeline

第十二节：碰撞

碰撞检测是 Chaos 物理引擎的一部分

每个 actor 需要被指定物体类型 “object type” 以作为碰撞检测的通道

每种物体类型可以被其他物体类型 “忽略 ignore”、“穿插 overlap”、“阻挡 block”

可以添加自定义的物体类型

OnHit Event 用来检测 block

Event Begin/End Overlap 用来检测 Overlap

第十三节：蓝图通信

蓝图通信是指实例间获取数据信息或调用函数的过程

在直接通信中，引用者需要先找到要引用的对象，然后才能和它进行通信

通过持有引用，引用者可以 set、get 被引用者的数据，调用被引用者的函数或事件

引用父类时，可以获取所有子类的引用，即父类有的子类都有。父类中的函数在子类中可以被重载（override），赋予新的逻辑

蓝图通信的四种方式

*   直接通信
    
*   类型转换
    
*   接口
    
*   事件分发器
    

直接通信：

获取引用对象的方法有:

1.  通过在编辑器中指定具体实例来获取引用对象
    
2.  通过代码（如 get all actors of class 等）获取场景中的实例，进而获取引用对象
    
    注意，get all actors of class 非常消耗性能，建议随意使用。如果必须使用，不建议每帧调用，而是在需要的时候单次调用
    
3.  通过 actor tag 的方式进行过滤
    

当直接引用引用父类时，可以访问其所有的子类

而当直接引用引用其子类时，无法访问兄弟、父类

Override：覆写 指在子类中重新实现父类的函数

Cast 类型转换：

询问对象是否是某个类，如果是，则转换成功，可以访问该类所有的功能；如果不是则转换失败

第十四节：蓝图接口

蓝图接口是一张列表，包含各种功能的定义，但它本身不知道功能的实现细节

具体的功能逻辑在 implement 了该接口的蓝图中实现

蓝图接口用于在不同的对象上调用相似的功能

例如，“按某个按键互动”是玩家和场景中的物体最常见的交互形式。不同的物体有不同的 “互动” 行为，例如一扇门会打开，一个按钮会被按下等，但它们都具有 “按键互动” 这一相同的形式。这时就可以抽象出一个 “互动” 的功能放在接口里。

第十五节：事件分发器

某物体发出了一条信息（call），提前注册（Bind、Assign）过这个信息的物体就会被通知，进而执行相应的操作。

可以用代码解除这种注册关系（Unbind、UnbindAll）

直接引用 / 类型转换是一对一的形式，A 找到 B，让 B 做某事

蓝图接口和事件分发器都是一对多的形式，A 可以找到 B1、B2、B3……，分别让他们做不同的事

![](1675437615271.png)

第十六节：射线检测

射线检测是物理的一部分

射线检测提供许多有用的信息，例如获取被碰撞的 actor 的引用，碰撞位置，距离等

射线检测一般需要用到向量计算

射线检测按形状、通道、是否多重检测分类

可以添加自定义的涉嫌检测通道、碰撞检测通道

按形状分类

    Line

    Box  

    Capsule  

    Sphere  

按检测单个还是多个物体分类

    Single/Multiline

按检测通道分类

    Channal/Collision profile

第十七节：组件

组件用于封装功能，以在不同 actor 之间复用

优缺点：

    优点  

        1. 保持代码整洁  

        2. 功能模块化  

        3. 更容易 debug

    缺点  

        1. 不能使用构造脚本（construction script）  

        2. 不能使用 InputEvent  

        3. 不能添加其他组件  

        4. 少量性能影响  

第十八节：综合应用

截至目前所学的概念包括：

    **面向对象**  

        面向对象的核心要点在于：1. 创建对象，2. 使用对象，3. 维护对象之间的关系  

        例如开一家公司：  

        首先要培训员工，分配职责（创建对象）

        然后，要给这些员工派活（使用对象）

        最后，要让这些员工之间互相配合（维护对象之间的关系 / 通信）

        面向对象的思想就是要站在宏观的角度考虑问题

    封装：功能和属性都在内部，只暴露接口，用于对外部的输入和输出  

    继承：子类拥有父类的全部特性  

    多态：派生的子类拥有自己的新特性（新属性、新函数、重载父类的函数等）  

    组合：通过组件化增加代码的复用率；不同的组件负责不同的功能，便于管理  

    事件图表 / 构造图表：事件图表里写运行时逻辑，构造图表当作初始化工具使用  

 **数据结构**

        基础数据类型：布尔值、整数、浮点数、向量……  

        数组  

        自定义数据类型：枚举、结构体、data asset……  

 **函数控制流**

 Sequence 队列

        Branch/If 分支  

        Loop 循环  

        Select/Switch 选择  

        FlipFlop 翻转  

        Gate 门  

        Do Once 做一次

    **代码分块**  

        多张图表  

        函数  

        自定义事件  

        宏  

        折叠到节点  

        组件  

 **插值**

        InterpTo  

        Lerp  

        AddTimeline  

    **时间控制**  

        Delay  

        Timer  

    **获取碰撞信息**  

        Overlaps  

        Traces  

    **蓝图通信**

        直接通信  

        类型转换  

        接口  

        事件分发器  

常见需求与解决办法：

![](1675437615317.png)

第十九节：像程序员一样思考

程序员就是**用代码解决问题**的人

一种良好的工作方式是：

对问题进行抽象——试着从较高的层面描述如何解决问题——编写伪代码理清思路——编写代码实现具体的功能——测试与改进

![](1675437615372.png)

虚幻官方 BeginPlay 系列教程 蓝图系列教程 解析

蓝图来自 C++  

![](1675437615402.png)

蓝图来自 C++

C++ 赋予的基础特性  

![](1675437615453.png)

![](1675437615504.png)

继承

![](1675437615549.png)

事件、函数、变量

![](1675437615594.png)

函数库

![](1675437615668.png)

网络复制：蓝图内建网络复制功能，特别是玩法框架中的类

![](1675437615735.png)

玩法框架：虚幻设计的玩法框架，能够满足大多数游戏类型的开发

![](1675437615782.png)

玩法框架细则

数据类型

![](1675437615829.png)

![](1675437615884.png)

数据表：由结构体 struct 定义表头，可与外部导入导出

![](1675437615933.png)

数据资产：一种特殊的类，在内容浏览器作为资产创建。可以包含变量和逻辑

![](1675437615987.png)

曲线：曲线数据可以满足特定功能的需要，同时曲线不用编译就能更新

蓝图被编译之后在虚拟机运行

![](1675437616040.png)

蓝图核心功能

![](1675437616086.png)

![](1675437616136.png)

组件化：通过添加特定的组件，为 Actor 添加特定的功能

![](1675437616198.png)

事件图表：编写可视化脚本的核心区域，游戏逻辑在这里实现

![](1675437616248.png)

构造脚本：一旦实例被添加到场景中，则率先运行（注：每当编译蓝图、更改实例属性时，实例都会被刷新，并重新添加到场景，所以会重新运行构造脚本）

![](1675437616303.png)

添加其他的图表页：通过添加多个图表页，分区管理，保持脚本的整洁

![](1675437616355.png)

网络复制：变量、函数、事件可以在细节面板中设置网络复制

![](1675437616409.png)

时间轴节点：Actor 蓝图内建的节点，基于曲线的动画工具（限定时间内逐帧更新）

![](1675437616474.png)

变量：强类型，支持大多数结构体和基础类型。可以从父类或 c++ 中继承

![](1675437616533.png)

事件分发器：可以随时订阅或解绑的消息分发机制

![](1675437616592.png)

函数

![](1675437616648.png)

事件

![](1675437616701.png)

宏：代码段，在编译时自动展开

蓝图的其他特性

![](1675437616753.png)

![](1675437616807.png)

子 Actor：将其他的 Actor 视为组件添加到自身

![](1675437616923.png)

蓝图组件：封装可跨蓝图复用的功能

![](1675437616982.png)

函数库：可以跨蓝图使用

![](1675437617035.png)

宏库：可以跨蓝图使用

![](1675437617094.png)

编辑器蓝图：为编辑器添加功能（作为编辑器工具使用，而非运行时功能）

虚幻引擎里使用到了可视化编程的系统：

![](1675437617159.png)

![](1675437617212.png)

关卡蓝图：每个关卡有一个关卡蓝图，用来管理关卡中特定的交互功能

![](1675437617265.png)

Actor 蓝图：最常用的蓝图，创建 Actor

![](1675437617317.png)

过场动画工具：过场动画可以直接触发逻辑

![](1675437617369.png)

动画蓝图：处理动画片段的混合和状态机切换

![](1675437617423.png)

UMG：制作 UI 界面、实现 UI 逻辑

![](1675437617476.png)

Niagara：蓝图风格的节点化编程，用以实现特定的粒子效果

![](1675437617554.png)

材质编辑器：通过可视化节点编辑器，为物体表面、UI、特效、后期处理编写 shader

![](1675437617608.png)

Mass：通过任务和状态图管理海量的游戏实体

![](1675437617672.png)

声音编辑器：能够非常细致地调整声音效果

![](1675437617734.png)

EQS（场景查询系统）：通过一系列的规则，将场景的状态视觉化地呈现出来

![](1675437617798.png)

行为树：设计和调试 AI 行为

![](1675437617859.png)

变体管理器：管理大量的可切换选项，切换场景中的物体

蓝图通信

![](1675437617924.png)

![](1675437617988.png)

蓝图之间的交互有多种方式

![](1675437618052.png)

直接引用

![](1675437618116.png)

软引用

![](1675437618177.png)

继承：引用了子类，则可以访问父类的全部功能

![](1675437618297.png)

类型转换：如果无法直接获取对象，将对象转换到目标对象，如果转换成功则获得了目标对象。强引用

![](1675437618348.png)

接口：通过一个轻量、中性的接口层，连接两种以上的蓝图

![](1675437618464.png)

C++

![](1675437618576.png)

事件分发器：监听某个事件，如果收到消息则触发行动

蓝图调试

![](1675437619713.png)

![](1675437620810.png)