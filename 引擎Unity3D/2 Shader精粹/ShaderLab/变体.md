# 变体基础
![[Pasted image 20230628192002.png]]

能否写一个 All in One 的 Shader？
有三种方式，根据具体需求选择：
1. 静态分支 `#if`
2. 动态分支 `if`
3. 着色器变体 `#pragma`

## 静态分支 `#if`
![[Pasted image 20230628192227.png|500]]

**原理**：着色器**编译时**选择代码分支

**选择**：编译时，能够确定 Shader 执行的条件

**用法**：
- 使用 `#define` 定义激活分支
- 使用 `#if` 、 `#elif` 、 `#else` 和 `#endif` 预处理程序指令来创建静态分支
- 让 shader 代码执行其中一个分支
- 编译器会裁剪未激活代码分支，只会将执行的部分编译

**注意**：静态分支仅在手写代码可用，不能在 Shader Graph 中创建静念分文。

## 动态分支 `if`
![[Pasted image 20230628192654.png|300]]
**原理**：着色器**运行时**选择代码分支

**选择**：运行时，是否有可能动态选择分支? 

**用法**:
- 在手写代码中，使用 if 语句来执行分支
- 在 Shader Graph 中，使用 Branch 节点

动态分支的优点（相对于着色器变体方式)：
- 可以动态选择分支
- 不会造成代码膨胀

动态分支缺点（相对于着色器变体方式)：会导致运行时性能损失

## 着色器变体 `#pragma`

![[Pasted image 20230628193118.png]]

**着色器变体原理： (静态分支的加强版)**
- 编译时，生成多个**静态分支**的着色器版本
- 运行时，根据选择的变体**动态确定**要执行的着色器版本

**变体形成的 Shader 集合:** shader variants (SL) / shader states (SG)
  >SL 意思是手写的 shaderlab ，SG 意思是 shadergraph
  
**变体关键字:** shader keyword (SL) / keyword node (SG)

**包含多个变体的 Shader 被称为 Mega / Uber Shader**
- 例如: Standard/Lit Shader
- 详见《TA 进阶之路》: Unity Shader 源码解析

**着色器变体优点**：不会导致运行时性能损失
**着色器变体缺点**：构建时间、文件大小、运行时内存使用、加载时间

![[Pasted image 20230628193737.png]]

## 变体分类
  ![[Pasted image 20230628194409.png|700]]
**使用方法：**
属性快：声明变体
代码头：定义变体
代码体：使用变体

> [!Bug] 
> 变体关键词必须大写！
### 全局关键字
**变体分类：**
1. `multi_ compile`：打包会为所有关键词生成变体，因此**可以在运行的时候通过脚本切换效果
2. **`shader_feature`：只会为材质使用到的关键词生成变体，没有使用到的关键词被裁剪不会生成变体，减小打包体积，**但无法在运行的时候通过脚本切换效果**。
```c
//shader_feature 可以看作 multi_compile 的子集 
#pragma shader_feature FANCY_STUFF
//这只是 #pragma shader_feature _ FANCY_STUFF 的快捷方式。它会扩展为两个着色器变体（第一个没有定义；第二个有定义）。
```


**如何选择：**
1. 变体用于所有 Shader 还是单个材质?
    - 应该将 shader_feature 用于单个材质中设置的关键字
    - 而 multi_compile 更适合**通过代码**来全局设置的
2. 关键字运行时是否会通过 CS 脚本修改？
如果设定好的变体在运行时不会通过 CS ，则应选择 shader_feature，否则选择 multi_compile

### 局部关键字
**shader_feature** 和 **multi_compile** 的主要缺点是其中定义的所有关键字均会影响 Unity 的全局关键字计数上限（384 个全局关键字，外加 64 个本地关键字）。为了避免此问题，可以使用不同的着色器变体指令：__shader_feature_local__ 和 **multi_compile_local**。

*   `shader_feature_local`：类似于 `shader_feature`，但是枚举的关键字为本地关键字。
*   `multi_compile_local __`：类似于 `multi_compile`，但是枚举的关键字为本地关键字。

如果全局关键字和本地关键字同名，Unity 会优先考虑本地关键字。

**限制：**
*   不能将本地关键字与进行全局关键字更改的 API 一起使用（例如 Shader. EnableKeyword 或 CommandBuffer. EnableShaderKeyword）。
*   每个着色器最多有 64 个唯一性的本地关键字。
*   如果材质启用了本地关键字，并且其着色器变为不再声明的着色器，Unity 将创建新的全局关键字。

```c
# pragma multi_compile_local __ FOO_ON
```

此指令生成两个着色器变体：一个未定义任何关键字 (`__`)，另一个定义了 `FOO_ON`（本地关键字）。

启用本地关键字的过程与启用全局关键字的过程相同：

```c
public Material mat;
Private void Start() {
    mat.EnableKeyword("FOO_ON");
}
```

### 特定于阶段的关键字指令

创建着色器变体时，**Unity 编辑器的默认行为是在每个变体中生成着色器程序的每个阶段**。例如，如果您的着色器程序包含一个顶点阶段和一个片元阶段，Unity 会为每个关键字组合生成一个顶点阶段和一个片元阶段。

如果关键字不影响所有阶段，则此默认行为会导致冗余工作。

为避免此问题，您可以使用特定于阶段的关键字指令。这些是应用于常规关键字指令的后缀。它们告诉编辑器给定关键字影响哪个着色器阶段，因此在为支持的图形 API 构建着色器时，它可以跳过多余的工作。

**使用特定于阶段的关键字指令**

可用的后缀是 `_vertex`、`_fragment`、`_hull`、`_domain`、`_geometry` 和 `_raytracing`。您在关键字指令的末尾应用后缀，例如：`multi_compile_fragment` 或 `shader_feature_local_vertex`。**要针对多个着色器阶段，您可以使用多个特定于阶段的关键字指令来声明同一个关键字。**

注意：您应确保关键字仅用于指定的着色器阶段。

 **支持的图形 API：**
Unity 并不完全支持在所有图形 API 中使用特定于阶段的关键字指令。
- 为 OpenGL 和 Vulkan 编译着色器时，编辑器会自动将任何特定于阶段的关键字指令恢复为常规关键字指令。
- 为 Metal 编译着色器时，任何针对顶点阶段的关键字也会影响曲面细分阶段，反之亦然。


# multi_ compile

![[Pasted image 20230628194839.png]]
## 变体激活
Unity 默认激活第一个变体，因此我们可以将默认关闭的开关放在第一个，防止意外打开开关。
```c
//如下：将产生两个变体，默认激活LIGHT_OFF变体
#pragma multi_compile LIGHT_OFF LIGHT_ON 
```

Unity 中的关键字数量上限是 384，Unity 将大约 60 个关键字保留供内部使用（因此降低了可用上限）
因此，可以用 `_` 或 `__` 表示开关关闭 6
```c
 #pragma multi_compile _ LIGHT_ON
 //生成两个变体
 //_或__:无关键字，即表示不用 LIGHT_ON，又不产生变体LIGHT_ON
 //第二个就是变体LIGHT_ON
```

对于单一条件的判定，没必要写两个变体浪费变体数量。
直接使用以下方式即可：
```c
#if defined(LIGHT_ON)
...
#else 
...
```


## 变体组合

![[Pasted image 20230628195933.png]]
 ![[Pasted image 20230628195959.png]]

## 变体开关
![[Pasted image 20230628200255.png]]

```cs
Shader.EnableKeyword  //启用全局关键字
Shader.DisableKeyword  //禁用全局关键字
CommandBuffer.EnableShaderKeyword  //使用 CommandBuffer 来启用全局关键字
CommandBuffer.DisableShaderKeyword  //使用 CommandBuffer 来禁用全局关键字
Material.EnableKeyword  //为常规着色器启用本地关键字
Material.DisableKeyword  //为常规着色器禁用本地关键字
ComputeShader.EnableKeyword  //为计算着色器启用本地关键字
ComputeShader.DisableKeyword  //计算着色器禁用本地关键字
```
## 快捷方式

有些情况需要定义很多变体，代码很长，Unity 提供了一些快捷方式

URP支持着色器的变体，可以使用#pragma multi_compile宏实现编译不同需求下的着色器，常见的内置关键字有：

- _MAIN_LIGHT_SHADOWS
- _MAIN_LIGHT_SHADOWS_CASCADE
- _ADDITIONAL_LIGHTS_VERTEX
- _ADDITIONAL_LIGHTS
- _ADDITIONAL_LIGHT_SHADOWS
- _SHADOWS_SOFT
- _MIXED_LIGHTING_SUBTRACTIVE


大多数内置快捷方式会产生许多着色器变体。如果知道项目不需要这些变体，可以使用 `#pragma skip_variants` 来跳过对其中一些变体的编译。例如：

```c
# pragma multi_compile_fwdadd
# pragma skip_variants POINT POINT_COOKIE
```

该指令会跳过包含 `POINT` 或 `POINT_COOKIE` 的所有变体。

# 代码控制
通过外部控制变体切换有两种方式：
1. Properties 控制（KeywordEnum、Toggle 等）
2. 代码控制，当使用代码控制时，不要写 Properties，会有冲突。
![[6a7sdASdsssssadasd.gif]]
```cs
Properties
{
    //当使用代码控制时，注释掉该代码
    //[KeywordEnum(Red,Green,Blue)] _TestColor("Instancing", Float) = 0
}

...

float4 frag(Varyings input) : SV_Target
{
    #if _TESTCOLOR_RED
        return float4(1,0,0,1);
    #elif _TESTCOLOR_GREEN
        return  float4(0,1,0,1);
    #elif _TESTCOLOR_BLUE
        return float4(0,1,1,1);
    #endif

    return float4(1,1,1,1);
}
```

```cs
public class TestMultiCompile : MonoBehaviour
{
    public TMP_Dropdown dropdown; //使用一个dropdown来控制
   
    private List<string> showOptions = new List<string>();
    private List<string> dataOptions = new List<string>();
    
    void Start()
    {
        dropdown.options.Clear();
        
        showOptions.Add("Red");
        showOptions.Add("Green");
        showOptions.Add("Blue");
        
        
        dataOptions.Add("_TESTCOLOR_RED");
        dataOptions.Add("_TESTCOLOR_GREEN");
        dataOptions.Add("_TESTCOLOR_BLUE");
        
        dropdown.AddOptions(showOptions);
        dropdown.onValueChanged.AddListener(ChangeValue);
    }

    private void ChangeValue(int arg0)
    {
        for (int i = 0; i < dataOptions.Count; i++)
        {
            if (i == arg0)
            {
                Shader.EnableKeyword(dataOptions[i]);
            }
            else
            {
                Shader.DisableKeyword(dataOptions[i]);
            }
        }
    }

    private void OnDisable()
    {
        dropdown.onValueChanged.RemoveListener(ChangeValue);
        dropdown.options.Clear();
        showOptions.Clear();
        dataOptions.Clear();
    }
}
```



# 变体编辑器拓展（待续）

TestMultiCompile 属性面板如何自定义显示?
需求:
看到材质球当前启用了哪些全局和局部的变体
并且把全局和局部变体分两栏显示，两栏可折叠
# 局部变体的管理（待续）