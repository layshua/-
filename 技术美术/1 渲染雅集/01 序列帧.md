# 第 18 课序列帧与极坐标 Polar
## 序列帧

![[polar.gif|300]]

**原理：将一序列帧图片存贮在一张图中，通过 uv 的缩放移动来获取每一帧图像，达到动画效果

**帧序列图：** 从左到右，从上到下

![[3996f590767a5bd1c02c505b605ffb22_MD5.jpg]]
**方法：**

1.  通过行数、列数计算出**步长**
2.  通过当前所在的第几帧 (帧 id)计算**当前帧的行列值 (位置)**
3.  通过**步长**和**当前帧的行列值**来位移 uv

当前帧是第几帧，除以每列个数，商是当前所在行，余数是所在列

![[Pasted image 20221022193113.png|300]]
序列帧先缩放 uv（在左下角的原因：uv 原点在左下角）
![[Pasted image 20221022200141.png|300]]
然后进行偏移，使其从左上角开始

```less
Shader "L18/Sequence" {  
    Properties  
    {  
        _MainTex ("RGB：颜色 A：透贴", 2D) = "white" {}  
        _Opacity ("透明度", range(0, 1)) = 0.5  
        _Sequence ("序列帧", 2d) = "grey"{}  
        _Row ("行数",int) = 1  
        _Column ("列数",int) = 1  
        _Speed      ("速度", range(0.0, 15.0)) = 1  
    }  
    SubShader  
    {  
        Tags   
{   "Queue" = "Transparent"             //调整渲染顺序  
            "RenderType"="Transparent"    //对应改为Cutout  
            "ForceNoShadowCasting" = "True"     //关闭阴影投射  
            "IgnoreProjector" = "True"          //不响应投射器  
        }     
          
        //第一个Pass AB  
        Pass  
        {  
            Name "FORWARD_AB"  
            Tags  
            { "LightMode" = "ForwardBase" }  
            Blend One OneMinusSrcAlpha  
              
            CGPROGRAM  
            #pragma vertex vert  
            #pragma fragment frag  
            #pragma  multi_compile_fwdbase_fullshadows  
            #include "UnityCG.cginc"  
  
            struct appdata  
            {  
                float4 vertex : POSITION;  
                float2 uv : TEXCOORD0;  
            };  
  
            struct v2f  
            {  
                float4 pos : SV_POSITION;  
                float2 uv : TEXCOORD0;  
            };  
  
            sampler2D _MainTex;  
            float  _Opacity;  
              
              
            v2f vert (appdata v)  
            {  
                v2f o;  
                o.pos = UnityObjectToClipPos(v.vertex);  
                o.uv = v.uv;  
                return o;  
            }  
  
            fixed4 frag (v2f i) : SV_Target  
            {  
                float4 MainTex = tex2D(_MainTex, i.uv);       
                half3 finalColor = MainTex.rgb;  
                half opacity = MainTex.a * _Opacity;  
                return float4(finalColor * opacity, opacity);             
            }  
            ENDCG  
        }  
        //第二个Pass AD  
        Pass  
        {  
            Name "FORWARD_AD"  
            Tags  
            { "LightMode" = "ForwardBase" }  
            Blend One One  
            //Cull Off //更改Cull可以出现不同效果  
            CGPROGRAM  
            #pragma vertex vert  
            #pragma fragment frag  
            #pragma  multi_compile_fwdbase_fullshadows   
            #include "UnityCG.cginc"  
  
            struct appdata  
            {  
                float4 vertex : POSITION;  
                float2 uv : TEXCOORD0;  
                float3 normal : NORMAL; //法线偏移，用于偏移  
            };  
  
            struct v2f  
            {  
                float4 pos : SV_POSITION;  
                float2 uv : TEXCOORD0;  
            };  
  
            sampler2D _Sequence;  
            float4 _Sequence_ST;  
            float _Row;  
            float _Column;  
            float _Speed;  
              
            v2f vert (appdata v)  
            {  
                v2f o;  
                v.vertex.xyz += v.normal * 0.1; //顶点位置法向挤出  
                o.pos = UnityObjectToClipPos(v.vertex);  
                  
                o.uv = TRANSFORM_TEX(v.uv, _Sequence);  
                float id = floor(_Time.z * _Speed);  
                  
                float idV = floor(id / _Column);    //floor得商，舍弃余数  
                float idU = id - idV * _Column;     //计算余数  
                float stepU = 1.0 / _Column;    //行的步幅  
                float stepV = 1.0/ _Row;        //列的步幅  
                float2 initUV = o.uv * float2(stepU, stepV) + float2(0.0, stepV * ( _Column - 1.0 )); //缩小UV，只保留一帧的大小。然后进行V轴进行偏移，从左上角开始  
                o.uv = initUV + float2(idU * stepU, -idV * stepV);  //计算序列帧UV  
                return o;  
            }  
  
            fixed4 frag (v2f i) : SV_Target  
            {  
                float4 Sequence = tex2D(_Sequence, i.uv);  
                float3 finalColor = Sequence.rgb;  
                float opacity = Sequence.a;  
                return float4(finalColor * opacity, opacity);  
            }  
            ENDCG  
        }  
    }  
}
```