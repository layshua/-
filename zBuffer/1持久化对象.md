
---
title: 1持久化对象
aliases: []
tags: []
create_time: 2023-06-15 21:26
uid: 202306152126
banner: "![[1686835479404.png]]"
---

创建保存和加载：
- 根据按键产生随机立方体。
- 使用泛型类型和虚方法。
- 将数据写入文件并读回。
- 保存游戏状态，以便稍后加载。

## 按需创建对象

### 游戏逻辑

因为我们的游戏非常简单，所以我们将使用一个 `Game` 组件脚本来控制它。它会产生立方体，为此我们将使用预制件。因此，它应该包含一个公共字段来连接预制实例。

```
using UnityEngine;

public class Game : MonoBehaviour {

	public Transform prefab;
}
```

将一个游戏对象添加到场景中，并将此组件附加到场景中。然后创建一个默认立方体，将其变成预制体，并为游戏对象提供一个引用。

![](<images/1686835479985.png>)

![](<images/1686835480539.png>)


```
void Update () {
		if (Input.GetKeyDown(createKey)) {
			Instantiate(prefab);
		}
	}
```

###  随机化立方体

让我们随机化我们创建的每个立方体的位置。

使用静态 [Random](http://docs.unity3d.com/Documentation/ScriptReference/Random.html).insideUnitSphere属性获取一个随机点，将其放大到五个单位的半径，并将其用作最终位置。因为这不仅仅是一个微不足道的实例化，所以将代码放在一个单独的 `CreateObject` 方法中，并在按键时调用它。

```
void Update () {
		if (Input.GetKeyDown(createKey)) {

			CreateObject();
		}
	}

	void CreateObject () {
		Transform t = Instantiate(prefab);
		t.localPosition = Random.insideUnitSphere * 5f;
	}
```

![](<images/1686835481678.png>)

Randomly placed cubes. 随机放置的立方体。

让我们给每个立方体一个随机旋转，我们可以使用静态 [Random](http://docs.unity3d.com/Documentation/ScriptReference/Random.html).rotation 属性。

```
void CreateObject () {
		Transform t = Instantiate(prefab);
		t.localPosition = Random.insideUnitSphere * 5f;
		t.localRotation = Random.rotation;
	}
```

![](<images/1686835482240.png>)

Randomized rotations. 随机旋转。

最后，我们还可以改变立方体的大小。我们将使用均匀缩放的立方体，所以它们总是完美的立方体，只是大小不同。静态 [Random](http://docs.unity3d.com/Documentation/ScriptReference/Random.html). [Range](http://docs.unity3d.com/Documentation/ScriptReference/RangeAttribute.html) 方法可用于获取某个范围内的随机 float 值 。让我们从0.1号的小立方体到1号的常规立方体。要将该值用于刻度的所有三个维度，只需将 [Vector3](http://docs.unity3d.com/Documentation/ScriptReference/Vector3.html).one 与之相乘，然后将结果指定给局部刻度。

```
void CreateObject () {
		Transform t = Instantiate(prefab);
		t.localPosition = Random.insideUnitSphere * 5f;
		t.localRotation = Random.rotation;
		t.localScale = Vector3.one * Random.Range(0.1f, 1f);
	}
```

![](<images/1686835482807.png>)


### 开始新游戏

如果我们想开始一个新的游戏，我们必须退出游戏模式，然后再次进入。但这只有在Unity Editor中才有可能。玩家需要退出我们的应用程序并重新启动它才能玩新游戏。**如果我们能在保持游戏模式的同时开始一个新的游戏，那就更好了。**
如果按下了一个键，则调用新的 `BeginNewGame` 方法。我们一次只能处理一个键，所以如果没有按 C 键，只检查 N 键。

```
void Update () {
		if (Input.GetKeyDown(createKey)) {
			CreateObject();
		}
		else if (Input.GetKey(newGameKey)) {
			BeginNewGame();
		}
	}

	void BeginNewGame () {}
```

### 跟踪对象

我们的游戏可以生成任意数量的随机立方体，这些立方体都会添加到场景中。但 `Game` 对它产生的东西没有记忆。为了摧毁立方体，我们首先需要找到它们。为了实现这一点，我们将让 `Game` 跟踪它实例化的对象的引用列表。

```
List<Transform> objects;
```


```
void Awake () {
		objects = new List<Transform>();
	}
```

接下来，通过的 `Add` 方法，每次实例化一个新的列表时，都会向列表添加 Transform引用。

```
void CreateObject () {
		Transform t = Instantiate(prefab);
		t.localPosition = Random.insideUnitSphere * 5f;
		t.localRotation = Random.rotation;
		t.localScale = Vector3.one * Random.Range(0.1f, 1f);
		objects.Add(t);
	}
```

### 清除 List

现在我们可以循环浏览 `BeginNewGame` 中的列表，并销毁所有实例化的游戏对象。这与数组的工作原理相同，只是列表的长度是通过其 `Count` 属性找到的。

```
void BeginNewGame () {
		for (int i = 0; i < objects.Count; i++) {
			Destroy(objects[i].gameObject);
		}
	}
```

这给我们留下了一个被破坏对象的引用列表。我们也必须通过调用 `Clear` 方法清空列表来消除这些问题。

```
void BeginNewGame () {
		for (int i = 0; i < objects.Count; i++) {
			Destroy(objects[i].gameObject);
		}
		objects.Clear();
	}
```

## 保存和加载

真正的保存系统即使在游戏终止之后也能够记住游戏状态。这需要在游戏之外的某个地方保持游戏状态。最简单的方法是将数据存储在文件中。

###  保存路径


游戏文件应该存储在哪里取决于文件系统。Unity为我们解决了这些差异，使我们可以通过 [Application](http://docs.unity3d.com/Documentation/ScriptReference/Application.html).persistentDataPath 属性使用的文件夹路径可用。我们可以从这个属性中获取文本字符串，并将其存储在#2中的 `savePath` 字段中，因此我们只需要检索一次。

```
string savePath;

	void Awake () {
		objects = new List<Transform>();
		savePath = Application.persistentDataPath;
	}
```

### 打开要写入的文件



为了能够将数据写入保存文件，我们首先必须打开它。这是通过 [File](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=File).Open方法完成的，并为其提供一个路径参数。它还需要知道我们打开文件的原因。我们希望将数据写入其中，如果文件不存在，则创建该文件，或者替换已存在的文件。我们通过提供 [FileMode](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=FileMode).Create作为第二个参数来指定这一点。在新的方法中执行此操作。

```
void Save () {
		File.Open(savePath, FileMode.Create);
	}
```

`[File](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=File).Open` returns a file stream, which isn't useful on its own. We need a data stream that we could write data into. This data has to be of a certain format. We'll use the most compact uncompressed format available, which is raw binary data. The `System.IO` namespace has the `[BinaryWriter](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=BinaryWriter)` class to make this possible. Create a new instance of this class, using its constructor method, providing the file stream as an argument. We don't need to keep a reference to the file stream, so we can directly use the `[File](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=File).Open` invocation as the argument. We do need to keep a reference to the writer, so assign it to a variable.  
[File](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=File).Open 返回一个文件流，这本身没有用处。我们需要一个可以写入数据的数据流。这些数据必须具有特定的格式。我们将使用最紧凑的未压缩格式，即原始二进制数据。 `System.IO` 名称空间具有 [BinaryWriter](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=BinaryWriter) 类，可以实现这一点。使用该类的构造函数方法创建一个新实例，并提供文件流作为参数。我们不需要保留对文件流的引用，所以我们可以直接使用 [File](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=File).Open 调用作为参数。我们确实需要保留对编写器的引用，因此将其分配给一个变量。

```
void Save () {
		BinaryWriter writer =
			new BinaryWriter(File.Open(savePath, FileMode.Create));
	}
```

We now have a binary writer variable named writer that references a new binary writer. That's using the word"writer"three times in one expression, which is a bit much. As we're explicitly creating a new `[BinaryWriter](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=BinaryWriter)`, it is redundant to explicitly declare the variable's type as well. Instead, we can use the `**var**` keyword. This implicitly declares the variable's type to match whatever is immediately assigned to it, which is something that the compiler can figure out in this case. ❗ 🔄

```
void Save () {
		var writer = new BinaryWriter(File.Open(savePath, FileMode.Create));
	}
```

We now have a writer variable that references a new binary writer. Its type is obvious.  
我们现在有了一个引用新的二进制编写器的编写器变量。它的类型是显而易见的。

### Closing the File 关闭文件

If we open a file, we must make sure that we also close it. It's possible to do this via a `Close` method, but this isn't safe. If something goes wrong between opening and closing the file, an exception could be raised and execution of the method could be terminated before it got to closing the file. We have to carefully handle exceptions to ensure that the file is always closed. There is syntactic sugar to make this easy. Put the declaration and assignment of the `writer` variable inside round brackets, place the `**using**` keyword in front of it, and a code block after it. The variable is available inside that block, just like the iterator variable `i` of a standard `**for**` loop.  
如果我们打开一个文件，我们必须确保同时关闭它。通过 `Close` 方法可以做到这一点，但这是不安全的。如果在打开和关闭文件之间出现问题，则可能会引发异常，并且方法的执行可能会在关闭文件之前终止。我们必须小心处理异常，以确保文件始终处于关闭状态。有语法上的糖使这变得容易。将 `writer` 变量的声明和赋值放在圆括号内，将 `**using**` 关键字放在它前面，然后放一个代码块。该变量在该块内可用，就像标准 `**for**` 循环的迭代器变量 `i` 一样。

```
void Save () {
		using (
			var writer = new BinaryWriter(File.Open(savePath, FileMode.Create))
		) {}
	}
```

This will ensure that whatever `writer` references will be properly disposed of, after code execution exits the block, no matter how. This works for special disposable types, which the writer and stream are.  
这将确保在代码执行退出块之后，无论如何，任何 `writer` 引用都将被正确处理。这适用于特殊的一次性类型，即作家和流。

### Writing Data 写入数据

We can write data to our file by invoking our writer's `Write` method. It is possible to write simple values, like a boolean, integer, and so on, one at a time. Let's begin by writing only how many objects we have instantiated.  
我们可以通过调用编写器的 `Write` 方法将数据写入文件。可以一次写一个简单的值，比如布尔值、整数等等。让我们从只写我们实例化了多少对象开始。

```
void Save () {
		using (
			var writer = new BinaryWriter(File.Open(savePath, FileMode.Create))
		) {
			writer.Write(objects.Count);
		}
	}
```

To actually save this data, we have to invoke the `Save` method. We'll again control this via a key, in this case using S as the default.  
为了实际保存这些数据，我们必须调用 `Save` 方法。我们将再次通过一个键来控制它，在本例中使用S作为默认值。

```
public KeyCode createKey = KeyCode.C;
	public KeyCode saveKey = KeyCode.S;

	…

	void Update () {
		if (Input.GetKeyDown(createKey)) {
			CreateObject();
		}
		else if (Input.GetKey(newGameKey)) {
			BeginNewGame();
		}
		else if (Input.GetKeyDown(saveKey)) {
			Save();
		}
	}
```

![](<images/1686835483903.png>)

Save key set to S.  
将密钥集保存到S。

Enter play mode, create a few cubes, then save the game by pressing the key. This will have created a _saveFile_ file on your file system. If you're not sure where it is located, you can use `[Debug](http://docs.unity3d.com/Documentation/ScriptReference/Debug.html).Log` to write the file's path to the Unity console.  
进入游戏模式，创建几个立方体，然后按键保存游戏。这将在您的文件系统上创建一个文件。如果您不确定它的位置，可以使用 `[Debug](http://docs.unity3d.com/Documentation/ScriptReference/Debug.html).Log` 将文件的路径写入Unity控制台。

You'll find that the file contains four bytes of data. Opening the file in a text editor will show nothing useful, because the data is binary. It might show nothing at all, or might interpret the data as weird characters. There are four bytes because that's the size of an integer.  
您会发现该文件包含四个字节的数据。在文本编辑器中打开文件将不会显示任何有用的内容，因为数据是二进制的。它可能什么都不显示，或者可能将数据解释为奇怪的字符。有四个字节，因为这是一个整数的大小。

Besides writing how many cubes we have, we must also store the transformation data of each cube. We do this by looping through the objects and writing their data, one number at a time. For now, we'll limit ourselves to just their positions. So write the X, Y, and Z components of each cube's position, in that order.  
除了写我们有多少个Cube，我们还必须存储每个Cube的转换数据。我们通过循环遍历对象并一次写入一个数字来实现这一点。目前，我们将仅限于他们的立场。因此，按照这个顺序写出每个立方体位置的X、Y和Z分量。

```
writer.Write(objects.Count);
			for (int i = 0; i < objects.Count; i++) {
				Transform t = objects[i];
				writer.Write(t.localPosition.x);
				writer.Write(t.localPosition.y);
				writer.Write(t.localPosition.z);
			}
```

![](<images/1686835484431.png>)

File containing seven positions, in four-byte blocks.  
包含七个位置的文件，以四字节块为单位。

### Loading Data 正在加载数据

To load the data that we just saved, we have to again open the file, this time with `[FileMode](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=FileMode).Open` as the second argument. Instead of a `[BinaryWriter](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=BinaryWriter)`, we have to use a `[BinaryReader](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=BinaryReader)`. Do this in a new `Load` method, once again with a `**using**` statement.  
要加载我们刚刚保存的数据，我们必须再次打开文件，这次使用 `[FileMode](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=FileMode).Open` 作为第二个参数。我们必须使用#2而不是 `[BinaryWriter](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=BinaryWriter)` 。在一个新的#3方法中执行此操作，再次使用#4语句。

```
void Load () {
		using (
			var reader = new BinaryReader(File.Open(savePath, FileMode.Open))
		) {}
	}
```

The first thing we wrote to the file was the count property of our list, so that is also the first thing to read. We do this with the `ReadInt32` method of our reader. We have to be explicit what we read, because there is no parameter that makes this clear. The suffix 32 refers to the size of the integer, which is four bytes, thus 32 bits. There are also larger and smaller integer variants, but we don't use those.  
我们写入文件的第一件事是列表的count属性，所以这也是要读取的第一件事情。我们使用阅读器的 `ReadInt32` 方法来完成此操作。我们必须明确我们读到的内容，因为没有任何参数可以明确这一点。后缀32指的是整数的大小，它是四个字节，因此是32位。也有较大和较小的整数变体，但我们不使用它们。

```
using (
			var reader = new BinaryReader(File.Open(savePath, FileMode.Open))
		) {
			int count = reader.ReadInt32();
		}
```

After reading the count, we know how many objects were saved. We have to read that many positions from the file. Do this with a loop, reading three floats per iteration, for the X, Y, and Z components of a position vector. A single-precision `**float**` is read with the `ReadSingle` method. A double-precision `**double**` would be read with the `ReadDouble` method.  
看完计数后，我们知道有多少物体被保存了下来。我们不得不从文件中读到这么多的立场。使用循环执行此操作，每次迭代读取位置向量的X、Y和Z分量的三个浮点值。使用 `ReadSingle` 方法读取单个精度 `**float**` 。将使用#3方法读取双倍精度的#2。

```
int count = reader.ReadInt32();
			for (int i = 0; i < count; i++) {
				Vector3 p;
				p.x = reader.ReadSingle();
				p.y = reader.ReadSingle();
				p.z = reader.ReadSingle();
			}
```

Use the vector to set the position of a newly instantiated cube, and add it to the list.  
使用向量设置新实例化的Cube的位置，并将其添加到列表中。

```
for (int i = 0; i < count; i++) {
				Vector3 p;
				p.x = reader.ReadSingle();
				p.y = reader.ReadSingle();
				p.z = reader.ReadSingle();
				Transform t = Instantiate(prefab);
				t.localPosition = p;
				objects.Add(t);
			}
```

At this point we can recreate all cubes that we saved, but they get added to the cubes that were already in the scene. To properly load a previously saved game, we have to reset the game before recreating it. We can do this by invoking `BeginNewGame` before loading the data.  
此时，我们可以重新创建我们保存的所有Cube，但它们会添加到场景中已经存在的Cube中。为了正确加载之前保存的游戏，我们必须在重新创建游戏之前重置游戏。我们可以在加载数据之前调用 `BeginNewGame` 来完成这一操作。

```
void Load () {
		BeginNewGame();
		using (
			var reader = new BinaryReader(File.Open(savePath, FileMode.Open))
		) {
			…
		}
	}
```

Have `**Game**` invoke `Load` when a key is pressed, using L as the default.  
让 `**Game**` 在按键时调用 `Load` ，使用L作为默认值。

```
public KeyCode createKey = KeyCode.C;
	public KeyCode saveKey = KeyCode.S;
	public KeyCode loadKey = KeyCode.L;

	…

	void Update () {
		…
		else if (Input.GetKeyDown(saveKey)) {
			Save();
		}
		else if (Input.GetKeyDown(loadKey)) {
			Load();
		}
	}
```

![](<images/1686835484959.png>)

Load key set to L.  
加载键设置为L。

Now the player can save their cubes and later load them, either during the same play session or another one. But because we're only storing the position data, the rotation and scale of cubes are not stored. As a result, loaded cubes all end up with the default rotation and scale of the prefab.  
现在，玩家可以保存他们的Cube，然后在同一次或另一次游戏中加载它们。但因为我们只存储位置数据，所以不存储立方体的旋转和缩放。结果，加载的Cube都以预制件的默认旋转和比例结束。

## Abstracting Storage 抽象存储

Although we need to know the specifics of reading and writing binary data, that's rather low-level. Writing a single 3D vector requires three invocations of `Write`. When saving and loading our objects, it's more convenient if we could work at a slightly higher level, reading or writing an entire 3D vector with a single method invocation. Also, it would be nice if we could just use `ReadInt` and `ReadFloat`, instead of having to worry about all the different variants that we don't use. Finally, it shouldn't matter whether the data is stored in binary, plain text, base-64, or another encoding method. `**Game**` doesn't need to know such details.  
尽管我们需要了解读取和写入二进制数据的细节，但这是相当低级的。编写单个三维矢量需要调用三次 `Write` 。在保存和加载对象时，如果我们可以在稍高的级别上工作，只需一个方法调用即可读取或写入整个3D向量，那么会更方便。此外，如果我们可以只使用 `ReadInt` 和 `ReadFloat` ，而不必担心我们没有使用的所有不同变体，那就太好了。最后，数据是以二进制、纯文本、base-64还是其他编码方法存储都不重要 `**Game**` 不需要知道这些细节。

### Game Data Writer and Reader  
游戏数据编写器和阅读器

To hide the details of reading and writing data, we're going to create our own reader and writer classes. Let's begin with the writer, naming it `**GameDataWriter**`.  
为了隐藏读取和写入数据的细节，我们将创建自己的读取器和编写器类。让我们从编写器开始，将其命名为 `**GameDataWriter**` 。

`**GameDataWriter**` does not extend `[MonoBehaviour](http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.html)`, because we won't attach it to a game object. It will act as a wrapper for `[BinaryWriter](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=BinaryWriter)`, so give it a single writer field.  
`**GameDataWriter**` 不会扩展 `[MonoBehaviour](http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.html)` ，因为我们不会将其附加到游戏对象。它将充当#2的包装器，所以给它一个单独的编写器字段。

```
using System.IO;
using UnityEngine;

public class GameDataWriter {

	BinaryWriter writer;
}
```

A new object instance of our custom writer type can be created via `**new** **GameDataWriter**()`. But this only makes sense if we have a writer to wrap. So create a custom constructor method with a `[BinaryWriter](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=BinaryWriter)` parameter. This is a method with the type name of its class as its own name, which also acts as its return type. It replaces the implicit default constructor method.  
我们的自定义编写器类型的新对象实例可以通过 `**new** **GameDataWriter**()` 创建。但这只有在我们有一个作家的情况下才有意义。因此，创建一个带有 `[BinaryWriter](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=BinaryWriter)` 参数的自定义构造函数方法。这是一个方法，其类的类型名作为自己的名称，也作为其返回类型。它替换了隐式默认构造函数方法。

```
public GameDataWriter (BinaryWriter writer) {
	}
```

Although invoking a constructor method results in a new object instance, such methods don't explicitly return anything. The object gets created before the constructor is invoked, which can then take care of any required initialization. In our case, that's simply assigning the writer parameter to the object's field. As I've used the same name for both, I have to use the `**this**` keyword to explicitly indicate that I'm referring to the object's field instead of the parameter.  
尽管调用构造函数方法会产生一个新的对象实例，但这样的方法不会显式返回任何内容。在调用构造函数之前创建对象，然后构造函数可以处理任何所需的初始化。在我们的例子中，这只是将writer参数分配给对象的字段。由于我对两者使用了相同的名称，所以我必须使用 `**this**` 关键字来明确表示我指的是对象的字段，而不是参数。

```
public GameDataWriter (BinaryWriter writer) {
		this.writer = writer;
	}
```

The most basic functionality is to write a single `**float**` or `**int**` value. Add public `Write` methods for this, simply forwarding the invocation to the actual writer.  
最基本的功能是写入一个 `**float**` 或 `**int**` 值。为此添加公共#2方法，只需将调用转发给实际的编写器即可。

```
public void Write (float value) {
		writer.Write(value);
	}

	public void Write (int value) {
		writer.Write(value);
	}
```

Besides that, also add methods to write a `[Quaternion](http://docs.unity3d.com/Documentation/ScriptReference/Quaternion.html)`—for rotations—and a `[Vector3](http://docs.unity3d.com/Documentation/ScriptReference/Vector3.html)`. These methods have to write all the components of their parameter. In the case of a quaternion, that's four components.  
除此之外，还添加了一些方法来编写 `[Quaternion](http://docs.unity3d.com/Documentation/ScriptReference/Quaternion.html)` -用于旋转和 `[Vector3](http://docs.unity3d.com/Documentation/ScriptReference/Vector3.html)` 。这些方法必须写入其参数的所有组件。在四元数的情况下，这是四个分量。

```
public void Write (Quaternion value) {
		writer.Write(value.x);
		writer.Write(value.y);
		writer.Write(value.z);
		writer.Write(value.w);
	}
	
	public void Write (Vector3 value) {
		writer.Write(value.x);
		writer.Write(value.y);
		writer.Write(value.z);
	}
```

Next, create a new `**GameDataReader**` class, using the same approach as for the writer. In this case, we wrap a `[BinaryReader](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=BinaryReader)`.  
接下来，使用与编写器相同的方法创建一个新的 `**GameDataReader**` 类。在这种情况下，我们包装一个 `[BinaryReader](https://learn.microsoft.com/en-us/search/?category=Reference&scope=.NET&terms=BinaryReader)` 。

```
using System.IO;
using UnityEngine;

public class GameDataReader {

	BinaryReader reader;

	public GameDataReader (BinaryReader reader) {
		this.reader = reader;
	}
}
```

Give it methods that are simply named `ReadFloat` and `ReadInt`, that forward the invocations to `ReadSingle` and `ReadInt32`.  
给它简单命名为 `ReadFloat` 和 `ReadInt` 的方法，将调用转发到 `ReadSingle` 和 `ReadInt32` 。

```
public float ReadFloat () {
		return reader.ReadSingle();
	}

	public int ReadInt () {
		return reader.ReadInt32();
	}
```

Also create `ReadQuaternion` and `ReadVector3` methods. Read their components in the same order that we write them.  
同时创建 `ReadQuaternion` 和 `ReadVector3` 方法。按照我们编写它们的相同顺序读取它们的组件。

```
public Quaternion ReadQuaternion () {
		Quaternion value;
		value.x = reader.ReadSingle();
		value.y = reader.ReadSingle();
		value.z = reader.ReadSingle();
		value.w = reader.ReadSingle();
		return value;
	}

	public Vector3 ReadVector3 () {
		Vector3 value;
		value.x = reader.ReadSingle();
		value.y = reader.ReadSingle();
		value.z = reader.ReadSingle();
		return value;
	}
```

### Persistable Objects 持久性对象

Now it's a lot simpler to write the transform data of cubes in `**Game**`. But we can go one step further. What if `**Game**` could simply invoke `writer.Write(objects[i])`? That would be very convenient, but would require `**GameDataWriter**` to know the details of writing a game object. But it's better to keep the writer simple, limited to primitive values and simple structs.  
现在，在 `**Game**` 中编写Cube的转换数据要简单得多。但我们可以更进一步。如果 `**Game**` 可以简单地调用 `writer.Write(objects[i])` 呢？这将是非常方便的，但需要#3知道编写游戏对象的细节。但最好保持作者的简单，仅限于原始值和简单的结构。

We can turn this reasoning around. `**Game**` doesn't need to know how to save a game object, that's the responsibility of the object itself. All the object needs is a writer to save itself. Then `**Game**` could use `objects[i].Save(writer)`.  
我们可以扭转这种推理 `**Game**` 不需要知道如何保存游戏对象，这是对象本身的责任。对象所需要的只是一个写入程序来保存自己。那么#1可以使用#2。

Our cubes are simple objects, without any custom components attached. So the only thing that's to save is the transform component. Let's create a `**PersistableObject**` component script that knows how to save and load that data. It simply extends `[MonoBehaviour](http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.html)` and has a public `Save` method and `Load` method with a `**GameDataWriter**` or `**GameDataReader**` parameter respectively. Have it save the transform position, rotation, and scale, and load them in the same order.  
我们的Cube是简单的对象，没有附加任何自定义组件。因此，唯一要保存的是变换组件。让我们创建一个 `**PersistableObject**` 组件脚本，它知道如何保存和加载数据。它只是扩展了 `[MonoBehaviour](http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.html)` ，并有一个公共的 `Save` 方法和 `Load` 方法，分别带有 `**GameDataWriter**` 或 `**GameDataReader**` 参数。让它保存变换位置、旋转和缩放，并按相同顺序加载它们。

```
using UnityEngine;

public class PersistableObject : MonoBehaviour {

	public void Save (GameDataWriter writer) {
		writer.Write(transform.localPosition);
		writer.Write(transform.localRotation);
		writer.Write(transform.localScale);
	}

	public void Load (GameDataReader reader) {
		transform.localPosition = reader.ReadVector3();
		transform.localRotation = reader.ReadQuaternion();
		transform.localScale = reader.ReadVector3();
	}
}
```

The idea is that a game object that can be persisted only has one `**PersistableObject**` component attached to it. Having multiple such components makes no sense. We can enforce this by adding the `[DisallowMultipleComponent](http://docs.unity3d.com/Documentation/ScriptReference/DisallowMultipleComponent.html)` attribute to the class.  
这个想法是，一个可以持久化的游戏对象只有一个 `**PersistableObject**` 组件。拥有多个这样的组件是没有意义的。我们可以通过将 `[DisallowMultipleComponent](http://docs.unity3d.com/Documentation/ScriptReference/DisallowMultipleComponent.html)` 属性添加到类中来强制实现这一点。

```
[DisallowMultipleComponent]
public class PersistableObject : MonoBehaviour {

	…
}
```

Add this component to our cube prefab.  
将此组件添加到我们的立方体预制件中。

![](<images/1686835485537.png>)

Persistable prefab. 持久预制。

### Persistent Storage 持久性存储

Now that we have a persistent object type, let's also create a `**PersistentStorage**` class to save such an object. It contains the same saving and loading logic as `**Game**`, except that it only saves and loads a single `**PersistableObject**` instance, provided via a parameter to public `Save` and `Load` methods. Make it a `[MonoBehaviour](http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.html)`, so we can attach it to a game object and it can initialize its save path.  
既然我们有了一个持久对象类型，那么让我们创建一个 `**PersistentStorage**` 类来保存这样的对象。它包含与 `**Game**` 相同的保存和加载逻辑，只是它只保存和加载一个 `**PersistableObject**` 实例，该实例通过参数提供给公共 `Save` 和 `Load` 方法。让它成为 `[MonoBehaviour](http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.html)` ，这样我们就可以将它附加到游戏对象上，它就可以初始化其保存路径。

```
using System.IO;
using UnityEngine;

public class PersistentStorage : MonoBehaviour {

	string savePath;

	void Awake () {
		savePath = Path.Combine(Application.persistentDataPath, "saveFile");
	}

	public void Save (PersistableObject o) {
		using (
			var writer = new BinaryWriter(File.Open(savePath, FileMode.Create))
		) {
			o.Save(new GameDataWriter(writer));
		}
	}

	public void Load (PersistableObject o) {
		using (
			var reader = new BinaryReader(File.Open(savePath, FileMode.Open))
		) {
			o.Load(new GameDataReader(reader));
		}
	}
}
```

Add a new game object to the scene with this component attached. It represents the persistent storage of our game. Theoretically, we could have multiple such storage objects, used to store different things, or to provide access to different storage types. But in this tutorial we use just this single file storage object.  
将一个新的游戏对象添加到附加了该组件的场景中。它代表了我们游戏的持久存储。理论上，我们可以有多个这样的存储对象，用于存储不同的东西，或者提供对不同存储类型的访问。但是在本教程中，我们只使用了这个单独的文件存储对象。

![](<images/1686835486080.png>)

Storage object. 存储对象。

### Persistable Game 持久性游戏

To make use of the new persistable object approach, we have to rewrite `**Game**`. Change the `prefab` and `objects` content type to `**PersistableObject**`. Adjust `CreateObject` so it can deal with this type change. Then remove all the code specific to reading from and writing to files.  
为了使用新的持久化对象方法，我们必须重写 `**Game**` 。将 `prefab` 和 `objects` 内容类型更改为 `**PersistableObject**` 。调整#4，使其能够处理此类型的更改。然后删除所有特定于读取和写入文件的代码。

```
using System.Collections.Generic;

using UnityEngine;

public class Game : MonoBehaviour {

	public PersistableObject prefab;

	…

	List<PersistableObject> objects;



	void Awake () {
		objects = new List<PersistableObject>();

	}

	void Update () {
		…
		else if (Input.GetKeyDown(saveKey)) {

		}
		else if (Input.GetKeyDown(loadKey)) {

		}
	}
	
	…

	void CreateObject () {
		PersistableObject o = Instantiate(prefab);
		Transform t = o.transform;
		…
		objects.Add(o);
	}








}
```

We'll have `**Game**` rely on a `**PersistentStorage**` instance to take care of the details of storing data. Add a public `storage` field of this type, so we can give `**Game**` a reference to our storage object. To again save and load the game state, we have `**Game**` itself extend `**PersistableObject**`. Then it can load and save itself, using the storage.  
我们将让 `**Game**` 依赖 `**PersistentStorage**` 实例来处理存储数据的细节。添加一个这种类型的公共#2字段，这样我们就可以给#3一个对存储对象的引用。为了再次保存和加载游戏状态，我们有#4本身扩展 `**PersistableObject**` 。然后，它可以使用存储来加载和保存自己。

```
public class Game : PersistableObject {

	…

	public PersistentStorage storage;

	…

	void Update () {
		if (Input.GetKeyDown(createKey)) {
			CreateObject();
		}
		else if (Input.GetKeyDown(saveKey)) {
			storage.Save(this);
		}
		else if (Input.GetKeyDown(loadKey)) {
			BeginNewGame();
			storage.Load(this);
		}
	}

	…
}
```

Connect the storage via the inspector. Also reconnect the prefab, as its reference was lost due to the field's type change.  
通过检查员连接存储器。同时重新连接预制件，因为字段的类型更改导致其引用丢失。

![](<images/1686835486646.png>)

Game connected to prefab and storage.  
游戏连接到预制和存储。

### Overriding Methods 覆盖方法

When we save and load the game now, we end up writing and reading the transformation data of our main game object. This is useless. Instead, we have to save and load its list of objects.  
当我们现在保存和加载游戏时，我们最终会写入和读取主游戏对象的转换数据。这没用。相反，我们必须保存并加载它的对象列表。

Instead of relying on the `Save` method defined in `**PersistableObject**`, we have to give `**Game**` its own public version of `Save` with a `**GameDataWriter**` parameter. In it, write the list as we did before, now using the convenient `Save` method of the objects.  
我们不依赖于 `**PersistableObject**` 中定义的 `Save` 方法，而是必须给 `**Game**` 一个 `**GameDataWriter**` 参数来提供其自己的#3的公共版本。在其中，像以前一样编写列表，现在使用对象的便捷 `Save` 方法。

```
public void Save (GameDataWriter writer) {
		writer.Write(objects.Count);
		for (int i = 0; i < objects.Count; i++) {
			objects[i].Save(writer);
		}
	}
```

This is not yet enough to make it work. The compiler complains that `**Game**.Save` hides the inherited member `**PersistableObject**.Save`. While `**Game**` can work with its own `Save` version, `**PersistentStorage**` only knows about `**PersistableObject**.Save`. So it would invoke this method, not the one from `**Game**`. To make sure that the correct `Save` method gets invoked, we have to explicitly declare that we override the method that `**Game**` inherited from `**PersistableObject**`. That's done by adding the `**override**` keyword to the method declaration.  
这还不足以使其发挥作用。编译器抱怨 `**Game**.Save` 隐藏了继承的成员 `**PersistableObject**.Save` 。虽然#2可以使用自己的#3版本，但#4只知道 `**PersistableObject**.Save` 。所以它会调用这个方法，而不是来自 `**Game**` 的方法。为了确保正确的 `Save` 方法被调用，我们必须明确声明我们覆盖了 `**Game**` 从 `**PersistableObject**` 继承的方法。这是通过将 `**override**` 关键字添加到方法声明中来完成的。

```
public override void Save (GameDataWriter writer) {
		…
	}
```

However, we cannot just override any method we like. By default, we're not allowed to do this. We have to explicitly enable it, by adding the `**virtual**` keyword to the `Save` and `Load` method declarations in `**PersistableObject**`.  
然而，我们不能只是覆盖我们喜欢的任何方法。默认情况下，我们不允许这样做。我们必须显式地启用它，方法是将 `**virtual**` 关键字添加到#3中的 `Save` 和 `Load` 方法声明中。

```
public virtual void Save (GameDataWriter writer) {
		writer.Write(transform.localPosition);
		writer.Write(transform.localRotation);
		writer.Write(transform.localScale);
	}

	public virtual void Load (GameDataReader reader) {
		transform.localPosition = reader.ReadVector3();
		transform.localRotation = reader.ReadQuaternion();
		transform.localScale = reader.ReadVector3();
	}
```

`**PersistentStorage**` will now end up invoking our `**Game**.Save` method, even though it's passed to it as a `**PersistableObject**` argument. Also have `**Game**` override the `Load` method.  
`**PersistentStorage**` 现在将最终调用我们的 `**Game**.Save` 方法，即使它是作为 `**PersistableObject**` 参数传递给它的。同时让#3覆盖#4方法。

```
public override void Load (GameDataReader reader) {
		int count = reader.ReadInt();
		for (int i = 0; i < count; i++) {
			PersistableObject o = Instantiate(prefab);
			o.Load(reader);
			objects.Add(o);
		}
	}
```

![](<images/1686835487185.png>)

File containing two transforms.  
包含两个变换的文件。

The next tutorial is [Object Variety](https://catlikecoding.com/unity/tutorials/object-management/object-variety/).  
下一个教程是“对象多样性”。

[repository](https://bitbucket.org/catlikecodingunitytutorials/object-management-01-persisting-objects) [PDF](https://catlikecoding.com/unity/tutorials/object-management/persisting-objects/Persisting-Objects.pdf)