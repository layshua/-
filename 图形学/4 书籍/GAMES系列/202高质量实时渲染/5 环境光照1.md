主要内容：**如何不采样去计算不考虑shadow时的shading值**

# 距离场软阴影 Distance Field 
1. 比 shadowmap 快
2. 需要预计算，内存占用大
3. 动态物体需要实时计算

## 有向距离场 Signed Distance Function
![[Pasted image 20230714114227.png]]
>SDF 可视化

Distance Function：对于任一点，给出**到最近的对象上的最小距离** (可以是带符号的距离，即有向距离场，物体内部为负，物体外部为正)

![[Pasted image 20230714104506.png]]

Blend移动的边界：
![[Pasted image 20230714111349.png]]

Blend 任意任意两个 SDF，得到一个新的 SDF
![[Pasted image 20230714111554.png]]
SDF 大多用在与几何之类的方向上, 比如我有两个物体的 SDF, 我们将两个 SDF 进行 Blend 操作, 从而得到一个新的 SDF, 也就得到了一个新的几何物体, 因为当距离 0 为实，即可认为是物体的边界，SDF 可以很准确地反应物体的边界。几何转换 SDF 的时候，可以很好地把几何进行过渡。

## SDF 的应用:

### Ray Marching

假设我们已经知道场景的 SDF, 现在有一根光线, 我们试图让光线和 SDF 所表示的隐含表面进行求交, 也就是我们要用 Ray Marching :进行求交.

![[Pasted image 20230714111756.png]]
任意一点的SDF 是预计算的, 因此在 $P_{0}$ 点时, 我们以它的 $SDF(P_0)$ 为半径做一个圆 (此处假设在 2D 内, 如果在 3D 内则是一个球), 在这个圆内无论是哪个方向前进, 只要不超过半径距离, 都不会碰见物体, 是安全的。

因此我们可以利用这个特性不断的朝一个方向前进, 以 $P_{0}$ 开始朝一方向走 $SDF(P_{0}$) 到达 $P_{1}$ 点, 若仍与物体表面相距甚远, 则以 $P_{1}$ 点为新起点继续走 $SDF(P_{1}$) 到达 $P_{2}$ 点, 假设此处 $P_{2}$ 点的 $SDF$ 足够小, 也就是代表离物体表面足够接近了, 则进行求交操作.

如果在超一方向 trace 非常远的距离但仍然什么都没 trace 到, 此时就可以舍弃这条光线, 也就是停止了.
SDF
### SDF软阴影

将安全距离的概念进行延伸，在任意一点通过 sdf 可以获得一个安全角度 safe angle（图中灰色部分）
![[Pasted image 20230714112418.png|500]]
我们取点 P 为 shading point 往一方向打出一根光线, 光线上的一点 a, 有一个 SDF 值 SDF(a), 也就是在 a 点以 SDF(a) 为半径所做的球或圆内是安全的, 不会碰到物体.

把 shading point 和**面光源**相连，所得到的安全角度越小，被遮蔽的可能越高，就可以认为
- **safe angle 越小，阴影越黑，越趋近于硬阴影;**
- **safe angle 够大就视为不被遮挡没有阴影, 也就越趋近于软阴影。**

- ? **如何从 ray marching 中求出 safe angle？**
![[Pasted image 20230714113316.png|450]]
我们以 $o$ 为起点, 沿一个方向推进, 仍然是 ray marhcing 的步骤, 在 $p1$ 点以 $SDF(p1)$ 进行推进, 其余点也是一样, 此处主要是为了求 safe angle,。
1. 我们在起点 $o$ 沿每个点的 $SDF$ 为半径所形成圆做切线, 从而求出各个点的 safe angle,
2. 取其中最小的角度作为 safe angle.


**那么我们该怎么去计算这个角度?**

从图我们可以知道, 以 $p1$ 点为例, 从 $o$ 点到 $p1$ 的距离为斜边, $sdf(p1)$ 函数值是圆的半径，当然也是 p1 到切点的长度，p1 到到切点是直角边, 因此我们用 $arcsin$ 就可以求出 safe angle 了.
$$
\arcsin\frac{\mathrm{SDF}(p)}{p-o}
$$
但是 arcsin 的计算量其实是十分大的, 因此在 shader 中我们不用反三角函数。

只要 sdf 长度除以光线走过的距离乘一个 k 值，再限定到 1 以内，就能得到遮挡值或者说是 visibility，而 k 的大小是控制阴影的软硬程度.
$$
\min\left\{\frac{k\cdot\mathbf{SDF}(p)}{p-0},1.0\right\}
$$
![[Pasted image 20230714114113.png|300]]

我们从图中分可以看出来, 当 k 值越大时候, 就越接近硬阴影的效果, 也就是它限制了可能半影的区域:
- k 越小, 半影区域越大, 越接近软阴影效果.
- K 越大, 半影区域越小, 越接近硬阴影效果.


# 环境光照

在环境光照下做一点的 shading 时是不用去考虑 shadow 的, 首先我们复习一下什么是环境光照:

- 环境光照就是在场景中任意一点往四周看去可看到的光照（距离视为无限远）, 将其记录在一张图上存储。也叫做 **IBL(image-based lighing)**。
- 通常我们用 Spherical Map 和 Cube Map 来存储环境光照.

---

如果已知环境光照, 此时放置一个物体在场景中间, 在不考虑阴影时我们该如何去得到任何一物体上着色点的 shading 值呢?

- @ **首先要先来看渲染方程**
$$L_o(p,\omega_o) = \int\limits_{\Omega} f_r(p,\omega_i,\omega_o) L_i(p,\omega_i) n \cdot \omega_i d\omega_i$$
通用的解法是使用**蒙特卡洛积分**去解, 但是蒙特卡洛需要大量的样本才能让得出的结果足够接近, 如果我们对每个 shading point 都做一遍蒙特卡洛，那样的话太慢了。

- @ **如何避免采样?**

**brdf 分为两种情况:**
1.  brdf 为 glossy 时, 覆盖在球面上的范围很小
2.  brdf 为 diffuse 时, 它会覆盖整个半球的区域，在积分域内变化不大
![[Pasted image 20230714130125.png]]

此时应该想到了我们之前讲的渲染方程近似公式:
[[02 PBR理论#渲染方程不等式近似]]
$$
\int_\Omega f(x)g(x)\mathrm{~d}x\approx\frac{\int_\Omega f(x)\mathrm{~d}x}{\int_\Omega\mathrm{~d}x}\cdot\int_\Omega g(x)\mathrm{~d}x
$$
![[02 PBR理论#^ptjnu8]]

由于  $f_r$  项作为 $g(x)$ 正好满足这个条件, 即 small support 或 Smooth integrand, 从而我们将渲染方程的 $L_i$ 项作为 $f(x)$ ，方程可化为：
$$
L_o(p,\omega_o)\approx\boxed{\frac{\int_{\Omega_{f_{r}}}L_i(p,\omega_i)\mathrm{~d}\omega_i}{\int_{\Omega_{f_r}}\mathrm{~d}\omega_i}}\cdot\int_{\Omega^+}f_r(p,\omega_i,\omega_o)\cos\theta_i\mathrm{~d}\omega_i
$$

**The spilt sum: 1st stage**

把 light 项拆分出来, 然后将 brdf 范围内的 lighting 积分起来并进行 normalize, 其实就是将 IBL 这张图给模糊了.

模糊就是在任何一点上取周围一片范围求出范围内的平均值并将平均值写回这个点上, 主语滤波的核取多大取决于 BRDF 占多大, BRDF 的区域越大, 最后取得的图也就越模糊.

![[c9bf382c03e235b544147001dbc87491_MD5.jpg]]

而这些模糊过的图是我们在进行 rendering 之前生成的, 也就是 pre-filtering,Prefiltering 就是提前把滤波环境光生成，提前将不同卷积核的滤波核的环境光生成一系列模糊过的图（和 mipmap 相似），当我们需要时进行查询即可, 其他尺寸的图则可以经过这些已生成的通过三线性插值得到.

之前提过, 拆分就是为了做一个 Pre-filtering, 那么做 pre-filtering 是为了干什么?

![[a3689e8eedc6d0a17bc66fac37505420_MD5.jpg]]

左图为 brdf 求 shading point 值时, 我们要以一定立体角的范围内进行采样再加权平均从而求出 shading pointd 的值.

右图为我们从镜面反射方向望去在 pre-filtering 的图上进行查询, 由于图上任何一点都是周围范围内的加权平均值, 因此在镜面反射方向上进行一次查询就等价于左图的操作, 并且不需要采样, 速度更快.

**The spilt sum: 2nd stage**

到此我们解决了拆分后的前半部分积分采样的问题, 那么接下来我们处理 BRDF 项采样的问题:

![[4ee2a40a998a23168e390cb2d3392972_MD5.jpg]]

接下来讲的方法并不是最优方法, 现如今已经有更简单方便的方法了, 但是本课我们主要是为了学习方法背后的思想.

![[d732c617cf59e831f8be11c2172cd720_MD5.jpg]]

我们仍然可以用预计算来解决后半部分积分采样的问题, 但是预计算的话我们需要将参数的所有可能性均考虑进去, 但是比较多，包括 roughness、color 等。考虑所有参数的话我们需要打印出一张五维或者更高的表格, 这样会拥有爆炸的存储量, 因此我们需要想办法降低维度, 也就是减少参数量从而实现预计算.

![[f7a880cd20315186e67f6394fb1969d8_MD5.jpg]]

在 microfacet brdf 中中，考虑的是菲涅尔项、阴影项以及法线项，由于此时暂时不考虑阴影，此处需要关注的是 Fresnel term 和 distribution of normals。

![[f0f6a8efd002a3f75c2d1188055ba7ea_MD5.jpg]]

Frenel term 可以近似成一个基础反射率 R0 和入射角度的指数函数

法线发布函数（NDF）是一个一维的分布，其中有两个变量，一个变量定义是 diffuse 还是 gloosy，另一个 是 half vector 和法线中间的夹角，可以近似成入射角度相关的数，这样就变成了 3 维的预计算。

(PS: 在这里我们认为反射角, 入射角, half vector 可以用一个角 $\theta$ 代替).

至此我们有了三个变量: 基础反射率 r0,roughness $\alpha$ 和角度 $\theta$ , 三维的预计算仍然是一个存储量爆炸的结果, 因此我们还要想办法减少参数量.

所以我们通过将 Schlick 近似带入后半部分的积分中：

![[92bac7e0c09ae9868a36833f06712d65_MD5.jpg]]

基础反射 R0 被拆出积分式，需要预计算的两个量就只有 roughness $\alpha$ 和角度 $\theta$，可以将预计算结果绘制成一张纹理，在使用时进行查询即可。

![[89ab8044817bd3598a88a9bb973411aa_MD5.jpg]]

我们可以看到, 最后产生的结果是十分满意的:

![[af284f0e4f1c61b13a675710ddbff129_MD5.jpg]]

问题:

1.renel 需要预计算吗

frenel 项被拆开了，避免了对变量的依赖性

2 这张预计算是固定的吗？

是固定的。

3 Microfacet 在 ggx 中会多参数吗

不会

4. 深度学习在实时渲染中有什么应用吗

深度学习在实时渲染中并不成功，太慢了。