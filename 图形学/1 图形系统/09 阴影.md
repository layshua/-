
---
title: 09 阴影
aliases: [09 Shadow]
tags: []
create_time: 2023-06-20 10:42
uid: 202306201042
banner: "![[Pasted image 20230620104207.png]]"
---

需要补一下 games202 阴影内容
[实时阴影技术总结 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/45805097)
[实时渲染中的软阴影技术 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/26853641)
# 非基于图像的实时阴影
## 平面投影阴影
平面投影映射不是一个基于图像的解决方案

**内容**：根据光的方向，把物体的每个顶点投影到平面地面上。
![[Pasted image 20221209130631.png]]
**数学原理**：相似三角形
光 Light 所在的点 L 已知，V 已知，P 很容易就能求得

**缺点**：
- 只能投影到平面（阴影的接收物只能是平面）
- 投影物体必须在光线和平面之间
## 投影阴影

平面投影阴影的阴影接收物只能是平面，为了**在曲面上得到阴影**，做了以下改进：

**投影阴影**：
1. 把光源当做一个相机/投影器
2. 然后将阴影投影渲染到一张纹理
3. 最后**渲染阴影接收者时**，将上一步得到的阴影合并进去
- ![[Pasted image 20221209144815.png]]

**投影阴影在 Unity 中的实现**
![[Pasted image 20221209144939.png]]
-   第一步，设置 Project 组件，通过它的参数使用给它的材质生成一个视锥体
-   第二步，使用 Render Texture 生成一张纹理，将阴影绘制到纹理中
-   第三步，将设置 Project 组件的物体和阴影纹理进行混合

# 一、基于图像的实时阴影技术
**shadow mapping 是一个完全在图像空间 (images space)中的算法**
**优点:**
一旦 shadow Map 已经生成, 就可以利用 shadow map 来获取场景中的几何表示
**缺点:**
会产生自遮挡 (self occlusion)和走样 (aliasing) 现象.

## 2、阴影映射（ShadowMapping）
### 理解阴影

-   **如何确定“是不是阴影”**
	-   我们能看见+光能看见 = 正常渲染
	-   我们能看见 + 光看不见 = 阴影

-   **GAMES101 中，讲过的关于阴影的理解：**
	-   是一个经典的双 Pass 做法
	-   Pass1：从光源看向场景，记录看到点的深度
		-   需要从光源的位置渲染整个场景的深度图（这张图就是**shadowmap**）

	-   Pass2：从相机看向场景
		-   再从相机位置渲染这个场景

	- 在投影回光源所在的图像上，比较在相机位置渲染和光位置的深度，结果可以这样理解：
		-   **深度一致：说明相机和光都能看到**
		-   **深度不一致：我们能看到，但是光看不到 =>阴影**
		![[Pasted image 20221209145349.png]]
### 阴影图/深度图（Shadow Map）
![[Pasted image 20221209145547.png]]
-   光源视角下（shadowmap）
-   我们从光源看向场景的角度渲出一张深度图，这张深度图：
-   离光源越近就越黑（0）；越远就越白（1）
-   这张图就反映出了场景中物体的远近关系

![[Pasted image 20221209145655.png]]
**阴影映射的流程**
-  1. 从光源的位置生成一张深度图，这一步称之为阴影映射（ShadowMap）。
-  2. 从摄像机的视角，渲染整个渲染整个场景的物体。每次渲染时，需要和 shadowmap 的深度做比较（深度测试）。
>比如左下角红色点的位置，他的深度是摄像机视角的深度，所以要先转换成阴影映射的坐标系，保证坐标系是一致的。然后比较深度值，如果一个**片元的深度>它在 shadowmap 中的深度**，那么就认为它在阴影中。

**总结/注意事项：**
-   ShadowMapping 本质上是一种图像空间做法，也就是说生成 shadow 这一步不需要这个场景的几何信息
-   ShadowMapping 只能做**硬阴影**


### ShadowMapping 背后的数学

在微积分中有很多有用的不等式, 如图中的两个不等式为例：

![[Pasted image 20230622211119.png]]

**在实时渲染中, 我们只关心近似约等, 我们不考虑不等的情况, 因此我们将这些不等式当约等式来使用。**
![[Pasted image 20230622211059.png]]

如果你有两个函数的乘积, 你又想把他们的乘积积分起来, 你可以将其拆出来, 也就是:

**两个函数乘积的积分 $≈$ 两个函数积分的乘积**


1. **为什么右边第一个函数多了个分母？**

**分母这一项的作用是为了保证左右能量相同而做的归一化操作。**

我们来用一个例子来解释这个归一化操作。我们假设 $f(x)$ 是一个**常值函数**, 也就是 $f(x) = 2$, 我们的积分域恒为 $\int_0^3$.

那么约等式左边, 把 $f(x) = 2$ 代入, 则可以提出来变为 $2$ 倍的 $g(x)$ 积分

而等式右侧第一个函数代入 $f(x)$ 的积分是 $\int_0^3 2dx=2x|_0^3=2 * 3 =6$，分母的积分是 $\int_0^3 dx=x|_0^3=3$，结果也正好是 $2$. 正好也是 $2$ 倍的 $g(x)$ 积分.

2. **在什么情况下约等式结果更加准确:**

一般需要以下两个条件:

1.  g (x) 积分的 support 较小。这里的 support 我们可以暂时理解为积分域。

2. g (x) 在积分域内变化不大（学术界称为 Smooth integrand）。

**此时我们把渲染方程代入这个约等式中:**
我们把 visibility 看作是 $f(x)$, 提取出来并作归一化处理:
![[Pasted image 20230622212736.png]]

红色区域部分时 visibility, 那么剩下的 $g(x)$ 部分, 也就是 shading 的结果.

因此其表示的意义就是, 我们计算每个点的 shading，然后去乘这个点的 visibality 得到的就是最后的渲染结果。

这也就是 shadow mapping 的基本思想。

**那么什么时候这个约等式比较正确呢？**

1. 我们要控制积分域足够小，也就是说我们只有一个点光源或者方向光源。环境光不行。

2. 我们要保证 shading 部分在积分域内变化不大，也就是说 brdf 的部分变化足够小，那么这个 brdf 部分是 diffuse 的。gloss  brdf 不行。

3. 我们还要保证光源各处的 radience 变化也不大，类似于一个面光源。
## 3、Unity 中的屏幕空间阴影映射
### 步骤
1.  渲染屏幕空间的深度贴图
2.  从光源方向渲染出 shadowmap
3.  **在屏幕空间**做一次阴影收集计算（Shadows Collector，将前两步生成的图做深度比较），
		a.  **这次计算会得到一张屏幕空间的 shadowmap（Collect Shadows）**
		b.  //实际上就是对前两步的深度图做一个比较，得到一张新的深度图
4.  在绘制物体时，用物体的**屏幕坐标 uv**采样第三步中生成的屏幕空间 shadowmap

从 FrameDebugger 查看过程
![[Pasted image 20221209151539.png]]
![[Pasted image 20221209151553.png]]
# 二、阴影映射的问题与优化
## 1 自阴影/自遮挡/阴影粉刺
### 自阴影 self-shadowing：
自阴影/自遮挡也被称为**阴影粉刺（Surface Acne）

![[6ead296a05b80777473845429dcbbef8_MD5.png]] ![[6368ed87749ac4a26550234e84ff7c15_MD5.png]]
- 地板上的东西会感觉像摩尔纹, 但并不是**它是由数值精度造成的一种现象。**
- 因为 shadowmapping 的分辨率有限，离散的采样点以及数值上的偏差可能造成不正确的自遮挡效果


 **出现自阴影的原因：**
-   如下图所示，在映射 shadowmap 的过程中，用表面上**点的 uv**采样阴影映射的深度值都是一个值（shadowmap 的一格代表的是一个纹素，在这一格里面采样阴影映射得到的值都是一样的）
- 例如：红点和蓝点采样后得到的深度值都是一样的，这一段所有点采样得到的深度值都和红线（代表深度值）相等。
![[Pasted image 20221209153218.png]]
当比较深度时，为了避免表面自阴影，需要设置容错阈值：
- 深度偏移（Depth Bias），增加深度偏移会使该像素向光源靠近
- 法线偏移（Normal Bias），沿着表面法线方向向外偏移
- 偏移单位是 shadowmap 的纹素

**深度偏移会造成的问题（Peter Panning）**
-   当 Bias 设置过大时，会导致漏光现象，即阴影与投影者之间发生脱节：也叫做**Peter panning 问题（学术界叫作 detached shadow）**
>Peter Panning 名称的由来：Peter 是西方漫画中的人物，他和影子是可以分开的
![[Pasted image 20221209152205.png]]

GAMES202 提到了一个解决方案:**Second-depth shadow mapping**，实际中并没有人去使用这个技术, 因为场景内的物体必须都是 watertight（非面片），还有就是开销太大。

简单介绍下原理：
舍弃 biasd 的概念, 在**渲染时不仅存最小的深度, 我们还要存第二小的深度, 然后我们用最小深度和第二小深度中间的深度来作比较：**

![[530dda48b31bab142f1bec8a0ad4f2d6_MD5.png]]

假设一根光线照过来, 我们不用最小深度来比较, 而是用由最小和第二小深度所得到的红色线来做后续的阴影, 此处就没有 Bias 的事情了.



### GAMES101 补充理解
![[Pasted image 20221209152350.png]]
-   从 light 往场景看（左边太阳的线）时，比如沿着某一个像素往过看，看到的位置（红色斜线）就是像素所代表的深度，（假设任何一个像素是一个常值的深度）。也就是说，在 shadowmap 看来，场景离散成了图中红色斜线形成的结果。
-   第二个 pass 渲染的时候，从 camera 出发（右边连着眼睛的蓝色虚线），常规操作：连向 light （左边蓝色虚线），这段虚线长度就是它的深度
-   **问题**：在 shadowmap 记录的对应的深度是橙色的部分（更浅），而实际上从相机看向这个像素，它的深度应该是被橙色部分遮挡住的点（两条蓝色虚线的交点）→这就是自遮挡情况
-   **特殊情况**：
    -   光垂直的，从上往下照时候，不存在问题
    -   光非常偏的时候，问题最大（例如：塞尔达中夕阳西下时）
    -   不难理解，斜着的时候就完全被挡住了，垂直的时候就不会被遮挡，图已经画的很清楚了

**如何解决这个问题：**
![[Pasted image 20221209153545.png]]
-   加上一个 Bias 避免自遮挡（图中橙色那段）
	- **具体方式就是当一个点深度大于记录深度的值超过一个阈值时，我们才认为这个点在阴影内**
	-   认为 shadowmap 上的深度，明显比实际的深度小的情况下，橙色的这一段障碍物就不算了。
	-   bias 可以不是一个常数，可调整，如果垂直打光，可以非常小，夹角很大的情况，可以更长一点。

**投影后的 Z 值**
关于深度, 我们在 101 中讨论过一个问题, 在做透视投影时, 我们是将透视投影挤压成正交投影, 然后再拍平, 在这个过程中中间的点是会向近平面移动还是向远平面移动?

答案是中间的所有点会被推向远平面.
[[02 视图变换#思考：挤压后 z 值为(n+f)/2的点会挤向 n 还是 f]]

所以, 在经过投影之后得到的 Z 其实不是实际上几何上的点到 Light 的距离, 因此在真正生成阴影时比较两个 pass 中的 depth 时需要一致。也就是要么都用**投影后的 Z 值**比较, 要么通过**两点的位置得一向量算实际距离**.
### Unity 中实现自阴影的优化
-   思路：
-   在生成 shadowmap 时去做 Bias（偏移）
![[Pasted image 20221209153656.png]]
## 2 走样
### 走样问题
走样，最明显的表现就是锯齿，我们可以看下边的例图

![[Pasted image 20221209153803.png]]

**在什么阶段会走样？**
初始采样：渲染 shadowmap 时
重采样：从相机位置对 shadowmap 进行重采样时

**初始采样阶段**
最严重的问题：**透视走样**
![[Pasted image 20221209162811.png]]
**透视走样是如何形成的？**
- shadowmap 在世界空间均匀分配（左图的三段纹素对应的世界空间的一个像素大小是一样的）
-   **经过透视投影后**，根据近大远小的原理，原来大小不一样的近平面和远平面，在屏幕内占的像素便不一样了。（右图）
-   这时远平面对应在 shadowmap 中的纹素就比近平面大了
-   这种离相机近的部分走样的情况一般称为**透视误差**。

**如何解决**？
-   思路 1：
    -   因为我们在使用 shadowmap 时，相机是经过透视投影的，但生成 shadowmap 时并没有经过透视投影
    -   所以我们在生成 shadowmap 时就进行一次透视投影

-   思路 2：
    -   尽量减少近平面和远平面之间的像素差距
    -   Unity 中的**级联阴影映射**（投影走样最有效的解决方案）就是用的这个思路
![[Pasted image 20221209163324.png]]

# 级联阴影映射
(Cascaded Shadow Map)
- 投影走样最有效的解决方案
- 把视锥体分割为多个子视锥体；
- 为每个子视锥体计算独立的相等大小的阴影映射；
-  就是给 shadowmap 不同位置不同的分辨率
# 重采样误差
-   shadowmap 可以理解为一张动态生成的纹理
-   重采样误差的解决方法：**滤波（Filter）**
 ![[Pasted image 20221209163546.png]]
-   滤波：在图像处理中，通过滤波强调一些特征或者去除图像中一些不需要的部分 (高斯模糊就是一种滤波方式)
-   滤波是一个**领域操作算子**，利用给定像素周围的像素的值决定该像素的最终输出值

-   **补充**：
-   滤波就是抹掉特殊频率的东西
-   高通滤波 = 边界
-   低通滤波 = 模糊
-   //滤波（Filtering）=卷积（Convolution）=平均（Averaging）

-   **阴影滤波**：
-   使用一部分 shadowmap 采样点来计算某个指定 View 采样点的最终阴影结果的方法

# 软阴影和硬阴影
**软硬阴影的区别**：硬阴影没有一个明显的从有阴影到没有的过度/界限（因为绝大多数的生活中的光源是面光源）
![[Pasted image 20221209164343.png]]
![[Pasted image 20230622213757.png]]
Umbra：本影区（影子中光源完全照射不到的部分）
Penumbra ：半影区（黑暗与光明之间的），半影区的影子比较软。

ShadowMapping 只能实现硬阴影
软阴影方案：PCF/pCsS、

后文中提到的 Filter Size 即滤波核大小，在这里也可以称为半影区大小

# PCF 百分比渐进过滤
## 原理
Percentage Closer filtering **百分比渐进过滤**
PCF 的初衷是为了抗锯齿, 反走样，后来发现可以用在软阴影上。

![[Pasted image 20221209163837.png]]

PCF 中，不是取 shadowmap 上一个点的深度去比较，而是取 shadowmap 上任意一个点的周围一个 Filter 大小的区域（滤波核），将**这个区域的所有点都去做一次**深度比较（0 或 1 的结果），最后再对这些结果做一个平均（不是非 0 即 1 的结果，而是一个权重值/像素的颜色值）

**Filter Size 滤波核大小**
-   可以是规则滤波，3x3 或者 5x5 等
-   也可以采用**泊松滤波（Poisson DIsk）** 的形式来分布一定数量的采样点 ![[Pasted image 20221209164052.png]]

**Filter Size重要吗？**
-   如果小（比如 1×1 = 没做 Filter），结果是锐利（sharpener）对应硬阴影
-   如果大，结果是 softer，对应软阴影
-   既然 Filter 的大小可以决定阴影的软硬，我们不妨这样理解：
-   软阴影 = 硬阴影做一个非常大的 Filter

## 注意事项
1.  PCF 不是直接在最后生成的阴影上进行 filtering。
   如下图，可以发现没有解决走样的问题。就跟我们在反走样时一样, 我们不能先得到一个走样的结果再去做在这个走样的结果上进行模糊。
![[2586f23c8f8f35667133cf9c8c941265_MD5.jpg|500]]

2.  也不是对 shadow map 进行 filtering
如果直接在 shadow map 上 filtering 就会造成阴影和物体交界直接糊起来，而且在第二个 pass 上做深度测试还是非 0 即 1 的结果, 最后得到的仍然是硬阴影。

我们之前在做点是否在阴影中时, 把 shading point 连向 light 然后跟 Shadow map 对应的这一点深度比较判断是否在阴影内, 之前我们是做一次比较, 这里的区别是, **对于这个 shading point 我们仍要判断是否在阴影内, 但是我们把其投影到 light 之后不再只找其对应的单个像素, 而是找其周围一圈的像素, 把周围像素深度比较的结果加起来平均一下，就得到一个 0-1 之间的数，就得到了一个模糊的结果。**  
![[Pasted image 20230622214840.png]]

如图, 蓝点是本来应该找的单个像素, 现在我们对其周围 3 * 3 个像素的范围进行比较, 由于是在 Shadow map 上, 因此每个像素都代表一个深度, 我们让在 shadow map 上范围内的每个像素都与 shading point 的实际深度进行一下比较, 如果 shadow map 上范围内的像素深度小于 shading point 的实际深度, 则输出 1, 否则输出 0.

从而得到 9 个非 0 即 1 的值:

最终我们用得到的加权平均值 0.667 作为 shading point 的可见性。在计算阴影的时候我们就拿这个作系数来绘制阴影。

## 现实世界的软硬阴影
![[Pasted image 20221209164914.png]]
我们发现阴影在笔尖的地方是硬的，远的地方就很虚（软），得出两个结论：
1. **遮挡物 Blocker 与阴影接受物 Reciever 的距离越小, 阴影越锐利.**
2. 要想做一个软阴影的效果，应该给硬阴影各个位置不同大小的 filter，这样就能做到符合现实世界的阴影效果。

**那么这个不同位置不同的 Filter Size怎么计算呢？**
PCSS 可以解决这个问题。
# PCSS 百分比渐进软阴影
Percentage Closer Soft Shadows 

> [!NOTE] PCF 和 PCSS 的区别
> - PCF 采用的 Filter 是固定的
> - PCSS 在不同位置使用了不同的 Filter

**PCSS 本质上就是求出了阴影中需要做 PCF 的半影部分后，再进行 PCF 的计算**。这样动态调节了半影范围，也就是动态设置了 PCF 的搜索范围，这样我们的硬阴影部分清晰，软阴影部分模糊，动态的实现了不错的软阴影效果。

> [!summary] PCSS 的步骤
> 
> 1.  计算**指定范围（即通过计算得到的范围 [[09 阴影#^2480r1]]）** 的 blocker 平均深度。
> 2.  通过 blocker 平均深度计算 filter size。
> 3.  有了 filter size 就可以按照 PCF 方式绘制软阴影。 ^rybveh

- ? **如何计算一个软阴影的不同位置不同的 Filter Size？**
**blocker distance** 即图中的 $d_{Blocker}$：遮挡物和光源的距离。这不是单个点的距离，更详细的说，是相对的平均的遮挡物深度

![[Pasted image 20221209165125.png]]
-   上方黄色线段表示 Light（光），中间绿色线段表示 Blocker（遮挡物），下边蓝色线段就是 Receiver（阴影的接收物）
-   我们可以看到左下和右上两个黄色虚线形成的三角是两个**相似三角形**。

如果我们将 Blocker 的位置移动一下, 比如越靠近 receiver, 我们会发现 $W_{Penumbra}$ 也就会越小。

用数学来表示半影区（$W_{Penumbra}$）, 由相似三角形 :

$$
\frac{W_{Light}}{W_{Penumbra}}=\frac{d_{Blocker}}{d_{Receiver}}
$$
即
$$
W_{Pemumbra}= W_{Light}\cdot \frac{d_{Receiver}}{d_{Blocker}}
$$

这里的 $d_{Recevier}$ 和 $W_{Light}$ 的大小我们是知道的，所以我们只需要拿到 blocker 的深度即可。

- ? **如何确定一个 blocker 距离面光源的位置   $d_{Blocker}$？**

**不能直接使用 shadow map 中对应单个点的深度来代表 blcoker 距离**, 因为如果该点的深度与周围点的深度差距较大（遮挡物的表面陡峭或者对应点正好有一个孔洞），将会产生一个错误的效果, 我们选择使用**平均遮挡距离**来代替，所以平常我们指的 blocker depth 其实是 **Average blocker depth**.

**blocker 上的每个点距离光源的距离是不同的，深度也是不一样的。这里我们采用取平均深度的方式来表示 blocker 的深度。**

- @ **求 blocker 距离的过程如下：**

1. **把观察空间下的目标 shading point 转换到 light space**，目的是获取 shading point 的深度
2. 找到 shading point 在 shadow map 上对应的像素。
3. 如果 shading point 的深度大于这个 shadow map 上点对应的深度, 则说明 shadow map 上的点就是一个 Blocker, 然后我们**取 shadow map 上这个点 (像素) 周围的一些像素**
4. 在周围像素张**找出能够挡住 shading point 的点的像素**, 并求出他们的**深度平均值**作为 blocker 的深度，得到了一个在 0 到 1 之间的软阴影效果。

这个方法关键点在于**取 shadow map 上这个点 (像素) 周围的一些像素**，我们需要确定取多少像素。  ^2480r1

一般我们有两种方法可以解决这个问题。
**第一种**，就是自己规定一个, 比如 4 * 4, 16 * 16, 比较简单但不实用.
**第二种**，shading point 连向 light，覆盖 shadowmap 的区域（红色区域），我们只在这个区域范围内找 blocker
![[Pasted image 20230622222325.png|500]]
![[17a5f4b8a24467710c615889bd174d97_MD5.jpg|500]]

我们计算 shadow map 的时候在光源处设置过相机，如图所示，我们把 shadow map 放在由相机看向场景形成的视锥中的近截面上, 然后 shading point 连向 light，**在 shadow map 上截出来的面就是要查询计算平均遮挡距离的部分**。这部分的深度求一个均值，就是 **Blocker 到光源的平均遮挡距离**。
# VSSM
Variance Soft Shadow mapping，针对性解决 PCSS 步骤 1 和步骤 2 较慢的问题。

回顾一下 PCSS 的步骤：
![[09 阴影#^rybveh]]

PCSS 中步骤 1 和步骤 3 需要对整个区域的各个 texels 的深度进行比较，所以会导致很慢。

如果觉得区域过大不想对每一个 texels 都进行比较, 就可以通过随机采样其中的 texels，而不是全部采样，会得到一个近似的结果, 近似的结果就可能会导致出现噪声。

工业的处理的方式就是**先稀疏采样进行PCSS得到的结果是有噪声的, 接着再在图像空间进行降噪。至于如何降噪在 real-time ray tracing 讲.**

由于需要在一个范围内进行比较，那么步骤 1 和 3 的时间开销会决定整个算法的时间开销，此外为了得到越 “软” 的阴影意味着需要使用更大的 filtering size，会导致速度越慢。**为了解决这两步慢的问题, 就有人提出了 Variance Soft Shadow Mapping。**

## 理解
PCSS 第三步我们使用 PCF 的方法绘制软阴影，我们要在 shadow map 上对其周围 Filter Size 内的像素的各个最小深度与 Shading point 比较，从而判断是否遮挡, 也就是要求出 Filter Size内有百分之多少的像素比它浅。


## 2. 怎么理解  

### ①：用 PCF 第三步说（think from percentage closer）  

*   在 shadowmap 上记录了一个区域内，把每一个点/texel 的深度拿到，来看有百分之多少的 texel 深度要比 shading point 浅。  
*   确定一个区域，直接去找有多少 texel 的深度比 shading point 小   
*   这听起来像另外一个问题：在一场考试中，你知道自己多少分，想知道自己在百分之几。  
    

*   前边的操作就像是把所有人的成绩都看一遍，来获取自己的排名  
*   VSSM 聪明的地方：不想所有人的成绩都看一遍，用了一个稍微不准但还不错的解决方案：  
![[dbb8bfbab32101195775c2191f7ad423_MD5.png|550]]  

*   如果知道成绩的直方图，并且画的也比较细，我就可以根据这个图自己所处的位置来得到答案  
    

*   更进一步：甚至直方图都不需要 ->把它当做正态分布  
    

*   也就是说，VSSM 的思路就是：  
    

*   想要研究一个大概范围内的排名在百分之多少，是不需要所有的成绩/精准的分布的（只需要近似的认为它是正态分布）  
    

*   所以只需要：均值/期望（决定峰值在哪）、方差（决定胖瘦）。  
    

VSSM 的 Key idea  

*   为了做第三步的 PCF, 我想知道这个深度在所有的深度中排百分之几，那就把所有深度的的平均和方差在某个区域内快速的拿到，那就立刻可以做这个计算了  
    

### ②先考虑均值  

*   MipMap  
    

*   给你一张 shadowmap（图），给你框一块区域出来，这块区域内的平均值是多少？ -> Mipmap（但不准、只能查找正方形区域）   
    

*   一个更精准的数据结构：SAT（Summed Area Tables）   
    

### ③再考虑方差  

*   给你一个区域，里边的方差如何知道？  
    

*   VSSM 用了一个超级经典的公式，它结合了期望和方差（一个随机变量的方差 = 它平方的期望 - 它期望的平方）：  
    

*   Var (X) = E (X2) − E2 (X)  
    

*   期望就是算均值，之前 shadowmap 里存的 depth，就是对应的 x ，给你一个区域，你可以立刻得到他们的平均值，这样一来，E2 (X)就搞定了  
    

*   E (X2)怎么办？ ->需要另外一张 shadowmap，里边记录的不是深度，而是深度的平方。这样一来，E (X2)也搞定  
    

*   //正常情况，深度只用一个通道。如果不考虑精度问题，在生成 shadowmap 时，可以直接在 texture 中的一个通道里，顺手生成深度的平方（“square-depth map”），根本不需要再用一张纹理  
    

//到此均值和方差就都解决了  

### ④回到问题上，我们是来干嘛的？  

*   是为了把这块分布近似成正态分布  
    

*   有了均值和方差，就有了正态分布  
    

*   再考虑：知道了深度的平均、方差、实际 x 的深度是多少，有百分之多少 texel 记录的深度要比我记录的深度小/大？  
    

*   这就是概率论说的 CDF（跳过这个概念）其实就是曲线下面的面积  
    

*   例如下图中，想要知道有百分之多少的值是小于 1 的，只需要统计标注出的面积即可  
    

*   ![[22228e86f3fa08fcd2029198cbaff6c7_MD5.png]]  
    

*   怎么算曲线下面的面积？  
    

*   对于通用的高斯的 PDF (比正态的更通用一些)，可以直接把积分的值打成一张表，积分出来的值叫作 error function（误差函数）  
    

*   积分没有解析解，能够有数值解，并且 C++还真有（erf）  
    

### ⑤VSSM 找到了一个不等式  

### （切比雪夫不等式）  

![[ca4d6ecedbf7626ccb7ad6ca14dcb322_MD5.png]] 
    

*   这个不等式可以告诉你，一个随机变量取的值超过某一个值的概率，又可以不需要知道这个随机变量所满足的具体是一个什么样的分布，只需要知道分布的期望和方差。  
    

*   也就是说我们都不用知道是正态分布还是其他什么分布，只需要知道方差和期望，就能告诉你：均值一定上图上箭头位置，方差一定在上图“<- - ->”的位置，  
    

*   这里没有考虑它实际的曲线是不是正态分布（对于任意分布），可以回答这样一个问题：  
    

*   如果真的给了一个 t，会立刻知道，从 t 开始，一直到曲线结束，曲线的面积不会超过 ![[e2c9e60434ca0586a95f530186e656b6_MD5.png]]  
    

*   =>告诉你从 t 开始面积的上界  
    

*   因为你在实时渲染中，我们不太关心不等，更关心近似相等（当做约等）  
    

*   所以是当做面积的一个不错的估计  
    

*   所以我们得到了以下结论：  
    

*   CDF 就=1-右边的面积  
    

*   //切比雪夫不等式有一个苛刻的条件：t 必须在均值的右边。（左边就不准了）  
    

## 3. 做一个简单总结  

如果想用 VSSM 提升 PCF 第三步的速度：  

*   需要生成 depth map 的同时，再多生成一张深度平方的图（用来解决 E (X2)）  
    

*   还要干什么？ =>接下来 Mipmap、sat 要说的（为了支持范围查询）  
    

*   这样，使用 shadowmap 时，将会非常的方便简单：  
    

*   ![[2d0b6ecd886a4eae3916cdbc049486ed_MD5.png]]  
    

*   给你任意一个 shading point、已经算好的数据（上边需要的 Depth、Depth2），再给你 shadowmap 上的某一个范围，立刻就能查到它的平均/均值（O (1)）  
    

*   Depth2 也是一张图（通道），同样范围取其平均，就得到了方差  
    

*   知道了均值、方差 = 知道了分布  
    

*   知道了分布之后，根据 shading point 真正的深度，就可以回答：在这个范围内，有百分之多少的 texel/fragment 挡住了它  
    

*   Visibility = 1 - 挡住的百分比  
    

*   //VSSM 让第三步不需要任何采样/循环，就能得到 Visibility  
    

### 理清 VSSM 和要解决的两个问题的关系  

VSSM 说到这里，要解决的是第三步。  

### 回过来解决 Step1 ：blocker search  

*   给你一个 shadow 上的一个区域，需要知道这个区域的平均的遮挡物的深度。  
    

*   ![[6e3224f7c8325eef917c82388fad56db_MD5.png]]  
    

*   非常慢、不高效  
    

*   注意：是遮挡物的平均深度，不是整个的平均深度（也就是说，是上图例子中蓝色数字的平均值）  
    

*   怎么解决？  
    

*   Key idea ：做一些定义：  
    

*   有一个遮挡物，它的 shading point 是 t，那么谁是遮挡物呢？ z<t 的就是  
    

*   遮挡物（z<t）（上例中蓝色深度），记为：avg. Zooc  
    

*   不是遮挡物（z>t）（上例中红色深度），记为：avg. Zunooc  
    

*   我们需要的是：蓝色部分深度的平均值 avg. Zooc  
    

*   他俩满足一个关系：  
    

*   ![[6cb1783228e58d33c3d988b2a4d83d7b_MD5.png]]  
    

*   Zavg 是在整个区域深度的平均值，我们早就知道了  
    

*   他们各自占比乘以平均深度相加 = 整个区域的深度平均值  
    

*   更重要的一点：  
    

*   对应到切比雪夫不等式上，N1/N = P (x>t)。  
    

*   知道了前一项，也就能推出了 N2/N = 1-P  
    

*   我们想要求 Zocc 的话，上述式子中只有一项需要我们知道了：Zunocc（非遮挡物的平均深度）  
    

*   再次近似！认为非遮挡物的深度和 shading point 的深度一样 => Zunocc = t  
    

*   到此就求出了 Zocc  
    

//到此，第一步也解决了  

#   

# 三、Mipmap 和 SAT （Summed Area Tables/Summed-Area Variance Shadow Maps）  

*   是为了解决 VSSM 中间的遗留问题：如何让记录了深度平方的 shadowmap 支持范围查询  
    

*   给你一个范围，你要快速的得到均值和方差 ->要快速的得到深度平均和深度的平方的平均  
    

*   先当成一回事，抽象出来：给你一张图，要问：这张图上的任何一块区域，这块区域如何快速的得到平均值。 （并且这块区域是矩形）  
    

## 1、最简单的：Mipmap。  

*   快速的、近似的、方形的范围查找，但是不准  
    

*   是不准的，涉及到插值  
    

## 2、SAT（Summed Area Tables）  

*   100%准确的方式  
    

*   是一种数据结构，和“前缀和”的算法紧密结合起来的  
    

*   求范围内的平均和求范围内总和，可以认为是一个概念（知道范围多大，元素个数）  
    

### 一维的情况下的范围查询：  

*   ![[f101a5f4ffc804b9f9785b77df6d4612_MD5.png]]  
    

*   做了一件事：预处理。对于一个数组，先花 O (n)的时间走一遍，走的时候就把对应的每一步的累加的和加上。  
    

*   精准定义：  
    

*   SAT 上任何一个元素它表示的都是原本一维数组从最左边的元素加到这个元素的和  
    

*   如何做查询？  
    

*   e.g，上边 3 7 1 这三个元素的和可以看做是前 6 个的和减去前 3 个的和  
    

*   前 6 项、前 3 项的和，刚刚的预处理都已经算了（上图的下半部分）  
    

*   那么 3 7 1 三元素的和就是 20-9=11  
    

### 二维情况下的范围查询：  

*   ![[3d5847f8e37a8e167b93c77fbc2d8d33_MD5.png]]  
    

*   蓝色的=绿色的-黄色的-黄色的+重复减的部分  
    

*   这些矩形的特点：起点都是左上角  
    

*   用刚才的思路：  
    

*   可以预计算一张表，这张表里的任何元素表示的都是从左上角加到这个元素，整个矩形的值  
    

*   这样就可以通过查 4 次（图中的 4 个白点），来精准的得到这个求和（蓝色方块）。  
    

*   二维情况下如何建立一张 SAT：  
    

*   每一行都是一个一维数组，这样每一行的一个点都表示这一行从左加到右加到当前这个点的值。  
    

*   每一列再做一遍。  
    

*   行与行之间是并行的 ->GPU 做会比较快，如果算法写的不好，还是会有点慢  
    

# 四、Moment shadow mapping  

*   VSSM 发明，是为了解决 PCSS 的问题，  
    

### 那么 VSMM 自己会不会有问题？  

*   ->有的，因为做了很多假设，当假设不对时，它当然就不对。  
    

*   e.g. ![[acc9eae04b7ca7a6f785267d988da2af_MD5.png]] 
    

*   如图，当时左图时，它足够复杂，所以可以当成正态/高斯分布；但情况相对简单时（右图），就不准确了  
    

*   描述的不准 ->算出来的百分比自然就不对 ->深度分布就会出错  
    

*   不准的情况  
    

*   Overly dark，过大->偏黑（阴影，偏黑也能忍）  
    

*   eg，本来实际有 30%的 texel 能够挡住当前 shading point，但是算出来的是 50%  
    

*   Overly bright，过小->变白（出问题了！）  
    

*   ![[5790d516c206560925f5046e721d2b26_MD5.png]] ![[eb177f2cfe20c1682ed2f4f9c5fddfb4_MD5.png]]  
    

### 导致的问题：-->局限性  

*   Light leaking（阴影的有些地方会变亮）  
    

*   non-planarity artifact (如果接受物不是一个平面，阴影会断)  
    

*   切比雪夫不等式同样会有问题：只适用于>t 的情况  
    

### 避免 VSSM 其中的一个问题：解决分布描述的不准。  

#### 方法：使用更高阶的 moments（矩）  

*   一个简单理解：记录一个数 x，记录多少次方，就是保留它的多少阶的 moments  
    

*   方法：记录多几阶 ->估计的就更准了  
    

*   原因太复杂，不讲  
    

*   结论：如果保留前 m 阶的矩，用这几阶的矩就可以表示一个函数（由一系列的阶越函数堆起来的函数），并且可以表示 m/2 个台阶  
    

*   ![[9ca3a977926b16d019bedef48eeb6f37_MD5.png]] 
    

*   可以理解为一种展开：保留前多少项的矩，就可以描述一个 2/m 台阶的函数  
    

*   正常情况下，4 阶矩就够了。  
    

*   不一定越多越好：存储代价要往上涨。  
    

*   给你前 4 阶矩，怎么得到这个有两个台阶的函数？ ->非常复杂！  
    

*   总结一下 Moment shadowmapping  
    

*   ![[8ed0cd1914f02cd07645255f0457573e_MD5.png]]
