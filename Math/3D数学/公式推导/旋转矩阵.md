
---
title: 旋转矩阵
aliases: []
tags: []
create_time: 2023-04-25 23:33
uid: 202304252333
banner: "![[camera_pitch_yaw_roll.png]]"
banner_y: 0.3975
banner_x: 0.414
---
# 旋转矩阵

> [!NOTE] 约定
> 列向量/右手坐标系


旋转矩阵的应用范围比较广，是姿态变换，坐标变换等的基础。本篇先介绍旋转矩阵的推导过程与助记方法。

旋转矩阵的旋转其实包含两种意思，一是在同一个坐标系下，**向量的旋转**；二是**坐标系的旋转**，使得同一向量在不同的坐标系下有不同的坐标。

首先讨论二维平面坐标下的旋转，然后引申至三维。

## 1.1 2D旋转

如下图，XY 坐标系中，向量 OP 旋转β角度到了 OP'的位置：

![](1672813754528.png)

根据三角函数关系，可以列出向量 OP 与 OP'的坐标表示形式：

对比上面个两个式子，将第 2 个式子展开：

![](1672813754601.png)

用矩阵形式重新表示为：

![](1672813754645.png)

这就是二维旋转的基本形式，中间的矩阵即二维旋转的**旋转矩阵**，坐标中的某一向量左乘该矩阵后，即得到这个向量旋转β角后的坐标。

## 1.2 3D旋转

三维旋转可借助二维旋转来理解，由于三维空间中可以任意轴旋转，为方便分析与使用，只考虑绕 X、Y、Z 轴的旋转。

*   **绕 Z 轴**

参照上面的图，添加一个 Z 轴，则上面的二维旋转实际上就是绕 Z 轴的三维旋转

![](1672813754694.png)

照搬上面的推导公式，并添加 Z 坐标的变换关系 (实际是没有变)，然后改写成矩阵形式，红色方框即为绕 Z 轴的旋转矩阵。

![](1672813754762.png)

*   **绕 Y 轴**

绕 Y 轴旋转同理，这里直接改变坐标轴的符号表示，**注意坐标顺序要符合右手系**，我这里用颜色区分了不同的轴。最终的矩阵形式要进一步改写成 XYZ 的顺序。红色方框即为绕 Y 轴的旋转矩阵。

![](1672813754808.png)

*   **绕 X 轴**

参照绕 Y 轴的推导，可以得到绕 X 轴的结果。红色方框即为绕 X 轴的旋转矩阵。

![](1672813754839.png)

![](1672813754873.png)

## 1.3 助记

对于单位矩阵，绕哪个轴旋转，哪一列不用变，然后将二维旋转矩阵替换对应的 4 个位置，注意，绕 Y 的旋转矩阵看起来与另外两个不同，它的 - sinβ是在左下！

![](1672813754907.png)

## 1.4 注意事项

*   **反向旋转**

如果是反向旋转一个角度，推导过程类似：

![](1672813754938.png)

最终得到的旋转矩阵其实是正向旋转矩阵的**逆矩阵**，由于这个矩阵是**正交阵**，所以逆矩阵就是**转置矩阵**。

![](1672813754971.png)

*   **书写形式**

上面的向量的坐标都是按照**列**的形式书写，如果是换成**行**的形式表示，则旋转的矩阵形式被转置了一下，同时矩阵在行向量的右边进行相乘。

![](1672813755002.png)
## 1.5  罗德里格斯公式
沿任意轴旋转：

![image-20220914230035451](image-20220914230035451.png) 代表任意旋转轴

![image-20220914230027175](image-20220914230027175.png)

P54
## 1.6  欧拉角

### 定义
 旋转是一个过程，一个物体围绕周或者点角度变化的过程。为了描述这个过程我们必须有参照物，于是我们先定义一个世界坐标系，笛卡尔坐标系。

![](1682481030052.png)

 欧拉角用 $(x, y, z)$ 分别来表示这个物体相对三个坐标系的夹角，这是由数学家欧拉首先提出而得名的。 

![](1682481030097.png)

 
 然而仅仅有 $(x, y, z)$ 来表示旋转是不够的，还有两个因素：
 
1.  首先是**旋转顺序**，从各个轴上进行角度旋转时 xyz 先后的不同会得到不同的结果。我们称这个顺序定义为**顺规**。
> [!quote] 顺规
在经典力学里，时常用 zxz 顺规来设定欧拉角；照着第二个转动轴的轴名，简称为 x 顺规。另外，还有别的欧拉角组。合法的欧拉角组中，唯一的限制是，任何两个连续的旋转，必须绕着不同的转动轴旋转。因此，一共有 12 种顺规。例如，y 顺规，第二个转动轴是 y - 轴，时常用在量子力学、核子物理学、粒子物理学。另外，还有一种顺规，xyz 顺规，是用在航空航天工程学；
>
按 (z-x-z, x-y-x, y-z-y, z-y-z, x-z-x, y-x-y) 轴序列旋转，即第一个旋转轴和最后一个旋转轴相同，我们称之为**经典欧拉角（Proper Euler Angle）**。 
>
>按 (x-y-z, y-z-x, z-x-y, x-z-y, z-y-x, y-x-z) 轴序列旋转，即三个不同的轴，我们称之为**泰特布莱恩角（Tait–Bryan angles）**。
 
 2. 其次是**旋转的参照坐标系**，欧拉角按旋转的坐标系分为：  
 **内旋（intrinsic rotation）：** 即按照物体本身的坐标系进行旋转，坐标系会跟随旋转与世界坐标系产生偏移。  
 **外旋（extrinsic rotation）：** 即根据世界坐标系进行旋转。  
 这是我们看看 Unity3d 中 Transform 的 Rotate，最后一个参数即坐标系： 

```c++
public void Rotate(Vector3 eulerAngles, Space relativeTo = Space.Self);
```

 注意：**Unity3d 使用的是 zxy 的顺规**，且进行一次欧拉旋转的 zxy 依次执行过程中，始终沿着初始的固定轴向在进行按 Z、X、Y 顺序的旋转。

### 推导

> [!info] 约定
> 这里使用了 OpenGL 采用的列向量/右手坐标系/ XYZ 顺规

**欧拉角 (Euler Angle)是可以表示 3D 空间中任何旋转的 3 个值**，由莱昂哈德·欧拉 (Leonhard Euler)在 18 世纪提出。
**一共有 3 种欧拉角：俯仰角 (Pitch)、偏航角 (Yaw)和滚转角 (Roll)**

![img](camera_pitch_yaw_roll.png)

- 俯仰角绕 x 轴旋转，是描述我们如何往上或往下看的角
- 偏航角绕 y 轴旋转，表示我们往左和往右看的程度。
- 滚转角绕 z 轴旋转，代表我们如何**翻滚**摄像机

**每个欧拉角都有一个值来表示，把三个角结合起来我们就能够计算 3D 空间中任何的旋转向量了。对于我们的摄像机系统来说，我们只关心俯仰角和偏航角**，所以我们不会讨论滚转角。

**给定一个俯仰角和偏航角，我们可以把它们转换为一个代表新的方向向量的 3D 向量。**

![img|300](camera_triangle.png)

如果我们把斜边边长定义为 $1$，我们就能知道邻边的长度是 $cos x$，它的对边是 $sin y$。这样我们获得了能够得到 $x$ 和 $y$ 方向长度的通用公式，它们取决于所给的角度。**欧拉角推导过程：**

我们需要得到向量 $\vec{a}(x,y,z)$ 
![[zip/images/Diagram 1.svg|529]]

已知俯仰角 $p$，偏航角 $y$ ，设 $\vec{a}$ 的值为 $1$
 
所以 $\vec{b}=sinp$， $\vec{c}=cosp$

$x=cosp*cosy$
$y=|b|=sinp$
$z=cosp*siny$

所以 $\vec{a}=(x,y,z)=(cosp*cosy,sinp,cosp*siny)$ 

### 万向节死锁（Gimbal Lock）
视频： [无伤理解欧拉角中的“万向死锁”现象](https://www.bilibili.com/video/BV1Nr4y1j7kn/?share_source=copy_web&vd_source=299c4f6627c111293ca308fd2699c4d2) 

为了解释原因，规定以下三个条件：
1. **旋转顺序**：xyz 顺规
2. **旋转的参照坐标系**：内旋，即按照物体本身的坐标系进行旋转
3. **平衡环架（Gimbal）规则**：旋转顺序靠前的轴可以带动后面的轴旋转，后面的轴不可以带动前面的轴旋转，例如：
    - 绕 x 旋转，那么 yz 轴也会跟着旋转
    - 绕 y 轴旋转，x 轴不动，z 轴跟着旋转
    - 绕 z 轴旋转，那么 xy 轴不会跟着旋转

初始状态：
![[Pasted image 20230426141259.png]]

绕 y 轴旋转 90 度：x 轴和 z 轴重合
![[Pasted image 20230426141332.png]]

此时旋转 x 轴和 z 轴效果相同，三个旋转轴相当于变成了两个，物体丢失了一个自由度，此时发生了万向节死锁。（顺规中间的轴只要是 90 度就会发生死锁）

**为什么后面的轴不可以带动前面的轴旋转？平衡环架是因为其机械结构导致，那么欧拉角为什么要使用这么奇怪的设定？**
实际上这不是一个设定，只是凑巧和平衡环架的物理表现相同。实际上因为是算法本就是这样实现的，每次变换都是从物体的初始状态按顺规 xyz 开始变换。自然后面的计算不会影响前面，换句话说，必须从前开始，所谓的后面轴带动前面轴这种情况根本不会出现。

万向节死锁无法避免，游戏开发中可以根据需要将最不可能发生 90 度旋转的轴放在顺规的中间次序。四元数可以解决这一问题

## 1.7 四元数
# 欧拉角、四元数、旋转矩阵、轴角之间的转换
$Ref:$[三维旋转：欧拉角、四元数、旋转矩阵、轴角之间的转换](https://zhuanlan.zhihu.com/p/45404840)

> [!NOTE] 约定
> 列向量/右手坐标系/采用 DX 的 ZXY 顺规

![](1682480296032.png)

## **1 欧拉角 (Euler Angle) 与旋转矩阵(Rotation Matrix)**

### 1.1 欧拉角 ----> 旋转矩阵

D3D 和 OpenGL 不同，用的坐标系是 Y 轴竖直向上的左手系，所以欧拉角的顺规是跟广大 blog、OpenGL 不一样的，那么博客上、甚至维基百科 [2] 上的各种基于右手系 xyz 顺规 (分别对应 roll, pitch,yaw) 的看起来就不太能随随便便直接用了。

DirectXMath 库采用的是 **ZXY 顺规**，分别对应着 Z-Roll，X-Pitch，Y-Yaw。
**注意：那么下文我们都采用 ZXY 顺规来推导公式！采用列主向量 (column major)！(但是注意 DirectXMath API 生成的矩阵其实是行主向量(row major) 的)

![](1682480296105.png)

**欧拉角旋转矩阵：**

$\begin{aligned} R(\alpha,\beta,\gamma) &=R_y (\alpha) R_x (\beta) R_z (\gamma) \\ &= \left[\begin{matrix} cos\alpha & 0 & sin\alpha \\ 0 & 1 & 0 \\ -sin\alpha & 0 & cos\alpha \end{matrix}\right] \left[\begin{matrix} 1 & 0 & 0 \\ 0 & cos\beta & -sin\beta \\ 0 & sin\beta & cos\beta \end{matrix}\right] \left[\begin{matrix} cos\gamma & -sin\gamma & 0 \\ sin\gamma & cos\gamma & 0 \\ 0 & 0 & 1 \end{matrix}\right] \\ &= \left[\begin{matrix} c_1 & 0 & s_1 \\ 0 & 1 & 0 \\ -s_1 & 0 & c_1 \end{matrix}\right] \left[\begin{matrix} 1 & 0 & 0 \\ 0 & c_2 & -s_2 \\ 0 & s_2 & c_2 \end{matrix}\right] \left[\begin{matrix} c_3 & -s_3 & 0 \\ s_3 & c_3 & 0 \\ 0 & 0 & 1 \end{matrix}\right] \\ &= \left[\begin{matrix} c_1 & s_1s_2 & s_1c_2 \\ 0 & c_2 & -s_2 \\ -s_1 & c_1s_2 & c_1c_2 \end{matrix}\right] \left[\begin{matrix} c_3 & -s_3 & 0 \\ s_3 & c_3 & 0 \\ 0 & 0 & 1 \end{matrix}\right] \\ &= \left[\begin{matrix} c_1c_3+s_1s_2s_3 & c_3s_1s_2-c_1s_3 & c_2s_1 \\ c_2s_3 & c_2c_3 & -s_2 \\ c_1s_2s_3-s_1c_3 & s_1s_3+c_1c_3s_2 & c_1c_2 \end{matrix}\right] \\ \end{aligned}$

其中：

$c_1=cos(\alpha)=cos(Y_{yaw}), s_1=sin\alpha=sin(Y_{yaw})$
$c_2=cos(\beta)=cos(X_{pitch}), s_2=sin\beta=sin(X_{pitch})$
$c_3=cos(\gamma)=cos(Z_{roll}), s_3=sin\gamma=sin(Z_{roll})$

上面的矩阵之所以是这么个顺序，是因为：

1.  采用了 ZXY 顺规
2.  采用列主向量
3.  采用外旋的约定

在这规定下，上面的矩阵就是先 roll Z，再 pitch X，再 yaw Y。

所有顺规对应的旋转矩阵
![](1682480296139.png)

.

### **1.2 旋转矩阵 ----> 欧拉角**

参考一篇 NASA 的关于姿态描述的技术报告 [1] 的 Appendix-A6 和[5]，我们可以用**旋转矩阵元素的相乘、相除、反三角函数等操作去 “凑” 出欧拉角**。[5]给出了从 XYZ 顺规提取欧拉角的方法、步骤、思路，[1]则给出了全部 12 种顺规的欧拉角提取公式，但是没有给一些细节注意事项。所以总结一下，根据 [1]、[5]、[7]《Real Time Rendering 3rd Edition》4.2.2 和自己的推导，从 ZXY 顺规旋转矩阵提取欧拉角的公式是（[1] 原文下标似乎有点小问题）：

*   Y axis yaw angle:

$\alpha=atan2(sin\alpha cos\beta,cos\alpha cos\beta)=atan2(m_{13},m_{33})$

*   X axis pitch angle:

$\beta=arcsin(sin\beta)=arcsin(-m_{23})$

*   Z axis roll angle:

$\gamma=atan2(cos\beta sin\gamma,cos\beta cos\gamma)=atan2(m_{21},m_{22})$

.

注意到一点，注意到矩阵的每一个元素都是 pitch angle $\beta$ 的函数… 所以当 $m_{23}=-sin\beta=\pm1$ 即 $cos\beta=0$ 的时候，这时候其他的欧拉角提取表达式就凉凉了（分子分母都是 0, arctan 和 atan2 都没有意义了）…. 其实 pitch angle $\beta=\pm \pi/2$ 恰好就是 Gimbal Lock 的位置。在 Gimbal Lock 的时候，旋转矩阵会退化为：

$\begin{aligned} R(\alpha,\beta,\gamma)&= \left[ \begin{matrix} c_1c_3\pm s_1s_3 & \pm c_3s_1-c_1s_3 & 0 \\ 0 & 0 & \pm 1 \\ \pm c_1s_3-s_1c_3 & s_1s_3 \pm c_1c_3 & 0 \end{matrix}\right]\\ &=\left[ \begin{matrix} cos(\alpha \pm \gamma) & sin(\alpha \pm \gamma) & 0 \\ 0 & 0 & \pm 1 \\ -sin(\alpha \pm \gamma) & -cos(\alpha \pm \gamma) & 0 \end{matrix}\right] \end{aligned}$

.

那么要进一步处理万向节死锁的 corner case 就需要分两种情况：

*   $\beta=-\pi/2$ ，此时  $sin\beta=-1, cos\beta=0$

$\begin{aligned} R(\alpha,\beta,\gamma)&= \left[ \begin{matrix} c_1c_3- s_1s_3 & -c_3s_1-c_1s_3 & 0 \\ 0 & 0 & \pm 1 \\ - c_1s_3-s_1c_3 & s_1s_3 - c_1c_3 & 0 \end{matrix}\right]\\ &=\left[ \begin{matrix} cos(\alpha + \gamma) & -sin(\alpha + \gamma) & 0 \\ 0 & 0 & 1 \\ -sin(\alpha + \gamma) & -cos(\alpha + \gamma) & 0 \end{matrix}\right] \end{aligned}$

$\Rightarrow \alpha+\gamma =atan2(-m_{12},m_{11})$

其中要给$\alpha$ 或者 $\gamma$ 其中一个欧拉角赋值，另外一个就按等式计算出来。

.

*   $\beta=\pi/2$ ，此时  $sin\beta=1, cos\beta=0$

$\begin{aligned} R(\alpha,\beta,\gamma)&= \left[ \begin{matrix} c_1c_3+ s_1s_3 & c_3s_1-c_1s_3 & 0 \\ 0 & 0 & -1 \\ c_1s_3-s_1c_3 & s_1s_3 + c_1c_3 & 0 \end{matrix}\right]\\ &=\left[ \begin{matrix} cos(\alpha - \gamma) & sin(\alpha - \gamma) & 0 \\ 0 & 0 & -1 \\ -sin(\alpha - \gamma) & cos(\alpha - \gamma) & 0 \end{matrix}\right] \end{aligned}$

$\Rightarrow \alpha - \gamma =atan2(m_{12},m_{11})$

同样的，要给$\alpha$ 或者 $\gamma$ 其中一个欧拉角赋值，另外一个就按等式计算出来。

.

从旋转矩阵提取欧拉角的公式跟欧拉角顺规的选取有关，因为旋转矩阵的元素会略有不同，但是思路都是一样的，就是**根据旋转矩阵的解析表达式 + 反三角函数凑出来** 23333。

## **2 四元数 (Quaternion) 与旋转矩阵**

**2.1 四元数 ----> 旋转矩阵**

众所周知的是，欧拉旋转是有万向节死锁 (Gimbal Lock) 的问题的。幸好我们有四元数 (Quaternion) 这种数学工具可以避免这个情况。一般来说，我们都会用单位四元数 $\textbf q=w+x \textbf i+y \textbf j+z \textbf k$ 来表示旋转，其中 $||\textbf q||=x^2+y^2+z^2+w^2=1$ 。那么给定一个单位四元数，可以构造旋转矩阵 (column major)[1][4][8][14][15]：

$\begin{aligned} R(q)&= \left[ \begin{matrix} 1-2y^2-2z^2 & 2xy-2zw & 2xz+2yw \\ 2xy+2zw & 1-2x^2-2z^2 & 2yz-2xw\\ 2xz-2yw & 2yz+2xw & 1-2x^2-2y^2 \end{matrix}\right]\\ \end{aligned}$

这个四元数构造的大概思路就是把**四元数的旋转操作写成矩阵形式**（注：给定一个用于旋转的单位四元数 $\textbf q=w+x \textbf i+y \textbf j+z \textbf k$ 和被旋转的三维向量 $\textbf v$ ，那么要直接用四元数旋转这个向量，则我们首先要构造一个纯四元数 $\textbf p=(\textbf v, 0)$ ，设旋转后的向量为 $\textbf v'$ ，旋转后的向量构造的纯四元数为 $\textbf p'=(\textbf v', 0)$ ，那么 $\textbf p'= \textbf q \textbf p \textbf q^-1$ ）。因为是用四元数来构造矩阵的，所以这个矩阵构造公式就没有欧拉角顺规的说法了。

.

**2.2 旋转矩阵 ----> 四元数**

那第一步肯定是判断 3x3 矩阵是一个正交矩阵啦（满足 $RR^T=R^TR=I$ ）。那么如果这个矩阵已经是一个合法的旋转矩阵了，要从旋转矩阵里提取四元数，也是可以像提取欧拉角那样，**用参数化过的矩阵的表达式凑出来**。参考 [8]《Real Time Rendering 3rd edition》Chapter4 的思路，我们观察一下用四元数分量进行参数化的矩阵 $R(q)$ ，然后经过一顿操作，我们发现：

$m_{32}-m_{23}=(2yz+2xw)-(2yz-2xw)=4xw\\ m_{13}-m_{31}=(2xz+2yw)-(2xz-2yw)=4yw\\ m_{21}-m_{12}=(2xy+2zw)-(2xy-2zw)=4zw$

于是我们再凑出个实分量 $w$ ，就可以把四元数四个分量都用矩阵元素表示出来了。于是我们又机智地发现了一个等式：

$\begin{aligned} tr(R(q))&=m_{11}+m_{22}+m_{33}\\ &=3-4(x^2+y^2+z^2)\\ &=4(1-(x^2+y^2+z^2))-1\\ &=4w^2-1 \end{aligned}$

其中 $tr(M)$ 是矩阵 $M$ 的迹 (trace)，也就是矩阵对角元素的和。因为这里用的是 3x3 矩阵，跟其他资料里面的表示有一点不同。所以我们可以把四元数的四个分量都用矩阵元素凑出来了：

$$w=\frac{\sqrt{(tr(R)+1}}{2}\\ x=\frac{m_{32}-m_{23}}{4w}\\ y=\frac{m_{13}-m_{31}}{4w}\\ z=\frac{m_{21}-m_{12}}{4w}\\ $$

有一点《Real Time Rendering》提到的， $w$ 绝对值比较小的时候，可能会出现数值不稳定的情况，那么想要数值稳定的话就得用一种不用除法的方式来凑，在这不展开了，可以看一下 RTR 2333。

## **3 欧拉角与四元数**

**3.1 欧拉角 ----> 四元数**

首先提一下四元数的乘积：

$\textbf p=w_1+\textbf v_1=w_1+x_1 \textbf i + y_1 \textbf j + z_1 \textbf k \\ \textbf q=w_2+\textbf v_2=w_2+x_2 \textbf i + y_2 \textbf j + z_2 \textbf k$

$\begin{aligned} \Rightarrow \textbf p \textbf q &= w_1w_2 - \textbf v_1 \cdot \textbf v_2 + w_2 \textbf v_1+w_1\textbf v_2 + \textbf v_1\times \textbf v_2 \\ &= \left[\begin{matrix} x_1w_2+w_1x_2+y_1z_2-z_1y_2\\ y_1w_2+w_1y_2+z_1x_2-x_1z_2\\ z_1w_2 + w_1z_2 + x_1y_2-y_1x_2\\ w_1w_2-x_1x_2-y_1y_2-z_1z_2 \end{matrix}\right] \end{aligned}$

参考维基百科 [2] 的思路，欧拉角构造四元数，跟欧拉角构造旋转矩阵一样，就是**把三个基础旋转 Elemental Rotation 组合在一起。**

[Conversion between quaternions and Euler angles](https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Euler_Angles_to_Quaternion_Conversion)

那么用于旋转的四元数 $q(x,y,z,w)$ 的表达式是：

$\begin{aligned} q(\alpha,\beta,\gamma) &=q_y(\alpha)q_x(\beta)q_z(\gamma)\\ &=\left[ \begin{matrix} 0 \\sin\alpha/2\\0\\cos\alpha/2 \\ \end{matrix}\right] \left[ \begin{matrix} sin\beta/2 \\0\\0\\cos\beta/2 \\ \end{matrix}\right] \left[ \begin{matrix} 0 \\0\\sin\gamma/2\\cos\gamma/2 \\ \end{matrix}\right]\\ &=\left[ \begin{matrix} cos(\alpha/2)sin(\beta/2) \\sin(\alpha/2)cos(\beta/2)\\-sin(\alpha/2)sin(\beta/2)\\cos(\alpha/2)cos(\beta/2) \\ \end{matrix}\right] \left[ \begin{matrix} 0 \\0\\sin\gamma/2\\cos\gamma/2 \\ \end{matrix}\right] \\ &=\left[ \begin{matrix} cos(\alpha/2)sin(\beta/2)cos(\gamma/2)+sin(\alpha/2)cos(\beta/2)sin(\gamma/2) \\ sin(\alpha/2)cos(\beta/2)cos(\gamma/2)-cos(\alpha/2)sin(\beta/2)sin(\gamma/2)\\ -sin(\alpha/2)sin(\beta/2)cos(\gamma/2)+cos(\alpha/2)cos(\beta/2)sin(\gamma/2)\\ cos(\alpha/2)cos(\beta/2)cos(\gamma/2)+sin(\alpha/2)sin(\beta/2)sin(\gamma/2) \\ \end{matrix}\right] \end{aligned}$

这个我自己推导的结果跟 [1]NASA Technical Report 的 Appendix A 给出的结果对比过了

[https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19770019231.pdf](https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19770019231.pdf)

（[1] 中四元数记号是 $\textbf q=q_1+q_2 \textbf i + q_3 \textbf j + q_4 \textbf k$ ），看起来没什么问题。

.

**3.2 四元数 ----> 欧拉角**

本来我以为，从四元数提取欧拉角的思路可以跟旋转矩阵提取欧拉角类似，也是用四元数的元素运算和反三角函数凑出公式来。后来我发现这简直就是一个极其硬核的任务，展开之后每一项都是六次多项式，画面有一丢暴力且少儿不宜，直接强行凑的话画风大概是这样：

$\begin{aligned} xw&=(c_1s_2c_3+s_1c_2s_3)(c_1c_2c_3+s_1s_2s_3)\\ &=c_1^2c_2s_2c_3^2+c_1s_2s_2^2c_3s_3+c_1s_1c_2^2c_3s_3+s_1^2c_2s_2s_3^2 \end{aligned}\\ \begin{aligned} yz&=(s_1c_2c_3-c_1s_2s_3)(-s_1s_2c_3+c_1c_2s_3)\\ &=-s_1^2c_2s_2c_3^2+c_1s_1c_2^2c_3s_3+c_1s_1s_2^2c_3s_3-c_1^2c_2s_2s_3^2 \end{aligned}$

 $\Rightarrow 2(xw-yz)=2(c_1^2c_2s_2+s_1^2c_2s_2) =2c_2s_2 =sin\beta$

$\begin{aligned} \Rightarrow \beta = arcsin(2(xw-yz))=arcsin(-m_{23}) \end{aligned}$

这个结果跟欧拉角参数化的旋转矩阵的 $m_{23}=-sin\beta=2yz-2xw$ 的表达式是吻合的。但这还只是最好凑的那一个，惹不起惹不起。所以舒服的思路还是**四元数 --> 旋转矩阵 --> 欧拉角**，想一步到位的话，把四元数分量参数化的旋转矩阵、欧拉角参数化的旋转矩阵结合在一起，参考下旋转矩阵转欧拉角的方法，替换下元素就完事了。这里就不把公式展开了，因为四元数直接转欧拉角 跟 旋转矩阵转欧拉角一样，依旧是要处理 gimbal lock 的 corner case，还是那么麻烦，所以这里先鸽了 23333

## **4 轴 - 角 (Axis-Angle)**

**4.1 轴角 ----> 四元数**

轴 - 角 (Axis-Angle) 顾名思义就是绕某条单位轴旋转一定角度，从这个意义上看，它构造四元数是非常舒服的，毕竟直观的几何意义有一点点类似，绕单位轴 $\textbf u$ 旋转 $\theta$ 的四元数是：

$\textbf q(w,\textbf v)=(cos\frac{\theta}{2},\textbf usin\frac{\theta}{2})$

.

**4.2 轴角 ----> 旋转矩阵**

Axis Angle 转 Rotation Matrix 可以从 [9] 罗德里格斯旋转公式 Rodrigues Rotation Formula 开始推导。

[https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula](https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula)

[Rodrigues' rotation formula](https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula)

[Rodrigues' rotation formula](https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula)

设 $\textbf v$ 是我们要旋转的单位向量，旋转轴为 $\textbf k$ ， $\textbf v$ 绕 $\textbf k$ 旋转角度 $\theta$ ，那么旋转后的向量为：

$\textbf v_{rot}=\textbf vcos\theta+(\textbf k \times \textbf v)sin\theta + \textbf k (\textbf k \cdot \textbf v)(1-cos\theta)$

这个公式的推导思路是这样子的，我们先对向量 $\textbf v$ 进行正交分解，分解成投影到旋转轴 $\textbf k$ 的分量和垂直于 $\textbf k$ 的分量：

$\textbf v=\textbf v_\parallel+\textbf v_\bot$

其中：

$\textbf v_\parallel=(\textbf v \cdot \textbf k)\textbf k \\ \textbf v_\bot = - \textbf k \times(\textbf k \times \textbf v)$

![](1682480296265.png)

于是绕 $\textbf k$ 旋转向量 $\textbf v$ 其实就是把上面**正交投影后的向量分别旋转之后再加起来**。那么很明显的，投影到旋转轴上的部分 $\textbf v_\parallel$ 都跟旋转轴共享了，那么自然旋转之后的结果就没有变化了，于是我们只需要旋转和旋转轴垂直的部分 $\textbf v_\bot$ 。那么这个 $\textbf v_\bot$ 旋转后的表达式就是：

 $\textbf v_{\bot -rotated}=cos\theta \textbf v_\bot +sin\theta \textbf k \times \textbf v$

然后我们不按 wikipedia 里面坑爹的、不考虑下文的变形，自己推一波：

$\begin{aligned} \textbf v_{rotated} &= \textbf v_{\bot-rotated}+\textbf v_{\parallel-rotated}\\ &=cos\theta \textbf v_\bot + sin\theta\textbf k \times \textbf v+\textbf v_\parallel \\ &=-cos\theta\textbf k \times (\textbf k\times \textbf v)+sin\theta\textbf k \times \textbf v+(\textbf v- \textbf v_\bot)\\ &=-cos\theta\textbf k \times (\textbf k\times \textbf v)+sin\theta\textbf k \times \textbf v+(\textbf v- (-\textbf k\times(\textbf k\times \textbf v)))\\ &=\textbf v+(1-cos\theta)\textbf k \times (\textbf k \times \textbf v) +sin\theta \textbf k \times \textbf v \end{aligned}$

这里我们把旋转后向量的表达式**变形得只剩下叉积 (cross product)，去掉点积(dot product) 了**，这样子我们才可以把这个绕轴旋转的表达式写成矩阵形式。怎么写呢？首先叉积可以写成矩阵形式：

$\textbf M= \left[\begin{matrix} 0 & -k_z & k_y \\ k_z & 0 & -k_x \\ -k_y & k_x & 0 \\ \end{matrix}\right]\\ \textbf M\textbf v= \textbf k \times \textbf v$

[Cross product - Wikipedia](https://en.wikipedia.org/wiki/Cross_product#Conversion_to_matrix_multiplication)

于是罗德里格斯旋转公式的变换就可以写成矩阵形式：

$R(\textbf k,\theta)=\textbf I +sin\theta \textbf M+(1-cos\theta)\textbf M^2$

展开之后就是：

$R(\textbf k,\theta)=\left[ \begin{matrix} cos\theta + k_x^2(1-cos\theta) & -sin\theta k_z + (1-cos\theta)k_xk_y & sin\theta k_y+(1-cos\theta)k_xk_z\\ sin\theta k_z + (1-cos\theta)k_xk_y & cos\theta+k_y^2(1-cos\theta) & -sin\theta k_x +(1-cos\theta)k_yk_z \\ -sin\theta k_y + (1-cos\theta) k_xk_z & sin\theta k_x+(1-cos\theta)k_yk_z & cos\theta+ k_z^2(1-cos\theta) \end{matrix}\right]$
# 另一篇
[旋转的数学表达：欧拉角、轴向角、四元数与矩阵 - 游戏程序员刘宇 - 博客园 (cnblogs.com)](https://www.cnblogs.com/xiaohutu/p/10979936.html)



**欧拉角**


**四元数**

 这里先说一下基本原理：

 参考链接：https://www.3dgep.com/understanding-quaternions/

 译文：https://blog.csdn.net/lhs322/article/details/80066960

 四元数的概念是由爱尔兰数学家汉密尔顿发明的，他当时正和老婆一起前往爱尔兰皇家研究院，一边走一边想，路过一座桥时，他顿悟了公式，并立刻把它刻在桥上的石头上：

![](1682481030442.png)

 那么，为什么四元数能表示三维空间的旋转呢？首先学过高数我们都知道复数的定义以及几何意义，复数可以映射到复数平面上，并且对这复数乘以 i，得到的复数就相当于复数空间里旋转了 90 度。

 例如下图，p = 2 + i，乘以 i 后： q = pi = (2+i)*i = 2i + i*i = 2i - 1 = -1 + 2i。可以看出 q 逆时针旋转了 90 度。同理乘以 - i 即为正时针旋转 90 度。

![](1682481030483.png)

 此时将复数的虚部扩展为三个，并根据汉密尔顿的著名表达式以及推论

![](1682481030754.png)

![](1682481030800.png)

 四元数的定义可以用来表达笛卡尔坐标系的旋转，其中 i,j,k 分别代表笛卡尔坐标系里 xyz 三个轴的单位向量。这些表达式里 ij = k 是不是很眼熟？两个互相垂直的单位向量的叉乘等于垂直于两个向量的单位向量。

![](1682481030839.png)

 经过一系列的推导和运算（略），大家感兴趣可以看上面的链接，假设一个旋转的基准向量

![](1682481030867.png)

是（A,B,C)，角度是 θ （theta），那么表达这个旋转过程的四元数如下：　　

![](1682481030919.png)

 注意 ABC 本质上就是基准向量

![](1682481030981.png)

在 3 个笛卡尔轴上的分量，用来准确描述向量

![](1682481031019.png)

，上面的公式也就是

[

![](1682481031050.png)

](javascript:void(0); "复制代码")

```
四元数 q = [cos(θ/2), sin(θ/2)* v‘]; 
即：
w = cos(θ/2)    
x  = A * sin(θ/2)    
y  = B * sin(θ/2)    
z  = C * sin(θ/2)
```

[

![](1682481031238.png)

](javascript:void(0); "复制代码")

 假设有一个向量 v 要进行旋转，这个旋转描述为 q，那么结果是 v' = qvq-1， 如果要进行多次旋转，则表示为：

![](1682481031406.png)

 四元数的乘法是：

```
q1 * q2 =
(w1*w2 - x1*x2 - y1*y2 - z1*z2) +
(w1*x2 + x1*w2 + y1*z2 - z1*y2) i +
(w1*y2 - x1*z2 + y1*w2 + z1*x2) j +
(w1*z2 + x1*y2 - y1*x2 + z1*w2) k
```

 可以看到，通过一系列的数学推导和定义，可以只用 4 个浮点数就来表达一个旋转过程，并且可以方便简单的快速计算旋转的叠加。这对于游戏引擎来说是非常有意义的，可以加快运算速度。

 四元数还有很多具体的特性，计算规则等，感兴趣的可以去研究，本文主要讨论旋转，这里不再赘诉。 

 **【球形插值】**

 四元数还可以实现球形插值，制定两个旋转 qa 到 qb，时间间隔为 t，那么此刻的旋转插值为：

![](1682481031448.png)

 其中θ为两个旋转之间的夹角：

![](1682481031496.png)

 球面插值可以在游戏里实现很平滑的转向和球面运动。

**四元数与欧拉角之间的转换**

 已知欧拉角，求四元数：

![](1682481031532.png)

 已知四元素，求欧拉角

![](1682481031558.png)

**用矩阵来计算旋转**

 学过矩阵乘法我们都知道，如果把向量看成一个列矩阵，那么与向量维度相同的列数的矩阵乘以它，得到的结果也是一个列矩阵，即：

![](1682481031609.png)

 所以可以充分利用左边矩阵的内容，对右边的向量进行各种变换（包括平移，缩放，旋转等等），这里我们只讨论旋转。

 具体推导过程参考这里: https://www.cnblogs.com/xpvincent/archive/2013/02/15/2912836.html

 假设一个向量 V（Vx,Vy, Vz) 绕另外一个轴角（nx, ny, nz, θ）进行旋转，那么旋转结果 V'是：

![](1682481031656.png)

 这个公式我们称之为**罗德里格旋转公式 (Rodrigues' rotation formula)**，用矩阵计算旋转在游戏图形渲染里非常普遍，不过引擎里一般为了兼容更多的向量变换，都使用了其次矩阵，即多一个维度的矩阵，本文不表。

 **小结**

 总结完这几种在常见的表达旋转的数学方式，可以看到游戏引擎里也都使用到这些表达方法，感觉收益匪浅，后面准备讨论一下齐次矩阵和矩阵变换的原理。

