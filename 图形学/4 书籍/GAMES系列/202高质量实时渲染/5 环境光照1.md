主要内容：**如何不采样去计算不考虑shadow时的shading值**

# 距离场软阴影 Distance Field 
1. 比 shadowmap 快
2. 内存占用大
   
   

## 有向距离场 Signed Distance Function
Distance Function：对于任一点，给出**到最近的对象上的最小距离** (可以是带符号的距离，即有向距离场，物体内部为负，物体外部为正)

![[Pasted image 20230714104506.png]]

Blend移动的边界：
![[Pasted image 20230714111349.png]]

Blend 任意任意两个 SDF，得到一个新的 SDF
![[Pasted image 20230714111554.png]]
SDF 大多用在与几何之类的方向上, 比如我有两个物体的 SDF, 我们将两个 SDF 进行 Blend 操作, 从而得到一个新的 SDF, 也就得到了一个新的几何物体, 因为当距离 0 为实，即可认为是物体的边界，SDF 可以很准确地反应物体的边界。几何转换 SDF 的时候，可以很好地把几何进行过渡。


## SDF 的应用:

### Ray Marching

假设我们已经知道场景的 SDF, 现在有一根光线, 我们试图让光线和 SDF 所表示的隐含表面进行求交, 也就是我们要用 Ray Marching :进行求交.

![[Pasted image 20230714111756.png]]
任意一点的 SDF 一般会提前计算好, 因此在 $P_{0}$ 点时, 我们以它的 $SDF(P_0)$ 为半径做一个圆 (此处假设在 2D 内, 如果在 3D 内则是一个球), 在这个圆内无论是哪个方向前进, 只要不超过半径距离, 都不会碰见物体, 是安全的。

因此我们可以利用这个特性不断的朝一个方向前进, 以 $P_{0}$ 开始朝一方向走 $SDF(P_{0}$) 到达 $P_{1}$ 点, 若仍与物体表面相距甚远, 则以 $P_{1}$ 点为新起点继续走 $SDF(P_{1}$) 到达 $P_{2}$ 点, 假设此处 $P_{2}$ 点的 $SDF$ 足够小, 也就是代表离物体表面足够接近了, 则进行求交操作.

如果在超一方向 trace 非常远的距离但仍然什么都没 trace 到, 此时就可以舍弃这条光线, 也就是停止了.

### 生成软阴影

将安全距离的概念进行延伸，在任意一点通过 sdf 可以获得一个安全角度 safe angle（图中灰色部分）
![[Pasted image 20230714112418.png|500]]
我们取点 P 为 shading point 往一方向打出一根光线, 光线上的一点 a, 有一个 SDF 值 SDF(a), 也就是在 a 点以 SDF(a) 为半径所做的球或圆内是安全的, 不会碰到物体.

把 shading point 和**面光源**相连，所得到的安全角度越小，被遮蔽的可能越高，就可以认为
- **safe angle 越小，阴影越黑，越趋近于硬阴影;**
- **safe angle 够大就视为不被遮挡没有阴影, 也就越趋近于软阴影。**

- ? **如何从 ray marching 中求出 safe angle？**
![[Pasted image 20230714113316.png|450]]
我们以 $o$ 为起点, 沿一个方向推进, 仍然是 ray marhcing 的步骤, 在 $p1$ 点以 $SDF(p1)$ 进行推进, 其余点也是一样, 此处主要是为了求 safe angle,。
1. 我们在起点 $o$ 沿每个点的 $SDF$ 为半径所形成圆做切线, 从而求出各个点的 safe angle,
2. 取其中最小的角度作为 safe angle.


**那么我们该怎么去计算这个角度?**

从图我们可以知道, 以 $p1$ 点为例, 从 $o$ 点到 $p1$ 的距离为斜边, $sdf(p1)$是直角边, 因此我们用 $arcsin$ 就可以求出 safe angle 了.

但是 arcsin 的计算量其实是十分大的, 因此在 shader 中我们不用反三角函数。

![[3c38918b3e0d430d13b08fde55570656_MD5.jpg]]

只要 sdf 长度除以光线走过的距离乘一个 k 值，再限定到 1 以内，就能得到遮挡值或者说是 visibility，而 k 的大小是控制阴影的软硬程度.

![[bab1bcd3bd07de3c093c4b37b003f305_MD5.jpg]]

我们从图中右半部分可以看出来, 当 k 值越大时候, 就越接近硬阴影的效果, 也就是它限制了可能半影的区域:

k 越小, 半影区域越大, 越接近软阴影效果.

K 越大, 半影区域越小, 越接近硬阴影效果.

这个思想并不是去考虑一个 $\frac{安全角度}{面光源覆盖的总角度}$ 从而求出一个比值, 再用这个比值作为 visibility.

**而是求出 safe angle, 安全角度越大, 阴影越软; 安全角度越小, 阴影越硬.**

**Conclusion:**

SDF 是一个快速的高质量的软阴影生成方法 (比 shadow map 快是忽略了 SDF 生成的时间), 但是在存储上的消耗非常大，而且生成 SDF 的花的时间也要很久，SDF 是预计算，在有动态的物体的情况就得重新计算 SDF。

**Shading from environment lighting**

在环境光照下做一点的 shading 时是不用去考虑 shadow 的, 首先我们复习一下什么是环境光照:

在 games101 中我们知道, 环境贴图就是在场景中任意一点往四周看去可看到的光照, 将其记录在一张图上这就是环境光照, 或者也可以叫做 IBL(image-based lighing). 这里我们认为看到的光照来自于无限远处, 这也就是为什么用环境光照去渲染物体时会产生一种漂浮在空中的感觉, 因为光照来自于无限远处.

通常我们用 spherical map 和 cube map 来存储环境光照.

如果已知环境光照, 此时放置一个物体在场景中间, 在不考虑遮挡时我们该如何去得到任何一物体上任何一 shading part 的 shading 值呢?

首先要先来看 rendering equation:

![[926bdad6487dcf83d729957f4d52f39b_MD5.jpg]]

由于我们在这里不考虑遮挡, 所以舍去 visibility 项. 通用的解法是使用蒙特卡洛积分去解, 但是蒙特卡洛需要大量的样本才能让得出的结果足够接近, 如果我们对每个 shading point 都做一遍蒙特卡洛, 那样的话将会花费很多时间在采样上, 太慢了.

(ps: 一般来说 shader 中如果出来 Sampling 的话是不会用于 rtr 中的, 但是由于这几年技术的提升, 使得 sampling 在 rtr 中也有了可行性.)

![[24635319714cebefc2310e431e81d2a9_MD5.jpg]]

既然采样这么慢, 那么如果我们不进行采样呢?

**基本思路**

由于我们不考虑 visibility 项, 那么 rendering equation 就只是 brdf 项和 lighting 项相乘再积分。

**brdf 又分为两种情况:**

1.  brdf 为 glossy 时, 覆盖在球面上的范围很小, 也就是 small support(积分域).
2.  brdf 为 diffuse 时, 它会覆盖整个半球的区域, 但是是 smooth 的, 也就是值的变化不大, 就算加上 cos 也是相对平滑的.

![[9a29527cf25c481d36ee9da63316ddf8_MD5.jpg]]

此时应该想到了我们之前讲的近似公式:

![[e861cc576be436fb9a599719f77ee8ec_MD5.jpg]]

由于 brdf 项满足 accuary condition, 即 small support 或 smooth, 从而我们将 rendering equation 的 lighting 项拆出让他变为 :

![[45dee7c3dc8bb73c027e225847576c73_MD5.jpg]]

**The spilt sum: 1st stage**

把 light 项拆分出来, 然后将 brdf 范围内的 lighting 积分起来并进行 normalize, 其实就是将 IBL 这张图给模糊了.

模糊就是在任何一点上取周围一片范围求出范围内的平均值并将平均值写回这个点上, 主语滤波的核取多大取决于 BRDF 占多大, BRDF 的区域越大, 最后取得的图也就越模糊.

![[c9bf382c03e235b544147001dbc87491_MD5.jpg]]

而这些模糊过的图是我们在进行 rendering 之前生成的, 也就是 pre-filtering,Prefiltering 就是提前把滤波环境光生成，提前将不同卷积核的滤波核的环境光生成一系列模糊过的图（和 mipmap 相似），当我们需要时进行查询即可, 其他尺寸的图则可以经过这些已生成的通过三线性插值得到.

之前提过, 拆分就是为了做一个 Pre-filtering, 那么做 pre-filtering 是为了干什么?

![[a3689e8eedc6d0a17bc66fac37505420_MD5.jpg]]

左图为 brdf 求 shading point 值时, 我们要以一定立体角的范围内进行采样再加权平均从而求出 shading pointd 的值.

右图为我们从镜面反射方向望去在 pre-filtering 的图上进行查询, 由于图上任何一点都是周围范围内的加权平均值, 因此在镜面反射方向上进行一次查询就等价于左图的操作, 并且不需要采样, 速度更快.

**The spilt sum: 2nd stage**

到此我们解决了拆分后的前半部分积分采样的问题, 那么接下来我们处理 BRDF 项采样的问题:

![[4ee2a40a998a23168e390cb2d3392972_MD5.jpg]]

接下来讲的方法并不是最优方法, 现如今已经有更简单方便的方法了, 但是本课我们主要是为了学习方法背后的思想.

![[d732c617cf59e831f8be11c2172cd720_MD5.jpg]]

我们仍然可以用预计算来解决后半部分积分采样的问题, 但是预计算的话我们需要将参数的所有可能性均考虑进去, 但是比较多，包括 roughness、color 等。考虑所有参数的话我们需要打印出一张五维或者更高的表格, 这样会拥有爆炸的存储量, 因此我们需要想办法降低维度, 也就是减少参数量从而实现预计算.

![[f7a880cd20315186e67f6394fb1969d8_MD5.jpg]]

在 microfacet brdf 中中，考虑的是菲涅尔项、阴影项以及法线项，由于此时暂时不考虑阴影，此处需要关注的是 Fresnel term 和 distribution of normals。

![[f0f6a8efd002a3f75c2d1188055ba7ea_MD5.jpg]]

Frenel term 可以近似成一个基础反射率 R0 和入射角度的指数函数

法线发布函数（NDF）是一个一维的分布，其中有两个变量，一个变量定义是 diffuse 还是 gloosy，另一个 是 half vector 和法线中间的夹角，可以近似成入射角度相关的数，这样就变成了 3 维的预计算。

(PS: 在这里我们认为反射角, 入射角, half vector 可以用一个角 $\theta$ 代替).

至此我们有了三个变量: 基础反射率 r0,roughness $\alpha$ 和角度 $\theta$ , 三维的预计算仍然是一个存储量爆炸的结果, 因此我们还要想办法减少参数量.

所以我们通过将 Schlick 近似带入后半部分的积分中：

![[92bac7e0c09ae9868a36833f06712d65_MD5.jpg]]

基础反射 R0 被拆出积分式，需要预计算的两个量就只有 roughness $\alpha$ 和角度 $\theta$，可以将预计算结果绘制成一张纹理，在使用时进行查询即可。

![[89ab8044817bd3598a88a9bb973411aa_MD5.jpg]]

我们可以看到, 最后产生的结果是十分满意的:

![[af284f0e4f1c61b13a675710ddbff129_MD5.jpg]]

问题:

1.renel 需要预计算吗

frenel 项被拆开了，避免了对变量的依赖性

2 这张预计算是固定的吗？

是固定的。

3 Microfacet 在 ggx 中会多参数吗

不会

4. 深度学习在实时渲染中有什么应用吗

深度学习在实时渲染中并不成功，太慢了。