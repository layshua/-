---
banner: "![[Pasted image 20230101204819.png]]"
banner_y: 0.33
---
# 1 概念
DX12较之上个版本主要改变：性能优化方面大大减少了 CPU 开销，改进了对多线程的支持。性能提升！

通过 Direct3D 这种底层**图形应用程序编程接口（Application Programming Interface, API)**, 即可在在应用程序中对**图形处理器 (Graphics Processing Unit, GPU)** 进行控制和编程。我们能够借此以硬件加速的方式渲染出虚拟的 3D 场景。

**渲染目标（render target）** 是为了渲染场景而将像素绘制到的特定缓冲区 (buffer)。通常是占用部分显存的后台缓冲区，以及纹理（详见后文）。

**像素（pixl）**  是构成图像的基本元素。从图形角度来讲，可认为像素是一种图像的采样单位（将图像以像素为基础进行划分，再于像素中进行采样)。因此，两张同样大小的图片，分辨率高者，意味着像素数量越多，细节越丰富，画面就越清晰。由于实际显示上的原因（后面注释会提到)，也赋予了像素“大小”的概念。**在 Direct3D 中，像素被抽象为具有一定长宽的色块。**

**纹素 (texel)** ：构成纹理的基本元素又称纹素，**通常我们将纹素视为像素**。尽管后台缓冲区是一个纹理, 但我们仍常将其组成元素称为像素，因为就后台缓冲区这种情况而言，它所存储的内容是颜色信息。即便纹理中存储的不是颜色信息，大家有时也称纹理的元素为像素（如“法线图中的像素”)。**至于二者是否需要区分，具体还要看应用场景。** 比如谈到像素与纹素的映射关系时，必须将这两个概念予以区分。文中谈到的基本上是约定俗成的叫法。

**采样 ( sampling )**：又称取样，本是信号处理方面的术语。在本书中, 可认为该操作是以特定的模式，从连续的图像数据中采集出离散的关键颜色信息。

## 组件对象模型
**组件对象模型 (Component Object Model, COM)** 是一种令 DirectX 不受编程语言束缚，并且使之向后兼容的技术。
我们通常将 COM 对象视为一种接口，但考虑当前编程的目的，遂将它当作一个 C++类来使用。用 C++语言编写 DirectX 程序时，COM 帮我们隐藏了大量底层细节。

**不使用 C++的 new 和 delete**：
要获取指向某 COM 接口的指针，需借助特定函数或另一 COM 接口的方法一而不是用 C+语言中的关键字 new 去创建一个 COM 接口。
COM 对象会统计其引用次数；因此，在使用完某接口时，我们便应调用它的 Release 方法 (COM 接口的所有功能都是从 IUnknown 这个 COM 接口继承而来的，包括 Release 方法在内)，而不是用 delete 来别删除——当 COM 对象的引用计数为 0 时，它将自行释放自己所占用的内存。

为了**辅助用户管理 COM 对象的生命周期**，Windows 运行时库 (Windows Runtime Library, WRL)专门为此提供了 `Microsoft::WRL: ComPtr` 类 ( `#include <wrl.h>`), 我们可以把它当作是 **COM 对象的智能指针**。当一个 `ComPtr` 实例超出作用域范围时，它便会自动调用相应 COM 对象的 Release方法，继而省掉了我们手动调用的麻烦。本书中常用的 3 个 `ComPtr` 方法如下。
1. `Get`：返回一个指向此底层 COM 接口的指针。此方法常用于把原始的 COM 接口指针作为参数传递给函数。例如：
```c++ nums
ComPtr<ID3D12Rootsignature> mRootsignature;
......
//SetGraphicsRootsignature 需要获取 ID3D12 RootSignature*类型的参数
mCommandList->SetGraphicsRootsignature (mRootsignature.Get());
```

2. `GetAddressof`: 返回指向此底层 COM 接口指针的地址。凭此方法即可利用函数参数返回 COM接口的指针。例如：
```c++ nums
ComPtr<ID3D12CommandAllocator> mDirectCmdListAlloc;
ThrowIfFailed(md3dDevice->CreateCommandAllocator (
		D3D12 COMMAND LIST TYPE DIRECT,
		mDirectCmdListAlloc. GetAddressof ())
	);
```
3. `Reset` : 将此 ComPtr 实例设置为 nullptr 释放与之相关的所有引用（同时减少其底层 COM 接口的引用计数)。此方法的功能与将 ComPtr 目标实例赋值为 nullptr 的效果相同。

> [!NOTE] 
> COM 接口都以大写字母“I”作为开头。例如，表示命令列表的 COM 接口为  
> `ID3D12GraphicsCommandList`
> 
## 纹理格式
**2D 纹理（2D texture)** 是一种由数据元素构成的矩阵（可将此“矩阵”看作 2D 数组)。它的用途之一是存储 2D 图像数据，在这种情况下，纹理中每个元素存储的都是一个像素的颜色。
然而，纹理的用处并非仅此而已。例如，有种称作法线贴图 (normal mapping)的高级技术，其纹理内的每个元素存储的就是一个 3D 向量而不是颜色信息。因此，尽管纹理给人的第一印象通常是用来存储图像数据，但其实际用途却十分广泛。简单来讲，1D、2D、3D 纹理就相当于特定数据元素所构成 1D、2D、3D 数组。但随着后续章节中对纹理讨论的逐渐深入，我们便会知道，**纹理其实还不只是像“数据数组”那样简单。它们可能还具有多种 mipmap 层级，而 GPU 则会据此对它们进行特殊的处理**，例如运用过滤器（filter)和进行多重采样（multisample)。**另外，并不是任意类型的数据元素都能用于组成纹理，它只能存储 `DXGI FORMAT` 枚举类型中描述的特定格式的数据元素。** 下面是一些相关的格式示例：
1. `DXGI FORMAT R32G32B32 FLOAT`: 每个元素由 3 个 32 位浮点数分量构成。
2. `DXGI FORMAT R16G16B16A16 UNORM`: 每个元素由 4 个 16 位分量构成，每个分量都被映射到$[0,1]$区间。
3. `DXGI FORMAT R32G32UINT`: 每个元素由 2 个 32 位无符号整数分量构成。
4. `DXGI FORMAT R8G8B8A8 UNORM`: 每个元素由 4 个 8 位无符号分量构成，每个分量都被映射到$[0,1]$区间。
5. `DXGI FORMAT R8G8B8A8 SNORM`: 每个元素由 4 个 8 位有符号分量构成，每个分量都被映射到$[-1,1]$ 小区间。
6. `DXGI FORMAT R8G8B8A8SINT`: 每个元素由 4 个 8 位有符号整数分量构成，每个分量都被
映射到 $[-128,127]$ 区间。
7. `DXGI FORMAT R8G8B8A8UINT`: 每个元素由 4 个 8 位无符号整数分量构成，每个分量都被
映射到 $[0,255]$ 区间。

颜色都是由红、绿、蓝“**三基色**” (注意美术中的“三原色”是指红黄蓝！)组合而成（例如，红色和绿色混合成黄色)。alpha 通道（或称为 alpha 分量)则通常用于控制透明度。
然而，正如前文所述，尽管格式名称在字面上指示的是颜色和 lpha 值，但**纹理存储的却不一定是颜色信息**。例如，格式 `DXGI FORMAT R32G32B32 FLOAT` 中含有 3 个浮点数分量，因此可以利用坐标格式为浮点数的方式存储任意 3D 向量。除此之外，亦有**无类型 (typeless)格式的纹理，我们仅用它来预留内存**，待纹理被绑定到渲染流水线 (rendering pipeline, 详见第 5 章)之后，再具体解释它的数据类型（有点像 C++语言里的强制转换 2）。例如，下面的无类型格式保留的是由 4 个 16 位分量组成的元素，但并没有指出数据的具体类型（例如，是整数、浮点数还是无符号整数？）：`DXGI FORMAT R16G16B16A16 TYPELESS`
我们将在第 6 章中看到 `DXGI FORMAT` 枚举类型也可用于描述顶点以及索引的数据格式。

## 交换链和页面翻转
**为了避免动画中出现画面闪烁的现象，最好将动画帧完整地绘制在一种称为<mark style="background: #FF5582A6;"><mark style="background: #FF5582A6;">后台缓冲区</mark></mark>的<mark style="background: #FF5582A6;">离屏</mark>(off-screen, 即不可直接呈现在显示设备上之意)<mark style="background: #FF5582A6;">纹理</mark>内。** 只要将指定动画帧的整个场景绘到后台缓冲区中，它就会以一个完整的帧画面展现在屏幕上；依照此法，观者便不会察觉出帧的绘制过程一而只会观赏到完整的动画帧。为此，需要利用由硬件管理的两种纹理缓冲区：即所谓的**前台缓冲区 (front buffer)** 和**后台缓冲区 (back buffer)** 。
**前台缓冲区存储的是当前显示在屏幕上的图像数据，而动画的下一帧则被绘制在后台缓冲区里。**
当后台缓冲区中的动画帧绘制完成之后，两种缓冲区的角色互换：后台缓冲区变为前台缓冲区呈现新一帧的画面，而前台缓冲区则为了展示动画的下一帧转为后台缓冲区，等待填充数据。前后台缓冲的这种互换操作称为**呈现 (presenting, 亦有译作提交、显示等)**。呈现是一种高效的操作，只需交换指向当前前台缓冲区和后台缓冲区的两个指针即可实现。
![[Pasted image 20230406150703.png]]
>图 4.1 对于第 n 帧来讲，当前显示的是缓冲区 A 中的内容，我们将把下一帧的数据渲染到此时的后台缓冲区 B 内。一旦后台缓冲区绘制完毕，两个缓冲区的指针将互换，即缓冲区 B 将变成前台缓冲区，而缓冲区 A 则成为新的后台缓冲区。接下来，我们会把下一帧的内容渲染到缓冲区 A 中。待后台缓冲区（即此时的缓冲区 A)完成绘制，两个缓冲区的指针再次互换，即在第+2 帧中，缓冲区 A 重新成为前台缓冲区，缓冲区 B 则再次客串后台缓冲区

**前台缓冲区和后台缓冲区构成了<mark style="background: #FF5582A6;">交换链（swap chain)</mark>**, 在 Direct3D 中用 `IDXGISwapChain` 接口来表示。这个接口不仅存储了前台缓冲区和后台缓冲区两种纹理，而且还提供了修改缓冲区大小(`IDXGISwapChain::ResizeBuffers`)和呈现缓冲区内容 (`IDXGISwapChain::Present`)的方法。**使用两个缓冲区（前台和后台)的情况称为<mark style="background: #FF5582A6;">双缓冲</mark> (double buffering, 亦有译作双重缓冲、双倍缓冲等)。** 当然，也可以运用更多的缓冲区。例如，使用 3 个缓冲区就叫作三重缓冲（triple buffering, 亦有译作三倍缓冲等)。对于一般的应用来说，使用两个缓冲区就足够了。

> [!NOTE] 
> 尽管后台缓冲区是一个纹理（因而构成纹理的基本元素又称纹素，texel), 但我们仍常将其组成元素称为像素，因为就后台缓冲区这种情况而言，它所存储的内容是颜色信息。即便纹理中存储的不是颜色信息，大家有时也称纹理的元素为像素（如“法线图中的像素”)。
> 至于二者是否需要区分，具体还要看应用场景。比如谈到像素与纹素的映射关系时，必须将这两个概念予以区分。文中谈到的基本上是约定俗成的叫法。


## 深度缓冲
**<mark style="background: #FF5582A6;">深度缓冲区（depth buffer)</mark>这种<mark style="background: #FF5582A6;">纹理</mark>资源存储的并非图像数据，而是特定像素的深度信息。**
深度值的范围为 0.0~1.0。0.0 代表观察者在视锥体（view frustum）中能看到离自己最近的物体，1.0 则代表观察者在视锥体中能看到离自己最远的物体。
**深度缓冲区中的元素与后台缓冲区内的像素呈一一对应关系（即后台缓冲区中第 i 行第 j 列的元素对应于深度缓冲区内第 i 行第 j 列的元素)。** 所以，如果后台缓冲区的分辨率为 1280×1024，那么深度缓冲区中就应当有 1280×1024 个深度元素。
为了确定不同物体间的像素前后顺序，Direct3D 采用了一种叫作深度缓冲 (depthbuffering)或 z 缓冲 (z-buffering, 其中的 z 指 z 坐标)的技术。**这里要着重强调一个细节：若使用了深度缓冲，则物体的绘制顺序也就变得无关紧要了。**

总而言之，深度缓冲技术的原理是计算每个像素的深度值，并执行深度测试 (depth test)。而深度测试则用于对竞争写入后台缓冲区中同一像素的多个像素深度值进行比较。具有最小深度值的像素（说明该像素离观察者最近)会获得最终的胜利，它将被写入后台缓冲区中。这样做也是合乎情理的，因为离观察者较近的像素无疑会遮挡其后面的像素。
**深度缓冲区也是一种纹理，所以一定要用明确的数据格式来创建它。深度缓冲可用的格式包括以下几种：**
1. `DXGI_FORMAT_D32_FLOAT_S8X24_UINT`: 该格式共占用 64 位，取其中的 32 位指定一个浮点型深度缓冲区，另有 8 位（无符号整数)分配给模板缓冲区（stencil buffer), 并将该元素映射到$[0,255]$区间，剩下的 24 位仅用于填充对齐（padding)不作他用。
2. `DXGI_FORMAT_D32_FLOAT`: 指定一个 32 位浮点型深度缓冲区。
3. `DXGI_FORMAT_D24_UNORM_S8_UINT`: 指定一个无符号 24 位深度缓冲区，并将该元素映射
到 $[0,1]$ 区间。另有 8 位（无符号整型)分配给模板缓冲区，将此元素映射到$[0,255]$区间。
4. `DXGI_FORMAT_D16_UNORM`: 指定一个无符号 16 位深度缓冲区，把该元素映射到 $[0, 1]$ 区间。

> [!NOTE] 
> **一个应用程序不一定要用到模板缓冲区。但一经使用，则深度缓冲区将总是与模板缓冲区如影随形，共同进退**。例如，32 位格式 `DXGI_FORMAT_D24_UNORM_S8_UINT` 使用 24 位作为深度缓冲区，其他 8 位作为模板缓冲区。**出于这个原因，深度缓冲区叫作深度/模板缓冲区更为得体。** 

## 资源与描述符
在渲染处理的过程中，GPU 可能会对资源进行读和写两种操作。**在发出绘制命令之前，我们需要将与本次<mark style="background: #FF5582A6;">绘制调用 (draw call) </mark>相关的资源<mark style="background: #FF5582A6;">绑定 (bind 或称链接，link)</mark> 到渲染流水线上。**
部分资源可能在每次绘制调用时都会有所变化，所以我们也就要每次按需更新绑定。但是，GPU 资源并非直接与渲染流水线相绑定，而是要通过一种名为**描述符（descriptor)** 的对象来对它间接引用，我们可以**把描述符视为一种对送往 GPU 的资源进行描述的轻量级结构。** 
从本质上来讲，它实际上即为一个中间层; 若指定了资源描述符，GPU 将既能获得实际的资源数据，也能了解到资源的必要信息。因此，**我们将把绘制调用需要引用的资源，通过指定描述符的方式绑定到渲染流水线。**
**为什么我们要额外使用描述符这个中间层呢?** 究其原因，GPU 资源实质都是一些普通的内存块。由于资源的这种通用性，它们便能被设置到渲染流水线的不同阶段供其使用。一个常见的例子是先把纹理用作渲染目标 (即 Direct3D 的绘制到纹理技术)，随后再将该纹理作为一个着色器资源（即此纹理会经采样而用作着色器的输入数据)。不管是充当渲染目标、深度/模板缓冲区还是着色器资源等角色，仅靠资源本身是无法体现出来的。而且，我们有时也许只希望将资源中的部分数据绑定至渲染流水线，但如何从整个资源中将它们选取出来呢? 再者，创建一个资源可能用的是无类型格式，这样的话，GPU 甚至不会知道这个资源的具体格式。
解决上述问题就是引入描述符的原因。除了指定资源数据, 描述符还会为 GPU 解释资源: 它们会告知 Direct3D 某个资源将如何使用 (即此资源将被绑定在流水线的哪个阶段上)，而且我们可借助描述符来指定欲绑定资源中的局部数据。这就是说，如果某个资源在创建的时候采用了无类型格式，那么我们就必须在为它创建描述符时指明其具体类型。

> [!NOTE] 视图（view)与描述符（descriptor)是同义词
> **“视图”虽是 Direct3D 先前版本里的常用术语，但它仍然沿用在 Direct3D 12 的部分 API 中。**在本书里，两者交替使用**，例如，“常量缓冲区视图 ( constant buffer view)”与“常量缓冲区描述符 ( constant buffer descriptor )"表达的是同一事物。

**每个描述符都有一种具体类型，此类型指明了资源的具体作用。** 本书常用的描述符如下：
1. CBV/SRV/UAV 描述符分别表示的是常量缓冲区视图（ constant buffer view)、着色器资源视图( shader resource view)和无序访问视图 ( unordered access view )这 3 种资源。
2. 采样器（ sampler，亦有译为取样器）描述符表示的是采样器资源（用于纹理贴图)。
3. RTV 描述符表示的是渲染目标视图资源 ( render target view )。
4. DSV 描述符表示的是深度/模板视图资源 ( depth/stencil view )。

**描述符堆 ( descriptor heap )** 中存有一系列描述符（可将其看作是描述符数组)，本质上是存放用户程序中某种特定类型描述符的一块内存。**我们需要为每一种类型的描述符都创建出单独的描述符堆。另外，也可以为同一种描述符类型创建出多个描述符堆**。
**我们能用多个描述符来引用同一个资源**。例如，可以通过多个描述符来引用同一个资源中不同的局部数据。而且，前文曾提到过，一种资源可以绑定到渲染流水线的不同阶段。因此，**对于每个阶段都需要设置独立的描述符**。例如，当一个纹理需要被用作渲染目标与着色器资源时，我们就要为它分别创建两个描述符: 一个 RTV 描述符和一个 SRV 描述符。类似地，如果以无类型格式创建了一个资源，又希望该纹理中的元素可以根据需求当作浮点值或整数值来使用，那么就需要为它分别创建两个描述符: 一个指定为浮点格式，另一个指定为整数格式。
**创建描述符的最佳时机为初始化期间**。由于在此过程中需要执行一些类型的检测和验证工作，所以**最好不要在运行时 ( runtime)才创建描述符**。

> [!NOTE] 
> 2009 年 8 月的 SDK 文档写到:“所谓创建一个完整类型的资源，即在资源创建的伊始就确定了它的具体格式。这将使运行时的访问操作得到优化。”因此，当确实需要用到无类型资源所带来的灵活性时 (即根据不同的视图对同一种数据进行多种不同解释的能力)，再以这种方式来创建资源，否则应创建完整类型的资源。

多重采样ji's