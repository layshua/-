
主要内容：**PCF算法思路**

![[df61446711700a1173330e8032355eaa_MD5.jpg]]

_课程目录_

本节课的内容主要分为三部分：

1.Shadow mapping 的回顾

2.Shadow mapping 的数学基础

3.PCSS 和 PCF

# 1 Shadow Mapping 回顾

![[c8de9667d32652e726cf80c75c63a75a_MD5.jpg]]

要渲染一个点光源在场景中投射出的阴影, 我们要用 shadow mapping 技术, 在 101 中我们介绍过 shadow mapping, 它是一个 Pass2 的算法, 也就是我们会对场景渲染两次。

Pass1 我们从 Light 处看向场景并输出一个从 light 处看向场景所生成的深度图, 也就是所谓的 shadow map.

Pass2 我们从 camera 处看向场景渲染一遍, 并参考 Pass1 生成的 shadow map 去判断物体是否在阴影中.

**shadow mapping 是一个完全在图像空间 (images space)中的算法**
**优点:**
一旦 shadow Map 已经生成, 就可以利用 shadow map 来获取场景中的几何表示而不是场景中的几何.
**缺点:**
会产生自遮挡 (self occlusion)和走样 (aliasing) 现象.

**步骤:**

1. 从 light 处出发看向场景生成一张记录每个像素中最近物体深度的一张图, 如图:

![[b5928b5d1f3132da7c2054dd2a116b5f_MD5.jpg]]

图中有很多像素, 我们记录下每个像素中他们各自看到的最浅的深度或是最近的物体他们的位置在哪, 存下来从而得到一张 texture.

2. 我们从 camera(眼睛) 出发, 在渲染一遍场景.

![[0becd6a4555aabbdfde29f2ccbbe0199_MD5.jpg]]

对于这次我们来看渲染中的每个像素中都要来判断是否能被 light 照到, 如果被照到则不在阴影中, 反之, 则存在于阴影中.

![[b72bd02e18119cfff50b0b73107fdcbb_MD5.jpg]]

对于这个点来说, 如果将这点连向 light 处会发现在 Pass1 得到的 shadow map 中, 这一点的最浅深度 = Pass2 中从点连到 light 处的深度 (Pass2 中得到的点是可以投影回 light 处求出距离的), 因此这一点是可见的, 不在阴影中.

![[6803a4347a277763aec0c67d100e5054_MD5.jpg]]

而对于这个点来说, 仍然连向 light 处会发现:

Pass1 的 shadow map 中这一点的最浅深度 < Pass2 中从点连到 light 处的深度, 因此这一点是被遮挡的, 在阴影中.

![[588482727a733cdf328b7b04fadce37a_MD5.jpg]]

从这图可以看到, light 在左上方, 场景中的遮挡关系和阴影表示出的效果是很不错的.

![[92a549514e7f92b16cd5865c1e8a92bd_MD5.jpg]]

从 Light 处看向场景生成的是 shadow map, 并不是 Shading 的结果, 而是在 light 的 pass 中生成一张深度的 buffer, 如图中, 颜色深的表示值比较小, 也就是离 light 近, 颜色浅的就是离 light 远, 值大.

![[257ed7c7334d006c0e01c73039105717_MD5.jpg]]

![[db5a999cad9a98df86488cb8e3019cdf_MD5.jpg]]

![[4e7b2e64a55e2fdf73dc0a941530308f_MD5.jpg]]



关于深度, 我们在 101 中讨论过一个问题, 在做透视投影时, 我们是将透视投影挤压成正交投影, 然后再拍平, 在这个过程中中间的点是会向近平面移动还是向远平面移动?

答案是中间的所有点会被推向远平面.
[[02 视图变换#思考：挤压后 z 值为(n+f)/2的点会挤向 n 还是 f]]

所以, 在经过投影之后得到的 Z 其实不是实际上几何上的点到 Light 的距离, 因此在真正生成阴影时比较两个 pass 中的 depth 时需要一致。也就是要么都用**投影后的 Z 值**比较, 要么通过**两点的位置得一向量算实际距离**.

**Shadow Mapping 也是存在一些问题的:**

**A ：自遮挡**

![[b229b82fc6e1de7744dcb6aa1a746dd5_MD5.jpg]]

学过 101 的看见地板上的东西会感觉像摩尔纹, 但并不是, 它是由数值精度造成的一种现象.

我们生成了一个 Shadow map, 那么这个 Shadow map 肯定有自己的分辨率, 其每个像素要记录它所看见的最浅深度, 可以理解为, 每个像素内部他的深度是一个**常数**

那么从 Light 处看向场景时, 沿某一像素看过去我们看到的位置就认为是像素所代表的深度, 也就是认为这个场景在像素覆盖区域内都是一个常数的深度.

在 Shadow map 看来, 场景被离散化为一系列红色小片形成的场景而不是直接的平面.

因为每个红色小片所代表的深度不一样, 因此在 Pass2, 也就是从 camera 处看向场景时, 后面的红色小片在连接 light 时, 会被误认为被前面的红色小片遮挡住, 从而产生了错误的阴影, 这个现象在 light 与平面趋于平行时候最严重.

有了问题自然要去解决问题:

![[e6e5545f442c120138822337daf8cd4f_MD5.jpg]]

我们只需要把在黄色区域内的遮挡关系给舍弃掉就可以了, 而且是有技巧的, 当 Light 处垂直于场景时, 我们可以让这个遮挡区域尽可能小一点, 当 light 趋近于平行场景时, 我们让这个区域尽可能大一点, 我们可以引入一个 bias 的概念 (黄色区域), 来降低自遮挡情况, bias 是根据角度调整的, 并非常数.

**具体方式就是当一个点深度大于记录深度的值超过一个阈值时，我们才认为这个点在阴影内**。这也是工业界使用较多的一个办法。

但是这样也引出了另一个问题:

![[0c003e9f6c32c0b305345ff3cdf216c2_MD5.jpg]]

从图中我们可以看到, 有一段的阴影被舍弃了, 因为**当 Bias 调的过大时, 我们会丢失原本应该存在的阴影.**

解决方案:

**Second-depth shadow mapping**

此时我们就舍弃 biasd 的概念, 而是在**渲染时不仅存最小的深度, 我们还要存第二小的深度, 然后我们用最小深度和第二小深度中间的深度来作比较.**

(个人理解为, 我们在渲染时生成两张深度图, 一张存储的是最浅, 一张存储的是第二浅, 之后将两张图平均从而得到最后的深度图, 然后用这张平均得来的深度图和物体算遮挡关系)

![[9abf34a4688aec3916999634fcdac923_MD5.jpg]]

以这个为例:

![[530dda48b31bab142f1bec8a0ad4f2d6_MD5.png]]

假设一根光线照过来, 我们不用最小深度来比较, 而是用由最小和第二小深度所得到的红色线来做后续的阴影, 此处就没有 Bias 的事情了.

![[51b6f022ef54a3f1a992729d665f17a9_MD5.jpg]]

假设图中是人物的鞋, 鞋底是接着一个平面的, 我们以右边最极端的部分为例, 当一根光线从右边鞋头部分打向鞋底, 就算它底部紧贴着平面, 我们能得到一个明显的遮挡关系.

然后**实际中并没有人去使用这个技术, 因为场景内的物体必须都是 watertight（非面片），还有就是算的复杂，开销太大，实时渲染不相信复杂度，O (n)也可能常数项很大，2O (n)比 O(n)慢。只相信绝对的速度!
![[39461ae7a24db1d8aa928e64c8ac8512_MD5.jpg]]



**B : 走样**

Shadow mapping 的第二个问题就是走样。

shadow map 本身就存在分辨率，当分辨率不够大自然会看到锯齿, 因为 shadow map 上每一个像素都可以看为小片, 那么投出来的阴影自然会存在锯齿.

![[1a1dd59446a99442d60673aa2446183a_MD5.jpg]]

# 2 Shadow Mapping 背后的数学

在微积分中有很多有用的不等式, 如图中的两个不等式为例：

![[Pasted image 20230622211119.png]]

**在实时渲染中, 我们只关心近似约等, 我们不考虑不等的情况, 因此我们将这些不等式当约等式来使用。**
![[Pasted image 20230622211059.png]]

如果你有两个函数的乘积, 你又想把他们的乘积积分起来, 你可以将其拆出来, 也就是:

**两个函数乘积的积分 $≈$ 两个函数积分的乘积**


1. **为什么右边第一个函数多了个分母？**

**分母这一项的作用是为了保证左右能量相同 而做的归一化操作。**

我们来用一个例子来解释这个归一化操作。我们假设 $f(x)$ 是一个**常值函数**, 也就是 $f(x) = 2$, 我们的积分域恒为 $\int_0^3$.

那么约等式左边, 把 $f(x) = 2$ 代入, 则可以提出来变为 $2$ 倍的 $g(x)$ 积分

而等式右侧第一个函数代入 $f(x)$ 的积分是 $\int_0^3 2dx=2x|_0^3=2 * 3 =6$，分母的积分是 $\int_0^3 dx=x|_0^3=3$，结果也正好是 $2$. 正好也是 $2$ 倍的 $g(x)$ 积分.

2. **在什么情况下约等式结果更加准确:**

一般需要以下两个条件:

1.  g(x) 积分的 support 较小。这里的 support 我们可以暂时理解为积分域。

2. g (x) 在积分域内变化不大（学术界称为 Smooth integrand）。

**此时我们把渲染方程代入这个约等式中:**
我们把 visibility 看作是 $f(x)$, 提取出来并作归一化处理:
![[Pasted image 20230622212736.png]]

红色区域部分时 visibility, 那么剩下的 $g(x)$ 部分, 也就是 shading 的结果.

因此其表示的意义就是, 我们计算每个点的 shading，然后去乘这个点的 visibality 得到的就是最后的渲染结果。

这也就是 shadow mapping 的基本思想。

**那么什么时候这个约等式比较正确呢？**

1. 我们要控制积分域足够小，也就是说我们只有一个点光源或者方向光源。环境光不行。

2. 我们要保证 shading 部分在积分域内变化不大，也就是说 brdf 的部分变化足够小，那么这个 brdf 部分是 diffuse 的。gloss  brdf 不行。

3. 我们还要保证光源各处的 radience 变化也不大，类似于一个面光源。

# 3 PCF(Percentage Closer Filtering) 与 PCSS(Percentage Closer Soft Shadows)**

**首先我们来说一下软阴影和硬阴影:**

![[Pasted image 20230622213647.png|400]]
![[Pasted image 20230622213757.png]]
Umbra：本影区（影子中光源完全照射不到的部分）
Penumbra ：半影区（黑暗与光明之间的），半影区的影子比较软



我们可以看出, 软阴影的效果要更加真实也更自然, 强于硬阴影的效果。

为了实现软阴影的效果, 我们首先会用一个工具 PCF------percentage closer filtering:

**PCF 的初衷是为了抗锯齿, 反走样，比如上面的忍者阴影出现的锯齿状, 是为了解决这个现象.**

后来发现可以用在软阴影上，通过把 shadow 结果求一个加权平均 (或者叫 filtering).

注意：
1.  PCF 不是直接在最后生成的阴影上进行 filtering，, 而是在你做阴影判断时进行 filtering。
   如下图，可以发现没有解决走样的问题。就跟我们在反走样时一样, 我们不能先得到一个走样的结果再去做在这个走样的结果上进行模糊。

![[2586f23c8f8f35667133cf9c8c941265_MD5.jpg]]

2.  **也不是对 shadow map 进行 filtering**

如果直接在 shadow map 上 filtering 就会造成阴影和物体交界直接糊起来，而且在第二个 pass 上做深度测试还是非 0 即 1 的结果, 最后得到的仍然是硬阴影。

我们之前在做点是否在阴影中时, 把 shading point 连向 light 然后跟 Shadow map 对应的这一点深度比较判断是否在阴影内, 之前我们是做一次比较, 这里的区别是, **对于这个 shading point 我们仍要判断是否在阴影内, 但是我们把其投影到 light 之后不再只找其对应的单个像素, 而是找其周围一圈的像素, 把周围像素深度比较的结果加起来平均一下，就得到一个 0-1 之间的数，就得到了一个模糊的结果。**  
![[Pasted image 20230622214840.png]]
如图, 蓝点是本来应该找的单个像素, 现在我们对其周围 3 * 3 个像素的范围进行比较, 由于是在 Shadow map 上, 因此每个像素都代表一个深度, 我们让在 shadow map 上范围内的每个像素都与 shading point 的实际深度进行一下比较, 如果 shadow map 上范围内的像素深度小于 shading point 的实际深度, 则输出 1, 否则输出 0.

从而得到 9 个非 0 即 1 的值:

最终我们用得到的加权平均值 0.667 作为 shading point 的可见性。在计算阴影的时候我们就拿这个作系数来绘制阴影。
![[Pasted image 20230622215034.png]]

**我们会发现如果 filter size 越大，阴影本身越软，所以这个方法也就可以去绘制软阴影，也就是 pcss 技术。**
![[Pasted image 20230622215242.png|500]]
在这幅图中我们可以看见, 笔尖的阴影十分锐利 (硬), 因为我们可以认为

**阴影接受物与阴影投射物的距离越小, 阴影越锐利.**

因此, 我们要解决的一个问题是我们如何决定一个软阴影的半影区。换句话说，就是 filter size 有多大的问题:
blocker distance 即图中的 $d_{Blocker}$：遮挡物和阴影投射物 (光源)的距离。更详细的说，是相对的平均的投影遮挡物深度
![[Pasted image 20230622215651.png|400]]
我们可以看到左下和右上两个黄色虚线形成的三角是两个**相似三角形**。

如果我们将 blocker 的位置移动一下, 比如越靠近 receiver, 我们会发现（$W_{Penumbra}$）也就会越小.

用数学来表示半影区（$W_{Penumbra}$）, 由相似三角形 :

$$
\frac{W_{Light}}{W_{Penumbra}}=\frac{d_{Blocker}}{d_{Receiver}}
$$
即
$$
W_{Pemumbra}= W_{Light}\cdot \frac{d_{Receiver}}{d_{Blocker}}
$$
这里的 $d_{Recevier}$ 和 $W_{Light}$ 的大小我们是知道的，所以我们只需要拿到 blocker 的深度即可。


**如何确定一个 blocker 距离光源的位置   $d_{Blocker}$？**

不能直接使用 shadow map 中对应单个点的深度来代表 blcoker 距离, 因为如果该点的深度与周围点的深度差距较大（遮挡物的表面陡峭或者对应点正好有一个孔洞），将会产生一个错误的效果, 我们选择使用平均遮挡距离来代替，所以平常我们指的 blocker depth 其实是 Average blocker depth.

blocker 上的每个点距离光源的距离是不同的，深度也是不一样的。这里我们采用取平均深度的方式来表示 blocker 的深度。

求 blocker 距离的方法如下：

首先，我们把目标 shading point 转换到 light space 找到 shading point 在 shadow map 上对应的像素。

如果 shading point 的深度大于这个 shadow map 上点对应的深度, 则说明 shadow map 上的点就是一个 Blocker, 然后我们取 shadow map 上这个点 (像素) 周围的一些像素，找出能够挡住 shading point 的点的像素, 并求出他们的深度平均值作为 blocker 的深度。

这个方法还是有一个问题，这个问题就是我们虽然找出了 filter size 的大小。但是我们需要知道寻找 blocker 之一步骤中，我们需要找到周围的一些像素，那这个范围又是多少呢？一般我们有两种方法可以解决这个问题。

第一种，就是自己规定一个, 比如 4 * 4, 16 * 16, 比较简单但不实用.

第二种，是通过计算得到一个范围大小:

![[7b6b2557fb4612a3bd6c2e75712c820f_MD5.jpg]]

![[17a5f4b8a24467710c615889bd174d97_MD5.jpg]]

我们计算 shadow map 的时候在光源处设置过相机，如图所示，我们把 shadow map 放在由相机看向场景形成的视锥中的近截面上, 然后将光源 shading point 相连，在 shadow map 上截出来的面就是要查询计算平均遮挡距离的部分. 这部分的深度求一个均值，就是 Blocker 到光源的平均遮挡距离。

离光源越远，遮挡物也会更多, 所以需要在 Shadow map 上的一个小区域内查找 blocker.

离光源越近，遮挡物会少, 所以需要在 Shadow map 上的一个大区域内查找 blocker.

这样我们就得到了 PCSS 的三个步骤：

1.  寻找 blocker，并计算平均 blocker深度。
2.  通过 blocker 深度计算 filter size。
3.  按照 PCF 方式绘制软阴影。

PCSS 本质上就是求出了阴影中需要做 PCF 的半影部分后再进行 PCF 的计算，这样动态调节了半影范围，也就是动态设置了 PCF 的搜索范围，这样我们的硬阴影部分清晰，软阴影部分模糊，动态的实现了不错的软阴影效果。

说实话在写笔记过程中给自己写迷糊了, 可能有些错误之处希望指出, 在写完 lecture 04 之后我们再来看一遍视频对着改正一下, 希望这篇笔记能给您带来帮助.