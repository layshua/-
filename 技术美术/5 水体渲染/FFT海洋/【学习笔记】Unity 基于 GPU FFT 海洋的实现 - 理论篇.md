
## 0 振幅、周期、相移和频率
有些函数（像[正弦和余弦](https://www.shuxuele.com/algebra/trig-sin-cos-tan-graphs.html)） 永远重复，它们叫**周期函数。**


$y = A sin (Bx + C) + D$

*   振幅是 $A$
*   角频率 $B$
*   周期是 $2π/B$ ，频率为周期的倒数
*   相移是 $−C/B$
*   垂直移位是 $D$

**周期**是从一个最高点到下一个最高点（或任何一点到下一个相对点）：

![[96dd33653dd84ae74cc6e2b9363ea089_MD5.svg]]


**频率**是在一个时间单位里发生多少次（每 "1"）。
$频率=\frac{1}{周期}$
例子：这个正弦函数在 0 到 1 之间重复了 4 次：

![[ca9f58389e42428d0337ec33391c3cf6_MD5.svg]]


**振幅**是从中（平）线到最高点的高度（或到最低点），也是从最高点到最低点的距离除以 2。

![[d79ec3499d643bc8ccccaeeb39a61b40_MD5.svg]]

**相移**是函数比通常的位置**水平**向**右移**了多远。

![[2a9fb6980154519d1a128d980b11ffee_MD5.svg]]

**垂直位移**是函数比通常的位置**垂直**向上移了多远。


例：$2 sin(4x − 2) + 3$
*   振幅 **A = 2**
*   周期 **2π/B** = **2π/4 = π/2**
*   相移 **−C/B** = **−(−2)/4 = 1/2**
*   垂直移位 **D = 3**

![[a95371e3ff488c053ab7455f2801bf18_MD5.svg]]

用文字写出来：

*   **2** 告诉我们它是比一般高了一倍，所以振幅 = 2
*   一般周期是 2**π**，但在这例子它是 "加快了"（短了）**4** 倍，所以周期 = **π/2**
*   **−2 代表函数向右移（正向左，负向右）**，但因为它也 "加快" 了 **4** 倍，所以函数只是移动了 **1/2**，故此相移 = **1/2**
*   最后，+3 的意思是中（平）线是 y = +3，所以垂直位移 = 3

注意：相移的公式 **−C/B** 有负号：

*   若 C 为正值，曲线向负方向（左）移
*   若 C 为负值，曲线向正方向（右）移

有时我们用 **t** 而不用 **x** （也可能用其他变量）：


## 1 简单的正弦波

我们在模拟水面时，如果水面的起伏不是非常明显，直接使用法线纹理动画就可以得到不错的结果 (在《UnityShader 入门精要》15.2 节, 有详细的讲解)。如果想要一些比较明显的波形，我们可以使用最简单的波形 - 正弦波，我们来看下最简单的公式形式

$y = sin(x)$

![[6a87be83ce5216ea9e0335abe118cd75_MD5.jpg]]

为了方便说明，这里的波形都是 2 维的，如果你想拓展到 3 维，可以参考《GPU Gems 1》第一章的内容。

我们可以看到，我们已经有了一个基本的波形。但是又有一些问题，我们不能控制他的形状，他也不会动。所以我们现在需要一些参数来控制他，我们加入第一个控制的参数振幅 A, 公式变为

$y = Asin(x)$

![[6ee09d4bba3b8faceb5d8a34fcbd1582_MD5.gif]]

我们调节振幅 A 的值，可以看到振幅就是从水平面到波峰的高度。然后加入第二个参数**角频率** $\omega$ ，公式为

$y = Asin(\omega x)$

![[cd8162e35bb272122e7a3c0cd292a0ee_MD5.gif]]

可以轻易的看出角频率 $\omega$ 指的是波动震动次数， $\omega$ 值越高波长 $L$ 越小，角频率 $\omega$ 与波长的关系为 $\omega = 2\pi/L$ , **波长 $L$ 是波的周期，也是波峰到波峰之间的距离**。至此我们已经改变波的基本形状，但是这个波是静止的，他并不会随着时间的推移而运动，我们添加一个时间参数 $t$ 和速度参数 $s$，用来控制波的运动，**一般使用相位常数 $\varphi$ 来表示速度,** $\varphi=s*2\pi/L=s\omega$ 公式为

$y = Asin(\omega x + t\varphi)$

$\displaystyle 相移 = \frac{-t\varphi}{\omega}=\frac{-ts \omega}{\omega}=-ts$，即向右移动$-ts$

![[bcd20891bdc226638283a9fa7a862e0c_MD5.gif]]

至此我们的波已经可以动了，还可以在运动时修改振幅、频率等参数来改变波行，可喜可贺、可喜可贺。但是我们的工作还远没有结束，这个波显得太单一了，没有细节。那如何让他的波形变得更复杂呢，可以想到既然一个波行太单一，我们可以多加几个波，来让波形变得更加复杂。

$y=\Sigma A_{i}sin(\omega_{i}x+t\varphi_{i})$

![[98ba8ff27caec754b80ef54281e2b80a_MD5.gif]]

这里为了简单我们就进行了两个波的叠加。通过两个波的叠加就可以得到一个比之前更复杂的波形，如果想要更加复杂的波形，那就多加几个....

下图是截取《GPU Gems 1》对单个波函数参数的介绍

![[5f6300ea5b9feebc1f8640094be3343d_MD5.jpg]]

## 2.Gerstner 波

对于正弦波所叠加起来的波，看起来比较圆滑，这适用于绘制一个平静的水面。但是对于粗狂的海洋，需要形成较尖的浪头和较宽的浪槽，我们选择使用 Gerstner 波。

Gerstner 波是**将水平位置进行挤压，使得波峰变尖，波谷变宽。** 下面简单演示了 Gerstner 是如何进行挤压的。

![[a2d921534a9cc60b61f42ab7397758e7_MD5.gif]]

这里我们可以清楚的看到一个简单的正弦波，是如何被挤压成比较野蛮的波。当挤压过头时，波峰就会形成环。来看一下 Gerstner 波的公式

![[5697eff8b8f39ed7024a2597d18e6ef5_MD5.jpg]]

这里是一个 3 维的公式， $x$ 、 $y$ 是水平坐标 (在 Unity 中 $y$ 指的是高度，需要注意变换)， $D$ 是波动方向。先看 $z$ 坐标的表达式，其实就是我们之前所说简单的正弦波的叠加公式。再看 $x$ 、 $y$ 表达式，他们的形式都是一样的，都加了一个 cos 波的偏移来进行挤压，前面的是控制挤压程度的参数 $Q_{i}$ 。当 $Q_{i}=0$ 时，我们就会得到一个简单的正弦波, 当 $Q_{i}=1/(\omega_{i}A_{i})$ 时会得到波峰最尖的波形。如果使用更大的值，就像我们上面那样，在波峰处形成环。如果想要复杂的波形那么叠加波就是了....

Gerstner 波还有另一种形式，可以模拟近海岸的潮水......

## 3.FFT 海洋

好的，终于到我们的主题了，请系好安全带，要上高速了。

## 3.1 理解时域、频域、(逆) 傅里叶变换

在这我们需要简单的了解时域、频域、傅里叶变换和逆傅里叶变换。像我们上面说的那样，对于一个非常复杂的波形，我们可以使用非常多的正弦波叠加来逼近他。像下图所描述的那样

![[08960014330ea3bb69124bc2d6964581_MD5.jpg]]

图截取自 Heinrich 大佬的文章 [Heinrich：傅里叶分析之掐死教程（完整版）更新于 2014.06.06](https://zhuanlan.zhihu.com/p/19763358)

时域图像就是我们所叠加出来的波形，中间的波就是我们进行叠加的正弦波，将他们叠加起来就是时域图像 (最后的海浪波形)。将这些正弦波按照频率大小依次展开，他们的振幅所形成的图像就是频域图像 (也被称为频谱)。下面的一个动图可以更清楚的看到时域和频域之间的关系，取自 [wiki](https://en.wikipedia.org/wiki/File:Fourier_series_and_transform.gif)

![[b6d5d5d4d7783d02ab3bbcddca93b609_MD5.gif]]

好的，知道这些有用什么用呢。其实时域和频域之间是可以相互转换的。

将时域转换成频域被称为傅里叶变换

将频域转换成时域被称为逆傅里叶变换

聪明的我们已经察觉到了，如果我们想要实现一个复杂的波浪，我们只需要生成一个频域图像 (也被称为频谱)，然后对其进行逆傅里叶变换就可以了。现在我们已经学会了，可喜可贺，完结，撒花........ 额... 当然不是，黎明前的黑夜即将到来，一大波的公式即将来袭。

## 3.2 理解傅里叶变换公式

这部分内容并不是必须的，只是帮助你理解傅里叶变换公式.... 看不懂也并没有影响....

在计算机中只能处理离散的点，我们所说的也都是离散的。

离散傅里叶变换 (Discrete Fourier Transform，缩写为 DFT)

逆离散傅里叶变换 (Inverse Discrete Fourier Transform, 缩写为 IDFT)

我们先来看下 DFT 的公式, 如果 $f(x)$ 为一个长度为 $N$ 的数字序列，则其 DFT $F(\mu)$ 为

$F(\mu)=\sum_{x=0}^{N-1}{f(x)}e^{-i\frac{2\pi\mu x}{N}}$

这只是第一个公式，差点就有点接受不住。先来看下每个参数的含义， $F(\mu)$ 为转换后的频域函数， $\mu$ 是频率。可以看上面的图，我们将一个复杂的波形展开成多个正弦波，在将正弦波按照频率大小依次排列，频率和振幅就组成了频域图像。频域图像的横坐标为频率，纵坐标为振幅。

$f(x)$ 是我们时域的函数， $e^{-i\frac{2\pi\mu x}{N}}$ 是一个复数。

这样还是什么都看不懂，我们将后面的复数用欧拉公式展开

$e^{ix} = cos(x) + isin(x)$

你可以看 b 站上 [如何用傅里叶级数绘制出任意图像来? 双语](https://www.bilibili.com/video/av49238862) (在 15 分钟..) 这个视频来理解欧拉公式。

$F(\mu)=\sum_{x=0}^{N-1}{f(x)}cos(\frac{2\pi\mu x}{N})-i\sum_{x=0}^{N-1}{f(x)}sin(\frac{2\pi\mu x}{N})$

啊! 看似变得更复杂了，其实并不然，这更有助于我们理解。我们需要从另一个方向切入，抛开这个公式，我们想如何将时域转换到频域。

在此之前我们需要知道另一个比较重要的东西，三角函数的正交性。组成三角级数的函数系 $1,cosx,sinx,cos2x,sin2x,...,cosnx,sinnx$ ，其中任意两个不同的函数之积，在他们的公共周期内的积分等于 0

这是非常重要的，我们想将时域转换成频域，也就是根据时域的函数，来计算出在频域上各个频率正弦波的振幅。时域图像是由很多不同频率的正弦波叠加而成，所以我们再求某一个频率分量的振幅时需要把其他频率的波给过滤掉。

可以构造一个检波器，称检波器 A。

![[c5d9ac6d245fb67b5425f8089b8bbdef_MD5.jpg]]

图截取自 [傅里叶变换就是这么简单，你学会了吗?](http://k.sina.com.cn/article_6367168142_17b83468e001004j89.html?sudaref=graph.qq.com&display=0&retcode=0) ，额... 本部分都截取自那....

检波由一个乘法器和一个积分器构成，乘法器的一个输入为一个已知频率 f(我们想要求的频率) 的单位振幅正弦波 (正弦信号 f)，另一个输入为待变换信号，也就是我们的时域。通过两个信号相乘并求积分，根据三角函数的正交性，时域中其他频率的信号会被过滤掉，最后只会留下和频率 f 有关的一个量，这个量等于待变换信号中 f 分量与标准正弦信号 f 的乘积的积分。

我们还需要另一个检波器 (检波器 B), 因为我们并不知道待变换信号 (时域)，中各个分量的初始相位，因为当相位刚好差 $\pi/2$ 时, $sin(x+\frac{\pi}{2})=cos(x)$ , 以可看到频率为 1，初始相位为 $\pi/2$ 时，检波器 A 也会检测不到。所以我们还要在构造个检测余弦信号的

![[2ff60e50f9d1bdd87104fc587096464e_MD5.jpg]]

这样通过两个检波器的过滤，最后就会输出我们想要频率的分量, 检波器 A 和检波器 B 输出信号的幅值的方和根就等于频率为 f 分量的幅值。通过这两个检波器，我们只需要输入待变换信号 (时域)，以及一个想要求的频率，就可以得到该频率的振幅，完成时域到频域的转换。

好了现在在回过头来看那个 DFT 的公式，一切都那么简单明了了。

$F(\mu)=\sum_{x=0}^{N-1}{f(x)}cos(\frac{2\pi\mu x}{N})-i\sum_{x=0}^{N-1}{f(x)}sin(\frac{2\pi\mu x}{N})$

输入想要求的频率，时域 $f(x)$ 会进行两个检波器的检测， $\sum_{x=0}^{N-1}{f(x)}cos(\frac{2\pi\mu x}{N})$ 代表着检波器 B, 在离散处理中积分就是累加。可以看到我们到最后得到了一个复数，复数的模就是我们想要频率的振幅。

你也可以看 b 站上这个视频来理解 [离散傅里叶变换零基础入门 - 中文 1（针对工科生，无需连续傅立叶变换知识）](https://www.bilibili.com/video/av44600709?from=search&seid=17408625534542082014)

逆离散傅里叶变换公式 IDFT, 可以由 DFT 推导得到

$f(x)=\frac{1}{N}\sum_{\mu=0}^{N-1}{F(\mu)}e^{i\frac{2\pi\mu x}{N}}$

## 3.3 FFT 海洋公式

通过上面的讲述我们应当知道了，如果我们想要得到一个复杂的海面，我们需要生成一个频谱 (也就是上面的频域)，然后在通过逆离散傅里叶变换 (IDFT)，我们就可以得到由很多不同频率、振幅的波所叠加出来的复杂海面 (也就是上面的时域)。频谱直接决定了我们的海面形状，那么频谱的生成就变得尤为重要。

在这之前我们先来看下 Simulating Ocean Water-Jerry Tessendorf 中所提到的海洋公式。

$h(\vec{x},t)=\sum_{k}{\tilde{h}(\vec{k},t)}e^{i\vec{k}\cdot\vec{x}}$

可以看到这个式子和我们上面公式给出的逆离散傅里叶变换那么的像，其实就是将 $\tilde{h}(\vec{k},t)$ 来进行 IDFT。

先来看一下参数 $\vec{x}=(x,z)$ 是我们水平方向的坐标, $t$ 是时间，函数 $h$ 可以直接给我们返回在时间 $t$ 时， $\vec{x}$ 处的海面高度。

$\vec{k}$ 被定义为 $\vec{k}=(k_{x},k_{z})=(\frac{2\pi n}{L_{x}},\frac{2\pi m}{L_{z}})$

$-\frac{N}{2}\leq n <\frac{N}{2}$

$-\frac{M}{2}\leq m <\frac{M}{2}$

$\vec{k}$ 为波矢量，$L_{x}$ 和 $L_{z}$ 是海平面的大小， $N$ 和 $M$ 是我们采样离散点的数量。当然 $N$ 和 $M$ 取值越大我们得到的波形就更加细节 (叠加的波就更多)，当然计算时间也会大大的增加。

我们只需要计算出频谱然后按照 $h(\vec{x},t)$ 函数就可以得到我们海面的高度, 现在我们来看一下频谱公式 $\tilde{h}(\vec{k},t)$

$\tilde{h}(\vec{k},t) =\tilde{h}_{0}(\vec{k})e^{i\omega(k)t}+\tilde{h}^{*}_{0}(-\vec{k})e^{-i\omega(k)t}$

$\tilde{h}^{*}_{0}$ 是 $\tilde{h}_{0}$ 的共轭复数， $k$ 是 $\vec{k}$ 的模。

$\omega(k)$ 是角频率 $\omega$ 和波长$k$ 的 Dispersio 关系 (不知道翻译成啥合适，就选择了不翻译..)，这个关系取决于重力、海洋深度和其他物理参数。这里只给出了深水的关系，其他的可以去 Simulating Ocean Water 上找到

$\omega^2 = gk$

$\omega(k) = \sqrt{gk}$

$g$ 是引力常数 $=9.8m/sec^2$

$\tilde{h}_{0}(\vec{k})=\frac{1}{\sqrt{2}}(\xi_{r}+i\xi_{i})\sqrt{P_{h}(\vec{k})}$

$\xi_r$ 和 $\xi_i$ 是两个相互独立服从均值为 0，标准差为 1 的高斯随机数。对于随机数的生成我们会在实践篇说到。

$P_{h}(\vec{k})$ 是我们的方向波谱，方向波谱一般描述为 $S(\omega,\theta)$ , 这和我们前面的参数不太一样，其实他们之间可以相互转换，有兴趣可以看 Empirical Directional Wave Spectra for Computer Graphics 这篇论文。

方向波谱 $S(\omega,\theta)$ 是非定向波普 $S(\omega)$ 和方向拓展函数 $D(\omega,\theta)$ 的乘积

$S(\omega,\theta)=S(\omega)D(\omega,\theta)$

$\omega$ 是我们前面提到的角频率， $\theta$ 是波矢量相对于风向的角度

在 Simulating Ocean Water-Jerry Tessendorf 中使用到的非定向波谱为 $A\frac{e^{-1/(kL)^2}}{k^4}$ , 而方向拓展函数为 $\left| \vec{k}\cdot\vec{\omega} \right|^2$ , 他们的乘积就是 $P_{h}(\vec{k})=A\frac{e^{-1/(kL)^2}}{k^4}\left| \vec{k}\cdot\vec{\omega} \right|^2$

$L=V^2/g$ , $V$ 是风速， $\vec{\omega}$ 是风向。

在我们的实现中风向拓展函数使用的不是 $\left| \vec{k}\cdot\vec{\omega} \right|^2$ ，而是 Donelan-Banner 定向传播，这里就先不贴这个公式了，免得 显得公式太多....

好，上面的只是海面高度的公式，这里顺便也把水平偏移丢出来吧, 法线和泡沫会在最后单独说一下

$\vec{D}(\vec{x},t)=\sum_{k}{-i\frac{\vec{k}}{k}\tilde{h}(\vec{k},t)}e^{i\vec{k}\cdot\vec{x}}$

可以看到这和我们的高度函数基本一样，只是我们需要把频谱进行改变一下。这是对 $x$ 和 $z$ 总体的描述，我们将其拆开就可以得到对 $x$ 和 $z$ 单独的描述

$D_x(\vec{x},t)=\sum_{k}{-i\frac{k_{x}}{k}\tilde{h}(\vec{k},t)}e^{i\vec{k}\cdot\vec{x}}$

$D_z(\vec{x},t)=\sum_{k}{-i\frac{k_{z}}{k}\tilde{h}(\vec{k},t)}e^{i\vec{k}\cdot\vec{x}}$

中间的其实就是两个复数相乘。

公式都是前辈大佬们通过海洋上的数据检测.... 巴拉巴拉.... 得到的，简单来说直接用，不要多想，想也不懂，懂也不会调，调也不会对 (说给我这种弱鸡听的.... 大佬请无视....)

以上就是海洋的所有 (大部分) 公式，那我们面临着一个问题，公式到手依然是满脸迷茫不知道该从哪里下手。

## 3.4 公式的计算流程

如果想要得到一个海面 (也就是时域、海面高度、海面波形)，就像把大象装进冰箱一样分三步。

生成频谱 (打开冰箱门) $\rightarrow$ 逆离散傅里叶变换 (把大象塞进去) $\rightarrow$ 生成高度图、渲染等 (关上冰箱门)

嗯，可以看到公式最多的那一步 (生成频谱) 其实是最简单的，因为公式都给你写好了，照着抄就可以了(就像冰箱大佬们已经给你造好了，你不需要自己在造个冰箱)。最难的就是 IDFT 那一步了，当然如果你使用第三方的库，自己生成频谱直接丢给他，他就会给你返回一个高度图(就像你请人把大象塞进去样)。

我们来看看 Ocean Surface Simulation NV 给的流程图，来让我们更直观的看公式是如何进行计算的

![[081c29e7b614f0b355443056a51a1646_MD5.jpg]]

首先根据公式生成 Phillips 频谱，这并不难直接套用公式就可以。然后在计算两个相互独立服从均值为 0，标准差为 1 的高斯随机数。然后根据公式结合，就完成了第一步，我们得到了一个初始的频谱。这个频谱只需要计算一次就好，因为并没有时间去影响他，有的只有风。如果你的风每帧的是变动的话，那他就需要每帧计算了，但是随机数只需要计算一次就好。

![[f8e29a6bae16241d4b653b05be05a87c_MD5.jpg]]

我们拿到初始频谱后，就可以使用他来计算高度频谱 $\tilde{h}(\vec{k},t)$ , 使用高度频谱就可以轻易的计算处两个偏移频谱 $D_x(\vec{x},t)$ 和 $D_z(\vec{x},t)$ 。然后第一步生成频谱就结束了，是不是很简单。

然后就到了第二步，当我们拿到这些频谱后，分别对他们进行 IDFT，就会得到水平 $x$ 、 $z$ 以及高度 $y$ 的偏移图 (注意上图中的 $z$ 为高度)。第二步就此结束。

然后是第三步，我们将拿到的图放到一起就会得到一个偏移纹理，通过这个偏移纹理我们可以计算法线和泡沫纹理，这样我们所有的纹理就都拿到了，接下来对其进行渲染就可以了。

什么？你感觉第二步比较简单，只要进行相乘累加就可以了。确实，如果是直接进行计算的话，他并不复杂。但是那样的效率太低了。

## 3.5 FFT 推导

首先我们来看直接进行计算效率为什么会非常低。首先看我们的海洋公式

$h(\vec{x},t)=\sum_{k}{\tilde{h}(\vec{k},t)}e^{i\vec{k}\cdot\vec{x}}$

这是一个二维的 IDFT，对于计算二维的 IDFT 其实就是拆解成两个一维的 IDFT，首先横向进行 IDFT，然后对得到的结果进行纵向 IDFT。

我们将 $h(\vec{x},t)$ 进行展开

$h(x,z,t)=\sum_{m=-\frac{M}{2}}^{\frac{M}{2}-1}\sum_{n=-\frac{N}{2}}^{\frac{N}{2}-1}{\tilde{h}(\frac{2\pi n}{L_{x}},\frac{2\pi m}{L_{z}},t) e^{i(\frac{2\pi n}{L_{x}}x+\frac{2\pi m}{L_{z}}z)}}$

这里的展开并不难，只需要把 $\vec{x}$ 和 $\vec{k}$ 带进去就可以得到。可以看到当我们只计算一个位置的海面时，时间复杂度是 $O(NM)$ ，如果是串行计算所有位置的海面时，时间复杂度是 $O(N^2M^2)$ , 可见我们计算一个海面就要在每帧执行 $N^2M^2$ 次 for 循环，这是什么概念呢，如果我们要计算一个 512x512 的海面，我们需要执行 $512^4$ ,680 多亿次 for 循环, 电脑会被气炸的... 所以我们要优化这个算法。

说了半天也没说 FFT 到底是什么，现在终于轮到他出场了。

快速傅里叶变换 (Fast Fourier Transform, 简称 FFT)

一听名字就感觉十分的快速。这里需要注意一下我们用的是快速傅里叶逆变换 (IFFT), 然而我们一般都会说 FFT 海洋啥的，这里 FFT 主要指的是算法思想，并不是指的正变换。FFT 还有一个好处就是他可以高度进行并行运算，在加上 GPU 强大的并行运算能力，简直是量身定做。

为了便于后面的计算和推导，我们需要做一些规定。

$0\leq n'<N$ ， $n'\in(0,1,...,N-1)$

$0\leq m'<M$ ， $m'\in(0,1,...,M-1)$

为了使求和符号从 0 开始，我们需要设置两个新的参数 $n'$ 和 $m'$ 在进行等价变换。

那么$n$ 和 $m$ 就可以使用 $n'$ 和 $m'$ 来表示

$n=n'-\frac{N}{2}$

$m=m'-\frac{M}{2}$

将 $\vec k$ 也使用 $n'$ 和 $m'$ 来表示

$k_x=\frac{2\pi(n'-\frac{N}{2})}{L_x}=\frac{2\pi n'-\pi N}{L_x}$

$k_z=\frac{2\pi(m'-\frac{M}{2})}{L_z}=\frac{2\pi m'-\pi M}{L_z}$

最后海面的波高方程可以写成

$h'(x,z,t)=\sum_{m'=0}^{M-1}\sum_{n'=0}^{N-1}{\tilde{h}'(n',m',t) e^{\frac{ix(2\pi n'-\pi N)}{L_{x}}+\frac{iz(2\pi m'-\pi M)}{L_{z}}}}$

对于 $\tilde{h}'(n',m',t)$ 的推导，你可以自己直接带入就可以了，或者参考这篇文章 [Ocean simulation part one: using the discrete Fourier transform](https://www.keithlantz.net/2011/10/ocean-simulation-part-one-using-the-discrete-fourier-transform/)

我们之前说过这是一个二维的 IDFT，需要进行两次一维的 IDFT。这么看不是很直观，我们可以重新排列一下这个方程。

$h'(x,z,t)=\sum_{m'=0}^{M-1}\sum_{n'=0}^{N-1}{\tilde{h}'(n',m',t) e^{\frac{ix(2\pi n'-\pi N)}{L_{x}}}e^{\frac{iz(2\pi m'-\pi M)}{L_{z}}}}$

$h'(x,z,t)=\sum_{m'=0}^{M-1}{e^{\frac{iz(2\pi m'-\pi M)}{L_{z}}}}\left(\sum_{n'=0}^{N-1}{\tilde{h}'(n',m',t) e^{\frac{ix(2\pi n'-\pi N)}{L_{x}}}}\right)$

这回就比较清晰了，我们先对括号内的做一次 IDFT，然后将得到的结果在进行一次 IDFT。将一个二维的 IDFT 转换成了两个一维的 IDFT。

然后我们可以将这个式子拆开，拆成两个一维的 IDFT。

$h'(x,z,t)=\sum_{m'=0}^{M-1}{e^{\frac{iz(2\pi m'-\pi M)}{L_{z}}}h''(x,m',t)}$

$h''(x,m',t)=\sum_{n'=0}^{N-1}{e^{\frac{ix(2\pi n'-\pi N)}{L_{x}}}\tilde{h}'(n',m',t)}$

我们接下来只会关注 $h''(x,m',t)$ 的推导，因为 $h'(x,z,t)$ 做的和他是一样的事情。

我们会在 $(x,z) = \left(\frac{\left( n'-\frac{N}{2} \right)L_x}{N},\frac{\left( m'-\frac{M}{2} \right)L_z}{M} \right)$ 位置处生成高度场，为了便于计算推导，我们在这令 $L_x=N$ ， $L_z=M$ 。那么 $(x,z)=\left( n'-\frac{N}{2},m'-\frac{M}{2} \right)$

接着继续关注$h''(x,m',t)$ 这个式子, 使用 $N$ 将 $L_x$ 代换。

$h''(x,m',t)=\sum_{n'=0}^{N-1}{e^{\frac{ix(2\pi n'-\pi N)}{N}}\tilde{h}'(n',m',t)}$

$=\sum_{n'=0}^{N-1}{e^{\frac{i2\pi n'x}{N}}e^{-i\pi x}\tilde{h}'(n',m',t)}$

根据欧拉公式 $e^{-i\pi x}=\left( -1 \right)^x$ , 并将他提取到前面来

$=\left( -1 \right)^x\sum_{n'=0}^{N-1}{e^{\frac{i2\pi n'x}{N}}\tilde{h}'(n',m',t)}$

我们只需要进行 IDFT 后，再将结果乘上个 $\left( -1 \right)^x$ 就可以了，同样的对于 $h'(x,z,t)$ 也有个 $\left( -1 \right)^z$

$h''(x,m',t)=\left( -1 \right)^xF(u,m',t)$

我们将使用新的函数 $F(u,m',t)$ 来表示后边部分，使用参数 $u$ 来表示 $x$ ， $x=u-\frac{N}{2}$ 。 $u$ 其实就是上面计算 $(x,z)$ 位置的 $n'$ ，因为 $h''(x,m',t)$ 这里已经有一个 $n'$ 了，为了避免混淆，我们将使用 $u$ 来代替。你可以会问问什么弄的这么复杂，因为这么做都是为了向 IDFT 公式靠拢，并且能够便于我们推导 FFT

$F(u,m',t)=\sum_{n'=0}^{N-1}{e^{\frac{i2\pi n'\left( u-\frac{N}{2} \right)}{N}}\tilde{h}'(n',m',t)}$

$=\sum_{n'=0}^{N-1}{e^{\frac{i2\pi n'u-i\pi n'N}{N}}\tilde{h}'(n',m',t)}$

$=\sum_{n'=0}^{N-1}{e^{\frac{i2\pi n'u}{N}}e^{-i\pi n'}\tilde{h}'(n',m',t)}$

$=\sum_{n'=0}^{N-1}{\left( -1 \right)^{n'}e^{\frac{i2\pi n'u}{N}}\tilde{h}'(n',m',t)}$

欧，好的，如果我们不看 $\left( -1 \right)^{n'}$ ，其实就是我们上面所说的 IDFT 公式。废了这么大的劲，只是将公式化到了 IDFT 的标准形式，FFT 都还没有开始推导，接下来才是高潮。

为了使公式显得简洁一些，我们定义 $W_{N}^{n'u}=e^{\frac{i2\pi n'u}{N}}$ 。可以发现 $W_{N}^{n'u}$ 是以 $N$ 为周期， $W_{N}^{n'u+N}=W_{N}^{n'u}$ 。并且 $W_{N}^{\frac{N}{2}}=e^{\frac{i2\pi \frac{N}{2}}{N}}=e^{i\pi}=-1$ ，所以 $W_{N}^{n'u+\frac{N}{2}}=W_{N}^{n'u}W_{N}^{\frac{N}{2}}=-W_{N}^{n'u}$ 。通过这些性质我们可以看到 IDFT 计算了很多重复的项。

我们需要设 $N$ 为 2 的整数次幂，至于原因当你看完 FFT 推导就自然明白了

基于上面的性质我们将 $F(u,m',t)$ 进行奇偶划分，设

$g(n',m',t) = \tilde{h}'(2n',m',t)$

$h(n',m',t) = \tilde{h}'(2n'+1,m',t)$ ， $n'\in(0,1,2,...,\frac{N}{2}-1)$

这里的 $h$ 和我们最开始的那个函数重定义了，注意他们两个不是一个函数。

然后我们的 $F(u,m',t)$ 就可以表示为

$F(u,m',t)=\sum_{n'=0}^{N-1}{\left( -1 \right)^{n'}\tilde{h}'(n',m',t)W_{N}^{n'u}}$

这里注意一下 $\left( -1 \right)^{n'}$ ，进行奇偶划分后，他的值就可以计算出来。

$=\sum_{n'=0}^{\frac{N}{2}-1}{\tilde{h}'(2n',m',t)W_{N}^{u2n'}}-\sum_{n'=0}^{\frac{N}{2}-1}{\tilde{h}'(2n'+1,m',t)W_{N}^{u\left( 2n'+1 \right)}}$

$=\sum_{n'=0}^{\frac{N}{2}-1}{g(n',m',t)W_{\frac{N}{2}}^{un'}}-\sum_{n'=0}^{\frac{N}{2}-1}{h(n',m',t)W_{\frac{N}{2}}^{un'}W_{N}^{u}}$

$=G(u,m',t)-W_{N}^{u}H(u,m',t)$

$G$ 和 $H$ 是 $g$ 和 $h$ IDFT 后的结果。以可看到一个长度为 $N$ 的 IDFT 拆成了两个长度为 $\frac{N}{2}$ 的 IDFT，现在知道了我们为什么规定 $N$ 为 2 的整数次幂了把，这样我们就可以一直拆，拆到他最原始的样子 (库洛牌, 我现在命令你, 快点变回你原来的样子!)。

我们以 $N=8$ 的 IDFT 为例，看看我们 IFFT 是怎么计算的, 我们将数据带入。

*   $F(0,m',t)=G(0,m',t)-W_{8}^{0}H(0,m',t)$
*   $F(1,m',t)=G(1,m',t)-W_{8}^{1}H(1,m',t)$
*   $F(2,m',t)=G(2,m',t)-W_{8}^{2}H(2,m',t)$
*   $F(3,m',t)=G(3,m',t)-W_{8}^{3}H(3,m',t)$
*   $F(4,m',t)=G(4,m',t)-W_{8}^{4}H(4,m',t)$
*   $F(5,m',t)=G(5,m',t)-W_{8}^{5}H(5,m',t)$
*   $F(6,m',t)=G(6,m',t)-W_{8}^{6}H(6,m',t)$
*   $F(7,m',t)=G(7,m',t)-W_{8}^{7}H(7,m',t)$

因为 $G(u,m',t)$ 和 $H(u,m',t)$ 都是 $N=4$ 的 IDFT，所以都以 4 为周期。 $G(u+4,m',t)=G(u,m',t)$ ， $H(u+4,m',t)=H(u,m',t)$ 。还有 $W_{N}^{u}$ 的对称性， $W_{N}^{u+\frac{N}{2}}=-W_{N}^{u}$ 。所以上面的将会变成

*   $F(0,m',t)=G(0,m',t)-W_{8}^{0}H(0,m',t)$
*   $F(1,m',t)=G(1,m',t)-W_{8}^{1}H(1,m',t)$
*   $F(2,m',t)=G(2,m',t)-W_{8}^{2}H(2,m',t)$
*   $F(3,m',t)=G(3,m',t)-W_{8}^{3}H(3,m',t)$
*   $F(4,m',t)=G(0,m',t)+W_{8}^{0}H(0,m',t)$
*   $F(5,m',t)=G(1,m',t)+W_{8}^{1}H(1,m',t)$
*   $F(6,m',t)=G(2,m',t)+W_{8}^{2}H(2,m',t)$
*   $F(7,m',t)=G(3,m',t)+W_{8}^{3}H(3,m',t)$

为了更直观的观察这些数据运算，我们将使用蝶形运算来表示他们，为什么叫蝶形，当然是因为他们长的像蝴蝶 ==

![[ce6651a578b00b92e51176f72d03e30f_MD5.jpg]]

这是两种蝶形运算的表示形式。蝶形运算的左侧为输入端，右侧为输出端。 $H(0,m',t)$ 乘上个权值 (或称旋转因子) $W_{8}^{0}$ 或 $-W_{8}^{0}$ ，在与 $G(0,m',t)$ 相加就可以得到右侧输出端，第二个表示形式也是一样的。先乘 $W_{8}^{0}$ ，然后在乘 $-1$ 或 $1$ ，就可以得到右侧输出端。

下面我们用蝶形运算来吧上面的式子全部表示一下

![[ab8050c73b7b66926b5ae6eb36e6a0d0_MD5.jpg]]

然后接下来我们需要将 $G(u,m',t)$ 和 $H(u,m',t)$ 像上面一样进行奇偶拆分，设

*   $a(n',m',t)=g(2n',m',t)$
*   $b(n',m',t)=g(2n'+1,m',t)$
*   $c(n',m',t)=h(2n',m',t)$
*   $d(n',m',t)=h(2n'+1,m',t)$ ， $n'\in(0,1,2,...,\frac{N}{4}-1)$

则 $G(u,m',t)=\sum_{n'=0}^{\frac{N}{2}-1}{g(n',m',t)W_{\frac{N}{2}}^{un'}}$

$=\sum_{n'=0}^{\frac{N}{4}-1}{g(2n',m',t)W_{\frac{N}{2}}^{u2n'}}+ \sum_{n'=0}^{\frac{N}{4}-1}{g(2n'+1,m',t)W_{\frac{N}{2}}^{u\left( 2n'+1 \right)}}$

$=\sum_{n'=0}^{\frac{N}{4}-1}{a(n',m',t)W_{\frac{N}{4}}^{un'}}+ \sum_{n'=0}^{\frac{N}{4}-1}{b(n',m',t)W_{\frac{N}{4}}^{un'}W_{\frac{N}{2}}^{u}}$

$=A(u,m',t)+W_{N}^{2u}B(u,m',t)$

同理可得 $H(u,m',t)=C(u,m',t)+W_{N}^{2u}D(u,m',t)$

这样我们就将连个长度为 $\frac{N}{2}$ 的 IDFT，分解为四个个长度为 $\frac{N}{4}$ 的 IDFT。然后我们将数据代入。

*   $G(0,m',t)=A(0,m',t)+W_{8}^{0}B(0,m',t)$
*   $G(1,m',t)=A(1,m',t)+W_{8}^{2}B(1,m',t)$
*   $G(2,m',t)=A(0,m',t)-W_{8}^{0}B(0,m',t)$
*   $G(3,m',t)=A(1,m',t)-W_{8}^{2}B(1,m',t)$

*   $H(0,m',t)=C(0,m',t)+W_{8}^{0}D(0,m',t)$
*   $H(1,m',t)=C(1,m',t)+W_{8}^{2}D(1,m',t)$
*   $H(2,m',t)=C(0,m',t)-W_{8}^{0}D(0,m',t)$
*   $H(3,m',t)=C(1,m',t)-W_{8}^{2}D(1,m',t)$

然后我们用蝶形图来表示出来

![[6501ceb6620db013c4349daaf5232a33_MD5.jpg]]

我们这里 $A$ 、 $B$ 、 $C$ 和 $D$ ，可以直接由 $\tilde{h}'(n',m',t)$ 求出来。以 $A(u,m',t)$ 为例

$A(u,m',t)=\sum_{n'=0}^{\frac{N}{4}-1}{a(n',m',t)W_{\frac{N}{4}}^{un'}}$

因为$N=8$ ，所以

$=\sum_{n'=0}^{1}{a(n',m',t)W_{8}^{u4n'}}$

$=a(0,m',t)W_{8}^{0}+a(1,m',t)W_{8}^{4u}$

因为 $a(n',m',t)=g(2n',m',t)$ ， $g(n',m',t)=\tilde{h}'(2n',m',t)$

所以 $a(n',m',t)=\tilde{h}'(4n',m',t)$

所以 $A(u,m',t)=\tilde{h}'(0,m',t)+W_{8}^{4u}\tilde{h}'(4,m',t)$

同理可以得到 $B$ 、 $C$ 和 $D$ 的表达式。然后我们再将数据带入，得

*   $A(0,m',t)=\tilde{h}'(0,m',t)+W_{8}^{0}\tilde{h}'(4,m',t)$
*   $A(1,m',t)=\tilde{h}'(0,m',t)-W_{8}^{0}\tilde{h}'(4,m',t)$
*   $B(0,m',t)=\tilde{h}'(2,m',t)+W_{8}^{0}\tilde{h}'(6,m',t)$
*   $B(1,m',t)=\tilde{h}'(2,m',t)-W_{8}^{0}\tilde{h}'(6,m',t)$
*   $C(0,m',t)=\tilde{h}'(1,m',t)+W_{8}^{0}\tilde{h}'(5,m',t)$
*   $C(1,m',t)=\tilde{h}'(1,m',t)-W_{8}^{0}\tilde{h}'(5,m',t)$
*   $D(0,m',t)=\tilde{h}'(3,m',t)+W_{8}^{0}\tilde{h}'(7,m',t)$
*   $D(1,m',t)=\tilde{h}'(3,m',t)-W_{8}^{0}\tilde{h}'(7,m',t)$

这就是最后了，然后我们把一开始到最后的，全部用蝶形图来表示就会十分明了。

![[bdb0ebaa1b60040f8c16db5431e5697f_MD5.jpg]]

这就是求解 $N=8$ 的 FFT 整个流程，从左到右分为 3 个阶段，每一个阶段为后一个阶段提供数据。注意我们这里最后一个阶段的旋转因子 (权值) 是相反的，还记着我们第一次奇偶划分时的 $\left( -1 \right)^{n'}$ 么。除此之外，他和我们正常计算 FFT 都是一样的。

我们进行奇偶划分，对于长度为 $N$ 的 FFT，共可分为 $log_2N$ 个阶段，每个阶段共有 $\frac{N}{2}$ 个蝶形单元，每个蝶形单元需要进行一次复乘法和两次复加法运算。所以总共复乘法需要计算 $\frac{N}{2}log_2N$ 次，复加法需要计算 $Nlog_2N$ 次。是不是快了很多，当 $N$ 越大时这个算法带来的效率越高。如果你对这个效率收益比较迷茫时，这里贴了一个 DFT 和 FFT 的比较

![[3fd8dfa62f69f4d6cad981fab033bd7f_MD5.jpg]]

图截取自《精通 Visual C++ 数字图像处理典型算法及实现 (第二版)》，推导过程也是参照的这里。

## 3.6 如何使用 FFT

我们现在已经知道 FFT 是怎么来的了，并且迫不及待地想使用他，那我们干怎么做呢。

可以看上图，我们需要一个阶段一个阶段的计算。第一阶段将原始频谱作为输入，然后计算输出 ( $A$ 、 $B$ 、 $C$ 和 $D$ )，第一阶段全部计算完后，再开始进行第二阶段，第二阶段将第一阶段的输出作为输入进行计算，依次类推，直到把所有的阶段计算完，最后得到的就是我们想要的结果。

我们可以看到每一个阶段计算时，他们里面都是相互独立的，并没有相互影响。以第一阶段来说$A(0,m',t)$ ， $A(1,m',t)$.... $D(1,m',t)$ ，他们之间没有任何关系，是可以并行计算的，再加上 GPU 强大的并行计算能力，可以上我们的效率更上一层楼。

总结一句话就是，分阶段计算，阶段内部并行计算 (当然也可以串行计算)。

再给出实现之前，我们还需要注意一件事。眼尖的你已经发现了，对于上面的蝶形图。最左侧我们频谱的输入顺序是 (0,4,2,6,1,5,3,7) 是倒序输入，而输出是 (0,1,2,3,4,5,6,7) 是顺序输出。当然如果你的输入时顺序输入，那么在输出时必然是倒序输出。这里解释一下倒序是什么，将一个十进制转换成二进制，再将二进制码位倒序，在转成十进制，得到的就是那个十进制的倒序。

![[6dbc0d8099aaeb128e55f5f2824f8a7e_MD5.jpg]]

也是截取自《精通 Visual C++ 数字图像处理典型算法及实现 (第二版)》

杨超大佬的这篇 [fft 海面模拟（二）](https://zhuanlan.zhihu.com/p/64726720)有说明产生的原因。所以这时的我们在计算时必然要进行一次倒序操作，所以我们一般会使用 Stockham 算法，它能够顺序输入并且顺序输出，然后我们来看一下蝶形图

![[cfb8860ada29a9ddd1356902c1fc96ba_MD5.jpg]]

接下来给出在 GPU 上并行计算的伪代码

```
FFT(x,N, m, input)
{
	Ns = pow(2,m-1);
        //计算输入索引
	index = floor(x / (Ns * 2)) * Ns + x % Ns;
        //计算权值W
	angle = 2 * PI * (x / (Ns * 2));
	w = (cos(angle),sin(angle));
        //进行复数乘法，然后相加输出
	x0 = input[index];
	x1 = input[index + N / 2];
	return x0 + compldexMultiply(x1,w);
}
```

这里的 $N$ 和我们上面的是一样的，代表的是几点的 FFT。 $m$ 表示的是第几阶段。接下来我们简单的说下这代码的思路。对于每一个输出，他都是由两个输入复数，和一个权值 $W$ 构成。对于两个输入，我们只需要找到第一个输入的位置索引 index 就好，第二个复数的索引就是第一个索引再加 $\frac{N}{2}$ ，所以在一开始计算 index 就比较重要。原本是打算想说明白的，但是写了半天连自己都不知道在写什么，算了，只可意会不可言传。

这个是一维的，我们看看我们的二维频谱是怎么进行 FFT 的。

![[866bd10f21a9c58b09571c98f1098901_MD5.jpg]]

我们首先计算频谱，将得到的频谱进行横向 FFT，每一个红色的箭头代表着一次一维的 FFT，将每一行做为 FFT 的输入数据，然后在进行纵向 FFT。

## 4. 法线和泡沫的计算

对于法线的计算，可以由公式直接获得。

$\nabla h(\vec{x},t)=\sum_{k}{i\vec{k}\tilde{h}(\vec{k},t)}e^{i\vec{k}\cdot\vec{x}}$

$\vec{N}=normalize((0,1,0)-(\nabla h_x(\vec{x},t),0,\nabla h_z(\vec{x},t)))$

$=normalize(-\nabla h_x(\vec{x},t),1,-\nabla h_z(\vec{x},t))$

公式的推导可以看杨超大佬的文章，[fft 海面模拟 (一)](https://zhuanlan.zhihu.com/p/64414956)

可以看见这里也需要进行一次 FFT，我们也可以使用差分方法来求法线，虽然这样得出来并不是很精确。这里简单说明一下

![[a0c4e435a42580c72c32e743c3526dd2_MD5.jpg]]

图截取自《高等数学 第七版 下册》同济大学。

假设我们想要计算点 $M_0$ 处的法线，我们需要计算两个切向量 $T_x$ 和 $T_y$ ，然后两者叉积就可以得到我们的法线。对于求切向量就是对曲面方程求偏导就可以得到，因为我们这都是离散的点，可以直接取 $M_0$ 两侧的点，做差就可以求到。

泡沫的计算可以使用雅可比列行列式得到

$J=J_{xx}J_{zz}-J_{xz}J_{zx}$

$J_{xx}=1+\lambda\frac{\partial D_x(\vec{x},t)}{\partial x}$

$J_{zz}=1+\lambda\frac{\partial D_z(\vec{x},t)}{\partial z}$

$J_{xz}=\lambda\frac{\partial D_x(\vec{x},t)}{\partial z}=J_{zx}$

对于公式的推导同样可以参照杨超大佬的文章，当 $J<0$ 时代表波浪重叠，生成泡沫。$\lambda$ 是我们海洋的偏移程度 (挤压程度)，这里的偏导也可以像我们求法线那样求出。

## 5. 参考文献

1.  [高等数学（五）_中国大学 MOOC(慕课)](https://www.icourse163.org/learn/NUDT-42003#/learn/content?type=detail&id=1211144133&cid=1213681417)
2.  [Heinrich：傅里叶分析之掐死教程（完整版）更新于 2014.06.06](https://zhuanlan.zhihu.com/p/19763358)
3.  [如何理解傅里叶变换公式？](https://www.zhihu.com/question/19714540/answer/514107420)
4.  [傅里叶变换就是这么简单，你学会了吗?](http://k.sina.com.cn/article_6367168142_17b83468e001004j89.html?sudaref=graph.qq.com&display=0&retcode=0)
5.  [离散傅里叶变换零基础入门 - 中文 1（针对工科生，无需连续傅立叶变换知识）](https://www.bilibili.com/video/av44600709?from=search&seid=16620842320666378522)
6.  [Quick And Easy GPU Random Numbers In D3D11](http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/#wide-and-deep)
7.  《精通 Visual C++ 数字图像处理典型算法及实现 (第二版)》
8.  [基于 GPU 的连续波雷达频谱分析与谱峰搜索技术研究](http://www.doc88.com/p-4129257053463.html?tdsourcetag=s_pcqq_aiomsg)
9.  [杨超：fft 海面模拟 (一)](https://zhuanlan.zhihu.com/p/64414956)
10.  [杨超：fft 海面模拟（二）](https://zhuanlan.zhihu.com/p/64726720)
11.  [杨超：fft 海面模拟（三）](https://zhuanlan.zhihu.com/p/65156063)
12.  [音速键盘猫：Shader 相册第 6 期 --- 实时水面模拟与渲染 (一)](https://zhuanlan.zhihu.com/p/31670275)
13.  [Ocean simulation part one: using the discrete Fourier transform](https://www.keithlantz.net/2011/10/ocean-simulation-part-one-using-the-discrete-fourier-transform/)
14.  [Ocean simulation part two: using the fast Fourier transform](https://www.keithlantz.net/2011/11/ocean-simulation-part-two-using-the-fast-fourier-transform/)
15.  [《GPU Gems 1》](https://developer.nvidia.com/gpugems/GPUGems/gpugems_pref01.html)
16.  [《GPU Gems 3》](https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_pref01.html)
17.  Simulating Ocean Water_Tessendorf
18.  Ocean Surface Simulation
19.  Empirical Directional Wave Spectra for Computer Graphics
20.  Realtime GPGPU FFT Ocean Water Simulation
21.  [GX-EncinoWaves](https://github.com/speps/GX-EncinoWaves)