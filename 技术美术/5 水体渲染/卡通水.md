## 前言

今天给大家带来的案例是：用 UnityShader 写一个卡通水

先看看它长什么样：

![](https://pic4.zhimg.com/v2-d3a4b973d92e7a541d1b4acc08b8c54b_b.gif)

老规矩，先贴上教程的 Reference：

[https://roystan.net/articles/toon-water.html](https://roystan.net/articles/toon-water.html)

接下来，我会从几个方面概括实现过程：

1.  基于水深度的水着色
2.  基于 uv 的水波纹动画
3.  采样屏幕空间法线，实现**垂直与水平**水面的物体泡沫量的单独调整
4.  自定义混合模式，实现可改变的泡沫颜色
5.  用 SmoothStep 代替阈值 cutoff，实现抗锯齿

## 一、基于深度的水颜色

### 1. 相机深度 _CameraDepthTexture

**a. 获取深度纹理**

*   “_CameraDepthTexture” 这个变量对所有 Shader 全局可用，但默认是不可用的
*   这个 Demo 中，我们给主相机挂了一个脚本，用来开启这个变量

```cs
using UnityEngine;

public class CameraDepthTextureMode : MonoBehaviour 
{
    [SerializeField]
    DepthTextureMode depthTextureMode;

    private void OnValidate()
    {
        SetCameraDepthTextureMode();
    }

    private void Awake()
    {
        SetCameraDepthTextureMode();
    }

    private void SetCameraDepthTextureMode()
    {
        GetComponent<Camera>().depthTextureMode = depthTextureMode;
    }
}
```

*   之后将检查器字段设置为 Depth

![](https://pic3.zhimg.com/v2-cdfd934437ee366d68a16d01683fb8ca_b.jpg)

*   在 Shader 中，我们通过变量声明处的 “sampler2D _CameraDepthTexture” 访问相机的深度纹理

**b. 采样深度纹理**

*   深度纹理是一个全屏（full-screen）纹理，它的尺寸和我们的屏幕相同
*   所以我们使用**屏幕空间位置（ScreenPositin）**来采样这张深度纹理
*   在输出结构中声明屏幕空间位置

```
float4 screenPosition : TEXCOORD2;
```

*   在顶点着色器中计算屏幕空间位置

```
o.screenPosition = ComputeScreenPos(o.vertex);
```

*   在片元着色器中采样深度纹理

*   第一步采样深度纹理后的值是非线性的（0,1）的值，这样会造成一个问题：

*   相机近处的 1 米的深度值会比离相机远的 1 米的深度值大

*   所以，第二步我们将它非线性深度值转化为线性，以相机的世界单位计算

```
float existingDepth01 = tex2Dproj(_CameraDepthTexture, UNITY_PROJ_COORD(i.screenPosition)).r;
float existingDepthLinear = LinearEyeDepth(existingDepth01);
```

### 2. 水面深度

*   我们想要的是：刚才得到的这个屏幕空间的深度值相比水面深度有多深，所以我们还需要知道水面深度
*   水面深度就是屏幕空间位置的 w 分量，两者相减，就得到了差值

```
float waterDepth = i.screenPosition.w;    //水面深度
 float depthDifference = existingDepthLinear - waterDepth;   //两者差值
```

*   **// 阶段展示**

return depthDifference，我们看一下效果：

![](https://pic4.zhimg.com/v2-10ae60daca7a7ec250efe3c8242df6ef_r.jpg)

### 3、基于深度水着色

**a. 水颜色的原理**

*   当看向水时

*   水和地面距离近时颜色表现为浅色（绿色部分）
*   水和地面距离较远时表现为深色（红色部分）

![](https://pic1.zhimg.com/v2-82a0079c3f1c93ca61bc86b1f5126804_r.jpg)

**b. 计算水颜色**

*   我们用 Lerp 函数对 【地面附近水的颜色】 和 【水深处的颜色】 进行插值

*   用世界单位的深度除以最大深度，计算权重
*   并用 saturate 函数将他们钳制在（0,1）
*   最后用 Lerp 对两者插值

```
float waterDepthDifference01 = saturate(depthDifference / _DepthMaxDistance);
float4 waterColor = lerp(_DepthGradientShallow, _DepthGradientDeep, waterDepthDifference01);
```

*   // 阶段展示  
    此时我们就可以通过调整最大深度值参考，控制近处和远处水颜色

## 二、水波纹

### 1. 使用 Perlin Noise 添加波纹

*   我们使用柏林 noise 在水的表面添加波浪，并且用水深度来控制波浪的可见度（浅水处更明显，产生海岸线效果）

**a. 采样 noise**

```c
//声明个新属性用来读noise图
_SurfaceNoise("Surface Noise", 2D) = "white" {}

// 输入结构增加uv
float4 uv : TEXCOORD0;

// 输出结构增加uv
float2 noiseUV : TEXCOORD0;

// 使用前声明变量
sampler2D _SurfaceNoise;
float4 _SurfaceNoise_ST;//支持Tilling和offset

// 顶点着色器：传递uv，并支持Tilling和Offset
o.noiseUV = TRANSFORM_TEX(v.uv, _SurfaceNoise);

//片元着色器：采样noise
float surfaceNoiseSample = tex2D(_SurfaceNoise, i.noiseUV).r;
```

**b. 风格化波纹**

*   直接采样 noise 的效果是很辣眼睛的，我们需要再进行更卡通的改造
*   // 如果接触过卡渲风格的传统经验关照，一个思路就是将渐变过程截断成 “卡硬” 效果
*   所以这里我们设定一个阈值对上一步采样的 noise 结果进行 cutoff：

*   小于这个阈值的将会被直接舍弃（0）
*   大于这个阈值的将会被设为 1

```c
// Add as a new property.
_SurfaceNoiseCutoff("Surface Noise Cutoff", Range(0, 1)) = 0.777

// Matching property variable.
float _SurfaceNoiseCutoff;

// Add in the fragment shader, just after sampling the noise texture.
float surfaceNoise = surfaceNoiseSample > _SurfaceNoiseCutoff ? 1 : 0;
```

*   **// 阶段展示**  
    此时我们的已经可以通过调整阈值来控制还波纹

![](https://pic2.zhimg.com/v2-4de7b0ac3c48050254888d8ba91ec2dd_b.gif)

### 2. 与水相交的泡沫

*   这一步，我们实现和水面相交地方的泡沫效果
*   思路：

*   基于水深度，调整 noise 的 cutoff 阈值

```c
// Control for what depth the shoreline is visible.
_FoamDistance("Foam Distance", Float) = 0.4

// Matching variable.
float _FoamDistance;

// 片元着色器
float foamDepthDifference01 = saturate(depthDifference / _FoamDistance);
	//泡沫深度
float surfaceNoiseCutoff = foamDepthDifference01 * _SurfaceNoiseCutoff;
	//将泡沫深度乘给cutoff阈值
float surfaceNoise = surfaceNoiseSample > surfaceNoiseCutoff ? 1 : 0;
```

*   **// 阶段展示**  
    可以看到，通过调节 foam DIstance 参数，我们就可以控制和水相交物体的泡沫距离

// 例子资产中地形模型就有下凹，这一步我只是将水材质的 plane 往下移动了一下，相交就是圆形边缘

注：这里有个问题：

*   水和岸的相交点很棒，但和物体的相交处缺不明显
*   后续我们会解决

![](https://pic2.zhimg.com/v2-27ad5f6653453d2c66d94ee0aafee1b1_b.gif)

### 3. 水流动、扰动动画

接下来我们为水添加动画效果

**a. 水流动（uv 流动）**

*   思路：

*   通过_Time 参数对采样 noise 的 uv 进行偏移，实现动画效果

```c
// Property to control scroll speed, in UVs per second.
_SurfaceNoiseScroll("Surface Noise Scroll Amount", Vector) = (0.03, 0.03, 0, 0)

float2 _SurfaceNoiseScroll;

// 片元着色器
float2 noiseUV = float2(i.noiseUV.x + _Time.y * _SurfaceNoiseScroll.x, i.noiseUV.y + _Time.y * _SurfaceNoiseScroll.y);
	//偏移采样noise的uv，来产生动画效果
float surfaceNoiseSample = tex2D(_SurfaceNoise, noiseUV).r;
```

*   效果如下图

可以通过更改_SurfaceNoiseScroll 参数来控制流动方向和速度

![](https://pic4.zhimg.com/v2-5d8345e3c4011f5b196b3921106aec8f_b.gif)

**b. 水扰动**

*   思路：

*   采样一张 **distortion texture**（失真纹理），用它的信息来添加 uv 扰动
*   这张纹理类似一张法线贴图，但只有两个通道

```
// 失真纹理图
_SurfaceDistortion("Surface Distortion", 2D) = "white" {}	
// 扰动强度
_SurfaceDistortionAmount("Surface Distortion Amount", Range(0, 1)) = 0.27

// Matching variables.
sampler2D _SurfaceDistortion;
float4 _SurfaceDistortion_ST;

float _SurfaceDistortionAmount;

//输出结构里的第二套uv
float2 distortUV : TEXCOORD1;

// 顶点着色器传输
o.distortUV = TRANSFORM_TEX(v.uv, _SurfaceDistortion);

// 片元着色器：
float2 distortSample = (tex2D(_SurfaceDistortion, i.distortUV).xy * 2 - 1) * _SurfaceDistortionAmount;
	//采样失真纹理，映射到（-1,1）。并且乘上扰动强度参数
float2 noiseUV = float2((i.noiseUV.x + _Time.y * _SurfaceNoiseScroll.x) + distortSample.x,
                        (i.noiseUV.y + _Time.y * _SurfaceNoiseScroll.y) + distortSample.y);
	//给采样noise的uv添加扰动
```

*   效果如下图

*   可以看到，相对水流动，我们又增加了水的不规则扰动效果，并且可以通过参数控制扰动强度

![](https://pic3.zhimg.com/v2-71043f57c31b064a713fd715d16e5fda_b.gif)

## 三、解决和漂浮物相交泡沫不明显问题

在这一 Part，我们来解决之前提到的：和物体相交部分不明显的问题

*   **原因**：

*   岸边和水面之间的深度相当小，而水面和水下物体之间的深度（从相机的角度）相对较大。

*   **解决方法**：

*   **方案 1：**

*   将_FoamDistance 参数增加到 0.4 左右即
*   这样一来岸边的部分就太大了

![](https://pic2.zhimg.com/v2-2a6a142d557bac3c8cce3cd6e55c79b9_r.jpg)

*   **方案 2：**

*   根据**水面以下的角度**来改变**泡沫的深度（foam depth）**
*   这样一来，垂直的物体表面（和漂浮物相交部分）可以比平坦的物体表面（岸边）得到更多的泡沫（白色）

接下来就开始施行方案 2

### 1.Normal Buffer 法线缓冲区

*   法线缓冲区和深度缓冲区类似，也是一个屏幕空间大小的纹理，可以用于 shader，和深度缓冲区的区别是：它存的不是每个像素的深度，而是法线。

*   之前获取深度的 C# 脚本也能获取法线，方法是：

*   将 Depth 模式改为 Depth Normals 就能将法线和深度打包渲染到一张纹理的两个通道（一个 buffer 有两个通道）
*   但这种方法的法线精度不够，不能满足我们的需求

*   在这里，我们手动将法线渲染到一张贴图里

*   我们通过一个 C# 脚本，用一个 Replacement Shader 将法线渲染到一张名为_CameraNormalsTexture 的贴图上

*   **具体操作：**

*   将 C# 脚本挂在主相机上，并且把 Replacement Shader 给它
*   Replacement Shader 做得仅仅是: **输出 view space 的法线**

*   **效果**：

*   运行场景之后，我们可以看到在主相机的分支里自动加了一个 Normals camera
*   如果在 Scene 中查看这个自动增加的相机预览场景，就能看到渲染出来的场景的法线

![](https://pic3.zhimg.com/v2-dede4b262066f5f659dc18df3ba4ff32_b.jpg)

![](https://pic2.zhimg.com/v2-14d661970962d3ab84cfa44769a8eb11_b.jpg)

*   C# 脚本内容如下：

```
using UnityEngine;

public class NormalsReplacementShader : MonoBehaviour
{
    [SerializeField]
    Shader normalsShader;

    private RenderTexture renderTexture;
    private new Camera camera;

    private void Start()
    {
        Camera thisCamera = GetComponent<Camera>();

        // Create a render texture matching the main camera's current dimensions.
        renderTexture = new RenderTexture(thisCamera.pixelWidth, thisCamera.pixelHeight, 24);
        // Surface the render texture as a global variable, available to all shaders.
        Shader.SetGlobalTexture("_CameraNormalsTexture", renderTexture);

        // Setup a copy of the camera to render the scene using the normals shader.
        GameObject copy = new GameObject("Normals camera");
        camera = copy.AddComponent<Camera>();
        camera.CopyFrom(thisCamera);
        camera.transform.SetParent(transform);
        camera.targetTexture = renderTexture;
        camera.SetReplacementShader(normalsShader, "RenderType");
        camera.depth = thisCamera.depth - 1;
    }
}
```

*   Replacement Shader 内容如下：

```
Shader "Hidden/Roystan/Normals Texture"
{
    Properties
    {
    }
    SubShader
    {
        Tags 
		{ 
			"RenderType" = "Opaque" 
		}

        Pass
        {
            CGPROGRAM
 #pragma vertex vert
 #pragma fragment frag
 #include "UnityCG.cginc"

            struct appdata
            {
                float4 vertex : POSITION;
				float3 normal : NORMAL;
            };

            struct v2f
            {
                float4 vertex : SV_POSITION;
				float3 viewNormal : NORMAL;
            };

            sampler2D _MainTex;
            float4 _MainTex_ST;

            v2f vert (appdata v)
            {
                v2f o;
                o.vertex = UnityObjectToClipPos(v.vertex);
                o.viewNormal = COMPUTE_VIEW_NORMAL;
                return o;
            }

            float4 frag (v2f i) : SV_Target
            {
                return float4(i.viewNormal, 0);
            }
            ENDCG
        }
    }
}
```

### 2. 比较渲染的法线与 view space 的法线

**a. 计算水面的 view space 法线**

*   我们需要计算水的 view space 下的法线，来和渲染好的法线做比较

*   在输入输出结构增加相应的法线数据，并且在顶点着色器中传递给片元着色器

```
// Add to appdata.
float3 normal : NORMAL;

// Add to v2f.
float3 viewNormal : NORMAL;

// Add to the vertex shader.
o.viewNormal = COMPUTE_VIEW_NORMAL;
```

**b. 采样渲染的法线**

*   我们将之前脚本得到的法线纹理采样来读取法线

```
sampler2D _CameraNormalsTexture;

// Add to the fragment shader, just above the existing foamDepthDifference01 line.
float3 existingNormal = tex2Dproj(_CameraNormalsTexture, UNITY_PROJ_COORD(i.screenPosition));
```

**c. 作比较**

*   我们用点乘的方法对两者作比较

*   简单来说就是：0°~90° 内：当两个者夹角越小时，点乘结果就越趋近于 1；相反，就越趋近于 0

```
float3 normalDot = saturate(dot(existingNormal, i.viewNormal));
```

*   这里有一个随着两者角度，点积结果的变化图，非常有助于理解

![](https://pic3.zhimg.com/v2-f806a3321646d4f6ecc3df0e5e09a69e_b.gif)

**d. 控制泡沫量**

*   用上一步的点积结果控制与水相交时的泡沫量：

*   当点积大（接近 1）时，我们将使用比小（接近 0）时更低的泡沫阈值。

```
//用下边这两个参数代替之前声明的泡沫产生距离参数
_FoamMaxDistance("Foam Maximum Distance", Float) = 0.4
_FoamMinDistance("Foam Minimum Distance", Float) = 0.04
//声明变量
float _FoamMaxDistance;
float _FoamMinDistance;

//用Lerp插值泡沫距离，并且将它应用到之前的操作中
float foamDistance = lerp(_FoamMaxDistance, _FoamMinDistance, normalDot);
float foamDepthDifference01 = saturate(depthDifference / foamDistance);
```

**// 改善效果**

*   **注意**：**用 C# 脚本渲染的法线纹理要运行时才会生成**，所以观察是否生效 / 改善时，需要在运行状态下调整
*   可以看到，**在运行状态下**，我们可以单独调节岸边和漂浮物的泡沫量
*   // 想必大家也看到了调参数时其实是挺反人类的，这里可以做一个优化：

*   调节的参数改为 range 类型，让参数在一个范围内调节

![](https://pic1.zhimg.com/v2-73ffedd12553bd37f8edf20a040dfa04_b.gif)

##   
四、透明度

*   我们将渲染队列改为 Transparent
*   混合模式改为：Blend SrcAlpha OneMinusSrcAlpha
*   并且关闭深度写入
*   // 关于 Unity 中透明物体相关的知识，可以参考我这篇笔记

*   [https://www.yuque.com/sugelameiyoudi-jadcc/okgm7e/ua3bur](https://www.yuque.com/sugelameiyoudi-jadcc/okgm7e/ua3bur)

```
//Tags：
"Queue" = "Transparent" 
//Pass：
Blend SrcAlpha OneMinusSrcAlpha 
ZWrite Off
```

*   我们看看效果

![](https://pic4.zhimg.com/v2-8ee24429b638344f5e8ef4abac324d7f_r.jpg)

*   到此为止效果就很 ok 了，接下来我们做一些锦上添花的事情

## 五、让泡沫的颜色可控制

### 1. 增加泡沫颜色参数

*   我们声明一个 color 类型的属性，乘给最终的 surfacenoise

![](https://pic3.zhimg.com/v2-167ce84136ba4bdd3762b639ca71f7fa_r.jpg)

### 2. 理解混合模式

*   上一步的结果是：

*   可以改变颜色，但改变的结果不对

*   错误的原因出在混合模式，additive 的混合模式实际上多用于发光的特效，在这个 Demo 中是不适用的
*   **我们来看一下混合模式是如何工作的：**

*   当提供两个参数时，Blend 的工作方式是将着色器的输出乘以第一个值（SrcAlpha，或着色器输出的 alpha），将屏幕上的颜色乘以第二个值（OneMinusSrcAlpha 或 1 - 输出的 alpha），然后将两者相加得到最终颜色。

*   // 关于混合模式的更多知识就不多做整理了，自行查找资料
*   所以接下我们自定义混合方式

### 3. 自定义混合模式

*   自定义混合方式（函数）
*   混合 Alpha 通道

```
###alphaBlend函数###
float4 alphaBlend(float4 top, float4 bottom)
{
	float3 color = (top.rgb * top.a) + (bottom.rgb * (1 - top.a));
	float alpha = top.a + bottom.a * (1 - top.a);

	return float4(color, alpha);
}

###片元着色器###
float4 surfaceNoiseColor = _FoamColor;
surfaceNoiseColor.a *= surfaceNoise;	//只乘给a通道

return alphaBlend(surfaceNoiseColor, waterColor);
```

**// 效果：**

![](https://pic3.zhimg.com/v2-acaa0fffa0117f20c9e2155cd5a46b76_b.gif)

## 六、抗锯齿

*   仔细观察一下，我们能法线泡沫的边缘实际上锯齿是比较严重的。
*   锯齿严重的原因是我们 cutoff noise 的方式：**不是 0 就是 1**

![](https://pic3.zhimg.com/v2-7ce4a2334b417519d51616390237f6a6_r.jpg)

  
**解决方法**

*   使用 SmoothStep 函数将 Alpha 从 0 到 1 平滑过渡

*   smoothstep 与 lerp 有些类似。
*   它接收三个值：一个下限、一个上限和一个预期在这两个界限之间的值。
*   smoothstep 根据这第三个值在界限之间的距离，返回一个 0 到 1 的值。(如果它在下限或上限之外，smoothstep 分别返回 0 或 1）。)

*   // 关于 SmoothStep 的原理，我在这篇笔记中有详细记录

*   [https://zhuanlan.zhihu.com/p/424589478](https://zhuanlan.zhihu.com/p/424589478)

*   实现：

*   先定义一个宏，将后续使用的 SMOOTHSTEP_AA 替换为 0.01
*   注释掉之前的 cutoff 方法，改用 smoothstep 计算

*   我们定义的下限和上限（函数的前两个参数）是非常接近的
*   它们之间的距离刚好可以给边缘增加一些平滑度。
*   当 surfaceNoiseSample 超出这些界限时，它将返回 0 或 1，就像以前一样。

```
// 定义一个宏，将后续使用的SMOOTHSTEP_AA 替换为0.01
#define SMOOTHSTEP_AA 0.01

float surfaceNoise = smoothstep(surfaceNoiseCutoff - SMOOTHSTEP_AA, surfaceNoiseCutoff + SMOOTHSTEP_AA, surfaceNoiseSample);
```