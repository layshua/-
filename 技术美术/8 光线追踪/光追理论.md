
# **光线追踪**
光线追踪是和光栅化不同的着色方式

**为什么要使用光线追踪？**

光栅化不能很好的控制**全局效果**：
![[Pasted image 20221210160907.png]]
-   软阴影（光栅化虽然可以做，但不如光追简单）
-   Gossy：光滑的非玻璃镜面材质，例如光滑的金属
-   间接光照

**本课关于光线追踪的几个假设**（非物理正确）
- 光沿直线传播
- 光线与光线之间不会发生碰撞
- 光路的可逆性，光线的路径可以从眼睛到物体，也可以从物体到眼睛

## **光线投射（RayCasting）**
![[Pasted image 20221210161157.png]]
**光线投射的假设：**
-   出射点是一个点
-   光源点光源
-   场景物体中的反射为完美的镜面反射，即入射角等于出射角

**光线投射的步骤：**
-   从初射点穿过成像平面打出一根光线到场景中
-   找到与场景的最近交点（完美解决了光栅化的深度测试问题）
-   将交点和光源连接, 判断物体对光源来说是不是可见的（即是否在阴影中）
-   计算着色情况写回像素中

![[v2-33789871a86c5b76463e52b508c692dc_1440w.webp]]


## **Whitted-Style 光线追踪**
![[Pasted image 20221210161809.png]]
光线投射的光线只弹射一次，实际上光线会弹射很多次，这就引出了光线追踪。

 **Whitted-Style 光线追踪**是一种**递归光线追踪（Recursive Ray Tracing）**

-   光线不仅仅只会反射，还会折射、然后再与其他物体进行反射
-   **计算并相加所有点的颜色**，光线每次反射折射都会有能量损耗，不然经过无限 
     次的累加只会变成白色（过曝）
-   递归过程需要设置一个最大次数
-   两次反射和折射情况如下图可视
![[v2-53d9f085fe850ece368c5d018d85dbbf_1440w.webp]]

## 确定光线与物体表面的交点

### 光线方程

对于每一束光线都满足以下方程：
其中 o 为开始点，d 为方向（单位向量），t 为时间

![[Pasted image 20221210162854.png]]

求交点：
对于任何隐式的集合体，将 r (t)以 p 点带入隐式的方程中算出 f (o+td)=0 即可算出 t 求出交点。
![[v2-194d685244aaf670e9bce1664c70086a_1440w.webp]]

### 显式几何

-   几何体由若干个面组成
-   在几何体的面上判断是否与他的面相交
-   几何上的平面由一个法线和一个点 p‘表示

**已知平面上一点 p'和法线 N，如何判断点 p 是否在平面上：**
向量 p-p’与法线垂直，即 (p-p)·N = 0
由此可定义任意在平面 p’上的点，一系列点的集合就是面，所以也可以用来定义一个表面。

步骤：
-   可使用 (p-p')·N=0 表示一个平面
-   将光线方程以 p 带入光线方程中
-   求出 t 算出交点
-   判断交点在三角形的内还是外，若在内则是三角形的交点
![[Pasted image 20221210165026.png]]


### Möller Trumbore 算法

中文名： 射线三角相交算法

可以**更快的求三角形与射线的交点**

-   已知光线满足 r (t)=o+td
-   P0、P1、P2 为三角形三个顶点
-   可以得到以下等式，右边是重心坐标形式
-   通过以下 E1、E2 等的参数定义可以解出等式得到交点
-   通过重心坐标判断交点是否在三角形内：b1＞0；b2＞0；1 - b1 - b2 ＞0
![[Pasted image 20221210164908.png]]

## **光线追踪加速方法**

如果三角形面特别多，以上面的算法进行计算将会特别慢

### 轴对齐包围盒 (AABB)
Axis-Aligned Bounding Box（AABB）

- 思想：如果光线和包围盒不相交，那么更不可能和物体相交
- box 是三个对立面（三对无限大的平板，下图为其中一对）的交集，
- 轴对齐：边沿着 xyz 坐标轴
![[Pasted image 20221210165531.png]]
**如何判断光线你什么时候与 box 相交？**
-   先看**二维 bo**：分别计算光线在 x，y 平面的时间内，求交集即可得到结果

-   先判断与 x 这对面与光线相交（进和出）的时间 tmin、tmax
-   再判断 y 与光线的相交时间
-   取交集（求出 tmin 的最大值，tmax 的最小值）
![[Pasted image 20221210170221.png]]

- **三维 box 的关键思想：**
	- 光线三个对立面都满足光线进入了，才能说光线进入了 box
	- 只要离开任意对立面，就说明光线离开了 box

- **计算过程：**
	- 对每一对立面分别计算 t<sub>min</sub>和 t<sub>max</sub>
	- t<sub>enter</sub> = <font color="#ff0000">max</font>{t<sub>min</sub>}，t<sub>exit</sub> = <font color="#ff0000">min</font>{t<sub>max</sub>}
	- 如果 t<sub>enter</sub> ＜ t<sub>exit</sub>，说明光线在 box 中留存了一段时间（即相交）

-   **t 为负值的情况：**
	-   t<sub>max</sub><0 则说明 box 在光线的背面（无交点）
	-   t<sub>min</sub>>=0 且 t<sub>min</sub><0 则说明光源在 box 中（有交点）

总结：AABB 有交点当且仅当 t<sub>min</sub> < t<sub>max</sub> 且 t<sub>max</sub> >= 0

#### 轴对齐的定义

三对面的交集形成的立方体，三对面分别于 xyz 轴平行
使用包围盒包围与光一定轴对齐，减少了计算量

原始方案中：
需要 3 次减法，6 次乘法和 1 次除法。

AABB 中：
每一个轴只需要一次除法和一次减法，一共只需要 3 次减法和三次除法
![[v2-d3d5c2da31d64ed5db75a4cd8266d49d_1440w.webp]]
这么定义包围盒的好处：

只有三对面都有光线相交（进和出）时间才能证明光线已经进入包围盒
这也定义可以先判断光线是否经过该包围盒，如果不经过就不再进行更多的操作，节省了计算时间。

### 空间划分&AABB
#### AABB 的均匀划分

AABB 均匀划分的步骤：
-   1. 找到 box（最外层的正方体）
-   2. 建立网格（黑色网格）
-   3. 标记物体表面与 box 相交的网格（灰色标记）
- ![[Pasted image 20221210173123.png]]
-   4. 从光线发射方向逐个遍历网格
-   5. 将每个遍历到的网格测试与其的交点
- ![[Pasted image 20221210173553.png]]

建立网格的目的：
-   通过网格可以判断有 t<sub>min</sub>、t<sub>max</sub>
-   若有则对网格内的物体进行交点判断

网格的密度认为数量大约为 27x 物体数量
但是这种网格定义方式对物体分布不均匀的场景中不友好（即使这样的网格也很常用）因此引入空间划分来切割网格。

#### 空间划分的分类
![[Pasted image 20221210173202.png]]
八叉树：
-   八叉树是在每个子树下面画十字，划分为四块（在二维下是分为四块，三维是八块）
-   由于是均匀划分，会出现将同一个物体划分为两块的问题。

KD 树：
-   每次划分只划分为两块（类似二叉树）
-   在二维中第一次为水平的划分，第二次为竖直的，然后循环划分
-   在三维中类似，以 xyz 轴顺序进行划分
-   这样可以保证划分比较均匀
-   我们在 AABB 中主要使用 KD 树（曾经）

BSP 树：
-   划分和 kd 树类似
-   由于划分不是横平竖直的不能用于 AABB 的划分

#### KD 树

建立 KD 树
通过一次对 x, y（二维）进行递归划分，得到下面的 KD 树
![[Pasted image 20221210174330.png]]


遍历 KD 树
-   假设有一条光线射出
-   逐个对每个子树进行判断是否有与包围盒相交
-   若相交则对他的子树继续遍历知道将找到所有与光线相交的包围盒
-   将其包围盒下的物体查找交点
![[Pasted image 20221210175324.png]]

KD 树的问题：
-   难以判断物体与包围盒边界的相交问题
-   一个物体容易同时穿过多个包围盒被重复计算影响性能

因此 KD 树的应用场景越来越小。

目前广泛使用的技术名叫层次包围盒（BVH）

### 物体划分&层次包围盒（BVH）
Bounding Volume Hierarchy（BVH）

不是通过空间划分，而是通过**物体划分**。

BVH 的特点：
-   按照三角形进行划分，因此一个物体只可能出现在一个包围盒内
-   由于按照三角形进行划分，因此不会出现那一判断包围盒边界的问题
-   BVH 的思想更像**分组**，只需将三角形进行分组并对三角形较多的组进行递归分 
     组，分别计算 box
-   每次的划分都选择 XYZ 中最长的轴进行划分，这样保证划分的大小比较平均（也有其他办法）
-   总是选择中间的三角形进行划分，这样划分出来树更加接近平衡二叉树
-   划分到一个比较小的数量后停止划分（比如 5 个三角形）
 ![[Pasted image 20221210175639.png]]
**一组无序数，找到第 i 大的数，可以使用快速划分算法，时间内复杂度 O (n)。**

**BVH 的存储结构：**
- 中间节点：包围盒，子节点指针
	 - 孩子节点：包围盒，物体列表
	
BVH 的伪代码：

```c
Intersect(Ray ray, BVH node) 
{
    if (ray misses node.bbox) 
        return;//如果与节点光线都不相交就返回
    if (node is a leaf node)//如果相交且这是一个叶子节点
    {
        test intersection with all objs;//将节点内三角形都做判断
        return closest intersection;//返回最近的那个
    }
    hit1 = Intersect(ray, node.child1);//如果不是叶子节点则递归找到最近的那个
    hit2 = Intersect(ray, node.child2);
    return the closer of hit1, hit2;
}
```
