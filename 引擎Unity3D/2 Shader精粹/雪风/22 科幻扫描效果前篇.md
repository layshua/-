![[fe529498461ea9ee1e2a25a37b24cc82_MD5.webp]]

首先重建世界坐标
```c
//用深度纹理和屏幕空间uv重建像素的世界空间位置
//屏幕空间uv
float2 ScreenUV = GetNormalizedScreenSpaceUV(i.positionCS);
#if UNITY_REVERSED_Z
float depth = SampleSceneDepth(ScreenUV);
#else
float depth = lerp(UNITY_NEAR_CLIP_VALUE, 1, SampleSceneDepth(ScreenUV));
#endif

// 重建世界空间位置，注意，这里的深度为非线性深度
float3 rebuildPosWS = ComputeWorldSpacePosition(ScreenUV, depth, UNITY_MATRIX_I_VP);
```

取余数
得到世界坐标后，因为我们的坐标轴取值范围是从 -∞到 +∞，而颜色的范围只是 0-1 之间，如果对世界坐标使用 frac 取小数就可以得到只在 0-0.99 的值了
```c
return float4(frac(rebuildPosWS),1);
```

![[61fb3efd59dc2c6cf9b00ff81ee5c9b4_MD5.webp]]

取余数

对于在 0-1 之间均匀变换的我们想得到它的边界位置，所以直接来个 step 函数，我们只取 0.98 到 1.0 之间的值为 1，其他的值为 0，我们把它输出出来。是不是有那味了，线框就直接出来了。

![[89da9b0159e843562f581518306b433d_MD5.webp]]

但是这个线框的颜色红蓝绿（为什么是红蓝绿？是因为它对应 XYZ 三个轴向）很乱而且不好看，我们想要自由控制颜色，我们定义三个颜色，去分别控制 XYZ 方向的线框颜色，并把它输出。

![[248dd835198f5ef05b6c64552a6603ca_MD5.webp]]

线框颜色然后我们再看看输出后的效果如何，颜色加上 HDR 确实变漂亮了许多。

![[491827e4610af03207193f11c6a4878a_MD5.webp]]

得到正常的线框效果然后采样颜色，两者相加，即可得到正常的效果。

![[15daf97e90e4be4a42969ff2164f2944_MD5.webp]]

最后我们通过一个参数 Spacing 去控制线框的间距，Width 参数去控制线框宽度。