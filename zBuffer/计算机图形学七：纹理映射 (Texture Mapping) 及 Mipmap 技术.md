

# 1 纹理映射 TextureMapping 

首先让我们一起来观察这样一张图：

![](<images/1684499673566.png>)

无论是球上的图案，以及地板的木头纹理都呈现出了不同的颜色信息，那么回想在讲解 Blinn-Phong 反射模型的时候曾提到，一个点的颜色是由其漫反射系数决定的，反射什么颜色的光，人眼就能看见什么颜色。那么针对上面这幅图，难道要去**针对每一个点自己去设定一个颜色**吗？还是说有什么更方便的方法呢？那便是**纹理映射**了！

我们可以将三维物体上的任意一个点都映射到一个 2 维平面之上，举一个简单例子，地球仪：

![](<images/1684499673628.png>)

倘若拥有从 3 维 World space 到 2 维 Texture space 的一个映射关系，那么只需要将每个点的颜色信息即漫反射系数存储在 2 维的 Texture 之上，每次利用光照模型进行计算的时候根据映射关系就能查到这个点的漫反射系数是多少，所有点计算完之后，结果就像最左边的 screen space 之中，整个 Texture 被贴在了模型之上。


有一种特殊的纹理称为 tile，这种纹理的特征是重复拼接之后上下左右都是连续的，因此这种纹理可以复制很多张贴在墙面或地板上。

![](<images/1684499673976.png>)

一个具体的重复利用这种贴图的例子如下:

![](<images/1684499674131.png>)

最后给出一个纹理坐标使用的伪代码供参考:

![](<images/1684499674200.png>)

简而言之就是对每个光栅化的屏幕坐标算出它的 uv 坐标 (利用三角形顶点重心坐标插值)，再利用这个 uv 坐标去查询 texture 上的颜色，把这个颜色信息当作漫反射系数 Kd。

好了在理解了纹理映射的基础之后，考虑如果纹理精度特别小 (reslution 低) 或者纹理精度特别大 (reslution 大) 会分别引起什么问题呢？

# **2 纹理过小和纹理过大的问题及解决方案**

## **2.1 纹理过小引发的问题**

纹理过小的问题相对容易理解，想想我们把一张 100x100 的纹理贴图应用在一 500x500 的屏幕之上必然会导致走样失真，因为屏幕空间的几个像素点对应在纹理贴图的坐标上都是集中在一个像素大小之内。那么如果仅仅是使用对应 (u,v) 坐标在 texture 贴图下最近的那个像素点，往往会造成严重的走样。

![](<images/1684499674257.png>)

如图中红色点是屏幕空间下一像素所对应在 texture 空间中的点，会去选择离他最近的那个橙色框起来的点。

这种方法是不可取的，接下来会介绍利用双线性插值的方法缓解这种走样现象。

## **2.2 双线性插值 (Bilinear Interpolation)**

我们依然取上图的点作为例子，解释双线性插值。 第一步，取出离红色点最近的 4 个黑色顶点，分别算出，该红色点在水平及竖直方向偏移的比率 s,t，图示如下:

![](<images/1684499674313.png>)

接着先利用 s，可以线性插值出如下图所示的 u0，u1 点的颜色值

![](<images/1684499674368.png>)

那么下一步相信读者也能猜到了，利用比例 t，颜色值 u0，u1 插值出红色点的颜色值

$$f(x,y) = lerp(t,u_0,u_1)$$ 

如此这样利用两次线性插值，考虑到了所有 4 个点的颜色值，能够很好的缓解走样失真现象，并且计算速度较高。

(tips: 还有一种插值方法叫做双三次插值 (Bicubic), 是利用三次方程来进行两次插值，效果可能更好，但是计算速度很低不在这里具体讨论了)

最后以一张闫老师课上的例子看看这 3 种方法效果的对比

![](<images/1684499674429.png>)

可能会看不太清。理解个意思就好

## **2.3 纹理过大引发的问题**

可能对于我们的第一直觉来说，纹理小确实会引发问题，但是纹理大那不是更好吗，为什么会引发问题呢？但事实是纹理过大所引发的走样甚至会更加严重。 想象一张很大的地板，在上面铺满了重复的方格贴图，我们所期望看到的结果应该是这样的：

![](<images/1684499674488.png>)

嗯，非常符合透视关系，不错，当然这只是一个参考。再来看看利用在第一章所提到的计算纹理颜色的伪代码来计算的结果呢：

![](<images/1684499674550.png>)

近处锯齿！远处摩尔纹！非常严重的走样现象，为什么会导致这样的一个现象呢？这里作者尝试给出自己的两种解释:

**1 如开头所说，地板上铺满了重复的方格贴图，根据近大远小，远处的一张完整的贴图可能在屏幕空间中仅仅是几个像素的大小，那么必然屏幕空间的一个像素对应了纹理贴图上的一片范围的点，这其实就是纹理过大所导致的，直观来说想用一个点采样的结果代替纹理空间一片范围的颜色信息，必然会导致严重失真！(从信号的角度来说就是，采样频率过低无法还原信号原貌)**

**2 换一种想法，考虑离相机很远的一个三角形面，假设该三角形面真正在纹理贴图上对应的一片区域有 10 个像素点。但是由于透视的关系，距离很远的三角形面投影到近平面时可能只有 1 个或 2 个像素点的大小 (远远小于 10 个像素的原来大小)，那么这 1 个或 2 个像素采样 texture 的结果就要代表原来这个三角形面 10 个像素点的颜色信息，自然会导致失真！**

(tips: 可能有读者一开始会疑惑 (包括我也是) 为什么 1 个屏幕空间像素点覆盖多个纹理空间像素就是纹理过大呢，想象一下纹理贴图大小 500x500，屏幕空间 100x100，将屏幕空间的像素点均匀分布在纹理空间之中，那么 1 个屏幕空间像素点所占的平均大小就是 5x5=25 个纹理空间像素，因此这就是纹理过大所导致的结果)

![](<images/1684499674621.png>)

这种现象被形象的成为屏幕像素在 texture 空间的 footprint。如上图所示一个屏幕空间的蓝色像素点离相机越远，对应在 texture 空间的范围也就越大。其实也就是越来越欠采样，那么一种直观的解决方法就是 Supersampling，如果一个像素点不足以代表一个区域的颜色信息，那么便把一个像素细分为更多个小的采样点不就可以解决这个问题了吗？对，确实是这样，可以看看如下图 512x 超采样的结果

![](<images/1684499674687.png>)

效果虽称不上完美但也极大缓解了走样现象，但问题是什么？计算量太大了，一个像素点被分为了 512x512 个采样点，计算量几乎多出了 25 万倍！这显然不是所希望看到的，并且随着屏幕空间的点离相机距离更远，更多的 texels(纹理空间的像素) 会在屏幕像素的一个 footprint 里面，会要更高的超采样频率。

那么另外一种想法，如果不去超采样，仅仅是求出每个屏幕像素所对应的 footprint 里所有 texels 的颜色均值呢？这也就是接下来所要介绍的著名的 Mipmap 技术了！

## **2.3 Mipmap**

回顾一下屏幕像素在 Texture 空间里的 footprint 的这张图:

![](<images/1684499674811.png>)

正如上文所提，一个采样点的颜色信息不足以代表 “footprint” 里一个区域的颜色信息，如果可以求出这样一个区域里面所有颜色的均值，是不是就是一种可行的方法呢？没错我们的目标就是从点查询 Point Query 迈向区域查询 Range Query。但依然存在一个问题，从上图不难看出，不同的屏幕像素所对应的 footprint size 是不一样大小的，看下图这样一个例子：

![](<images/1684499674849.png>)

远处圆圈里的 footprint 必然比近处的要大，因此必须要准备不同 level 的区域查询才可以，而这正是 Mipmap。

![](<images/1684499674924.png>)

level 0 代表的是原始 texture，也是精度最高的纹理，随着 level 的提升，每提升一级将 4 个相邻像素点求均值合为一个像素点，因此越高的 level 也就代表了更大的 footprint 的区域查询。接下来要做的就是根据屏幕像素的 footprint 大小选定不同 level 的 texture，再进行点查询即可，而这其实就相当于在原始 texture 上进行了区域查询！

那么如何去确定使用哪个 level 的 texture 呢？利用屏幕像素的相邻像素点估算 footprint 大小再确定 level D！如下图:

![](<images/1684499674997.png>)

在屏幕空间中取当前像素点的右方和上方的两个相邻像素点 (4 个全取也可以)，分别查询得到这 3 个点对应在 Texture space 的坐标，计算出当前像素点与右方像素点和上方像素点在 Texture space 的距离，二者取最大值，计算公式如图中所示，那么 level D 就是这个距离的 log2 值 (D = log2L) ! 这不难理解，读者可以具体取几个例子比如 L = 1，L = 2，L = 4，看看是否符合这样的计算即可。

但是这里 D 值算出来是一个连续值，并不是一个整数，有两种对应的方法：

**1 四舍五入取得最近的那个 level D**

**2 利用 D 值在 向下和向上取整的两个不同 level 进行 3 线性插值**

第一个方法很容易理解，具体讲述一下第二个方法，如图:

![](<images/1684499675056.png>)

所谓 3 线性插值，就是在向下取整的 D level 上进行一次双线性插值 (前文提过)，再在 D+1 level 之上进行一次双线性插值，这二者数据再根据实际的连续 D 值在向下和向上取整的两个不同 level 之间的比例，再来一次线性插值，而这整体就是一个三线性插值了。

好了！根据上述的方法算出屏幕上每一个像素点所对应的 Mipmap level，再进行三线性插值得到颜色值，是否就能很好的解决走样问题了呢？很遗憾，在本文的那个地板的例子之中，费了这么大力气依然不能完美解决，如下图结果:

![](<images/1684499675124.png>)

虽然和一开始的 point sample 有了很大的进步，但是有一个严重的问题是，远处的地板产生一种过曝的现象，完全糊在了一起。该如何解决这个最后的问题呢——各向异性过滤。

## **2.4 各向异性过滤 Mipmap**

好，接着上文的远处产生过曝的问题继续来谈，产生这种现象的原因是因为，所采用的不同 level 的 Mipmap 默认的都是正方形区域的 Range Query，然而真实情况并不是如此，见下图:

![](<images/1684499675236.png>)

可以看出不同 screen space 的像素点所对应的 footprint 是不同的，有长方形，甚至是不规则图形，那么针对这种情况，有的所需要的是仅仅是水平方向的高 level，有的需要的仅仅是竖直方向上的高 level，因此这也就启发了各向异性的过滤:

![](<images/1684499675290.png>)

（个人感觉，应该是要算出水平方向的 level D0，再算一个竖直方向的 level D1，然后算根据这两个 level 去各项异性过滤的 texture 里面找一张最合适的）

利用这样不同的贴图，更加精细的选择后结果就会明显好很多:

![](<images/1684499675354.png>)

可以看出，远处过曝的现象已经大大减少了。

(Note: 其实各向异性过滤并不能解决 diagonal 的 footprint，因为各向异性只能解决水平或竖直的不同大小的矩形 footprint，所以针对 diagonal 的 footprint, 一般是去 sample 更多的点，或者提前算好 diagonal 过滤的 texture)
