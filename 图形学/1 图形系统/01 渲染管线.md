
---
title: 01 渲染管线
aliases: []
tags: []
create_time: 2023-06-19 20:09
uid: 202306192009
banner: "![[Pasted image 20230619222654.png]]"
banner_x: 0.09704
---

> [!NOTE]
> 本文是对 RTR4 和龙书渲染管线部分内容的总结
 
# 1 概述

## 关于Pipleline

当我们谈到管线时，我们指的是一个**由多个阶段组成的过程，每个阶段都完成任务的一部分**。在现实世界中，流水线的概念在许多不同的领域中都有应用，比如工厂的生产线和快餐厅的厨房等。

管线的各个阶段都是平行的，这意味着**各个阶段依次依赖于上一个阶段的输出**。理想情况下，将一个非管道系统划分为 n 个流水线阶段可以提供 n 倍的加速。这种性能提升是使用流水线的主要原因。

例如，一系列人可以快速准备大量的三明治，其中一个人负责准备面包，另一个人添加肉，另一个人添加浇头。每个人将结果传递给排队的下一个人，立即开始制作下一个三明治。如果每个人完成任务需要 20 秒，那么每 20 秒可以制作三个三明治。

管线的速度取决于管线中最慢阶段的速度，最慢的阶段被称为**瓶颈 (bottleneck)**。此时，其他的阶段会等待瓶颈的工作完成，称其他阶段此时处于 **starved** 状态。因此，优化管线中最慢的阶段可以提高整个管线的性能。

## 混乱的翻译

> [!NOTE] Pipeline 的翻译
>Pipleline 也叫流水线，图形渲染领域，更多翻译为**“管线”** , 后文也采用管线的译法。
>
>

**渲染管线（Rendering Pipeline）、图形管线、图形流水线(Graphics Pipeline)、图形渲染管线(Rendering Graphics Pipeline)** 其实是一个东西，我更习惯翻译成渲染管线。

- 对于渲染管线，将其分为**按功能阶段性划分的渲染管线**和 **GPU 硬件渲染管线**（本质相同）
- 对于更细分的渲染过程，我将其称为**渲染流程（Rendering Processing）**，如下为天涯明月刀 OL 的渲染流程。**渲染流程是个范围更大，更细节的管线。**
![[Pasted image 20230619220403.png|500]]
## 渲染管线
**渲染管线（graphics rendering pipeline）

在计算机图形学中，我们使用渲染管线来实现将 3D 场景转换成 2D 图像的过程。如果给出一台具有确定位置和朝向的摄像机以及某个场景的几何描述，那么渲染管线则是以摄像机为视角进行观察，并据此生成给定 3D 场景 2D 图像的一整套处理步骤。

具体来说，把渲染管线想象为一个工厂里的流水线，里面有不同的**加工环节（渲染阶段）**，可以根据用户需求对每个环节灵活**改造或拆卸（可编程或可配置）**，以此把**原始材料（CPU 端向 GPU 端提交的纹理等资源以及指令等）** 加工为成品出售给**消费者（在 GPU 端，资源流经流水线里的各个阶段, 经指令的调度对其进行处理，最终计算出像素的颜色，将其呈现在用户屏幕上）**。

事实上，渲染管线是种模型，将 3D 场景变换至 2D 场景的处理流程抽象分离为不同的流水线阶段，供用户使用。其本质即指令从 CPU 端的应用程序层发送至 API 运行时、驱动层及至 GPU 端（包括二者间的通信，连接都靠 PCle 接口，实质上就是围绕这种总线传递数据），资源数据在内存与显存间游走，最后是 GPU 内部各种引擎、缓存、命令队列等根据指令配合运作将数据转化为显示器可视信号。


# 按功能性阶段划分

在划分渲染管线阶段之前，首先需要区分**渲染管线的功能性阶段**和 **GPU 硬件管线阶段**区分。
- **功能性阶段是概念性的，是我们为了给一个渲染流程进行基本的功能划分而提出来的。**
- **GPU 硬件管线则是硬件层上真正用于实现上述功能的流水线**。
- 一个图形单元 / Core 可能处理多个功能性阶段，一个功能性阶段可能也会拆分成几个硬件单元。

实时渲染管线（real-time rendering pipeline）一般分为如下四个功能性阶段：**应用程序阶段 (Application)**、**几何处理阶段 (Geometry Processing)**、**光栅化阶段 (Rasterization)** 和**像素处理阶段 (Pixel Processing)**。
- **这些阶段中的每个阶段本身也可以是一条管线**（如本书描述的几何处理阶段），这意味着它会由几个子阶段组成。
- 这些阶段也可以是（部分的）并行化阶段（如本书描述的像素处理阶段）
- 本书中应用程序阶段是单个过程，但是该阶段也可以进行管线化或并行化。
- 需要注意的是，光栅化阶段可以调用到图元（如三角形）内部的像素。

![[Pasted image 20230619202118.png|450]]

细节：
![](<images/1683366278896.png>)
## 1 应用程序阶段 

> [!NOTE] 关联
> 产生 DrawCall


> [!summary] 任务
> **主要任务**：输入装配
> **其他任务**：粗粒度剔除 (将完全不可见的物体剔除)，碰撞检测、处理其他源输入 (键盘、鼠标等)、加速算法...

应用程序阶段是**完全可控制**的，因为它**在 CPU 上执行**。并且可以在之后对它进行修改以提高性能表现，另外，此处的修改也会影响后续阶段的性能表现。

输入装配阶段会从显存中读取几何数据 (顶点和索引)，再将它装配为**几何图元 (geometry primitive)**。简单来说，应用程序阶段通过索引将顶点装配在一起，构成图元传递给几何处理阶段。图元拓扑可以分为：点列表，线条带，线列表，三角形带和三角形列表。这通常在多个处理器核心上执行，被称为**超标量结构 (superscalar construction)**。


另外，应用程序阶段也可以通过计算着色器在 GPU 上运行。

> [!quote] compute shader
> 某些应用程序阶段的工作可以由 GPU 执行，使用一种被称为计算着色器（compute shader）的单独模式。此模式会将 GPU 视为高度并行的通用处理器，而忽略它专门用于渲染图形的特殊功能。

## 2 几何处理阶段

> [!NOTE] 关联
> 该阶段涉及 [[02 视图变换]]

> [!summary] 任务
> **把顶点坐标变换到屏幕空间中，再交给光栅器进行处理**
> 通过对输入的渲染图元进行多步处理后，这一阶段将会输出屏幕空间的二维顶点坐标、每个顶点对应的深度值、着色等相关信息，并传递给光栅化阶段。

**几何处理阶段在 GPU 上运行，它处理应用程序阶段发送的渲染图元，负责大部分的逐三角形和逐顶点操作。**

几何处理阶段可以细分为 4 个子阶段：**顶点着色阶段 (Vertex Shading)**，**投影阶段 (Projection)**，**裁剪阶段 (Clipping)** 和**屏幕映射阶段 (Screen Mapping)**。

![[1683366277741.png]]

### 顶点着色阶段

> [!NOTE] 关联
> 该阶段涉及**顶点着色器、曲面细分着色器、几何着色器 **
> [[第三章 进阶应用#3.3 曲面细分与几何着色器]]


> [!summary] 任务
> **主要任务：**
>1. 计算顶点位置，通过 MVP 矩阵从模型空间变换到齐次裁剪空间
>2. 传递后续流水线需要的用来插值的数据，如法线和纹理坐标

完成顶点着色阶段的两个主要任务后，在 GPU 上可以按照以下顺序进行几个**可选阶段**：**曲面细分**（tessellation），**几何着色**（geometry shading）和**流输出**（stream output）。
并不是所有 GPU 都支持它们，它们彼此独立，并且一般来说不常用

剩下三个阶段不再赘述，就是在执行视图变换的过程。
## 3 光栅化阶段


> [!summary] 任务
> 根据几何处理阶段传来的经过变换和投影的顶点及其关联的着色数据，找到需要渲染的图元（例如一个三角形）内的所有像素。
>

光栅化阶段**在 GPU 上执行**。

光栅化阶段的目标是找到处于图元 (三角形) 内部的所有像素，进而将 2D 坐标顶点转为屏幕上的像素，**每个像素附带深度和其他着色信息，它们一并传入 pixel**。它需要对上一个阶段得到的逐顶点数据 (例如纹理坐标 、顶点颜色等) 进行插值，然后再进行逐像素处理。

光栅化阶段分为两个子阶段：**三角形设置 (Triangle Setup)** 和**三角形遍历 (Triangle Traversal)**。

![[Pasted image 20230619204802.png]]
### 三角形设置阶段

计算三角形网格信息，例如三角形顶点坐标和边界表达式。

**edge 函数**用于确定一个像素中心或其他 sampler 是否在一个三角形内，硬件上会对每个三角形边缘应用一个 edge 函数，它基于直线方程。

![](<images/1683366278256.png>)

GPU 会在三角形设置阶段计算三角形上的常数因子，以便三角形遍历阶段能够有效地进行 (edge 方程的 a, b, c 常量)。并且，还会计算与属性插值相关的常量。 总之，它就是处理前面阶段传递的数据，为三角形遍历阶段做准备。

### 三角形遍历阶段

> [!NOTE] 关联
>1. 采样
> 2. 透视校正插值（perspective-correct interpolation）也发生在该阶段

> [!summary] 任务
> 检查像素是否在三角形内（采样），如果在的话就会生成一个**片元 (fragment)**。
> 判断方法有多种，由程序员决定。

找到哪些像素被三角网格覆盖的过程就是三角形遍历，这个阶段也被称为**扫描变换 (Scan Conversion)** 。

在三角形遍历阶段，片元的几何处理阶段传递的值会进行插值。GPU 采用**重心坐标系**来对值进行插值。重心坐标系的性质是，每个值的系数与三角形重心坐标顶点系数相同。因此，GPU 可以通过插值顶点的值来计算任意像素的值，并且这些值在三角形内部会进行插值计算。 重心坐标插值的具体计算这里就不展开了。

![](<images/1683366278379.png>)

## 4 像素处理阶段

> [!summary] 任务
> 处理光栅化阶段发送过来的在图元内部的片元序列。GPU 会对每个片元进行像素操作，如颜色和深度的计算、纹理采样、混合等。最终，这些像素被组合成最终的图像。

像素处理阶段**在 GPU 上执行**，它主要

像素处理阶段可以分为两个子阶段：**像素着色阶段 (Pixel Shading)** 和**合并阶段 (Merging)**。

![[Pasted image 20230619204802.png]]

### 像素着色阶段

> [!NOTE] 关联
> 该阶段使用像素着色器


> [!summary] 任务
> 使用光栅化阶段传递的插值后的数据以及纹理计算像素颜色，将计算的颜色传递给合并阶段


![](<images/1683366278498.png>)

需要注意的是，纹理可以认为是一种独立于” 插值 “数据的一种资源。由于顶点和像素着色器一般数据都存在更小更快的 **L1 缓存 (L1 Cache)** 中，但纹理存储在更大更慢的 **L2 缓存 (L2 Cache)** 中，因此 **Warp**(线程组，可以简单认为 Shader 程序通过 Warp 单元指令执行)中的指令可以分为两种，不产生延迟的 (寄存器的算数运算) 和产生延迟的(纹理访问)。 为了高效的并行，需要克服内存读取延迟。每个片元的本地寄存器会留出一点存储空间。Warp 首先执行不产生延迟的指令，并将结果存储在 LD/ST 单元中。当遇到产生延迟的指令时，快速切换到其他片元执行其他任务。这个过程会递归进行，直到最后一个片元。然后返回到第一个片元，取出产生延迟指令的结果。 如果 Shader 中使用的寄存器越多，Warp 留给片元的空间就越少。当遇到内存延迟时，可能会出现没有可切换的 Warp 而被迫等待的情况，这种情况称为占用率过高。

### 合并阶段

> [!NOTE] 关联
> 深度测试
> 模板测试
> 混合
> 缓冲区

> [!summary] 任务
> **将像素着色阶段产生的片元颜色与当前存储在缓冲区中的颜色进行组合**
>1.  决定每个片元的可见性。这涉及了很多测试工作，例如深度测试、模板测试等。
[[第三章 进阶应用#3.1.1 StencilTest 模板测试]] 
[[第三章 进阶应用#3.1.2 深度测试]]
> 
>2. 如果一个片元通过了所有的测试，就需要把这个片元的颜色值和已经存储在颜色缓冲区中的颜色进行合并，或者说是混合。
[[第三章 进阶应用#3.2 混合模式及剔除]]

合并阶段，又称 **ROP 阶段**，代表 “光栅操作管线”（raster operations pipeline）或 “渲染输出单元”（render output unit）。

与着色阶段不同，**执行此阶段的 GPU 子单元通常不是完全可编程的**。但是，它是**高度可配置**的，可实现各种效果。

**通过一系列测试决定每个片元的可见性：**

![[Pasted image 20221030230409.jpg]]

流程：
-   **像素所有权测试→裁剪测试→透明度测试→模板测试→深度测试→透明度混合**

-   **PixelOwnershipTest（像素所有权测试）：**
-   简单来说就是控制当前屏幕像素的使用权限
-   举例：比如 unity 引擎中仅渲染 scene 和 game 窗口，即只对 scene 和 game 窗口部分的像素具有使用权限

-   **ScissorTest（裁剪测试）：**
-   在渲染窗口再定义要渲染哪一部分，默认全部渲染，可以自己控制。
-   和裁剪空间一起理解，也就是只渲染能看到的部分
-   举例：只渲染窗口的左下角部分

-   **AlphaTest（透明度测试）**
-   提前设置一个透明度阈值
-   只能实现不透明效果和全透明效果
-  举例：设置透明度 a 为 0.5，如果片元大于这个值就通过测试，如果小于 0.5 就剔除掉


-   **StencilTest（模板测试）**

-   **DepthTest（深度测试）**

-   **Blending（透明度混合）**
-   可以实现半透明效果

-   完成接下来的其他一系列操作后，我们会将合格的片元/像素输出到**帧缓冲区（FrameBuffer）**，最后渲染到屏幕上。


我们的屏幕显示的就是颜色缓冲区中的颜色值。但是，为了避免我们看到那些正在进行光栅化的图元，GPU 会使用**双重缓冲 (Double Buffering)** 的策略。这意味着，场景的渲染发生在后台缓冲区的屏幕外，即在**后置缓冲 (Back Buffer)** 中。一旦场景已经被渲染到了后置缓冲中， GPU 就会交换后置缓冲区和**前置缓冲 (Front Buffer)** 中的内容，而前置缓冲区是之前显示在屏幕上的图像。由此，保证了我们看到的图像总是连续的。

帧缓冲区（framebuffer）通常由系统上的所有缓冲区组成。
# GPU 硬件渲染管线
DX12 的硬件管线：
[[DX12理论#3 渲染管线]] 


# DrawCall 在渲染管线中的作用

DrawCall 是指在应用程序阶段生成的渲染命令，用于绘制一个或多个图元 (如三角形) 的请求。每个 DrawCall 包含了一组渲染状态 (如渲染目标、着色器程序、纹理等) 和要渲染的几何数据。 DrawCall 在**应用程序阶段**生成。在应用程序阶段，应用程序通过调用图形 API 发送渲染命令给图形硬件。这些渲染命令包括绘制调用，即 DrawCall。

具体来说，DrawCall 在渲染管线的不同阶段起着不同的作用：

*   应用程序阶段：应用程序将准备好的几何数据 (如顶点坐标、纹理坐标等) 和渲染状态 (如光照、材质属性等) 通过 DrawCall 发送给图形硬件。应用程序阶段的 DrawCall 将几何数据传递到下一个阶段，即几何处理阶段。
*   几何处理阶段：在几何处理阶段，图形硬件对传入的几何数据进行处理，执行顶点着色器、图元装配和裁剪等操作。每个 DrawCall 会经过几何处理阶段的处理，生成裁剪后的几何图元。
*   光栅化阶段：在光栅化阶段，裁剪后的几何图元被转换为屏幕上的像素。这个阶段包括三角形光栅化、像素插值和面剔除等操作。每个 DrawCall 生成的几何图元会经过光栅化阶段的处理，生成覆盖屏幕上像素的片段。
*   像素处理阶段：像素处理阶段是渲染管线的最后一个阶段。在像素处理阶段，对每个片段进行像素着色器的计算，确定最终像素的颜色、深度和其他属性。每个 DrawCall 生成的片段会经过像素处理阶段的处理，最终输出到帧缓冲中。

DrawCall 与性能息息相关。例如一个场景中有两个小人，如果在应用程序阶段分别导入，那么就会产生两次 DrawCall。如果将它们**合并 (Batch)**，则只会产生一次 Drawcall。 DrawCall 批次太多会导致 CPU 性能开销过大，一般来说有两种解决方法： - 合批，把模型合成一个大 mesh。 - GPU Instance，用于绘制重复的模型。只需要提交一次模型数据，通过在 GPU 中对 buffer 进行偏移获取本次绘制的计算数据。

