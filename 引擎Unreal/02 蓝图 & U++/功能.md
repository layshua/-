


# 事件

## Actor
虚幻引擎 Actor 有一组类似于 Unity 的 `Start` 、 `OnDestroy` 和 `Update` 函数的方法。如下所示：

```c++
UCLASS()
class AMyActor : public AActor
{
    GENERATED_BODY()

    // 游戏开始时调用。
    void BeginPlay();

    // 销毁时调用。
    void EndPlay(const EEndPlayReason::Type EndPlayReason);

    // 每帧调用以更新此Actor。
    void Tick(float DeltaSeconds);
};
```

![](https://docs.unrealengine.com/5.2/Images/understanding-the-basics/unreal-engine-for-unity-developers/image_29.jpg)

## 组件
虚幻引擎中的组件包含不同的函数。下面是一个基本示例：

```c++
UCLASS()
class UMyComponent : public UActorComponent
{
    GENERATED_BODY()

    // 在创建所属Actor之后调用
    void InitializeComponent();

    // 在销毁组件或所属Actor时调用
    void UninitializeComponent();

    // 组件版的Tick函数
    void TickComponent(float DeltaTime, enum ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction);
};
```

![](https://docs.unrealengine.com/5.2/Images/understanding-the-basics/unreal-engine-for-unity-developers/image_30.jpg)

记住，在虚幻引擎中，你必须调用方法的父类版本。

例如，在 Unity C# 中，可能是调用 `base.Update()`，但在虚幻引擎 C++ 中，你将使用 `Super::TickComponent()`：

```c++
void UMyComponent::TickComponent(float DeltaTime, enum ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)
{
    // 此处添加自定义更新内容
    Super::TickComponent(DeltaTime, TickType, ThisTickFunction);
}
```

在 C++ 中，一些类使用以 `A` 开头，而另一些类以 `U` 开头。`A` 表示 Actor 子类，而 `U` 表示 **Object** 子类。另一个常用前缀是 `F` ，它用于大部分普通数据结构和非 UObject 类。

# 游戏逻辑
## 实例化 GameObject / 生成 Actor

在 Unity 中，你会使用 `Instantiate` 函数创建对象的新实例。此函数可以获取任意 `UnityEngine.Object` 类型（GameObject、MonoBehaviour 等），并创建其副本。

    public GameObject EnemyPrefab;
    public Vector3 SpawnPosition;
    public Quaternion SpawnRotation;

    void Start()
    {
        GameObject NewGO = (GameObject)Instantiate(EnemyPrefab, SpawnPosition, SpawnRotation);
        NewGO.name = "MyNewGameObject";
    }

虚幻引擎有两个不同的函数来实例化对象：

- `NewObject` 用于创建新的 `UObject` 类型。
    
- `SpawnActor` 用于生成 `AActor` 类型。
    

## UObject 和 NewObject

在虚幻引擎中创建 `UObject` 的子类与在 Unity 中创建 `ScriptableObject` 的子类非常类似。对于不需要生成到世界中或像 Actor 那样绑定了组件的 Gameplay 类，这些很有用。

在 Unity 中，如果你创建自己的 `ScriptableObject` 子类，你会如下所示将其实例化：

    MyScriptableObject NewSO = ScriptableObject.CreateInstance<MyScriptableObject>();

在虚幻引擎中，如果你创建自己的 `UObject` 派生类型，你可以如下所示将其实例化：

    UMyObject* NewObj = NewObject<UMyObject>();

## AActor 和 SpawnActor

Actor 使用 World（C++ 中的 `UWorld`）对象上的 `SpawnActor` 方法生成。一些 UObject 提供了 `GetWorld` 方法（例如，所有 Actor 都如此）。你会采用此方法获取 World 对象。

请注意，在下面的示例中，我们传入了我们想生成的 Actor 的类，而不是传入另一个 Actor。在我们的示例中，该类可以是 AMyEnemy 的任意子类。

要是你想创建另一个对象的副本，就像在 Unity 的 Instantiate 函数那样，你该怎么做呢？

`NewObject` 和 `SpawnActor` 函数也能给一个 "模板" 对象来工作。虚幻引擎将创建该对象的副本，而不是从头创建新对象。这将复制其所有 UPROPERTY 和组件。

    AMyActor* CreateCloneOfMyActor(AMyActor* ExistingActor, FVector SpawnLocation, FRotator SpawnRotation)
    {
        UWorld* World = ExistingActor->GetWorld();
        FActorSpawnParameters SpawnParams;
        SpawnParams.Template = ExistingActor;
        World->SpawnActor<AMyActor>(ExistingActor->GetClass(), SpawnLocation, SpawnRotation, SpawnParams);
    }

你可能会好奇这里的 "从头开始" 到底是什么意思。你创建的每个对象类都有一个默认模板，其中包含其属性和组件的默认值。如果你不覆盖这些属性，也没有提供你自己的模板，虚幻引擎将使用这些默认值来构造你的对象。为了更好地说明这一点，我们首先来看一下 MonoBehaviour 示例：

    public class MyComponent : MonoBehaviour
    {
        public int MyIntProp = 42;
        public SphereCollider MyCollisionComp = null;

        void Start()
        {
            // 如果尚无碰撞组件，则进行创建
            if (MyCollisionComp == null)
            {
                MyCollisionComp = gameObject.AddComponent<SphereCollider>();
                MyCollisionComp.center = Vector3.zero;
                MyCollisionComp.radius = 20.0f;
            }
        }
    }

在上面的示例中，我们有一个默认为 42 的 `int` 属性，以及默认为半径 20 的 `SphereCollider` 组件。

我们可以在虚幻引擎中使用对象的构造函数实现相同的效果：

    UCLASS()
    class AMyActor : public AActor
    {
        GENERATED_BODY()

        UPROPERTY()
        int32 MyIntProp;

        UPROPERTY()
        USphereComponent* MyCollisionComp;

        AMyActor()
        {
            MyIntProp = 42;

            MyCollisionComp = CreateDefaultSubobject<USphereComponent>(FName(TEXT("CollisionComponent"));
            MyCollisionComp->RelativeLocation = FVector::ZeroVector;
            MyCollisionComp->SphereRadius = 20.0f;
        }
    };

在构造函数 `AMyActor` 中，我们为这个类设置了属性的默认值。请注意 `CreateDefaultSubobject` 函数的用法，我们可以使用此函数创建组件并向其分配默认属性。使用此函数创建的所有子对象都充当默认模板，因此我们可以在子类或蓝图中修改它们。

## 类型转换

在此例中，我们获取了一个已知的组件，将其转换为特定类型，然后判断能否执行一些操作。

**Unity C#**

    Collider collider = gameObject.GetComponent<Collider>;
    SphereCollider sphereCollider = collider as SphereCollider;
    if (sphereCollider != null)
    {
            // ...
    }

**虚幻引擎 C++**

    UPrimitiveComponent* Primitive = MyActor->GetComponentByClass(UPrimitiveComponent::StaticClass());
    USphereComponent* SphereCollider = Cast<USphereComponent>(Primitive);
    if (SphereCollider != nullptr)
    {
            // ...
    }

## 销毁 GameObject/Actor

MyActor->Destroy();

## 销毁 GameObject/Actor（延迟 1 秒）

MyActor->SetLifeSpan(1);

## 禁用 GameObject/Actor

// 隐藏可见组件
    MyActor->SetActorHiddenInGame(true);

    // 禁用碰撞组件
    MyActor->SetActorEnableCollision(false);

    // 禁止Actor更新
    MyActor->SetActorTickEnabled(false);

## 从组件访问 GameObject/Actor

AActor* ParentActor =
     MyComponent->GetOwner();

## 从 GameObject/Actor 访问组件

**Unity C#**

    MyComponent MyComp = gameObject.GetComponent<MyComponent>();

**虚幻引擎 C++**

    UMyComponent* MyComp = MyActor->FindComponentByClass<UMyComponent>();

**蓝图**

![](https://docs.unrealengine.com/5.2/Images/understanding-the-basics/unreal-engine-for-unity-developers/image_33.jpg)

] 点击查看大图。

## 查找 GameObject/Actor

**Unity C#**

// 按名称查找 GameObject

    GameObject MyGO = GameObject.Find("MyNamedGameObject");

    // 按类型查找Object
    MyComponent[] Components = Object.FindObjectsOfType(typeof(MyComponent)) as MyComponent[];
    foreach (MyComponent Component in Components)
    {
            // ...
    }

    // 按标签查找GameObject
    GameObject[] GameObjects = GameObject.FindGameObjectsWithTag("MyTag");
    foreach (GameObject GO in GameObjects)
    {
            // ...
    }

**虚幻引擎 C++**

    // 按名称查找Actor（也适用于UObject）
    AActor* MyActor = FindObject<AActor>(nullptr, TEXT("MyNamedActor"));

    // 按类型查找Actor（需要UWorld对象）
    for (TActorIterator<AMyActor> It(GetWorld()); It; ++It)
    {
            AMyActor* MyActor = *It;
            // ...
    }

**蓝图**

![](https://docs.unrealengine.com/5.2/Images/understanding-the-basics/unreal-engine-for-unity-developers/image_14.jpg)

**虚幻引擎 C++**

    // 按类型查找UObject
    for (TObjectIterator<UMyObject> It; It; ++it)
    {
        UMyObject* MyObject = *It;
        // ...
    }

    // 按标签查找Actor（也适用于ActorComponent，需要改用TObjectIterator）
    for (TActorIterator<AActor> It(GetWorld()); It; ++It)
    {
        AActor* Actor = *It;
        if (Actor->ActorHasTag(FName(TEXT("Mytag"))))
        {
            // ...
        }
    }

**蓝图**

![](https://docs.unrealengine.com/5.2/Images/understanding-the-basics/unreal-engine-for-unity-developers/image_15.jpg)

## 向 GameObject/Actor 添加标签

**Unity C#**

    MyGameObject.tag = "MyTag";

**虚幻引擎 C++**

    // Actor可以有多个标签
    MyActor.Tags.AddUnique(TEXT("MyTag"));

**蓝图**

![](https://docs.unrealengine.com/5.2/Images/understanding-the-basics/unreal-engine-for-unity-developers/image_16.jpg)

## 向 MonoBehaviour/ActorComponent 添加标签

**Unity C#**

    // 这会更改它绑定到的GameObject上的标签
    MyComponent.tag = "MyTag";

**虚幻引擎 C++**

    // 组件有自己的标签数组
    MyComponent.ComponentTags.AddUnique(TEXT("MyTag"));

## 比较 GameObject/Actor 和 MonoBehaviour/ActorComponent 上的标签

**Unity C#**

    if (MyGameObject.CompareTag("MyTag"))
    {
        // ...
    }

    // 检查它绑定到的GameObject上的标签
    if (MyComponent.CompareTag("MyTag"))
    {
        // ...
    }

**虚幻引擎 C++**

    // 检查某个Actor是否有此标签
    if (MyActor->ActorHasTag(FName(TEXT("MyTag"))))
    {
        // ...
    }

**蓝图**

![](https://docs.unrealengine.com/5.2/Images/understanding-the-basics/unreal-engine-for-unity-developers/image_17.jpg)

**虚幻引擎 C++**

    // 检查某个ActorComponent是否有此标签
    if (MyComponent->ComponentHasTag(FName(TEXT("MyTag"))))
    {
        // ...
    }

**蓝图**

![](https://docs.unrealengine.com/5.2/Images/understanding-the-basics/unreal-engine-for-unity-developers/image_18.jpg)

### 物理：刚体与图元组件

在 Unity 中，假如要为 GameObject 赋予物理特征，首先必须为其提供刚体组件。

在虚幻引擎中，任何图元组件（C++ 中的 `UPrimitiveComponent`）都可以是物理对象。一些常见图元组件如下：

- 形状组件（胶囊体、球体和盒体）
    
- 静态网格体组件
    
- 骨骼网格体组件
    

Unity 将碰撞和可视性划分到不同的组件中，虚幻引擎则将 "潜在的物理碰撞" 和 "潜在的可视效果" 组合到了单个图元组件中。凡是在世界中具有形状的组件，只要能通过物理方式渲染或交互，都是 `PrimitiveComponent` 的子类。

### 层与通道

虚幻引擎中的碰撞通道对应 Unity 中的层。如需详细信息，请参阅[碰撞过滤](https://www.unrealengine.com/en-US/blog/collision-filtering?sessionInvalidated=true)。

### RayCast 与 RayTrace

**Unity C#**

    GameObject FindGOCameraIsLookingAt()
    {
        Vector3 Start = Camera.main.transform.position;
        Vector3 Direction = Camera.main.transform.forward;
        float Distance = 100.0f;
        int LayerBitMask = 1 << LayerMask.NameToLayer("Pawn");

        RaycastHit Hit;
        bool bHit = Physics.Raycast(Start, Direction, out Hit, Distance, LayerBitMask);

        if (bHit)
        {
            return Hit.collider.gameObject;
        }

        return null;
    }

#### 虚幻引擎 C++

    APawn* AMyPlayerController::FindPawnCameraIsLookingAt()
    {
        // 你可以在这里自定义有关追踪的各种属性
        FCollisionQueryParams Params;
        // 忽略玩家的Pawn
        Params.AddIgnoredActor(GetPawn());

        // 击中结果由线路追踪填充
        FHitResult Hit;

        // 来自摄像机的Raycast，仅与Pawn碰撞（它们在ECC_Pawn碰撞通道上）
        FVector Start = PlayerCameraManager->GetCameraLocation();
        FVector End = Start + (PlayerCameraManager->GetCameraRotation().Vector() * 1000.0f);
        bool bHit = GetWorld()->LineTraceSingle(Hit, Start, End, ECC_Pawn, Params);

        if (bHit)
        {
            // Hit.Actor包含指向追踪所击中的Actor的弱指针
            return Cast<APawn>(Hit.Actor.Get());
        }

        return nullptr;
    }

**蓝图**

[](https://docs.unrealengine.com/5.2/Images/understanding-the-basics/unreal-engine-for-unity-developers/image_19.png)

[![](https://docs.unrealengine.com/5.2/Images/understanding-the-basics/unreal-engine-for-unity-developers/image_19.jpg)](https://docs.unrealengine.com/5.2/Images/understanding-the-basics/unreal-engine-for-unity-developers/image_19.png)

点击查看大图。

### 触发器体积

**Unity C#**

    public class MyComponent : MonoBehaviour
    {
        void Start()
        {
            collider.isTrigger = true;
        }
        void OnTriggerEnter(Collider Other)
        {
            // ...
        }
        void OnTriggerExit(Collider Other)
        {
            // ...
        }
    }

#### 虚幻引擎 C++

    UCLASS()
    class AMyActor : public AActor
    {
        GENERATED_BODY()

        // 我的触发器组件
        UPROPERTY()
        UPrimitiveComponent* Trigger;

        AMyActor()
        {
            Trigger = CreateDefaultSubobject<USphereComponent>(TEXT("TriggerCollider"));

            // 两个碰撞物都需要将此项设置为true，才能触发事件
            Trigger.bGenerateOverlapEvents = true;

            // 设置碰撞物的碰撞模式
            // 此模式仅为光线投射、扫描和重叠启用碰撞物
            Trigger.SetCollisionEnabled(ECollisionEnabled::QueryOnly);
        }

        virtual void NotifyActorBeginOverlap(AActor* Other) override;

        virtual void NotifyActorEndOverlap(AActor* Other) override;
    };

#### 虚幻引擎蓝图

![](https://docs.unrealengine.com/5.2/Images/understanding-the-basics/unreal-engine-for-unity-developers/image_20.jpg)

如需详细了解如何设置碰撞响应，请参阅[碰撞](https://docs.unrealengine.com/5.2/zh-CN/collision-in-unreal-engine)页面。

### 刚体运动

**Unity C#**

    public class MyComponent : MonoBehaviour
    {
        void Start()
        {
            rigidbody.isKinematic = true;
            rigidbody.velocity = transform.forward * 10.0f;
        }
    }

在虚幻引擎 4 中，碰撞组件和刚体组件是同一个组件。其基类是 `UPrimitiveComponent`，它有许多子类（`USphereComponent`、`UCapsuleComponent` 等）可满足你的需要。

**虚幻引擎 C++**

    UCLASS()
    class AMyActor : public AActor
    {
        GENERATED_BODY()

        UPROPERTY()
        UPrimitiveComponent* PhysicalComp;

        AMyActor()
        {
            PhysicalComp = CreateDefaultSubobject<USphereComponent>(TEXT("CollisionAndPhysics"));
            PhysicalComp->SetSimulatePhysics(false);
            PhysicalComp->SetPhysicsLinearVelocity(GetActorRotation().Vector() * 100.0f);
        }
    };

### 输入事件

**Unity C#**

    public class MyPlayerController : MonoBehaviour
    {
        void Update()
        {
            if (Input.GetButtonDown("Fire"))
            {
                // ...
            }
            float Horiz = Input.GetAxis("Horizontal");
            float Vert = Input.GetAxis("Vertical");
            // ...
        }
    }

**虚幻引擎 C++：**

    UCLASS()
    class AMyPlayerController : public APlayerController
    {
        GENERATED_BODY()

        void SetupInputComponent()
        {
            Super::SetupInputComponent();

            InputComponent->BindAction("Fire", IE_Pressed, this, &AMyPlayerController::HandleFireInputEvent);
            InputComponent->BindAxis("Horizontal", this, &AMyPlayerController::HandleHorizontalAxisInputEvent);
            InputComponent->BindAxis("Vertical", this, &AMyPlayerController::HandleVerticalAxisInputEvent);
        }

        void HandleFireInputEvent();
        void HandleHorizontalAxisInputEvent(float Value);
        void HandleVerticalAxisInputEvent(float Value);
    };

**蓝图**

![](https://docs.unrealengine.com/5.2/Images/understanding-the-basics/unreal-engine-for-unity-developers/image_21.jpg)

你的项目设置中的输入属性可能如下所示：

![](https://docs.unrealengine.com/5.2/Images/understanding-the-basics/unreal-engine-for-unity-developers/unreal-engine-input-settings.jpg)

如需详细了解如何设置虚幻引擎项目的输入，请参阅[输入](https://docs.unrealengine.com/5.2/zh-CN/input-in-unreal-engine)页面。

## 常见问题解答

### 如何自动加载最后一个项目？

你可以将虚幻引擎配置为在启动时自动加载你之前处理的最后一个项目。从 Epic 启动程序打开项目时，在虚幻引擎启动屏幕上启用 **在启动时总是加载最后一个项目（Always Load Last Project on Startup）** 选项。

![](https://docs.unrealengine.com/5.2/Images/understanding-the-basics/unreal-engine-for-unity-developers/always-load-last-project-at-startup.jpg)

### 哪里可以设置游戏的输入绑定？

在 Unity 中，你使用项目的输入管理器设置来设置默认绑定。

在虚幻引擎中，你从 **项目设置（Project Settings）** 窗口中的 **输入（Input）** 类别配置输入绑定。在此窗口中，你可以添加各种按钮（操作）和模拟功能按钮（轴）。为每个功能按钮提供名称和默认绑定。这样做之后，你就可以在触发输入事件时获得对游戏的 Pawn 的回调。

如需详细了解如何设置虚幻引擎项目的输入，请参阅[输入](https://docs.unrealengine.com/5.2/zh-CN/input-in-unreal-engine)页面。

### 如何更改项目的初始场景？

默认情况下，虚幻引擎会在你打开项目时加载默认关卡。你可以在 **项目设置（Project Settings）** 窗口（主菜单：**编辑（Edit）> 项目设置（Project Settings）**）中的 **通用（General）> 加载和保存（Loading & Saving）** 类别中更改此行为。

### 如何运行游戏？

有多种方式可试玩（运行）你的游戏：

- 直接在虚幻编辑器中运行，方法是点击 **主工具栏（Main Toolbar）** 上的 **运行（Play）** 按钮。
    
- 作为独立的程序运行，方法是点击 **主工具栏（Main Toolbar）** 上的 **平台（Platforms）** 按钮，然后从下拉列表中选择你的机器。请注意，这会首先为你的平台编译一个可执行文件；例如，如果你在 Windows 机器上工作，这将构建 Windows 可执行文件。
    
- 在不同的平台（例如，移动设备或 Web 浏览器）上运行，方法是点击 **主工具栏（Main Toolbar）** 上的 **平台（Platforms）** 按钮，然后选择你想运行游戏的平台。请注意，你需要首先安装所有必需的软件。
    

如需详细了解如何在不同的平台上运行虚幻引擎游戏，请参阅以下页面：

- [运行和模拟](https://docs.unrealengine.com/5.2/zh-CN/playing-and-simulating-in-unreal-engine)
    
- [在虚幻编辑器中管理平台](https://docs.unrealengine.com/5.2/zh-CN/using-the-platforms-dropdown-in-unreal-editor)
    

### 虚幻引擎使用什么测量单位？

在 Unity 中，主要的测量单位是一米。在虚幻引擎中，主要测量单位是一厘米。

因此，在 Unity 中移动一个单位（米）相当于在虚幻引擎中移动 100 个单位（厘米）。

如果你想在 Unity 中移动 2 英尺，那就是 0.61 个单位（米）。在虚幻引擎中，这相当于 61 个单位（厘米）。

### 在虚幻引擎的坐标系中，哪个方向朝上？

Unity 和虚幻引擎都使用左手坐标系，但坐标轴的命名方式不同。在虚幻引擎中，X 的正方向是 "前"，Y 的正方向是 "右"，Z 的正方向是 "上"。

### 如何查看游戏的输出日志？

点击 **底部工具栏** 中的 **输出日志（Output Log）** 按钮。

### 如何抛出异常？

不同于 Unity，虚幻引擎并不处理异常。请改用 `check()` 函数来触发严重的断言错误。你可以传入错误信息提示。如果你想报告错误，但不希望打断程序，请改用 `ensure()`。这将记录一个带有完整调用堆栈的错误信息，但程序会继续执行。如果你附加了调试器，那么这两个函数都会暂定并进入调试器。

### .NET Framework 在哪里？

不同于 Unity，虚幻引擎并不使用. NET Framework。虚幻引擎有自己的一套容器类和库。下面列出了常见的容器比较：

你可以在[此处](https://docs.unrealengine.com/latest/INT/API/Runtime/Core/Containers/index.html)详细了解虚幻引擎的其他容器。

### 代码更改时虚幻引擎是否会自动重新加载？

会！你在编写代码时，可以将编辑器保持开启的状态。完成代码编辑后，从 Visual Studio 启动编译，编辑器将自动 "热重新加载" 你的更改。

## 查找帮助和答案

感谢阅读！本指南最初是在各地的虚幻引擎开发人员帮助下为虚幻社区而创建，现在我们已经针对虚幻引擎 5 进行了更新。随着我们不断了解如何更好地帮助大家过渡到虚幻引擎，我们会持续改新本文档，因此我们期待你的反馈意见和纠错意见。

要详细了解虚幻引擎，你可以参考本文档网站的其余部分，或访问下面的资源：

- [YouTube 上的虚幻引擎](https://www.youtube.com/c/UnrealEngine/playlists)

- [论坛](https://forums.unrealengine.com/)

- [社区资源](https://www.unrealengine.com/en-US/community)


全文完

本文由 [简悦 SimpRead](http://ksria.com/simpread) 优化，用以提升阅读体验

使用了 全新的简悦词法分析引擎 beta，[点击查看](http://ksria.com/simpread/docs/#/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%BC%95%E6%93%8E)详细说明

[虚幻编辑器](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#sr-toc-0)[编辑资产](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#sr-toc-1)[术语简表](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#sr-toc-2)[项目和文件](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#sr-toc-3)[怎么理解虚幻引擎项目的常用文件和目录？](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%EF%BC%9F-4)[我的资产应该放在哪里？](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#%E6%88%91%E7%9A%84%E8%B5%84%E4%BA%A7%E5%BA%94%E8%AF%A5%E6%94%BE%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F-5)[支持哪些文件格式？](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%EF%BC%9F-6)[如何保存场景？](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E5%9C%BA%E6%99%AF%EF%BC%9F-7)[如何修改项目设置？](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE%EF%BC%9F-8)[源文件在哪里？](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#%E6%BA%90%E6%96%87%E4%BB%B6%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F-9)[从 GameObject 到 Actor](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#sr-toc-10)[GameObject 在哪里？](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#gameobject%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F-11)[组件在哪里？](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#%E7%BB%84%E4%BB%B6%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F-12)[从 Unity 的 Prefab 到虚幻引擎的蓝图类](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#sr-toc-13)[Unity 中的 Script 组件和 MonoBehaviour 去哪里了？](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#unity%E4%B8%AD%E7%9A%84script%E7%BB%84%E4%BB%B6%E5%92%8Cmonobehaviour%E5%8E%BB%E5%93%AA%E9%87%8C%E4%BA%86%EF%BC%9F-14)[可编写脚本的 Actor 蓝图类](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#sr-toc-15)[蓝图类可以扩展](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#sr-toc-16)[那么应该用蓝图脚本还是 C++ 代码呢？或者同时使用？](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#%E9%82%A3%E4%B9%88%E5%BA%94%E8%AF%A5%E7%94%A8%E8%93%9D%E5%9B%BE%E8%84%9A%E6%9C%AC%E8%BF%98%E6%98%AFc++%E4%BB%A3%E7%A0%81%E5%91%A2%EF%BC%9F%E6%88%96%E8%80%85%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%EF%BC%9F-17)[蓝图类可以扩展 C++ 类](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#sr-toc-18)[变换组件](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#sr-toc-19)[复合对象](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#sr-toc-20)[我需要用组件构建一切吗？](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#%E6%88%91%E9%9C%80%E8%A6%81%E7%94%A8%E7%BB%84%E4%BB%B6%E6%9E%84%E5%BB%BA%E4%B8%80%E5%88%87%E5%90%97%EF%BC%9F-21)[那么一切都是 Actor 吗？](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#%E9%82%A3%E4%B9%88%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AFactor%E5%90%97%EF%BC%9F-22)[虚幻引擎中的 Gameplay 框架是什么？](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84gameplay%E6%A1%86%E6%9E%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-23)[在虚幻引擎中编写代码](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#sr-toc-24)[写给 C++ 程序员](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#sr-toc-25)[编写事件函数（Start、Update 等）](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#%E7%BC%96%E5%86%99%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0%EF%BC%88start%E3%80%81update%E7%AD%89%EF%BC%89-26)[在虚幻引擎中编写游戏逻辑代码](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#sr-toc-27)[实例化 GameObject / 生成 Actor](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#sr-toc-28)[UObject 和 NewObject](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#sr-toc-29)[AActor 和 SpawnActor](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#sr-toc-30)[类型转换](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#sr-toc-31)[销毁 GameObject/Actor](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#sr-toc-32)[销毁 GameObject/Actor（延迟 1 秒）](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#%E9%94%80%E6%AF%81gameobject/actor%EF%BC%88%E5%BB%B6%E8%BF%9F1%E7%A7%92%EF%BC%89-33)[禁用 GameObject/Actor](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#sr-toc-34)[从组件访问 GameObject/Actor](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#sr-toc-35)[从 GameObject/Actor 访问组件](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#sr-toc-36)[查找 GameObject/Actor](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#sr-toc-37)[向 GameObject/Actor 添加标签](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#sr-toc-38)[向 MonoBehaviour/ActorComponent 添加标签](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#sr-toc-39)[比较 GameObject/Actor 和 MonoBehaviour/ActorComponent 上的标签](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#sr-toc-40)[物理：刚体与图元组件](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#%E7%89%A9%E7%90%86%EF%BC%9A%E5%88%9A%E4%BD%93%E4%B8%8E%E5%9B%BE%E5%85%83%E7%BB%84%E4%BB%B6-41)[层与通道](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#sr-toc-42)[RayCast 与 RayTrace](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#sr-toc-43)[虚幻引擎 C++](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#sr-toc-44)[触发器体积](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#sr-toc-45)[虚幻引擎 C++](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#sr-toc-46)[虚幻引擎蓝图](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#sr-toc-47)[刚体运动](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#sr-toc-48)[输入事件](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#sr-toc-49)[常见问题解答](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#sr-toc-50)[如何自动加载最后一个项目？](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%EF%BC%9F-51)[哪里可以设置游戏的输入绑定？](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#%E5%93%AA%E9%87%8C%E5%8F%AF%E4%BB%A5%E8%AE%BE%E7%BD%AE%E6%B8%B8%E6%88%8F%E7%9A%84%E8%BE%93%E5%85%A5%E7%BB%91%E5%AE%9A%EF%BC%9F-52)[如何更改项目的初始场景？](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#%E5%A6%82%E4%BD%95%E6%9B%B4%E6%94%B9%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%88%9D%E5%A7%8B%E5%9C%BA%E6%99%AF%EF%BC%9F-53)[如何运行游戏？](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E6%B8%B8%E6%88%8F%EF%BC%9F-54)[虚幻引擎使用什么测量单位？](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E6%B5%8B%E9%87%8F%E5%8D%95%E4%BD%8D%EF%BC%9F-55)[在虚幻引擎的坐标系中，哪个方向朝上？](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#%E5%9C%A8%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E7%9A%84%E5%9D%90%E6%A0%87%E7%B3%BB%E4%B8%AD%EF%BC%8C%E5%93%AA%E4%B8%AA%E6%96%B9%E5%90%91%E6%9C%9D%E4%B8%8A%EF%BC%9F-56)[如何查看游戏的输出日志？](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E6%B8%B8%E6%88%8F%E7%9A%84%E8%BE%93%E5%87%BA%E6%97%A5%E5%BF%97%EF%BC%9F-57)[如何抛出异常？](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#%E5%A6%82%E4%BD%95%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%EF%BC%9F-58)[.NET Framework 在哪里？](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#.netframework%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F-59)[代码更改时虚幻引擎是否会自动重新加载？](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#%E4%BB%A3%E7%A0%81%E6%9B%B4%E6%94%B9%E6%97%B6%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E6%98%AF%E5%90%A6%E4%BC%9A%E8%87%AA%E5%8A%A8%E9%87%8D%E6%96%B0%E5%8A%A0%E8%BD%BD%EF%BC%9F-60)[查找帮助和答案](https://docs.unrealengine.com/5.2/zh-CN/unreal-engine-for-unity-developers/#sr-toc-61)